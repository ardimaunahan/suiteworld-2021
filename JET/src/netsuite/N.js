/**
 * SuiteScript module
 *
 * @private
 * @module N/nsobject
 * @NApiVersion 2.x
 */
define('N/nsobject',[], function (){
		/* NetSuite Javascript Object Marker */
		function NetSuiteObject() {}
		Object.freeze(NetSuiteObject);

		return {
			getNewInstance: function() { return new NetSuiteObject(); },
			isInstanceOfNSObject: function(obj) { return obj instanceof NetSuiteObject; }
		};
	}
);

/**
 * SuiteScript module
 *
 * @private
 * @module N/reflet
 * @NApiVersion 2.x
 */
define('N/restricted/reflet',[],
        function ()
        {
            var chargeMap = {};
            var currentScriptInfo = {};
            var usageCostMap = null;
            var totalBundleUsage = {};
            var nsJSONProxyURL = '/app/common/scripting/nlapijsonhandler.nl';

            function getCharges()
            {
                return chargeMap[currentScriptInfo.scriptId] || 0;
            }

            function setupScript(thisObject)
            {
                currentScriptInfo = {
                    scriptId: thisObject.scriptId,
                    deployId: thisObject.deployId,
                    bundleId: thisObject.bundleId
                };
                chargeMap[thisObject.scriptId] = 0;
            }

	        function recoverScript(thisObject)
	        {
		        currentScriptInfo = {
			        scriptId: thisObject.scriptId,
			        deployId: thisObject.deployId,
			        bundleId: thisObject.bundleId
		        };
	        }

	        function getScript()
	        {
		        return currentScriptInfo;
	        }

            function chargeUsage(method, type, args, governanceOverride) {
	            if (usageCostMap === null)
		            usageCostMap = serverCallSync(nsJSONProxyURL, "getUsageUnits", []);
	            var cost = 0;
	            if (util.isNumber(governanceOverride))
		            cost = governanceOverride;
	            else
	            {
		            if (method === 'nlapiSendEmail' && args[8] /*notifySenderOnBounce*/)
			            cost = usageCostMap[method + '_trackBouncesUpcharge'] || 0;
		            /* TODO: Figure out a better way to deal with bulk action */
		            else if (method === 'executeAction' && args[0] === 'timesheet')
			            cost = usageCostMap[method + 'Bulk'] || 0;
		            else
			            cost = usageCostMap[method] || 0;
		            if (type != null) {
			            var recordTypes = serverCallSync(nsJSONProxyURL, "getRecordTypes", []);
			            var recType = recordTypes[type.toLowerCase()].type;
			            cost /= (recType === "RECORD") ? 5 : ( (recType === "BODY" ? 1 : 2) )
			            if (method === 'nlapiLookupFields_v1')
			                cost--; // compensate for v2 nlapiLookupFields being already charged
		            }
                }
                var thisKey = currentScriptInfo.scriptId;
                chargeMap[thisKey] = (chargeMap[thisKey] || 0) + cost;
                //console.log("=======" + thisKey + "will be charged " + cost
                //            + " for using " + method + " (type = " + type + "). FYI, Total Charge is " + chargeMap[thisKey]);
                if (calculateRemainingUsage() < 0)
                {
                    var error = new Error(getErrorMsg("SCRIPT_EXECUTION_USAGE_LIMIT_EXCEEDED"));
                    error.name = "SCRIPT_EXECUTION_USAGE_LIMIT_EXCEEDED";
                    throw error;
                }
            }

            function createError(myCode, myDetails, suppressNotification)
            {
                var error = Error(myDetails);
                error.name = myCode;
                try
                {
                    throw error;
                }
                catch (e)
                {
                    error = e;
                }

                return {
                    getId: function () { return null },
                    getCode: function () { return error.name },
                    getDetails: function () { return error.message },
                    getStackTrace: function () { return error.stack.split("\n"); }
                };
            }

            function getTotalUsage()
            {
                var bundle = -1;
                var script = currentScriptInfo.scriptId;
                if (script != null && script != "global" && script != "internal")
                {
                    bundle = currentScriptInfo.bundleId;
                    if (bundle == null || bundle == '')  bundle = -1;
                }
                if (totalBundleUsage[bundle] == null)
                {
                    totalBundleUsage[bundle] = serverCallSync(nsJSONProxyURL, "getTotalScriptGovernance", [ bundle ] );
                }
                return totalBundleUsage[bundle];
            }

            function getErrorMsg(errorCode, errorVal1, errorVal2, errorVal3, errorVal4)
            {
                return serverCallSync(nsJSONProxyURL, "getErrorMessage", [errorCode, errorVal1, errorVal2, errorVal3, errorVal4]);
            }

            function calculateRemainingUsage()
            {
                return getTotalUsage() - parseInt(getCharges(), 10);
            }

            var theContext = null;

            function getContext()
            {
                try
                {
                    if (theContext === null)
                    {
                        if (typeof nsDefaultContextObj !== 'undefined' && nsDefaultContextObj !== null)
                            theContext = nsDefaultContextObj;
                        else
                        {
                            theContext = serverCallSync(nsJSONProxyURL, "getContext");
                            theContext.internal = true;
                            theContext.contexttypes = JSON.parse(theContext.contexttypes);
                        }
                    }
                }
                catch (e)
                {
                    throw Error(e);
                }

                function getRecordType()
                {
                    if (theContext.recordType == null)
                    {
                        require.forceSync(true);
                        try {
                            require(['N/currentRecord'], function (crMod) { theContext.recordType = crMod.get().type; });
                        }
                        finally {
                            require.forceSync(false);
                        }
                    }
                    return theContext.recordType;
                }

                function getPref(name)
                {
                    if (name.toLowerCase().indexOf('custscript') == 0)
                    {
                        if (theContext.scriptprefs == null)
                        {
                            theContext.scriptprefs = serverCallSync(nsJSONProxyURL, "getScriptPrefs", [getRecordType()]);
                        }
                        return theContext.scriptprefs[name];
                    }
                    return serverCallSync(nsJSONProxyURL, "getPref", [name]);
                }

                function getPrefType(name)
                {
                    if (name.toLowerCase().indexOf('custscript') == 0)
                    {
                        if (theContext.scriptpreftypes == null)
                        {
                            theContext.scriptpreftypes = serverCallSync(nsJSONProxyURL, "getScriptPrefTypes", [getRecordType()]);
                        }
                        return theContext.scriptpreftypes[name];
                    }
                    return serverCallSync(nsJSONProxyURL, "getPrefType", [name]);
                }

                return {
                    //Script
                    getLogLevel: function () { return undefined;}, // not supported for client scripts
                    getScriptId: function () { return !!currentScriptInfo ? currentScriptInfo.scriptId : undefined},
                    getPercentComplete: function () { return undefined;}, // not supported for client scripts
                    setPercentComplete: function () { return undefined;}, // not supported for client scripts
                    getDeploymentId: function () { return !!currentScriptInfo ? currentScriptInfo.deployId : undefined },
                    getBundleId: function () { return !!currentScriptInfo ? currentScriptInfo.bundleId : undefined },
                    getBundleIds: function ()
					{
						var rc = !!currentScriptInfo && currentScriptInfo.hasOwnProperty('bundleId') ? currentScriptInfo.bundleId.split(',') : undefined;
						if (Array.isArray(rc) && rc.length === 1 && rc[0] === '')
							return [];
						return rc;
					},
                    getRemainingUsage: function () { return calculateRemainingUsage();},
                    getPreferenceObject: function (name) { return getPref(name);},
                    getPreference: function (name) { return getPref(name);},
                    getPreferenceType: function (name) { return getPrefType(name);},
                    //Session
                    getSessionObject: function (name) { return serverCallSync(nsJSONProxyURL, "getSessionObject", [name]);},
                    setSessionObject: function () { return undefined;}, // not supported for client scripts
                    //User
                    getEmail: function () { return theContext.email;},
                    getName: function () { return theContext.name;},
                    getLocation: function () { return parseInt(theContext.location, 10);},
                    getDepartment: function () { return parseInt(theContext.department, 10);},
                    getRole: function () { return parseInt(theContext.role, 10);},
                    getRoleCenter: function () { return theContext.rolecenter;},
                    getRoleId: function () { return theContext.roleid;},
                    getUser: function () { return parseInt(theContext.user, 10);},
                    getSubsidiary: function () { return parseInt(theContext.subsidiary, 10);},
                    getPermission: function (name) { return serverCallSync(nsJSONProxyURL, "getPerm", [name]); },
                    //Base
                    getFeature: function (name) { return serverCallSync(nsJSONProxyURL, "getFeature", [name]);},
                    getQueueCount: function () { return undefined;}, // not supported for client scripts
	                getProcessorCount: function () { return undefined;}, // not supported for client scripts
                    getVersion: function () { return theContext.version;},
                    getCompany: function () { return theContext.company;},
                    getEnvironment: function () { return theContext.environment;},
                    getExecutionContext: function () { return theContext.context;},
                    getExecutionContextTypes: function(){ return theContext.contexttypes;},
                    //Client Script Only
                    isInternal: function () { return theContext.internal; },
                    getScriptType: function () { return "CLIENT"; }
                }
            }

            function XMLtoString(xml)
            {
                if (!xml)
                {
                    var error = new Error(getErrorMsg("SSS_MISSING_REQD_ARGUMENT"));
                    error.name = "SSS_MISSING_REQD_ARGUMENT";
                    throw error;
                }

                try
                {
                    if (xml.nodeType === 2)    /* Special Handling for Attribute Node. XMLSerializer supports Nodes only */
                        return xml.name + '=' + xml.value;
                    else if (window.XMLSerializer && window.XPathEvaluator)
                        return new XMLSerializer().serializeToString(xml);
                    else
                        return xml.xml
                }
                catch (e)
                {
                    throw e;
                }
            }

            function wrap(node)
            {
                if (!node)
                {
                    return node
                }

                switch (node.nodeType)
                {
                    case 1:
                        return wrapElement(node);
                    case 2:
                        return wrapAttr(node);
                    case 9:
                        return wrapDocument(node);
                    default:
                        return wrapNode(node);
                }
            }

            function wrapAttr(attr)
            {
                var wrappedAttr = {};
                wrappedAttr.getName = function () { return attr.name; };
                wrappedAttr.getOwnerElement = function () { return wrap(attr.ownerElement); };
                wrappedAttr.getSpecified = function () { return attr.specified; };
                wrappedAttr.getValue = function () { return attr.value; };
                wrappedAttr.setValue = function (val) { attr.value = val; };
                return wrappedAttr;
            }

            function wrapDocument(doc)
            {
                var wrappedDoc = wrapNode(doc);
                wrappedDoc.hasAttributes = undefined;
                wrappedDoc.adoptNode = function (source) { return wrap(doc.adoptNode(source)) };
                wrappedDoc.createAttribute = function (name) { return wrapAttr(doc.createAttribute(name)) };
                wrappedDoc.createAttributeNS = function (qualifiedName) { return wrapAttr(doc.createAttributeNS(qualifiedName)) };
                wrappedDoc.createCDATASection = function (data) { return wrapNode(doc.createCDATASection(data)) };
                wrappedDoc.createComment = function (data) { return wrapNode(doc.createComment(data)) };
                wrappedDoc.createDocumentFragment = function () { return wrapNode(doc.createDocumentFragment()) };
                wrappedDoc.createElement = function (tagName) { return wrapElement(doc.createElement(tagName)) };
                wrappedDoc.createElementNS = function (namespaceURI, qualifiedName) { return wrapElement(doc.createElementNS(namespaceURI, qualifiedName)) };
                wrappedDoc.createProcessingInstruction = function (target, data) { return wrapNode(doc.createProcessingInstruction(target, data)) };
                wrappedDoc.createTextNode = function (data) { return wrapNode(doc.createTextNode(data)) };
                wrappedDoc.getElementById = function (elementId) { return wrapElement(doc.getElementById(elementId)) };
                wrappedDoc.getElementsByTagName = function (tagName) { return wrapElement(doc.getElementsByTagName(tagName)) };
                wrappedDoc.getElementsByTagNameNS = function (namespaceURI, localName) { return wrapElement(doc.getElementsByTagNameNS(namespaceURI, localName)) };
                wrappedDoc.importNode = function (importedNode, deep) { return wrap(doc.importNode(importedNode, deep)) };
                wrappedDoc.normalizeDocument = function () { return doc.normalize(); };
                wrappedDoc.getDoctype = function () { return wrapNode(doc.doctype) };
                wrappedDoc.getDocumentElement = function () { return wrapElement(doc.documentElement) };
                wrappedDoc.getDocumentURI = function () { return doc.documentURI };
                wrappedDoc.setDocumentURI = function (val) { doc.documentURI = val};
                wrappedDoc.getInputEncoding = function () { return doc.inputEncoding };
                wrappedDoc.getXmlEncoding = function () { return doc.xmlEncoding };
                wrappedDoc.getXmlStandalone = function () { return doc.xmlStandalone };
                wrappedDoc.setXmlStandalone = function (val) { doc.xmlStandalone = val };
                wrappedDoc.getXmlVersion = function () { return doc.xmlVersion };
                wrappedDoc.setXmlVersion = function (val) { doc.xmlVersion = val };
                return wrappedDoc;
            }

            function wrapElement(element)
            {
                var wrappedElem = wrapNode(element)
                wrappedElem.getAttribute = function (name) { return element.getAttribute(name); };
                wrappedElem.getAttributeNode = function (name) { return wrap(element.getAttributeNode(name)); };
                wrappedElem.getAttributeNodeNS = function (namespaceURI, localName) { return wrap(element.getAttributeNodeNS(namespaceURI, localName)); };
                wrappedElem.getAttributeNS = function (namespaceURI, localName) { return element.getAttributeNS(namespaceURI, localName); };
                wrappedElem.getElementsByTagName = function (tagName) { return wrapElement(element.getElementsByTagName(tagName)); };
                wrappedElem.getElementsByTagNameNS = function (namespaceURI, localName) { return wrapElement(element.getElementsByTagNameNS(namespaceURI, localName)); };
                wrappedElem.hasAttribute = function (name) { return element.hasAttribute(name); };
                wrappedElem.hasAttributeNS = function (namespaceURI, localName) { return element.hasAttributeNS(namespaceURI, localName); };
                wrappedElem.removeAttribute = function (name) { return element.removeAttribute(name); };
                wrappedElem.removeAttributeNode = function (oldAttr) { return wrap(element.removeAttributeNode(oldAttr)); };
                wrappedElem.removeAttributeNS = function (namespaceURI, localName) { return element.removeAttributeNS(namespaceURI, localName); };
                wrappedElem.setAttribute = function (name, value) { return element.setAttribute(name, value); };
                wrappedElem.setAttributeNode = function (newAttr) { return element.setAttributeNode(newAttr); };
                wrappedElem.setAttributeNodeNS = function (newAttr) { return element.setAttributeNodeNS(newAttr); };
                wrappedElem.setAttributeNS = function (namespaceURI, qualifiedName, value) { return element.setAttributeNS(namespaceURI, qualifiedName, value); };
                wrappedElem.getTagName = function () { return element.getTagName(); };
                return wrappedElem;
            }

            function wrapNode(node)
            {
                return {
                    appendChild: function (newChild) { return wrap(node.appendChild(newChild)); },
                    cloneNode: function (deep) { return wrap(node.cloneNode(deep)); },
                    compareDocumentPosition: function (other) { return node.compareDocumentPosition(other); },
                    hasAttributes: function () { return node.hasAttributes(); },
                    hasChildNodes: function () { return node.hasChildNodes(); },
                    insertBefore: function (newChild, refChild) { return wrap(node.insertBefore(newChild, refChild)); },
                    isDefaultNamespace: function (namespaceURI) { return node.isDefaultNamespace(namespaceURI); },
                    isEqualNode: function (other) { return node.isEqualNode(other); },
                    isSameNode: function (other) { return node.isSameNode(other); },
                    lookupNamespaceURI: function (prefix) { return node.lookupNamespaceURI(prefix); },
                    lookupPrefix: function (namespaceURI) { return node.lookupPrefix(namespaceURI); },
                    normalize: function () { return node.normalize(); },
                    removeChild: function (oldChild) { return wrap(node.removeChild(oldChild)); },
                    replaceChild: function (newChild, oldChild) { return wrap(node.replaceChild(newChild, oldChild)); },

                    getAttributes: function () { return node.attributes; },
                    getBaseURI: function () { return null; },
                    getFirstChild: function () { return wrap(node.firstChild); },
                    getLastChild: function () { return wrap(node.lastChild); },
                    getLocalName: function () { return node.localName; },
                    getNamespaceURI: function () { return node.namespaceURI; },
                    getNextSibling: function () { return wrap(node.nextSibling); },
                    getNodeName: function () { return node.nodeName; },
                    getNodeType: function () { return node.nodeType; },
                    getNodeValue: function () { return node.nodeValue; },
                    setNodeValue: function (val) { return node.nodeValue = val; },
                    getOwnerDocument: function () { return wrap(node.ownerDocument); },
                    getParentNode: function () { return wrap(node.parentNode); },
                    getPrefix: function () { return node.prefix; },
                    setPrefix: function (val) { return node.prefix = val; },
                    getPreviousSibling: function () { return wrap(node.previousSibling); },
                    getTextContent: function () { return node.textContent; },
                    setTextContent: function (val) { return node.textContent = val; },
                    _gd: function () { return node; }
                }
            }

            function createIEDoc()   //NLAppUtil:nsCreateDocument
            {
                var doc = null;
                if (document.implementation && document.implementation.createDocument && !(window.ActiveXObject !== undefined))
                    doc = document.implementation.createDocument("", "", null);
                else
                {
                    try
                    {
                        doc = new ActiveXObject("Msxml2.DOMDocument.6.0");
                    }
                    catch (e)
                    {
                        try
                        {
                            doc = new ActiveXObject("Msxml2.DOMDocument.3.0");
                        }
                        catch (e)
                        {
                            doc = new ActiveXObject("Msxml2.DOMDocument.4.0");
                        }
                    }
                    if (doc != null)
                    {
                        doc.async = false;
                        doc.resolveExternals = false;
                    }
                }
                return doc;
            }

            function stringToXML(text, dontThrow)
            {
                var nsDocument = null;
                if (window.DOMParser && window.XPathEvaluator)
                {
                    nsDocument = new DOMParser().parseFromString(text, 'text/xml')
                    if (!dontThrow)
                    {
                        var parserErrors = nsDocument.getElementsByTagName("parsererror")
                        if (parserErrors.length > 0)
                        {
                            var error = new Error(getErrorMsg("SSS_XML_DOM_EXCEPTION") + ' ' + parserErrors[0].innerHTML) ;
                            error.name = "SSS_XML_DOM_EXCEPTION";
                            throw error;
                        }
                    }
                }
                else if (!window.XPathEvaluator)
                {
                    nsDocument = createIEDoc();
                    nsDocument.loadXML(text);
                    if (!dontThrow)
                    {
                        if (nsDocument.parseError && nsDocument.parseError.errorCode !== 0)
                        {
                            var error = new Error(getErrorMsg("SSS_XML_DOM_EXCEPTION") + ' ' +nsDocument.parseError.reason) ;
                            error.name = "SSS_XML_DOM_EXCEPTION";
                            throw error;
                        }
                    }
                }
                else
                {
                    return null;
                }


                return nsDocument;
            }

            function selectNodes(node, expr)
            {
                if (!node || !node.hasChildNodes())
                    return [];

                var nodes = null;
                var owner = node.ownerDocument != null ? node.ownerDocument : node;
                if (window.XPathEvaluator)
                {
                    var xpe = new XPathEvaluator();
                    /* manually resolve default namespace URI in Firefox/Safari (if needed) */
                    var resolver = function (prefix)
                    {
                        return thisNameSpace[prefix];
                    }
                    var thisNameSpace = {};
                    if (XMLtoString(node).indexOf('xmlns') != -1)
                    {
                        var nodelist = owner.getElementsByTagName("*")
                        for (var j = 0; j < nodelist.length; j++)
                        {
                            var attributes = nodelist[j].attributes;
                            for (var i = 0; attributes != null && i < attributes.length; i++)
                            {
                                if (attributes[i].name == 'xmlns')
                                    thisNameSpace["nlapi"] = attributes[i].nodeValue;
                                else if (attributes[i].name.indexOf('xmlns:') == 0)
                                    thisNameSpace[attributes[i].name.substring(6)] = attributes[i].nodeValue;
                            }
                        }
                    }
                    var results = xpe.evaluate(expr, node, resolver, XPathResult.ANY_TYPE, null)
                    if (results != null)
                    {
                        nodes = new Array();
                        var result;
                        while (result = results.iterateNext())
                            nodes[nodes.length] = result;
                    }
                }
                else
                {
                    /* manually resolve name spaces in IE (if needed) */
                    if (XMLtoString(node).indexOf('xmlns') != -1)
                    {
                        var namespaces = null;
                        owner.setProperty("SelectionLanguage", "XPath");
                        var nodelist = owner.getElementsByTagName("*")
                        for (var j = 0; j < nodelist.length; j++)
                        {
                            var attributes = nodelist[j].attributes;
                            for (var i = 0; attributes != null && i < attributes.length; i++)
                            {
                                if (attributes[i].name.indexOf('xmlns:') == 0)
                                    namespaces = (namespaces != null ? namespaces + " " : "") + attributes[i].xml;
                                else if (attributes[i].name == 'xmlns')
                                    namespaces = (namespaces != null ? namespaces + " " : "") + "xmlns:nlapi=\"" + attributes[i].nodeValue + "\"";
                            }
                        }
                        if (namespaces != null)
                            owner.setProperty("SelectionNamespaces", namespaces)
                    }
                    nodes = node.selectNodes(expr);
                }
                return nodes;
            }

            function throwNotSupported()
            {
                var e = new Error(getErrorMsg("SSS_NOT_YET_SUPPORTED"))
                e.name = "SSS_NOT_YET_SUPPORTED";
                throw e;
            }

            return Object.freeze({
                nlapiCreateError: createError,
                getErrorMessage: getErrorMsg,
                transform: function (record) { return record },
                nlapiGetContext: function () { return getContext(); },
                nlapiXMLToString: function (xml) { return XMLtoString(xml); },
                nlapiStringToXML: function (text, dontThrow) { return stringToXML(text, dontThrow); },
                nlapiSelectNodes: selectNodes,
                nlapiValidateXML: function () { throwNotSupported(); },
                nsObjectToMap: function (obj) { return obj; },
                setupScript: setupScript,
	            recoverScript: recoverScript,
	            getScript: getScript,
                chargeUsage: chargeUsage
            });
        }
);

/**
 * @private
 */
define('N/restricted/bridge',['N/restricted/reflet'], function(reflet){ return reflet; });

/**
 * @private
 */
define('N/restricted/errorApi',['N/restricted/reflet'], function(reflet){ return reflet; });

/**
 * @private
 */
define('N/restricted/remoteApiBridge',['N/restricted/reflet'], function(reflet){ return reflet; });

/**
 * SuiteScript error module
 *
 * @module N/error
 * @NApiVersion 2.x
 *
 */
define('N/error',['N/restricted/bridge', 'N/restricted/errorApi', 'N/restricted/remoteApiBridge', 'N/nsobject'],
        function (apiBridge, errorApi, remoteUtil, nsobject)
        {

            var ERROR_TYPES = Object.freeze({
                MISSING_REQD_ARGUMENT: 'SSS_MISSING_REQD_ARGUMENT',
                READ_ONLY_PROPERTY: 'READ_ONLY_PROPERTY',
                WRONG_PARAMETER_TYPE: 'WRONG_PARAMETER_TYPE',
                UNKNOWN_PARAM: 'UNKNOWN_PARAM',
                INVALID_FLD_VALUE: 'INVALID_FLD_VALUE',
                INVALID_FIELD_VALUE: 'INVALID_FIELD_VALUE',
                VALUE_1_OUTSIDE_OF_VALID_MINMAX_RANGE_FOR_FIELD_2: 'VALUE_1_OUTSIDE_OF_VALID_MINMAX_RANGE_FOR_FIELD_2',
	            INVALID_NUMBER_MUST_BE_BETWEEN_1_AND_2: 'INVALID_NUMBER_MUST_BE_BETWEEN_1_AND_2',
                INVALID_KEY_OR_REF: 'WS_INVALID_REFERENCE_KEY_1',
                EMPTY_KEY_NOT_ALLOWED: 'EMPTY_KEY_NOT_ALLOWED',
                INVALID_URL_URL_MUST_START_WITH_HTTP_HTTPS_FTP_OR_FILE: 'INVALID_URL_URL_MUST_START_WITH_HTTP_HTTPS_FTP_OR_FILE',
                INVALID_URL_SPACES_ARE_NOT_ALLOWED_IN_THE_URL: 'INVALID_URL_SPACES_ARE_NOT_ALLOWED_IN_THE_URL',
                INVALID_NUMBER_OR_PERCENTAGE: 'INVALID_NUMBER_OR_PERCENTAGE',
                INVALID_EMAILS_FOUND: 'INVALID_EMAILS_FOUND',
                INVALID_RCRD_TYPE: 'INVALID_RCRD_TYPE',
                IDENTIFIERS_CAN_CONTAIN_ONLY_DIGITS_ALPHABETIC_CHARACTERS_OR__WITH_NO_SPACES: 'IDENTIFIERS_CAN_CONTAIN_ONLY_DIGITS_ALPHABETIC_CHARACTERS_OR__WITH_NO_SPACES',
                CREDIT_CARD_NUMBERS_MUST_CONTAIN_BETWEEN_13_AND_20_DIGITS: 'CREDIT_CARD_NUMBERS_MUST_CONTAIN_BETWEEN_13_AND_20_DIGITS',
                CREDIT_CARD_NUMBER_MUST_CONTAIN_ONLY_DIGITS: 'CREDIT_CARD_NUMBER_MUST_CONTAIN_ONLY_DIGITS',
                CREDIT_CARD_NUMBER_IS_NOT_VALID__PLEASE_CHECK_THAT_ALL_DIGITS_WERE_ENTERED_CORRECTLY: 'CREDIT_CARD_NUMBER_IS_NOT_VALID__PLEASE_CHECK_THAT_ALL_DIGITS_WERE_ENTERED_CORRECTLY',
                PHONE_NUMBER_SHOULD_HAVE_SEVEN_DIGITS_OR_MORE: 'PHONE_NUMBER_SHOULD_HAVE_SEVEN_DIGITS_OR_MORE',
                PLEASE_INCLUDE_THE_AREA_CODE_FOR_PHONE_NUMBER: 'PLEASE_INCLUDE_THE_AREA_CODE_FOR_PHONE_NUMBER',
                THE_FIELD_1_CONTAINED_MORE_THAN_THE_MAXIMUM_NUMBER__2__OF_CHARACTERS_ALLOWED: 'THE_FIELD_1_CONTAINED_MORE_THAN_THE_MAXIMUM_NUMBER__2__OF_CHARACTERS_ALLOWED', 
                PROPERTY_VALUE_CONFLICT: 'PROPERTY_VALUE_CONFLICT',
                FORM_VALIDATION_FAILED_YOU_CANNOT_CREATE_THIS_SUBRECORD : 'FORM_VALIDATION_FAILED_YOU_CANNOT_CREATE_THIS_SUBRECORD',
                FORM_VALIDATION_FAILED_YOU_CANNOT_SUBMIT_THIS_RECORD: 'FORM_VALIDATION_FAILED_YOU_CANNOT_SUBMIT_THIS_RECORD',
                PLEASE_ENTER_AN_EXPIRATION_DATE_IN_MMYYYY_FORMAT: 'PLEASE_ENTER_AN_EXPIRATION_DATE_IN_MMYYYY_FORMAT',
                PLEASE_ENTER_A_VALID_FROM_START_DATE_IN_MMYYYY_FORMAT: 'PLEASE_ENTER_A_VALID_FROM_START_DATE_IN_MMYYYY_FORMAT',
                NOTICE_THE_CREDIT_CARD_APPEARS_TO_BE_INCORRECT: 'NOTICE_THE_CREDIT_CARD_APPEARS_TO_BE_INCORRECT',
                FIELD_MUST_CONTAIN_A_VALUE: 'FIELD_MUST_CONTAIN_A_VALUE',
                NON_KATAKANA_DATA_FOUND: 'NON_KATAKANA_DATA_FOUND',
                COLOR_VALUE_MUST_BE_6_HEXADECIMAL_DIGITS_OF_THE_FORM_RRGGBB__EXAMPLE_FF0000_FOR_RED: 'COLOR_VALUE_MUST_BE_6_HEXADECIMAL_DIGITS_OF_THE_FORM_RRGGBB__EXAMPLE_FF0000_FOR_RED',
                INVALID_DATE_VALUE_MUST_BE_ON_OR_AFTER_1CUTOFF_DATE: 'INVALID_DATE_VALUE_MUST_BE_ON_OR_AFTER_1CUTOFF_DATE',
                INVALID_GETSELECTOPTION_FILTER_OPERATOR: 'SSS_INVALID_GETSELECTOPTION_FILTER_OPERATOR',
                INVALID_UI_OBJECT_TYPE: 'SSS_INVALID_UI_OBJECT_TYPE',
                INVALID_SUBLIST_OPERATION: 'SSS_INVALID_SUBLIST_OPERATION',
                INVALID_SUITEAPP_APPLICATION_ID: 'INVALID_SUITEAPP_APPLICATION_ID',
                INVALID_SCRIPT_OPERATION_ON_READONLY_SUBLIST_FIELD: 'A_SCRIPT_IS_ATTEMPTING_TO_EDIT_THE_1_SUBLIST_THIS_SUBLIST_IS_CURRENTLY_IN_READONLY_MODE_AND_CANNOT_BE_EDITED_CALL_YOUR_NETSUITE_ADMINISTRATOR_TO_DISABLE_THIS_SCRIPT_IF_YOU_NEED_TO_SUBMIT_THIS_RECORD',
                WS_NO_PERMISSIONS_TO_SET_VALUE: 'WS_NO_PERMISSIONS_TO_SET_VALUE',
                SCRIPT_EXECUTION_USAGE_LIMIT_EXCEEDED: 'SCRIPT_EXECUTION_USAGE_LIMIT_EXCEEDED',
                NOT_SUPPORTED_ON_CURRENT_SUBRECORD: 'NOT_SUPPORTED_ON_CURRENT_SUBRECORD',
                FIELD_1_IS_NOT_A_SUBRECORD_FIELD: 'FIELD_1_IS_NOT_A_SUBRECORD_FIELD',
                THAT_RECORD_IS_NOT_EDITABLE: 'THAT_RECORD_IS_NOT_EDITABLE',
                SSS_INVALID_TYPE_ARG: 'SSS_INVALID_TYPE_ARG',
                SSS_INVALID_SRCH_OPERATOR: 'SSS_INVALID_SRCH_OPERATOR',
                SSS_INVALID_URL: 'SSS_INVALID_URL',
                SSS_INVALID_CURRENCY_ID: 'SSS_INVALID_CURRENCY_ID',
                SSS_INVALID_API_USAGE: 'SSS_INVALID_API_USAGE',
                FIELD_1_ALREADY_CONTAINS_A_SUBRECORD_YOU_CANNOT_CALL_CREATESUBRECORD: 'FIELD_1_ALREADY_CONTAINS_A_SUBRECORD_YOU_CANNOT_CALL_CREATESUBRECORD',
                BUTTONS_MUST_INCLUDE_BOTH_A_LABEL_AND_VALUE: 'BUTTONS_MUST_INCLUDE_BOTH_A_LABEL_AND_VALUE',
                SSS_INVALID_UI_OBJECT_TYPE: 'SSS_INVALID_UI_OBJECT_TYPE',
                INVALID_PAGE_RANGE: 'INVALID_PAGE_RANGE',
                SSS_UNSUPPORTED_METHOD: 'SSS_UNSUPPORTED_METHOD',
                SSS_TAX_REGISTRATION_REQUIRED: 'SSS_TAX_REGISTRATION_REQUIRED',
                INVALID_DIRECTION_FOR_SORTING : 'INVALID_DIRECTION_FOR_SORTING',
                INVALID_COLUMN_FOR_SORTING : 'INVALID_COLUMN_FOR_SORTING',
                INVALID_FILTER_FIELD_FOR_CURRENT_VIEW : 'INVALID_FILTER_FIELD_FOR_CURRENT_VIEW',
                INVALID_CUSTOM_VIEW_VALUE : 'INVALID_CUSTOM_VIEW_VALUE',
                INVALID_PAGE_INDEX : 'INVALID_PAGE_INDEX',
                INVALID_TASK_TYPE : 'INVALID_TASK_TYPE',
                METHOD_IS_ONLY_ALLOWED_FOR_MATRIX_FIELD : 'SSS_METHOD_IS_ONLY_ALLOWED_FOR_MATRIX_FIELD',
                SSS_METHOD_IS_ONLY_ALLOWED_FOR_MULTISELECT_FIELD: 'SSS_METHOD_IS_ONLY_ALLOWED_FOR_MULTISELECT_FIELD',
                SSS_METHOD_IS_ONLY_ALLOWED_FOR_SELECT_FIELD: 'SSS_METHOD_IS_ONLY_ALLOWED_FOR_SELECT_FIELD',
                SSS_RECORD_TYPE_MISMATCH:'SSS_RECORD_TYPE_MISMATCH' ,
                SSS_INVALID_SUBLIST_OPERATION:'SSS_INVALID_SUBLIST_OPERATION',
                SSS_SEARCH_FOR_EACH_LIMIT_EXCEEDED: 'SSS_SEARCH_FOR_EACH_LIMIT_EXCEEDED',
                SSS_INVALID_SEARCH_RESULT_INDEX:'SSS_INVALID_SEARCH_RESULT_INDEX',
                SSS_SEARCH_RESULT_LIMIT_EXCEEDED:'SSS_SEARCH_RESULT_LIMIT_EXCEEDED',
                INVALID_FIELD_INDEX :'INVALID_FIELD_INDEX',
                INVALID_FIELD_ID :'INVALID_FIELD_ID',
                INVALID_SUBRECORD_REFEFAILED_AN_UNEXPECTED_ERROR_OCCURREDRENCE: 'INVALID_SUBRECORD_REFERENCE',
                FAILED_AN_UNEXPECTED_ERROR_OCCURRED: 'FAILED_AN_UNEXPECTED_ERROR_OCCURRED',
                CANNOT_CREATE_RECORD_INSTANCE : 'CANNOT_CREATE_RECORD_INSTANCE',
                INVALID_SUBRECORD_MERGE: 'INVALID_SUBRECORD_MERGE',
                OPERATION_IS_NOT_ALLOWED: 'OPERATION_IS_NOT_ALLOWED',
                INVALID_CONFIGURATION_UNABLE_TO_CHANGE_REQUIRE_CONFIGURATION_FOR_1: 'INVALID_CONFIGURATION_UNABLE_TO_CHANGE_REQUIRE_CONFIGURATION_FOR_1',
                INVALID_CONFIGURATION_UNABLE_TO_CHANGE_REQUIRE_CONFIGURATION_WITHOUT_A_CONTEXT: 'INVALID_CONFIGURATION_UNABLE_TO_CHANGE_REQUIRE_CONFIGURATION_WITHOUT_A_CONTEXT',
                MUTUALLY_EXCLUSIVE_ARGUMENTS: 'MUTUALLY_EXCLUSIVE_ARGUMENTS',
                RELATIONSHIP_ALREADY_USED: 'RELATIONSHIP_ALREADY_USED',
                INVALID_SEARCH_TYPE: 'INVALID_SEARCH_TYPE',
                OPERATOR_ARITY_MISMATCH: 'OPERATOR_ARITY_MISMATCH',
                INVALID_SEARCH_OPERATOR: 'INVALID_SEARCH_OPERATOR',
                NEITHER_ARGUMENT_DEFINED: 'NEITHER_ARGUMENT_DEFINED',
                SSS_INVALID_MACRO_ID: 'SSS_INVALID_MACRO_ID',
                SSS_NO_SUCH_RECORD_ACTION: 'SSS_NO_SUCH_RECORD_ACTION',
	            SSS_RECORD_DOES_NOT_SATISFY_CONDITION: 'SSS_RECORD_DOES_NOT_SATISFY_CONDITION',
                SELECT_OPTION_ALREADY_PRESENT: 'SELECT_OPTION_ALREADY_PRESENT',
                SELECT_OPTION_NOT_FOUND: 'SELECT_OPTION_NOT_FOUND',
	            YOU_HAVE_ATTEMPTED_AN_UNSUPPORTED_ACTION: 'YOU_HAVE_ATTEMPTED_AN_UNSUPPORTED_ACTION',
	            INVALID_RETURN_TYPE_EXPECTED_1: 'INVALID_RETURN_TYPE_EXPECTED_1',
	            HISTORY_IS_ONLY_AVAILABLE_FOR_THE_LAST_30_DAYS: 'HISTORY_IS_ONLY_AVAILABLE_FOR_THE_LAST_30_DAYS',
	            SSS_ARGUMENT_DISCREPANCY: 'SSS_ARGUMENT_DISCREPANCY'
            });

            var isVersionTwoOne = apiBridge !== errorApi;

            /**
             *
             * @protected
             * @constructor
             */
            function SuiteScriptError(delegate)
            {
                var TYPE = 'error.SuiteScriptError';

                /**
                 * @name SuiteScriptError#id
                 * @type string
                 * @readonly
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'id', {
                    get: function ()
                    {
                        return delegate.getId();
                    },
                    set: function (val)
                    {
                        throw new SuiteScriptError(errorApi.nlapiCreateError(ERROR_TYPES.READ_ONLY_PROPERTY, getErrorMessage(ERROR_TYPES.READ_ONLY_PROPERTY,'id'),false)); //TODO invoker?
                    },
                    enumerable: true,
                    configurable: false
                });

                /**
                 * @name SuiteScriptError#name
                 * @type string
                 * @readonly
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'name', {
                    get: function ()
                    {
                        return delegate.name || (delegate.getCode) ? delegate.getCode() : '';
                    },
                    set: function (val)
                    {
                        throw new SuiteScriptError(errorApi.nlapiCreateError(ERROR_TYPES.READ_ONLY_PROPERTY, getErrorMessage(ERROR_TYPES.READ_ONLY_PROPERTY,'name'),false));
                    },
                    enumerable: true,
                    configurable: false
                });

                /**
                 * @name SuiteScriptError#message
                 * @type string
                 * @readonly
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'message', {
                    get: function ()
                    {
                        return delegate.message || (delegate.getDetails) ? delegate.getDetails() : '';
                    },
                    set: function (val)
                    {
                        throw new SuiteScriptError(errorApi.nlapiCreateError(ERROR_TYPES.READ_ONLY_PROPERTY, getErrorMessage(ERROR_TYPES.READ_ONLY_PROPERTY,'message'),false));
                    },
                    enumerable: true,
                    configurable: false
                });

                /**
                 * @name SuiteScriptError#stack
                 * @type string[]
                 * @readonly
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'stack', {
                    get: function ()
                    {
                        return util.isFunction(delegate.getStackTrace) ? delegate.getStackTrace().slice(0) : '';
                    },
                    //'stack' must be settable in order to wrap a JS error with a SuiteScript error
                    enumerable: true,
                    configurable: false
                });

                /**
                 * @name SuiteScriptError#cause
                 * @type Anything
                 * @readonly
                 * @since 2016.1
                 */
                Object.defineProperty(this, 'cause', {
                    get: function ()
                    {
                        return delegate.cause || this;
                    },
                    set: function (val)
                    {
                        throw new SuiteScriptError(errorApi.nlapiCreateError(ERROR_TYPES.READ_ONLY_PROPERTY, getErrorMessage(ERROR_TYPES.READ_ONLY_PROPERTY,'cause'),false));
                    },
                    enumerable: true,
                    configurable: false
                });

                /**
                 * @name SuiteScriptError#notifyOff
                 * @type boolean
                 * @readonly
                 * @since 2016.2
                 */
                Object.defineProperty(this, 'notifyOff', {
                    get: function ()
                    {
                        return delegate.notifyOff;
                    },
                    set: function (val)
                    {
                        throw new SuiteScriptError(errorApi.nlapiCreateError(ERROR_TYPES.READ_ONLY_PROPERTY, getErrorMessage(ERROR_TYPES.READ_ONLY_PROPERTY,'notifyOff'),false));
                    },
                    enumerable: true,
                    configurable: false
                });

                // Functions for debugger


                this.toJSON = function toJSON()
                {
                    var delegateType = typeof(delegate);
                    return {
                        type: TYPE,
                        name: this.name,
                        message: this.message,
                        stack: this.stack,
                        cause: delegateType === "function" || delegateType === "object" && !!delegate ? delegate.cause || delegate : this,
                        id: this.id,
                        notifyOff: this.notifyOff,
	                    data: this.data
                    };
                };

                this.toString = function toString()
                {
                    return JSON.stringify(this);
                };


            }

            //inheritance TODO this is not working for Error, SuiteScriptError is not an instanceof Error
            var debuggable = nsobject.getNewInstance();
            var err = Object.create(Error.prototype);
            debuggable.prototype = err;
            SuiteScriptError.prototype = debuggable;
            SuiteScriptError.prototype.constructor = SuiteScriptError;

            /**
             *
             * @protected
             * @constructor
             */
            function UserEventError(delegate)
            {
                var TYPE = 'error.UserEventError';

                /**
                 * @name SuiteScriptError#recordId
                 * @type string
                 * @readonly
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'recordId', {
                    get: function ()
                    {
                        return delegate.getInternalId();
                    },

                    enumerable: true,
                    configurable: false
                });

                /**
                 * @name SuiteScriptError#eventType
                 * @type string
                 * @readonly
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'eventType', {
                    get: function ()
                    {
                        return delegate.getUserEvent();
                    },

                    enumerable: true,
                    configurable: false
                });

                this.toJSON = function toJSON()
                {
                    var delegateType = typeof(delegate);
                    return {
                        type: TYPE,
                        name: delegate.getCode(),
                        message: delegate.getDetails(),
                        stack: this.stack,
                        eventType: delegate.getUserEvent(),
                        recordId: delegate.getInternalId(),
                        cause: delegateType === "function" || delegateType === "object" && !!delegate ? delegate.cause || delegate : this,
                        id: this.id
                    };
                };

                this.toString = function toString()
                {
                    return JSON.stringify(this);
                };

            }

            UserEventError.prototype = new SuiteScriptError();

            function getErrorMessage(errorCode, errorVal1, errorVal2, errorVal3, errorVal4)
            {
                return remoteUtil.getErrorMessage(errorCode, errorVal1, errorVal2, errorVal3, errorVal4);
            }

			function prepareDelegate(apiError)
			{
				var stackTrace = isVersionTwoOne ? Error().stack.split("\n\t") : apiError.getStackTrace();
				var code = apiError.getCode();
				var details = apiError.getDetails();
				var id = apiError.getId();
				var userEvent = apiError.getUserEvent();
                var notifyOff = apiError.isSuppressNotification()||false;
				var delegate = {
					getStackTrace: function() { return stackTrace; },
					getDetails: function() { return details; },
					getCode: function() { return code; },
					getId: function() { return id; }
				};
                delegate.notifyOff = notifyOff;
				delegate.cause = {
					id: id,
					code: code,
					details: details,
					userEvent: userEvent,
					stackTrace: stackTrace.slice(0),
					toString: function() { return JSON.stringify(this); },
					toJSON: function()
					{
						return {
							type: "internal error",
							code: code,
							details: details,
							userEvent: userEvent,
							stackTrace: stackTrace.slice(0),
                            notifyOff: notifyOff
						};
					}
				};
				return delegate;
			}

	        function javaArrayToJsArray(javaArray)
	        {
		        var toRet = [];
		        for(var i = 0; javaArray && i < javaArray.length; i++)
			        toRet[i] = javaArray[i];

		        return toRet;
	        }

			// The result of this method will pass a potential call to JSON.stringify(), etc.
			function getSafeCause(errorObj)
			{
				var cause = errorObj.cause || errorObj;
				if (cause instanceof Error)
				{
					var safeCopy = {};
					Object.getOwnPropertyNames(cause).forEach(function (prop) {
						safeCopy[prop] = (prop === "stack" || prop === "rhinoException") ? cause[prop].toString() : cause[prop];
					});
					cause = safeCopy;
				}
				return cause;
			}

			function addCustomDataToError(suiteScriptError, data)
			{
				Object.defineProperty(suiteScriptError, 'data', {
					get: function ()
					{
						return data;
					},
					set: function (val)
					{
						throw new SuiteScriptError(errorApi.nlapiCreateError(ERROR_TYPES.READ_ONLY_PROPERTY, getErrorMessage(ERROR_TYPES.READ_ONLY_PROPERTY, 'data'),false));
					},
					enumerable: true,
					configurable: false
				});
			}

            function createError(options)
            {
	            var currentStackTrace = null;
	            if (isVersionTwoOne)
		            currentStackTrace = Error().stack.split("\n\t");

                if (!options)
                    throw new SuiteScriptError(errorApi.nlapiCreateError(ERROR_TYPES.MISSING_REQD_ARGUMENT, getErrorMessage(ERROR_TYPES.MISSING_REQD_ARGUMENT, 'error.create', 'options'), false));
	            if (options.notifyOff !== undefined && !util.isBoolean(options.notifyOff))
		            throw new SuiteScriptError(errorApi.nlapiCreateError(ERROR_TYPES.WRONG_PARAMETER_TYPE, getErrorMessage(ERROR_TYPES.WRONG_PARAMETER_TYPE, 'options.notifyOff', 'boolean'), false));

                var toRet = null;
                // Wrap internal Java exception
                if (options instanceof Object && options.constructor.name === 'JavaException')
                {
	                toRet = new SuiteScriptError(prepareDelegate(errorApi.nlapiCreateError(options, null, false)));
	                if (!!options.javaException && util.isFunction(options.javaException.getData))
		                addCustomDataToError(toRet, JSON.parse(options.javaException.getData()));
                }
                else if (!!options.getClass && !!options.getClass().getName()
	                && (options.getClass().getName().endsWith('NLServerSideScriptException') || options.getClass().getName().endsWith('NLUserError') || options.getClass().getName().endsWith('SuiteScriptError')))
                {
	                toRet = new SuiteScriptError(prepareDelegate(errorApi.nlapiCreateError(options, null, false)));
	                if (options.getClass().getName().endsWith('SuiteScriptError'))
		                addCustomDataToError(toRet, JSON.parse(options.getData()));
                }
                // [Rhino Only] Wrap nlobjError delegate
                else if (options instanceof Object && options.constructor.name === 'nlobjError')
                {
                    toRet = new SuiteScriptError(prepareDelegate(options));
                }
                // JS error is the "cause"
	            else if (util.isError(options) || options instanceof SuiteScriptError)
	            {
		            var apiError = errorApi.nlapiCreateError(options.name, options.message, options.notifyOff || false);
		            var delegate = {
			            getStackTrace: function() { return isVersionTwoOne ? currentStackTrace : apiError.getStackTrace(); },
			            getDetails: function() { return options.message; },
			            getCode: function() { return options.name; },
			            getId: function() { return options.id; }
		            };
		            delegate.cause = getSafeCause(options);
		            delegate.notifyOff = options.notifyOff || false;
		            toRet = new SuiteScriptError(delegate);
	            }
                // Standard case, options are args to create SuiteScriptError, duck type the arg
                else if(options.hasOwnProperty // extends Object.prototype
	                && (options.hasOwnProperty('name') || options.hasOwnProperty('message') || options.hasOwnProperty('notifyOff')))
                {
	                var apiError = errorApi.nlapiCreateError(options.name, options.message, options.notifyOff || false);
	                var delegate = {
		                getStackTrace: function() { return isVersionTwoOne ? currentStackTrace : apiError.getStackTrace(); },
		                getDetails: function() { return apiError.getDetails(); },
		                getCode: function() { return apiError.getCode(); },
		                getId: function() { return apiError.getId(); }
	                };
	                delegate.cause = getSafeCause(options);
	                delegate.notifyOff = options.notifyOff || false;
	                toRet = new SuiteScriptError(delegate);
                }
                else if(typeof options !== 'object') //convenience method. If string is passed in, set it to details.
                {
	                var apiError = errorApi.nlapiCreateError(options, null, false);
	                var delegate = {
		                getStackTrace: function() { return isVersionTwoOne ? currentStackTrace : apiError.getStackTrace(); },
		                getDetails: function() { return options; },
		                getCode: function() { return ""; },
		                getId: function() { return apiError.getId(); }
	                };
	                delegate.cause = getSafeCause(options);
	                delegate.notifyOff = options.notifyOff || false;
	                toRet = new SuiteScriptError(delegate);
                }
	            else // nlobjError ctor logic tries to handle other cases (options is a java object)
	            {
		            var apiError = errorApi.nlapiCreateError(options, null, false);
		            var delegate = {
			            getStackTrace: function() { return isVersionTwoOne ? currentStackTrace : apiError.getStackTrace(); },
			            getDetails: function() { return apiError.getDetails(); },
			            getCode: function() { return apiError.getCode(); },
			            getId: function() { return apiError.getId(); }
		            };
		            delegate.cause = getSafeCause(options);
		            delegate.notifyOff = options.notifyOff || false;
		            toRet = new SuiteScriptError(delegate);
	            }

                return toRet;
            }

            return Object.freeze({
                /**
                 * Create a new Error object
                 *
                 * @param {Object} options
                 * @param {string} options.name
                 * @param {string} options.message
                 * @param {string} options.notifyOff
                 * @return {SuiteScriptError}
                 */
                create: createError,
                Type: ERROR_TYPES
            });

        });

/**
 * SuiteScript module
 *
 * @private
 * @module N/util
 * @NApiVersion 2.x
 *
 */
define('N/util',[], function () {
    return util;
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/log
 * @NApiVersion 2.x
 *
 */
define('N/log',[], function () {
    return log;
});

/**
 * @private
 */
define('N/restricted/fileApi',['N/restricted/reflet'], function(reflet){ return reflet; });

/**
 * SuiteScript module
 *
 * @private
 * @module N/utilityFunctionsImpl
 * @NApiVersion 2.x
 */
define('N/utilityFunctionsImpl',[],
    function ()
    {
        var serverCallSyncImpl = null;
        var serverCallAsyncImpl = null;

        // When client script modules are imported on the server side during script analysis, serverCallSync will not exist as a global variable.
        if (typeof serverCallSync !== 'undefined') {
            // serverCallSync is defined in client bootstrap.js, we should remove it from global space.
            serverCallSyncImpl = serverCallSync;
        }
        else {
            var global = (function () {return this;})();
            serverCallSyncImpl = global.serverCallSync;
        }

        // When client script modules are imported on the server side during script analysis, serverCallAsyncImpl will not exist as a global variable.
        if (typeof serverCallAsync !== 'undefined') {
            // serverCallAsyncImpl is defined in client bootstrap.js, we should remove it from global space.
            serverCallAsyncImpl = serverCallAsync;
        }
        else {
            var global = (function () {return this;})();
            serverCallAsyncImpl = global.serverCallAsync;
        }

        return {
            serverCall: serverCallSyncImpl,
            serverCallAsync: serverCallAsyncImpl
        };
    });

/**
 * SuiteScript module
 *
 * @private
 * @module /.api/restricted/invoker
 * @NApiVersion 2.x
 */
define('N/restricted/invoker',['N/error'],
        function (error)
        {
            var callURL = '/app/common/scripting/ClientScriptHandler.nl?';
            var platformRequestURL = '/app/common/scripting/PlatformClientScriptHandler.nl?';

            var needsFirstArg = ['nlapiLoadRecord', 'loadRecord', 'nlapiCreateRecord', 'createRecord', 'nlapiCopyRecord', 'copyRecord', 'nlapiTransformRecord', 'transformRecord', 'nlapiSubmitField', 'nlapiDeleteRecord', 'nlapiSearchRecord', 'executeAction'];

            function checkForCharge(target, method, args, governanceOverride)
            {
                if (!!target && target.hasOwnProperty("chargeUsage"))
                {
                    var type;
                    if (method === "nlapiSubmitRecord")
                        type = args[0].getRecordType()
                    else if (!!args && needsFirstArg.indexOf(method) != -1)
                        type = args[0];
                    else
                        type = null;
                    target["chargeUsage"].apply(this, [method, type, args, governanceOverride]);
                }
            }

            function tryParsing(data)
            {
                var parsedData = {};
                try
                {
                    parsedData = JSON.parse(data);
                }
                catch (e)
                {
                    return data;
                }

                return parsedData;
            }

            return function invokeOn(target, method, args, callback, parseResult)
            {
                var result;
	            var governanceOverride;

                parseResult = parseResult === undefined || !!parseResult;

                if (!!target && (typeof target[method] !== "undefined"))
                {
                    result = target[method].apply(target, args);
                }
                else
                {
                    try
                    {
	                    var bridge = !!target ? target.bridge : null;
	                    var targetURL = !!bridge ? platformRequestURL : callURL;
	                    if (args === undefined || args === null)
	                    	args = [];
                        if (!util.isFunction(callback))
                        {
	                        if (!!bridge)
	                        {
		                        result = serverCallSync(targetURL, "bridgeCall", [bridge, method].concat(JSON.stringify(args)));
		                        governanceOverride = result.governance;
		                        result = result.result;
	                        }
                            else
                            	result = serverCallSync(targetURL, method, args);
                            if (parseResult)
                            {
                                result = tryParsing(result);
                            }
                            checkForCharge(target, method, args, governanceOverride);
                        }
                        else
                        {
	                        var scriptRun;
	                        if (typeof document !== "undefined" && typeof target["getScript"] !== "undefined")
	                        {
		                        scriptRun = target["getScript"].apply(target, []);
	                        }
                            var myCallback = function (response)
                            {
	                            if (typeof document !== 'undefined' && !!scriptRun && typeof target["recoverScript"] !== "undefined")
	                            {
		                            target["recoverScript"].apply(target, [scriptRun]);
		                            window.NLScriptId = scriptRun.scriptId;
	                            }
                                var result = response;
                                //noinspection JSUnresolvedVariable
                                if (!(response instanceof Error))
                                {
                                    if (response.hasOwnProperty("nlError") && response.nlError)
                                    {
                                        result = Error(response.details);
                                        result.name = response.code;
                                    }
                                    else
                                    {
                                        result = response.result;

	                                    if (!!bridge)
	                                    {
		                                    governanceOverride = result.governance;
		                                    result = result.result;
	                                    }
                                        if (parseResult)
                                        {
                                            result = tryParsing(result);
                                        }
                                        checkForCharge(target, method, args, governanceOverride);
                                    }
                                }
                                return callback(result);
                            };
                            if (!!bridge)
                            	serverCallAsync(targetURL, "bridgeCall", [bridge, method].concat(JSON.stringify(args)), myCallback);
	                        else
	                            serverCallAsync(targetURL, method, args, myCallback);
                        }
                    }
                    catch (e)
                    {
                        throw error.create(e);
                    }
                }
                return result;
            };
        }
);

/**
 * SuiteScript module
 *
 * @private
 * @module N/utilityFunctions
 * @NApiVersion 2.x
 */
define(
	'N/utilityFunctions',['N/utilityFunctionsImpl', 'N/error', 'N/restricted/invoker', 'N/restricted/remoteApiBridge'],
	function (utilImpl, error, invoker, remoteApi)
	{
		function getGlobalScope()
		{
			return (function () {return this;}());
		}

		function isObject(obj)
		{
			return obj === Object(obj);
		}

		/**
		 * check if the value is empty
		 * @param val String being tested for whether it is empty (null or "")
		 * @originalFrom NLRecordUtil.js
		 */
		function isValEmpty(val)
		{
			if (val === null || val === undefined)
				return true;

			val = String(val);
			return (val.length === 0) || !/\S/.test(val);
		}

		function isEmpty(val)
		{
			if (val === null || val === undefined)
				return true;

			val = String(val);
			return val.length === 0;
		}

		function isInternalErrorCode(errorCode)
		{
			for (var code in error.Type)
			{
				if (error.Type[code] === errorCode)
					return true;
			}

			return false;
		}

		function getErrorMessage(errorCode, errorVal1, errorVal2, errorVal3, errorVal4)
		{
			return invoker(remoteApi, 'getErrorMessage', [errorCode, errorVal1, errorVal2, errorVal3, errorVal4]);
		}

		function throwSuiteScriptError(errorCode, errorMessageVal1, errorMessageVal2, errorMessageVal3, errorMessageVal4, internalErrorMessageCode)
		{
			var message = "";
			if (internalErrorMessageCode != null)
				message = getErrorMessage(internalErrorMessageCode, errorMessageVal1, errorMessageVal2, errorMessageVal3, errorMessageVal4);
			else if (isInternalErrorCode(errorCode))
				message = getErrorMessage(errorCode, errorMessageVal1, errorMessageVal2, errorMessageVal3, errorMessageVal4);
			throw error.create({name: errorCode, message: message});
		}

		function createSuiteScriptError(errorCode, errorMessageVal1, errorMessageVal2, errorMessageVal3, errorMessageVal4, internalErrorMessageCode)
		{
			var message = "";
			if (internalErrorMessageCode != null)
				message = getErrorMessage(internalErrorMessageCode, errorMessageVal1, errorMessageVal2, errorMessageVal3, errorMessageVal4);
			else if (isInternalErrorCode(errorCode))
				message = getErrorMessage(errorCode, errorMessageVal1, errorMessageVal2, errorMessageVal3, errorMessageVal4);
			return error.create({name: errorCode, message: message});
		}

		function checkArgs(funcArgs, funcArgNames, funcName)
		{
			for (var i = 0; i < funcArgs.length; i++)
			{
				if (!funcArgs[i] && funcArgs[i] !== 0)
					throwSuiteScriptError(error.Type.MISSING_REQD_ARGUMENT, funcName ? funcName : '', funcArgNames[i]);
			}
		}

		function checkArgsPresent(funcArgs, funcArgNames, funcName)
		{
			for (var i = 0; i < funcArgs.length; i++)
			{
				if (funcArgs[i] == null)
					throwSuiteScriptError(error.Type.MISSING_REQD_ARGUMENT, funcName ? funcName : '', funcArgNames[i]);
			}
		}

		function checkArgsAllowNull(funcArgs, funcArgNames, funcName)
		{
			for (var i = 0; i < funcArgs.length; i++)
			{
				if (!funcArgs[i] && funcArgs[i] !== 0 && funcArgs[i] !== null)
					throwSuiteScriptError(error.Type.MISSING_REQD_ARGUMENT, funcName ? funcName : '', funcArgNames[i]);
			}
		}

		function assertTrue(expression, errorCode, errorMessageVal1, errorMessageVal2)
		{
			if (!expression)
				throwSuiteScriptError(errorCode, errorMessageVal1, errorMessageVal2);
		}

		function checkMutuallyExclusiveArguments(arg1, arg2, arg1Name, arg2Name)
		{
			if (arg1 != undefined && arg2 != undefined)
				throwSuiteScriptError(error.Type.MUTUALLY_EXCLUSIVE_ARGUMENTS, arg1Name, arg2Name);
		}

		function freezeObjectIfPossible(obj)
		{
			return (Object.freeze && (obj || obj === "" || obj === 0)) ? Object.freeze(obj) : obj;
		}

		function wrapDelegates(array, type)
		{
			return (array && array.map)
				? array.map(function (el, idx, arr)
				{
					return new type(el);
				})
				: null;
		}

		function arrayIndexOf(array, val, ignoreCase)
		{
			for (var i = 0; array && i < array.length; i++)
			{
				if (val === array[i] || (ignoreCase && val && array[i] && val.toLowerCase() === array[i].toLowerCase()))
					return i;
			}
			return -1;
		}

		function assignDefaultOrCurrentValue(arg, defaultVal)
		{
			return arg || arg === 0 || arg === false ? arg : defaultVal;
		}

		function checkArgTypes(checkArgObjectArray)
		{
			for (var i = 0; i < checkArgObjectArray.length; i++)
			{
				var current = checkArgObjectArray[i];
				if ((current.value || current.value === 0 || current.value === false) &&
					((util.isNumber(current.value) && isNaN(current.value)) || !current.verifyFunction(current.value)))
				{
					throwSuiteScriptError(error.Type.SSS_INVALID_TYPE_ARG, current.name);
				}
			}
		}

		function checkArgObject(value, name, verifyFunction)
		{
			return {
				value: value,
				name: name,
				verifyFunction: verifyFunction
			};
		}

		var serverCall = function (url, methodName, args)
		{
			return utilImpl.serverCall(url, methodName, args);
		};

		serverCall.promise = function (url, methodName, args)
		{
			var myPromise = new Promise(function (resolve, reject)
			{
				try
				{
					utilImpl.serverCallAsync(url, methodName, args, function (response)
					{
						(response instanceof Error) ? reject(response) : resolve(response);
					});
				}
				catch (e)
				{
					reject(e);
				}
			});
			return myPromise;
		};

		/**
		 * Search Util
		 */
		function unmarshalArray(payloadMap, prefix, unmarshalFunction)
		{
			var array = [];
			var count = payloadMap[prefix + 'count']; // TODO : investigate if count is used elsewhere
			for (var i = 0; i < count; ++i)
			{
				var attributeMap = payloadMap[prefix + i];
				var obj = unmarshalFunction(attributeMap);
				array.push(obj);
			}
			return array;
		}

		function arrayToMap(array, func)
		{
			var result = [];
			for (var i = 0; i < array.length; ++i)
			{
				result.push(func(array[i]));
			}
			return result;
		}

		function assertArrayElementsOfSameType(array, type, argName, errorCode)
		{
			if (!util.isArray(array))
				return;
			for (var i = 0; i < array.length; i++)
			{
				assertTrue(isElementSameType(array[i], type), errorCode || 'SSS_INVALID_ARRAY_ARGUMENT', argName + '[' + i + ']');
			}

		}

		function isElementSameType(element, type)
		{
			return (element || element === 0) &&
				((type === Object(type) && element instanceof type) ||
					typeof element === type ||
					(element.constructor && element.constructor.name && element.constructor.name === type));
		}

		function normalizeArrayOrSingularObjectArg(arg)
		{
			return util.isArray(arg) ? arg : arg != undefined ? [arg] : null;
		}

		function arrayContains(array, val)
		{
			return arrayIndexOf(array, val) >= 0;
		}

		function arrayAdd(array, val)
		{
			if (!arrayContains(array, val))
				array.push(val);
		}

		function addParameterToMap(map, params)
		{
			if (!map)
				map = {};

			for (var key in params)
			{
				if (params.hasOwnProperty(key))
					map[key] = params[key];
			}

			return map;
		}

		/*
		 * Supply additional information to the arguments being passed in,
		 * with care to possibility that the inputted args are flattened or in an object
		 */
		function augmentArguments(args, keyName, keyValue)
		{
			var returnMe = args;
			if (!!returnMe)
			{
				if (returnMe.length > 1 || !isObject(returnMe[0]))
					Array.prototype.push.call(returnMe, keyValue);
				else if (isObject(returnMe[0]))
					returnMe[0][keyName] = keyValue;
			}
			return returnMe;
		}

		function returnEmptyIfNull(str)
		{
			return str != null ? str : "";
		}

		function getAsArray(arg)
		{
			return arg != null ? (util.isArray(arg) ? arg : [arg]) : null;
		}

		function addReadOnlyProperty(target, propertyName, getter)
		{
			Object.defineProperty(target, propertyName, {
				get: function ()
				{
					return getter();
				},
				set: function ()
				{
					throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, propertyName);
				},
				enumerable: true,
				configurable: false
			});
		}

		function addReadOnlyNonEnumerableProperty(target, propertyName, getter)
		{
			Object.defineProperty(target, propertyName, {
				get: function ()
				{
					return getter();
				},
				set: function ()
				{
					throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, propertyName);
				},
				enumerable: false,
				configurable: false
			});
		}

		function promiseTo(fn, params, postProcess)
		{
			return new Promise(function (resolve, reject)
			{
				var callback = function(result)
				{
					if (util.isError(result))
					{
						reject(result);
						return;
					}
					resolve(util.isFunction(postProcess) ? postProcess({result: result, data: this}) : result);
				};

				callback.promiseCallback = true;

				try
				{
					fn.apply(callback, Array.prototype.slice.call(params));
				}
				catch (e)
				{
					reject(e);
				}
			});
		}

		function isPromiseCallback(options)
		{
			return util.isFunction(options) && options.promiseCallback;
		}

		return Object.freeze({
								 getGlobalScope: getGlobalScope,
								 isObject: isObject,
								 isValEmpty: isValEmpty,
								 isEmpty: isEmpty,
								 assignDefaultOrCurrentValue: assignDefaultOrCurrentValue,
								 checkArgTypes: checkArgTypes,
								 checkArgObject: checkArgObject,
								 wrapDelegates: wrapDelegates,
								 freezeObjectIfPossible: freezeObjectIfPossible,
								 isInternalErrorCode: isInternalErrorCode,
								 getErrorMessage: getErrorMessage,
								 throwSuiteScriptError: throwSuiteScriptError,
								 createSuiteScriptError: createSuiteScriptError,
								 arrayIndexOf: arrayIndexOf,
								 arrayContains: arrayContains,
								 arrayAdd: arrayAdd,
								 checkArgs: checkArgs,
								 checkArgsPresent: checkArgsPresent,
								 checkArgsAllowNull: checkArgsAllowNull,
								 assertTrue: assertTrue,
								 checkMutuallyExclusiveArguments: checkMutuallyExclusiveArguments,
								 serverCall: serverCall,
								 unmarshalArray: unmarshalArray,
								 arrayToMap: arrayToMap,
								 assertArrayElementsOfSameType: assertArrayElementsOfSameType,
								 normalizeArrayOrSingularObjectArg: normalizeArrayOrSingularObjectArg,
								 addParameterToMap: addParameterToMap,
								 augmentArguments: augmentArguments,
								 returnEmptyIfNull: returnEmptyIfNull,
								 getAsArray: getAsArray,
								 addReadOnlyProperty: addReadOnlyProperty,
								 addReadOnlyNonEnumerableProperty: addReadOnlyNonEnumerableProperty,
								 promiseTo: promiseTo,
								 isPromiseCallback: isPromiseCallback
							 });
	}
);

/**
 * SuiteScript module
 *
 * @private
 * @module N/restricted/creationFunctionWrapper
 * @NApiVersion 2.x
 *
 */
define('N/creationFunctionWrapper',[], function () {
    function ReflectiveSetterProxy(target) {
        return (function init(target) {
            if (!target || target === this)
                return target;
            var proxy = null;
            if (util.isFunction(target) && target.prototype && target.prototype.hasOwnProperty) {
                proxy = function () {
                    var targetFunction = target;
                    var retMe = targetFunction.apply(this, arguments);
                    var options = arguments[0];
                    for (var p in options)
                    {
                        if (options.hasOwnProperty(p))
                        {
                            var value = options[p];
                            if (retMe.hasOwnProperty(p) && !util.isFunction(retMe[p]) && retMe[p] != value)
                            {
                                try
                                {
                                    retMe[p] = value;
                                }
                                catch (err)
                                {
                                    if (err.name !== 'READ_ONLY_PROPERTY')
                                    {
                                        throw err;
                                    }
                                }
                            }
                        }
                    }
                    return retMe;
                };
                proxy.toString = function () {
                    return '';
                };
            }
            else if (Object.prototype.toString.call(target) === '[object Object]' && target.hasOwnProperty) {
                proxy = {};
                proxyObjChildren(target, proxy);
            }
            else
                proxy = target;

            function proxyObjChildren(target, proxy) {
                for (var p in target)
                    if (target.hasOwnProperty(p))
                        proxy[p] = init(target[p]);
            }
            return proxy;
        })(target);
    };
    function wrapFunction (f) {
        return new ReflectiveSetterProxy(f);
    }
    return Object.freeze({
        wrap : wrapFunction
    });
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/iterator
 * @NApiVersion 2.x
 */
define('N/common/pattern/iterator',['N/nsobject', 'N/utilityFunctions'], function (nsObject, utilityFunctions)
{

	/**
	 *
	 * @param {JavaLikeIterator} delegate
	 * @constructor
	 * @protected
	 */
	function Iterator(delegate)
	{

		/**
		 * ECMA 2015 style
		 *
		 * @return {{done: boolean, value: *}}
		 */
		this.next = function next()
		{
			var result = {done: !delegate.hasNext()};
			if (!result.done)
			{
				result.value = delegate.next();
			}
			return result;
		};

		/**
		 *
		 * @callback iteratorFunction
		 * @param {{value: *}} value
		 * @return {boolean} Should continue iteration?
		 */

		/**
		 * SuiteScript style
		 *
		 * @param {iteratorFunction} iteratorFunction
		 */
		this.each = function each(iteratorFunction)
		{
			utilityFunctions.checkArgs([iteratorFunction], ['iteratorFunction'], 'Iterator.each');

			var cont = true;
			while (delegate.hasNext() && cont)
			{
				cont = !!iteratorFunction({value: delegate.next()});
			}
		};

	}

	Iterator.prototype = nsObject.getNewInstance();

	return Object.freeze({
		/**
		 * @param {JavaLikeIterator} iterable
		 * @return {Iterator}
		 */
		create: function create(iterable)
		{
			return Object.freeze(new Iterator(iterable));
		}
	});

});

/**
 * SuiteScript file module
 *
 * @module N/file
 * @NApiVersion 2.x
 *
 */
define('N/file',['N/restricted/fileApi', 'N/error', 'N/nsobject', 'N/utilityFunctions', 'N/restricted/invoker','N/creationFunctionWrapper', 'N/common/pattern/iterator'],
	function (apiBridge, error, nsobject, utilityFunctions, invoker, funcWrapper, iteratorFactory)
	{
		//enums
		var FILE_TYPES = Object.freeze({
			APPCACHE: 'APPCACHE',
			AUTOCAD: 'AUTOCAD',
			BMPIMAGE: 'BMPIMAGE',
			CERTIFICATE : 'CERTIFICATE',
			CONFIG : 'CONFIG',
			CSV: 'CSV',
			EXCEL: 'EXCEL',
			FLASH: 'FLASH',
			FREEMARKER: 'FREEMARKER',
			GIFIMAGE: 'GIFIMAGE',
			GZIP: 'GZIP',
			HTMLDOC: 'HTMLDOC',
			ICON: 'ICON',
			JAVASCRIPT: 'JAVASCRIPT',
			JPGIMAGE: 'JPGIMAGE',
			JSON: 'JSON',
			MESSAGERFC: 'MESSAGERFC',
			MP3: 'MP3',
			MPEGMOVIE: 'MPEGMOVIE',
			MSPROJECT: 'MSPROJECT',
			PDF: 'PDF',
			PJPGIMAGE: 'PJPGIMAGE',
			PLAINTEXT: 'PLAINTEXT',
			PNGIMAGE: 'PNGIMAGE',
			POSTSCRIPT: 'POSTSCRIPT',
			POWERPOINT: 'POWERPOINT',
			QUICKTIME: 'QUICKTIME',
			RTF: 'RTF',
			SCSS: 'SCSS',
			SMS: 'SMS',
			STYLESHEET: 'STYLESHEET',
			SVG : 'SVG',
			TAR: 'TAR',
			TIFFIMAGE: 'TIFFIMAGE',
			VISIO: 'VISIO',
			WEBAPPPAGE: 'WEBAPPPAGE',
			WEBAPPSCRIPT: 'WEBAPPSCRIPT',
			WORD: 'WORD',
			XMLDOC: 'XMLDOC',
			XSD : 'XSD',
			ZIP: 'ZIP'
		});
		var ENCODINGS = Object.freeze({
			UTF_8: 'UTF-8',
			WINDOWS_1252: 'windows-1252',
			ISO_8859_1: 'ISO-8859-1',
			GB18030: 'GB18030',
			SHIFT_JIS: 'SHIFT_JIS',
			MAC_ROMAN: 'MacRoman',
			GB2312: 'GB2312',
			BIG5: 'Big5'
		});

		var fileLinesObjectsCreated = [];

		/**
		 * Return a new instance of file.File used for accessing and manipulating files in the file cabinet.
		 *
		 * @protected
		 * @class File
		 * @classdesc Encapsulation of files (media items) in the file cabinet.
		 * @alias file.File
		 *
		 * @since 2015.2
		 */
		function File(delegate, folder)
		{
			var TYPE = 'file.File';
			/**
			 The id of the file (if stored in the FC).
			 * @name File#id
			 * @type number
			 * @readonly
			 * @throws READ_ONLY_PROPERTY when setting the property is attempted
			 */
			Object.defineProperty(this, 'id', {
				get: function ()
				{
					return delegate.getId();
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'id');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});
			/**
			 The size of the file in bytes.
			 * @name File#size
			 * @type number
			 * @readonly
			 * @throws READ_ONLY_PROPERTY when setting the property is attempted
			 */
			Object.defineProperty(this, 'size', {
				get: function ()
				{
					return delegate.getSize();
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'size');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});
			/**
			 Return the URL of the file (if stored in the FC).
			 * @name File#url
			 * @type string
			 * @readonly
			 * @throws READ_ONLY_PROPERTY when setting the property is attempted
			 */
			Object.defineProperty(this, 'url', {
				get: function ()
				{
					return delegate.getURL();
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'url');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});
			/**
			 The path to the file in the file cabinet.
			 * @name File#path
			 * @type string
			 * @readonly
			 * @throws READ_ONLY_PROPERTY when setting the property is attempted
			 */
			Object.defineProperty(this, 'path', {
				get: function ()
				{
					return delegate.getPath();
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'path');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});
			/**
			 The type of the file.
			 * @name File#fileType
			 * @type string
			 * @readonly
			 * @throws READ_ONLY_PROPERTY when setting the property is attempted
			 */
			Object.defineProperty(this, 'fileType', {
				get: function ()
				{
					return delegate.getType();
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'fileType');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});
			/**
			 * Indicates whether or not the file is text-based or binary.
			 * @name File#isText
			 * @type boolean
			 * @readonly
			 * @throws READ_ONLY_PROPERTY when setting the property is attempted
			 */
			Object.defineProperty(this, 'isText', {
				get: function ()
				{
					return delegate.isText();
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isText');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});
			/**
			 * The character encoding for the file.
			 * @name File#encoding
			 * @type string
			 */
			Object.defineProperty(this, 'encoding', {
				get: function ()
				{
					return delegate.getEncoding();
				},
				set: function (val)
				{
					delegate.setEncoding(val);
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});
			/**
			 * The name of the file.
			 * @name File#name
			 * @type string
			 */
			Object.defineProperty(this, 'name', {
				get: function ()
				{
					return delegate.getName();
				},
				set: function (val)
				{
					delegate.setName(val);
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});
			/**
			 * The internal ID of the folder that this file is in.
			 * @name File#folder
			 * @type number
			 */
			Object.defineProperty(this, 'folder', {
				get: function ()
				{
					return delegate.getFolder();
				},
				set: function (val)
				{
					delegate.setFolder(val);
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});
			/**
			 * The file description.
			 * @name File#description
			 * @type string
			 */
			Object.defineProperty(this, 'description', {
				get: function ()
				{
					return delegate.getDescription();
				},
				set: function (val)
				{
					delegate.setDescription(val);
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});
			/**
			 * The file's inactive status.
			 * @name File#isInactive
			 * @type boolean
			 */
			Object.defineProperty(this, 'isInactive', {
				get: function ()
				{
					return delegate.isInactive();
				},
				set: function (val)
				{
					delegate.setIsInactive(val);
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});
			/**
			 * The file's "Available without Login" status.
			 * @name File#isOnline
			 * @type boolean
			 */
			Object.defineProperty(this, 'isOnline', {
				get: function ()
				{
					return delegate.isOnline();
				},
				set: function (val)
				{
					delegate.setIsOnline(val);
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * @name File#lines
			 * @type {Iterator} iterator - Iterator which provides the next line of text from the text file to the iterator function.
			 *      <pre> file.lines.iterator().each(function(lineContext){...}); </pre>
			 *
			 * @throws {SuiteScriptError} YOU_CANNOT_READ_FROM_A_FILE_AFTER_YOU_BEGAN_WRITING_TO_IT if you call after having called appendLine
			 * @readonly
			 */
			Object.defineProperty(this, 'lines', {
				get: function ()
				{
					return Object.freeze({
						iterator: function iterator()
						{
							var fileContents = invoker(delegate, 'createStreamingFileContents', []);
							var fileLines = new FileLines(fileContents);
							fileLinesObjectsCreated.push(fileLines);
							return iteratorFactory.create(fileLines);
						}
					});
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'output');
				},
				enumerable: true,
				configurable: false
			});


			/*
			 * Helper function for http.writeFile()
			 */
			Object.defineProperty(this, '_writeTo', {
				set: function (val)
				{
					invoker(val.delegate, 'writeFile', [delegate, val.isInline ? true : false]);
				},
				enumerable: false,
				configurable: false,
				writeable: true
			});
			/*
			 * Helper function for task.CsvImportTask
			 */
			Object.defineProperty(this, '_sd', {
				set: function (val)
				{
					if (val.toString() === 'task.CsvImportTask')
						val._fd = delegate;
					else if (val.toString() === 'FileDelegateContainer')
						val.set(delegate);
				},
				enumerable: false,
				configurable: false,
				writeable: true
			});

			/*
			 * Helper function for sftp.upload
			 */
			Object.defineProperty(this, '_upload', {
				set: function (val)
				{
					invoker(val.delegate, 'upload', [delegate, val.filename, val.directory, val.timeout, val.replace])
				},
				enumerable: false,
				configurable: false,
				writeable: true
			});

			/*
			 * Helper function for bank connectivity
			 */
			Object.defineProperty(this, '_saveBankStatementFile', {
				set: function (val)
				{
					invoker(val.delegate, 'saveBankStatementFile', [delegate, val.bankStatementFormat])
				},
				enumerable: false,
				configurable: false,
				writeable: true
			});

			/**
			 * Return the value (Base64 encoded for binary types) of the file.
			 * Note: Contents are lazy loaded and must be less than 10MB in size in order to access.
			 *
			 * @throws {SuiteScriptError} SSS_FILE_CONTENT_SIZE_EXCEEDED when trying to get contents of a file larger than 10MB
			 *
			 * @return {string}
			 */
			this.getContents = function getContents()
			{
				return invoker(delegate, 'getValue', []);
			};

			/**
			 * Add/update a file in the file cabinet based on the properties of this object.
			 *
			 * @governance 20 units
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when the folder property is not set
			 * @throws {SuiteScriptError} INVALID_KEY_OR_REF if trying to save to a non-existing folder
			 *
			 * @return {number} return internal ID of file in the file cabinet
			 *
			 * @since 2015.2
			 */
			this.save = function save()
			{
				if (delegate.getFolder() == -1)
					utilityFunctions.throwSuiteScriptError(error.Type.MISSING_REQD_ARGUMENT,'file.File.save', 'folder');

				return invoker(apiBridge, 'nlapiSubmitFile', [delegate]);
			};

			/**
			 * Append a chunk of text to the file.
			 *
			 * @param {Object} options
			 * @param {string} options.value text to append
			 * @return {file} Returns this file
			 * @throws {SuiteScriptError} YOU_CANNOT_WRITE_TO_A_FILE_AFTER_YOU_BEGAN_READING_FROM_IT If you call it after having called FileLines#each
			 * @since 2017.1
			 */
			this.append = function append(options)
			{
				utilityFunctions.checkArgs([options], ['options'], 'file.append');
				utilityFunctions.checkArgs([options.value], ['options.value'], 'file.append');
				invoker(delegate, 'append', [options.value]);
				return this;
			};

			/**
			 * Append a line of text to the file.
			 *
			 * @param {Object} options
			 * @param {string} options.value text to append
			 * @return {file} Returns this file
			 * @throws {SuiteScriptError} YOU_CANNOT_WRITE_TO_A_FILE_AFTER_YOU_BEGAN_READING_FROM_IT If you call it after having called FileLines#each
			 * @since 2017.1
			 */
			this.appendLine = function appendLine(options)
			{
				utilityFunctions.checkArgs([options], ['options'], 'file.appendLine');
				utilityFunctions.checkArgs([options.value], ['options.value'], 'file.appendLine');
				invoker(delegate, 'appendLine', [options.value]);
				return this;
			};

			/**
			 * Reset the reading and writing streams that may have been opened by appendLine or FileLines#each
			 *
			 * @since 2017.1
			 */
			this.resetStream = function resetStream()
			{
				invoker(delegate, 'resetStream', []);
				for(var i = 0; i < fileLinesObjectsCreated.length; i++)
					fileLinesObjectsCreated[i].reset();
			};

			/**
			 * Returns the object type name (file.File)
			 *
			 * @returns {string}
			 */
			this.toString = function toString()
			{
				return TYPE;
			};

			/**
			 * JSON.stringify() implementation.
			 *
			 * @returns {{type: string, id: *, name: *, description: *, path: *, url: *, folder: *, fileType: *, isText: *,
                 *     size: *, encoding: *, isInactive: *, isOnline: *, contents: *}}
			 */
			this.toJSON = function toJSON()
			{
				return {
					type: TYPE,
					id: this.id,
					name: this.name,
					description: this.description,
					path: this.path,
					url: this.url,
					folder: this.folder,
					fileType: this.fileType,
					isText: this.isText,
					size: this.size,
					encoding: this.encoding,
					isInactive: this.isInactive,
					isOnline: this.isOnline
				};
			};

			Object.defineProperty(this, '_attachToEmail', {
				set: function (email)
				{
					email._attach = delegate;
				},
				enumerable: false,
				configurable: false,
				writeable: true
			});

			if (folder != null)
				this.folder = folder;
		}
		File.prototype = nsobject.getNewInstance();

		/**
		 * @protected
		 *
		 * @param delegate
		 * @constructor
		 */
		function FileLines(delegate)
		{

			var nextLine = invoker(delegate, 'nextLine', []);

			this.hasNext = function hasNext()
			{
				return nextLine !== null;
			};

			this.next = function next()
			{
				var _nextLine = nextLine;
				nextLine = invoker(delegate, 'nextLine', []);
				return _nextLine;
			};

			this.reset = function reset(){
				invoker(delegate, 'resetStream', []);
				nextLine = invoker(delegate, 'nextLine', []);
			}

		}

		function create(options)
		{
			utilityFunctions.checkArgs([options], ['options object'], 'file.create');
			utilityFunctions.checkArgs([options.name, options.fileType, options.contents], ['name', 'fileType', 'contents'], 'file.create');

			return new File(invoker(apiBridge, 'nlapiCreateFile', [options.name, options.fileType, options.contents]), options.folder);
		}

		/** @alias N/file */
		return Object.freeze({
			/**
			 * Instantiate a file object (specifying the name, type, and contents which are base-64 encoded for binary types.)
			 * @restriction Server SuiteScript only
			 *
			 * @param {Object} options
			 * @param {string} options.name file name
			 * @param {string} options.fileType file type i.e. PLAINTEXT, HTMLDOC, PDF, WORD, see file.Type enum
			 * @param {string} options.contents string containing file contents (must be base-64 encoded for binary types)
			 * @param {number} options.folder (optional) the internal ID of the folder to be used when the file is saved
			 * @return {File}
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options is missing or one of mandatory options
			 *     properties not set
			 * @throws {SuiteScriptError} SSS_INVALID_TYPE_ARG if options.fileType is an invalid type
			 *
			 * @since 2015.2
			 */
			create: funcWrapper.wrap( create ),
			/**
			 * Load a file from the file cabinet (via its internal ID or path).
			 *
			 * @governance 10 units
			 * @restriction Server SuiteScript only
			 *
			 * @param {Object} options
			 * @param {number|string} options.id internal ID or path to file in the file cabinet (i.e. /SuiteScript/foo.js)
			 * @return {File}
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if idOrPath parameter is missing
			 * @throws {SuiteScriptError} RCRD_DSNT_EXIST attempt to load a file from non-existing path
			 * @throws {SuiteScriptError} INSUFFICIENT_PERMISSION attempt to load a file with non-existing ID
			 *
			 * @since 2015.2
			 */
			load: function load(options)
			{
				var idOrPath = (options && options.hasOwnProperty('id')) ? options.id : options;

				utilityFunctions.checkArgs([idOrPath], ['id'], 'file.load');

				return new File(invoker(apiBridge, 'nlapiLoadFile', [idOrPath]));
			},
			/**
			 * Delete a file from the file cabinet.
			 *
			 * @governance 20 units
			 * @restriction Server SuiteScript only
			 *
			 * @param {Object} options
			 * @param {number|string} options.id internal ID of file to be deleted
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if id parameter is missing
			 *
			 * @since 2015.2
			 */
			'delete': function (options)
			{
				var id = (options && options.hasOwnProperty('id')) ? options.id : options;

				utilityFunctions.checkArgs([id], ['id'], 'file.delete');

				invoker(apiBridge, 'nlapiDeleteFile', [id]);
			},
			//Undocumented helper function, takes a nlobjFile and wraps it into file.File
			wrap: function wrap(nlobj)
			{
				return new File(nlobj);
			},
			/**
			 * Enum for file types.
			 * @enum {string}
			 * @readonly
			 */
			Type: FILE_TYPES,
			/**
			 * Enum for file encodings.
			 * @enum {string}
			 * @readonly
			 */
			Encoding: ENCODINGS
		});
	});

/**
 * @private
 */
define('N/restricted/xmlApi',['N/restricted/reflet'], function(reflet){ return reflet; });

/**
 * SuiteScript xml module
 *
 * @module N/xml
 * @NApiVersion 2.x
 *
 */
define('N/xml',['N/restricted/bridge', 'N/file', 'N/error', 'N/nsobject', 'N/restricted/invoker', 'N/utilityFunctions', 'N/restricted/xmlApi'],
        function (api, file, error, nsobject, invoker, utilityFunctions, xmlApi)
        {
            var NODE_TYPES = Object.freeze([
                'ELEMENT_NODE',
                'ATTRIBUTE_NODE',
                'TEXT_NODE',
                'CDATA_SECTION_NODE',
                'ENTITY_REFERENCE_NODE',
                'ENTITY_NODE',
                'PROCESSING_INSTRUCTION_NODE',
                'COMMENT_NODE',
                'DOCUMENT_NODE',
                'DOCUMENT_TYPE_NODE',
                'DOCUMENT_FRAGMENT_NODE',
                'NOTATION_NODE'
            ]);

			// Unfortunately need to duplicate this const since stub generation static analysis requires object literal enum.
			// Can't derive array from object since iteration may be unordered.
            var NODE_TYPES_ENUM = Object.freeze({
                ELEMENT_NODE: 'ELEMENT_NODE',
                ATTRIBUTE_NODE: 'ATTRIBUTE_NODE',
                TEXT_NODE: 'TEXT_NODE',
                CDATA_SECTION_NODE: 'CDATA_SECTION_NODE',
                ENTITY_REFERENCE_NODE: 'ENTITY_REFERENCE_NODE',
                ENTITY_NODE: 'ENTITY_NODE',
                ENTITY_NODE: 'ENTITY_NODE',
                PROCESSING_INSTRUCTION_NODE: 'PROCESSING_INSTRUCTION_NODE',
                COMMENT_NODE: 'COMMENT_NODE',
                DOCUMENT_NODE: 'DOCUMENT_NODE',
                DOCUMENT_TYPE_NODE: 'DOCUMENT_TYPE_NODE',
                DOCUMENT_FRAGMENT_NODE: 'DOCUMENT_FRAGMENT_NODE',
                NOTATION_NODE: 'NOTATION_NODE'
            });

            var IE_CONVERSIONS = Object.freeze({
                getTextContent: 'text',
                getLocalName: 'baseName'
            });

            var CLIENT_SIDE_ATTR = Object.freeze({
                getName: 'name',
                getOwnerElement: 'ownerElement',
                getSpecified: 'specified',
                getValue: 'value',
                setValue: 'value',
                getDoctype: 'doctype',
                getDocumentElement: 'documentElement',
                getDocumentURI: 'documentURI',
                setDocumentURI: 'documentURI',
                getInputEncoding: 'inputEncoding',
                getXmlEncoding: 'xmlEncoding',
                getXmlStandalone: 'xmlStandalone',
                setXmlStandalone: 'xmlStandalone',
                getXmlVersion: 'xmlVersion',
                setXmlVersion: 'xmlVersion',
                getAttributes: 'attributes',
                getBaseURI: 'baseURI',
                getFirstChild: 'firstChild',
                getLastChild: 'lastChild',
                getLocalName: 'localName',
                getNamespaceURI: 'namespaceURI',
                getNextSibling: 'nextSibling',
                getNodeName: 'nodeName',
                getNodeType: 'nodeType',
                getNodeValue: 'nodeValue',
                setNodeValue: 'nodeValue',
                getOwnerDocument: 'ownerDocument',
                getParentNode: 'parentNode',
                getPrefix: 'prefix',
                setPrefix: 'prefix',
                getPreviousSibling: 'previousSibling',
                getTextContent: 'textContent',
                setTextContent: 'textContent'
            });

            function checkThenInvoke(target, method, args)
            {
                if (method === "getBaseURI" || method === "getDocumentURI")
                    return null;

                var targetMethodType = typeof target[method];

                if (targetMethodType === "undefined")
                {
                    if (window && !window.XPathEvaluator && IE_CONVERSIONS.hasOwnProperty(method))
                        return target[IE_CONVERSIONS[method]];
                    if (CLIENT_SIDE_ATTR.hasOwnProperty(method))
                    {
                        if (method.indexOf("set") === 0)
                            return target[CLIENT_SIDE_ATTR[method]] = args[0];
                        else
                            return target[CLIENT_SIDE_ATTR[method]];
                    }
                    else
                    {
                        return undefined;
                    }
                }

                // IE is unable to handle generic calls on the XML object.
                if (typeof window !== "undefined" && !window.XPathEvaluator)
                {
                    switch (args.length)
                    {
                        case 0:
                            return target[method]();
                        case 1:
                            return target[method](args[0]);
                        case 2:
                            return target[method](args[0], args[1]);
                        case 3:
                            return target[method](args[0], args[1], args[2]);
                        case 4:
                            return target[method](args[0], args[1], args[2], args[3]);
                        default:
                            return target[method](args[0], args[1], args[2], args[3], args[4]);
                    }
                }
                else
                {
                    try
                    {
                        return invoker(target, method, args)
                    }
                    catch (e)
                    {
                        if (e.name === "NotFoundError")
                        {
                            e = Error(e.message);
                            e.name = "SSS_XML_DOM_EXCEPTION";
                        }
                        throw e;
                    }
                }
            }

            /**
             * XML Parser Object
             */
            function Parser()
            {
                /**
                 * Generate XML Document object from a string.
                 *
                 * @param {string} options.text XML text
                 * @returns {Document}
                 *
                 * @since 2015.2
                 */
                this.fromString = function fromString(options)
                {
                    var text = (options && options.hasOwnProperty('text')) ? options.text : options;
                    checkArgs([text], ['text'], 'Parser.fromString');
                    assertString(text, 'text');

                    var document = invoker(xmlApi, 'nlapiStringToXML', [text]);
                    return new Document(document);
                };

                /**
                 * Generate a String from an XML Document object.
                 *
                 * @param {Document} options.document XML Document object
                 * @returns {string}
                 *
                 * @since 2015.2
                 */
                this.toString = function toString(options)
                {
                    var document = (options && options.hasOwnProperty('document')) ? options.document : options;
                    checkArgs([document], ['document'], 'Parser.toString');
                    if(!(document instanceof Document) )
                        utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'document','xml.Document' );

                    return document._asString();
                };
            }

            /**
             * XPath Query Object
             */
            function XPath()
            {
                /**
                 * Returns an Array of Nodes matching the provided XPath expression.
                 *
                 * @param {string} options.xpath an XPath expression
                 * @param {Node} options.node XML node being queried
                 * @returns {Node[]} nodes associated with the current result
                 *
                 * @since 2015.2
                 */
                this.select = function select(options)
                {
                    var node = null, xpath = null;

                    if (options && (options.hasOwnProperty('node') || options.hasOwnProperty('xpath')))
                    {
                        node = options.node;
                        xpath = options.xpath;
                    }
                    else
                    {
                        node = options;
                        xpath = arguments[1];
                    }
                    checkArgs([node, xpath], ['node', 'xpath'], 'XPath.select');
                    assertNode(node, 'node');
                    assertString(xpath, 'xpath');

                    var nodes = invoker(xmlApi, 'nlapiSelectNodes', [node._gd(), xpath]);
                    var result = [];
                    for (var i = 0; i < nodes.length; i++)
                    {
                        result.push(wrap(nodes[i]));
                    }
                    return result;
                };
            }

            /**
             * Return a new instance of XML Node.
             *
             * @classDescription Encapsulation of W3C DOM Node
             * @return {Node}
             * @constructor
             *
             * @since 2015.2
             */
            function Node(xmlnode)
            {
                var TYPE = 'xml.Node';
                checkArgs([xmlnode], ['xmlnode'], 'xml.Node');

                var _deleg = xmlnode;

                // Node members

                /**
                 * Adds the node newChild to the end of the list of children of this node. If the newChild is already in the tree, it is first removed.
                 *
                 * @param {Node} options.newChild the node to add
                 * @returns {Node} the node added
                 * @throws {SuiteScriptError} SSS_DOM_EXCEPTION if node cannot be appended for some reason
                 */
                this.appendChild = function appendChild(options)
                {
                    var newChild = (options && options.hasOwnProperty('newChild')) ? options.newChild : options;
                    checkArgs([newChild], ['newChild'], 'Node.appendChild');
                    assertNode(newChild, 'newChild');

                    var result = checkThenInvoke(_deleg, 'appendChild', [newChild._gd()]);
                    return wrap(result);
                };

                /**
                 * Returns a duplicate of this node, i.e., serves as a generic copy constructor for nodes. The duplicate node has no parent.
                 *
                 * @param {boolean} options.deep if true, recursively clone the subtree under the specified node; if false, clone only the node itself (and its attributes, if it is an Element)
                 * @returns {Node} the duplicate node
                 */
                this.cloneNode = function cloneNode(options)
                {
                    var deep = (options && options.hasOwnProperty('deep')) ? options.deep : options;
                    checkArgs([deep], ['deep'], 'Node.cloneNode');

                    var result = checkThenInvoke(_deleg, 'cloneNode', [deep == true]);
                    return wrap(result);
                };

                /**
                 * Compares the reference node, i.e. the node on which this method is being called, with a node, i.e. the one passed as a parameter,
                 * with regard to their position in the document and according to the document order.
                 *
                 * @param {Node} options.other the node to compare against the reference node
                 * @returns {int} how the node is positioned relatively to the reference node
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION when the nodes cannot be compared
                 */
                this.compareDocumentPosition = function compareDocumentPosition(options)
                {
                    var other = (options && options.hasOwnProperty('other')) ? options.other : options;
                    checkArgs([other], ['other'], 'Node.compareDocumentPosition');
                    assertNode(other, 'other');

                    return checkThenInvoke(_deleg, 'compareDocumentPosition', [other._gd()]);
                };

                /**
                 * Returns whether this node (if it is an Element) has any attributes.
                 *
                 * @returns {boolean} true if this node has any attributes, false otherwise
                 */
                this.hasAttributes = function hasAttributes()
                {
                    return checkThenInvoke(_deleg, 'hasAttributes', []);
                };

                /**
                 * Returns whether this node has any children.
                 *
                 * @returns {boolean} true if this node has any children, false otherwise
                 */
                this.hasChildNodes = function hasChildNodes()
                {
                    return checkThenInvoke(_deleg, 'hasChildNodes', []);
                };

                /**
                 * Inserts the node newChild before the existing child node refChild. If refChild is null, insert newChild at the end of the list of children.
                 * If the newChild is already in the tree, it is first removed.
                 *
                 * @param {Node} options.newChild the node to insert
                 * @param {Node} options.refChild the reference node, i.e., the node before which the new node will be inserted
                 * @returns {Node} the node being inserted
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if node cannot be inserted for some reason
                 */
                this.insertBefore = function insertBefore(options)
                {
                    var newChild = null, refChild = null;

                    if (options && (options.hasOwnProperty('newChild') || options.hasOwnProperty('refChild')))
                    {
                        newChild = options.newChild;
                        refChild = options.refChild;
                    }
                    else
                    {
                        newChild = options;
                        refChild = arguments[1];
                    }
                    checkArgs([newChild], ['newChild'], 'Node.insertBefore');
                    assertNode(newChild, 'newChild');
                    assertNodeNullable(refChild, 'refChild');

                    var result = checkThenInvoke(_deleg, 'insertBefore', [newChild._gd(), refChild == null ? null : refChild._gd()]);
                    return wrap(result);
                };

                /**
                 * This method checks if the specified namespaceURI is the default namespace or not.
                 *
                 * @param {string} options.namespaceURI the namespace URI to look for
                 * @returns {boolean} true if the specified namespaceURI is the default namespace, false otherwise
                 */
                this.isDefaultNamespace = function isDefaultNamespace(options)
                {
                    var namespaceURI = (options && options.hasOwnProperty('namespaceURI')) ? options.namespaceURI : options;
                    checkArgs([namespaceURI], ['namespaceURI'], 'Node.isDefaultNamespace');
                    assertString(namespaceURI, 'namespaceURI');

                    return checkThenInvoke(_deleg, 'isDefaultNamespace', [namespaceURI]);
                };

                /**
                 * Tests whether two nodes are equal.
                 * This method tests for equality of nodes, not sameness (i.e., whether the two nodes are references to the same object) which can be tested
                 * with Node.isSameNode(). All nodes that are the same will also be equal, though the reverse may not be true.
                 * Two nodes are equal if and only if the following conditions are satisfied:
                 * - The two nodes are of the same type.
                 * - The following string attributes are equal: nodeName, localName, namespaceURI, prefix, nodeValue
                 * - The attributes maps are equal
                 * - The childNodes lists are equal
                 *
                 * @param {Node} options.other the node to compare equality with
                 * @returns {boolean} true if the nodes are equal, false otherwise
                 */
                this.isEqualNode = function isEqualNode(options)
                {
                    var other = (options && options.hasOwnProperty('other')) ? options.other : options;
                    checkArgs([other], ['other'], 'Node.isEqualNode');
                    assertNode(other, 'other');

                    return checkThenInvoke(_deleg, 'isEqualNode', [other._gd()]);
                };

                /**
                 * Returns whether this node is the same node as the given one.
                 * This method provides a way to determine whether two Node references returned by the implementation reference the same object.
                 * When two Node references are references to the same object, even if through a proxy, the references may be used completely interchangeably,
                 * such that all attributes have the same values and calling the same DOM method on either reference always has exactly the same effect.
                 *
                 * @param {Node} options.other the node to test against
                 * @returns {boolean} true if the nodes are the same, false otherwise
                 */
                this.isSameNode = function isSameNode(options)
                {
                    var other = (options && options.hasOwnProperty('other')) ? options.other : options;
                    checkArgs([other], ['other'], 'Node.isSameNode');
                    assertNode(other, 'other');

                    return checkThenInvoke(_deleg, 'isSameNode', [other._gd()]);
                };

                /**
                 * Look up the namespace URI associated to the given prefix, starting from this node.
                 *
                 * @param {string} options.prefix the prefix to look for; if this parameter is null, the method will return the default namespace URI if any
                 * @returns {string} the associated namespace URI or null if none is found
                 */
                this.lookupNamespaceURI = function lookupNamespaceURI(options)
                {
                    var prefix = (options && options.hasOwnProperty('prefix')) ? options.prefix : options;
                    assertStringNullable(prefix, 'prefix');

                    return checkThenInvoke(_deleg, 'lookupNamespaceURI', [prefix == null ? null : prefix]);
                };

                /**
                 * Look up the prefix associated to the given namespace URI, starting from this node. The default namespace declarations are ignored by this method.
                 *
                 * @param {string} options.namespaceURI the namespace URI to look for
                 * @returns {string} an associated namespace prefix if found or null if none is found; if more than one prefix are associated to the namespace prefix, the returned namespace prefix is implementation dependent
                 */
                this.lookupPrefix = function lookupPrefix(options)
                {
                    var namespaceURI = (options && options.hasOwnProperty('namespaceURI')) ? options.namespaceURI : options;
                    checkArgs([namespaceURI], ['namespaceURI'], 'Node.lookupPrefix');
                    assertString(namespaceURI, 'namespaceURI');

                    return checkThenInvoke(_deleg, 'lookupPrefix', [namespaceURI]);
                };

                /**
                 * Puts all Text nodes in the full depth of the sub-tree underneath this Node, including attribute nodes, into a "normal" form
                 * where only structure (e.g., elements, comments, processing instructions, CDATA sections, and entity references) separates
                 * Text nodes, i.e., there are neither adjacent Text nodes nor empty Text nodes.
                 *
                 * @returns {void}
                 */
                this.normalize = function normalize()
                {
                    checkThenInvoke(_deleg, 'normalize', []);
                };

                /**
                 * Removes the child node indicated by oldChild from the list of children, and returns it.
                 *
                 * @param {Node} options.oldChild the node being removed
                 * @returns {Node} the node removed
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if node cannot be removed for some reason
                 */
                this.removeChild = function removeChild(options)
                {
                    var oldChild = (options && options.hasOwnProperty('oldChild')) ? options.oldChild : options;
                    checkArgs([oldChild], ['oldChild'], 'Node.removeChild');
                    assertNode(oldChild, 'oldChild');

                    var result = checkThenInvoke(_deleg, 'removeChild', [oldChild._gd()]);
                    return wrap(result);
                };

                /**
                 * Replaces the child node oldChild with newChild in the list of children, and returns the oldChild node.
                 * If the newChild is already in the tree, it is first removed.
                 *
                 * @param {Node} options.newChild the new node to put in the child list
                 * @param {Node} options.oldChild the node being replaced in the list
                 * @returns {Node} the node replaced
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if node cannot be replaced for some reason
                 */
                this.replaceChild = function replaceChild(options)
                {
                    var newChild = null, oldChild = null;

                    if (options && (options.hasOwnProperty('newChild') || options.hasOwnProperty('oldChild')))
                    {
                        newChild = options.newChild;
                        oldChild = options.oldChild;
                    }
                    else
                    {
                        newChild = options;
                        oldChild = arguments[1];
                    }
                    checkArgs([newChild, oldChild], ['newChild', 'oldChild'], 'Node.replaceChild');
                    assertNode(newChild, 'newChild');
                    assertNode(oldChild, 'oldChild');

                    var result = checkThenInvoke(_deleg, 'replaceChild', [newChild._gd(), oldChild._gd()]);
                    return wrap(result);
                };

                /**
                 * A map of key/value (string->Attr) pairs containing the attributes of this node (if it is an Element) or null otherwise.
                 * @name Node#attributes
                 * @type Object
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'attributes', {
                    get: function ()
                    {
                        var attrs = checkThenInvoke(_deleg, 'getAttributes', []);
                        if (!attrs)
                            return null;
                        var result = {};
                        for (i = 0; i < attrs.length; i++)
                        {
                            var item = attrs.item(i);
                            var node = new Attr(item);
                            result[node.name.replace(':', '_')] = node;
                        }
                        return result;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'attributes' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The absolute base URI of this node or null if the implementation wasn't able to obtain an absolute URI.
                 * @name Node#baseURI
                 * @type string
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'baseURI', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getBaseURI', []);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'baseURI' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * An array of all children of this node. If there are no children, this is an empty array.
                 * @name Node#childNodes
                 * @type Node[]
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'childNodes', {
                    get: function ()
                    {
                        var result = [];
                        var child = this.firstChild;

                        while (child !== null)
                        {
                            result.push(child);
                            child = child.nextSibling;
                        }
                        return result;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'childNodes' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The first child of this node or null if there is no such node.
                 * @name Node#firstChild
                 * @type Node
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'firstChild', {
                    get: function ()
                    {
                        var result = checkThenInvoke(_deleg, 'getFirstChild', []);
                        return wrap(result);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'firstChild' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The last child of this node or null if there is no such node.
                 * @name Node#lastChild
                 * @type Node
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'lastChild', {
                    get: function ()
                    {
                        var result = checkThenInvoke(_deleg, 'getLastChild', []);
                        return wrap(result);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'lastChild' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The local part of the qualified name of this node.
                 * @name Node#localName
                 * @type string
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'localName', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getLocalName', []);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'localName' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The namespace URI of this node, or null if it is unspecified.
                 * @name Node#namespaceURI
                 * @type string
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'namespaceURI', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getNamespaceURI', []);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'namespaceURI' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The node immediately following this node or null if there is no such node.
                 * @name Node#nextSibling
                 * @type Node
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'nextSibling', {
                    get: function ()
                    {
                        var result = checkThenInvoke(_deleg, 'getNextSibling', []);
                        return wrap(result);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'nextSibling' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The name of this node, depending on its type.
                 * @name Node#nodeName
                 * @type string
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'nodeName', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getNodeName', []);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'nodeName' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The type of the underlying object.
                 * @name Node#nodeType
                 * @type NodeType
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'nodeType', {
                    get: function ()
                    {
                        var result = checkThenInvoke(_deleg, 'getNodeType', []);
                        return NODE_TYPES[result - 1];
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'nodeType' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The value of this node, depending on its type. When it is defined to be null, setting it has no effect, including if the node is read-only.
                 * @name Node#nodeValue
                 * @type string
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if it's not possible to get or set the property value
                 */
                Object.defineProperty(this, 'nodeValue', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getNodeValue', []);
                    },
                    set: function (val)
                    {
                        assertString(val, 'value');
                        checkThenInvoke(_deleg, 'setNodeValue', [val]);
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                /**
                 * The Document object associated with this node. This is also the Document object used to create new nodes.
                 * @name Node#ownerDocument
                 * @type Document
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'ownerDocument', {
                    get: function ()
                    {
                        var result = checkThenInvoke(_deleg, 'getOwnerDocument', []);
                        return wrap(result);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'ownerDocument' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The parent of this node. All nodes, except Attr, Document, DocumentFragment, Entity, and Notation may have a parent.
                 * @name Node#parentNode
                 * @type Node
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'parentNode', {
                    get: function ()
                    {
                        var result = checkThenInvoke(_deleg, 'getParentNode', []);
                        return wrap(result);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'parentNode' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The namespace prefix of this node, or null if it is unspecified. When it is defined to be null, setting it has no effect, including if the node is read-only.
                 * @name Node#prefix
                 * @type string
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if it's not possible to set the property value
                 */
                Object.defineProperty(this, 'prefix', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getPrefix', []);
                    },
                    set: function (val)
                    {
                        assertString(val, 'value');
                        checkThenInvoke(_deleg, 'setPrefix', [val]);
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                /**
                 * The node immediately preceding this node or null if there is no such node.
                 * @name Node#previousSibling
                 * @type Node
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'previousSibling', {
                    get: function ()
                    {
                        var result = checkThenInvoke(_deleg, 'getPreviousSibling', []);
                        return wrap(result);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'previousSibling' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * This attribute returns the text content of this node and its descendants. When it is defined to be null, setting it has no effect.
                 * @name Node#textContent
                 * @type string
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if it's not possible to get or set the property value
                 */
                Object.defineProperty(this, 'textContent', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getTextContent', []);
                    },
                    set: function (val)
                    {
                        assertString(val, 'value');
                        checkThenInvoke(_deleg, 'setTextContent', [val]);
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                // Other members

                this._gd = function _gd()
                {
                    return _deleg;
                };

                this.toString = function toString()
                {
                    return TYPE;
                };
                this.toJSON = function toJSON()
                {
                    return {
                        name: this.nodeName,
                        type: this.nodeType,
                        value: this.nodeValue,
                        textContent: this.textContent
                    };
                };
            }

            Node.prototype = nsobject.getNewInstance();

            /**
             * Return a new instance of XML Document.
             *
             * @classDescription Encapsulation of W3C DOM Document
             * @return {Document}
             * @constructor
             *
             * @since 2015.2
             */
            function Document(xmldoc)
            {
                var TYPE = 'xml.Document';

                checkArgs([xmldoc], ['xmldoc'], 'xml.Document');

                var _deleg = xmldoc;
                var _node = new Node(xmldoc);

                // Document members

                /**
                 * Attempts to adopt a node from another document to this document. If supported, it changes the ownerDocument
                 * of the source node, its children, as well as the attached attribute nodes if there are any. If the source
                 * node has a parent it is first removed from the child list of its parent.
                 *
                 * @param {Node} options.source the node to move into this document
                 * @returns {Node} the adopted node, or null if this operation fails, such as when the source node comes from a different implementation
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the node cannot be adopted for some reason
                 */
                this.adoptNode = function adoptNode(options)
                {
                    var source = (options && options.hasOwnProperty('source')) ? options.source : options;
                    checkArgs([source], ['source'], 'Document.adoptNode');
                    assertNode(source, 'source');

                    var result = checkThenInvoke(_deleg, 'adoptNode', [source._gd()]);
                    return wrap(result);
                };

                /**
                 * Creates an attribute node of the given name.
                 *
                 * @param {string} options.name the name of the attribute
                 * @param {string} options.value (optional) the value of the attribute; if omitted, the value of the attribute will be empty string
                 * @returns {Attr} new attribute node object with name and attribute value set as expected and localName, prefix, and namespaceURI set to null
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the attribute cannot be created
                 */
                this.createAttribute = function createAttribute(options)
                {
                    var name = null, value = null;

                    if (options && (options.hasOwnProperty('name') || options.hasOwnProperty('value')))
                    {
                        name = options.name;
                        value = options.value;
                    }
                    else
                    {
                        name = options;
                        value = arguments[1];
                    }
                    checkArgs([name], ['name'], 'Node.createAttribute');
                    assertString(name, 'name');

                    var result = checkThenInvoke(_deleg, 'createAttribute', [name]);
                    result = new Attr(result);
                    if (value)
                    {
                        assertString(value, 'value');
                        result.value = value;
                    }
                    return result;
                };

                /**
                 * Creates an attribute of the given qualified name and namespace URI.
                 *
                 * @param {string} options.namespaceURI the namespace URI of the attribute to create; can be null
                 * @param {string} options.qualifiedName the qualified name of the attribute to instantiate
                 * @param {string} options.value (optional) the value of the attribute; if omitted, the value of the attribute will be empty string
                 * @returns {Attr} new attribute node object with name, attribute value, namespaceURI, prefix and localName set accordingly
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the attribute cannot be created
                 */
                this.createAttributeNS = function createAttributeNS(options)
                {
                    var namespaceURI = null, qualifiedName = null, value = null;

                    if (options && (options.hasOwnProperty('namespaceURI') || options.hasOwnProperty('qualifiedName') || options.hasOwnProperty('value')))
                    {
                        namespaceURI = options.namespaceURI;
                        qualifiedName = options.qualifiedName;
                        value = options.value;
                    }
                    else
                    {
                        namespaceURI = options;
                        qualifiedName = arguments[1];
                        value = arguments[2];
                    }
                    checkArgs([qualifiedName], ['qualifiedName'], 'Document.createAttributeNS');
                    assertStringNullable(namespaceURI, 'namespaceURI');
                    assertString(qualifiedName, 'qualifiedName');

                    var result = checkThenInvoke(_deleg, 'createAttributeNS', [namespaceURI == null ? null : namespaceURI, qualifiedName]);
                    result = new Attr(result);
                    if (value)
                    {
                        assertString(value, 'value');
                        result.value = value;
                    }
                    return result;
                };

                /**
                 * Creates a CDATASection node whose value is the specified string.
                 *
                 * @param {string} options.data the data for the CDATASection contents
                 * @returns {Node} the new CDATASection node
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the CDATASection node cannot be created
                 */
                this.createCDATASection = function createCDATASection(options)
                {
                    var data = (options && options.hasOwnProperty('data')) ? options.data : options;
                    checkArgs([data], ['data'], 'Document.createCDATASection');
                    assertString(data, 'data');

                    var result = checkThenInvoke(_deleg, 'createCDATASection', [data]);
                    return new Node(result);
                };

                /**
                 * Creates a Comment node given the specified string.
                 *
                 * @param {string} options.data the data for the node
                 * @returns {Node} the new Comment node
                 */
                this.createComment = function createComment(options)
                {
                    var data = (options && options.hasOwnProperty('data')) ? options.data : options;
                    checkArgs([data], ['data'], 'Document.createComment');
                    assertString(data, 'data');

                    var result = checkThenInvoke(_deleg, 'createComment', [data]);
                    return new Node(result);
                };

                /**
                 * Creates an empty DocumentFragment object.
                 *
                 * @returns {Node} a new DocumentFragment
                 */
                this.createDocumentFragment = function createDocumentFragment()
                {
                    var result = checkThenInvoke(_deleg, 'createDocumentFragment', []);
                    return new Node(result);
                };

                /**
                 * Creates an element of the type specified.
                 *
                 * @param {string} options.tagName the name of the element type to instantiate; for XML, this is case-sensitive
                 * @returns {Element} a new Element object with the nodeName attribute set to tagName, and localName, prefix, and namespaceURI set to null
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the Element node cannot be created
                 */
                this.createElement = function createElement(options)
                {
                    var tagName = (options && options.hasOwnProperty('tagName')) ? options.tagName : options;
                    checkArgs([tagName], ['tagName'], 'Document.createElement');
                    assertString(tagName, 'tagName');

                    var result = checkThenInvoke(_deleg, 'createElement', [tagName]);
                    return new Element(result);
                };

                /**
                 * Creates an element of the given qualified name and namespace URI.
                 *
                 * @param {string} options.namespaceURI the namespace URI of the element to create; can be null
                 * @param {string} options.qualifiedName the qualified name of the element type to instantiate
                 * @returns {Element} a new Element object with the nodeName, localName, prefix, and namespaceURI set accordingly
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the Element node cannot be created
                 */
                this.createElementNS = function createElementNS(options)
                {
                    var namespaceURI = null, qualifiedName = null;

                    if (options && (options.hasOwnProperty('namespaceURI') || options.hasOwnProperty('qualifiedName')))
                    {
                        namespaceURI = options.namespaceURI;
                        qualifiedName = options.qualifiedName;
                    }
                    else
                    {
                        namespaceURI = options;
                        qualifiedName = arguments[1];
                    }
                    checkArgs([qualifiedName], ['qualifiedName'], 'Document.createElementNS');
                    assertStringNullable(namespaceURI, 'namespaceURI');
                    assertString(qualifiedName, 'qualifiedName');

                    var result = checkThenInvoke(_deleg, 'createElementNS', [namespaceURI == null ? null : namespaceURI, qualifiedName]);
                    return new Element(result);
                };

                /**
                 * Creates a ProcessingInstruction node given the specified name and data strings.
                 *
                 * @param {string} options.target the target part of the processing instruction
                 * @param {string} options.data the data for the node
                 * @returns {Node} the new ProcessingInstruction object
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the ProcessingInstruction node cannot be created
                 */
                this.createProcessingInstruction = function createProcessingInstruction(options)
                {
                    var target = null, data = null;

                    if (options && (options.hasOwnProperty('target') || options.hasOwnProperty('data')))
                    {
                        target = options.target;
                        data = options.data;
                    }
                    else
                    {
                        target = options;
                        data = arguments[1];
                    }
                    checkArgs([target, data], ['target', 'data'], 'Document.createProcessingInstruction');
                    assertString(target, 'target');
                    assertString(data, 'data');

                    var result = checkThenInvoke(_deleg, 'createProcessingInstruction', [target, data]);
                    return new Node(result);
                };

                /**
                 * Creates a Text node given the specified string.
                 *
                 * @param {string} options.data the data for the node
                 * @returns {Node} the new Text node
                 */
                this.createTextNode = function createTextNode(options)
                {
                    var data = (options && options.hasOwnProperty('data')) ? options.data : options;
                    checkArgs([data], ['data'], 'Document.createTextNode');
                    assertString(data, 'data');

                    var result = checkThenInvoke(_deleg, 'createTextNode', [data]);
                    return new Node(result);
                };

                /**
                 * Returns the Element that has an ID attribute with the given value. If no such element exists, this returns null.
                 *
                 * @param {string} options.elementId the unique id value for an element
                 * @returns {Element} the matching Element or null if there is none
                 */
                this.getElementById = function getElementById(options)
                {
                    var elementId = (options && options.hasOwnProperty('elementId')) ? options.elementId : options;
                    checkArgs([elementId], ['elementId'], 'Document.getElementById');
                    assertString(elementId, 'elementId');

                    var result = checkThenInvoke(_deleg, 'getElementById', [elementId]);
                    return new Element(result);
                };

                /**
                 * Returns an array of all the Elements with a given tag name in document order.
                 *
                 * @param {string} options.tagName the name of the tag to match on; the special value "*" matches all tags; for XML, the tagName parameter is case-sensitive
                 * @returns {Element[]} an array containing all the matched Elements
                 */
                this.getElementsByTagName = function getElementsByTagName(options)
                {
                    var tagName = (options && options.hasOwnProperty('tagName')) ? options.tagName : options;
                    checkArgs([tagName], ['tagName'], 'Document.getElementsByTagName');
                    assertString(tagName, 'tagName');

                    var elems = checkThenInvoke(_deleg, 'getElementsByTagName', [tagName]);
                    var result = [];
                    for (i = 0; i < elems.length; i++)
                    {
                        result.push(new Element(elems.item(i)));
                    }
                    return result;
                };

                /**
                 * Returns an array of all the Elements with a given local name and namespace URI in document order.
                 *
                 * @param {string} options.namespaceURI the namespace URI of the elements to match on; the special value "*" matches all namespaces
                 * @param {string} options.localName the local name of the elements to match on; the special value "*" matches all local names
                 * @returns {Element[]} an array containing all the matched Elements
                 */
                this.getElementsByTagNameNS = function getElementsByTagNameNS(options)
                {
                    var namespaceURI = null, localName = null;

                    if (options && (options.hasOwnProperty('namespaceURI') || options.hasOwnProperty('localName')))
                    {
                        namespaceURI = options.namespaceURI;
                        localName = options.localName;
                    }
                    else
                    {
                        namespaceURI = options;
                        localName = arguments[1];
                    }
                    checkArgs([namespaceURI, localName], ['namespaceURI', 'localName'], 'Document.getElementsByTagNameNS');
                    assertString(namespaceURI, 'namespaceURI');
                    assertString(localName, 'localName');

                    var elems = checkThenInvoke(_deleg, 'getElementsByTagNameNS', [namespaceURI, localName]);
                    var result = [];
                    for (i = 0; i < elems.length; i++)
                    {
                        result.push(new Element(elems.item(i)));
                    }
                    return result;
                };

                /**
                 * Imports a node from another document to this document, without altering or removing the source node from the original document;
                 * this method creates a new copy of the source node.
                 *
                 * @param {Node} options.importedNode the node to import
                 * @param {boolean} options.deep if true, recursively import the subtree under the specified node; if false, import only the node itself, as explained above
                 * @returns {Node} the imported node that belongs to this Document
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the node cannot be imported for some reason
                 */
                this.importNode = function importNode(options)
                {
                    var importedNode = null, deep = null;

                    if (options && (options.hasOwnProperty('importedNode') || options.hasOwnProperty('deep')))
                    {
                        importedNode = options.importedNode;
                        deep = options.deep;
                    }
                    else
                    {
                        importedNode = options;
                        deep = arguments[1];
                    }
                    checkArgs([importedNode, deep], ['importedNode', 'deep'], 'Document.importNode');
                    assertNode(importedNode, 'importedNode');

                    var result = checkThenInvoke(_deleg, 'importNode', [importedNode._gd(), deep == true]);
                    return wrap(result);
                };

                /**
                 * The Document Type Declaration associated with this document.
                 * @name Document#doctype
                 * @type Object
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'doctype', {
                    get: function ()
                    {
                        var result = checkThenInvoke(_deleg, 'getDoctype', []);
                        if (result === null || result === undefined)
                            return null;
                        return new Node(result);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'doctype' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * This is a convenience attribute that allows direct access to the child node that is the document element of the document.
                 * @name Document#documentElement
                 * @type Element
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'documentElement', {
                    get: function ()
                    {
                        var result = checkThenInvoke(_deleg, 'getDocumentElement', []);
                        return new Element(result);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'documentElement' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The location of the document or null if undefined.
                 * @name Document#documentURI
                 * @type string
                 */
                Object.defineProperty(this, 'documentURI', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getDocumentURI', []);
                    },
                    set: function (val)
                    {
                        assertString(val, 'value');
                        checkThenInvoke(_deleg, 'setDocumentURI', [val]);
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                /**
                 * An attribute specifying the encoding used for this document at the time of the parsing.
                 * @name Document#inputEncoding
                 * @type string
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'inputEncoding', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getInputEncoding', []);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'inputEncoding' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * An attribute specifying, as part of the XML declaration, the encoding of this document.
                 * @name Document#xmlEncoding
                 * @type string
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'xmlEncoding', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getXmlEncoding', []);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'xmlEncoding' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * An attribute specifying, as part of the XML declaration, whether this document is standalone. This is false when unspecified.
                 * @name Document#xmlStandalone
                 * @type boolean
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the property cannot be set
                 */
                Object.defineProperty(this, 'xmlStandalone', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getXmlStandalone', []);
                    },
                    set: function (val)
                    {
                        checkThenInvoke(_deleg, 'setXmlStandalone', [val == true]);
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                /**
                 * An attribute specifying, as part of the XML declaration, the version number of this document.
                 * @name Document#xmlVersion
                 * @type string
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the property cannot be set
                 */
                Object.defineProperty(this, 'xmlVersion', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getXmlVersion', []);
                    },
                    set: function (val)
                    {
                        assertString(val, 'value');
                        checkThenInvoke(_deleg, 'setXmlVersion', [val]);
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                // Members inherited from Node

                this.appendChild = function appendChild(options)
                {
                    return _node.appendChild(options);
                };

                this.cloneNode = function cloneNode(options)
                {
                    return _node.cloneNode(options);
                };

                this.compareDocumentPosition = function compareDocumentPosition(options)
                {
                    return _node.compareDocumentPosition(options);
                };

                this.hasChildNodes = function hasChildNodes()
                {
                    return _node.hasChildNodes();
                };

                this.insertBefore = function insertBefore()
                {
                    return _node.insertBefore.apply(_node, arguments);
                };

                this.isDefaultNamespace = function isDefaultNamespace(options)
                {
                    return _node.isDefaultNamespace(options);
                };

                this.isEqualNode = function isEqualNode(options)
                {
                    return _node.isEqualNode(options);
                };

                this.isSameNode = function isSameNode(options)
                {
                    return _node.isSameNode(options);
                };

                this.lookupNamespaceURI = function lookupNamespaceURI(options)
                {
                    return _node.lookupNamespaceURI(options);
                };

                this.lookupPrefix = function lookupPrefix(options)
                {
                    return _node.lookupPrefix(options);
                };

                this.normalize = function normalize()
                {
                    checkThenInvoke(_deleg, 'normalizeDocument', []);
                };

                this.removeChild = function removeChild(options)
                {
                    return _node.removeChild(options);
                };

                this.replaceChild = function replaceChild()
                {
                    return _node.replaceChild.apply(_node, arguments);
                };

                Object.defineProperty(this, 'attributes', {
                    get: function ()
                    {
                        return _node.attributes;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'attributes' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'baseURI', {
                    get: function ()
                    {
                        return _node.baseURI;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'baseURI' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'childNodes', {
                    get: function ()
                    {
                        return _node.childNodes;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'childNodes' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'firstChild', {
                    get: function ()
                    {
                        return _node.firstChild;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'firstChild' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'lastChild', {
                    get: function ()
                    {
                        return _node.lastChild;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'lastChild' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'localName', {
                    get: function ()
                    {
                        return _node.localName;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'localName' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'namespaceURI', {
                    get: function ()
                    {
                        return _node.namespaceURI;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'namespaceURI' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'nextSibling', {
                    get: function ()
                    {
                        return _node.nextSibling;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'nextSibling' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'nodeName', {
                    get: function ()
                    {
                        return _node.nodeName;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'nodeName' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'nodeType', {
                    get: function ()
                    {
                        return _node.nodeType;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'nodeType' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'nodeValue', {
                    get: function ()
                    {
                        return _node.nodeValue;
                    },
                    set: function (val)
                    {
                        _node.nodeValue = val;
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                Object.defineProperty(this, 'ownerDocument', {
                    get: function ()
                    {
                        return _node.ownerDocument;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'ownerDocument' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'parentNode', {
                    get: function ()
                    {
                        return _node.parentNode;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'parentNode' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'prefix', {
                    get: function ()
                    {
                        return _node.prefix;
                    },
                    set: function (val)
                    {
                        _node.prefix = val;
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                Object.defineProperty(this, 'previousSibling', {
                    get: function ()
                    {
                        return _node.previousSibling;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'previousSibling' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'textContent', {
                    get: function ()
                    {
                        return _node.textContent;
                    },
                    set: function (val)
                    {
                        _node.textContent = val;
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                // Other members

                this._asString = function _asString()
                {
                    return invoker(xmlApi, 'nlapiXMLToString', [_deleg]);
                };

                this._gd = function _gd()
                {
                    return _deleg;
                };

                this.toString = function toString()
                {
                    return TYPE;
                };
                this.toJSON = function toJSON()
                {
                    return _node.toJSON();
                };
            }

            Document.prototype = nsobject.getNewInstance();

            /**
             * Return a new instance of XML Element.
             *
             * @classDescription Encapsulation of W3C DOM Element
             * @return {Element}
             * @protected
             * @constructor
             *
             * @since 2015.2
             */
            function Element(xmlelem)
            {
                var TYPE = 'xml.Element';

                checkArgs([xmlelem], ['xmlelem'], 'xml.Element');

                var _deleg = xmlelem;
                var _node = new Node(xmlelem);

                // Element members

                /**
                 * Retrieves an attribute value by name.
                 *
                 * @param {string} options.name the name of the attribute to retrieve
                 * @returns {string} the Attr value as a string, or the empty string if that attribute does not have a specified or default value
                 */
                this.getAttribute = function getAttribute(options)
                {
                    var name = (options && options.hasOwnProperty('name')) ? options.name : options;
                    checkArgs([name], ['name'], 'Element.getAttribute');
                    assertString(name, 'name');

                    return checkThenInvoke(_deleg, 'getAttribute', [name]);
                };

                /**
                 * Retrieves an attribute node by name.
                 *
                 * @param {string} options.name the name of the attribute to retrieve
                 * @returns {Attr} the Attr node with the specified name or null if there is no such attribute
                 */
                this.getAttributeNode = function getAttributeNode(options)
                {
                    var name = (options && options.hasOwnProperty('name')) ? options.name : options;
                    checkArgs([name], ['name'], 'Element.getAttributeNode');
                    assertString(name, 'name');

                    var result = checkThenInvoke(_deleg, 'getAttributeNode', [name]);
                    return wrap(result);
                };

                /**
                 * Retrieves an attribute node by local name and namespace URI.
                 *
                 * @param {string} options.namespaceURI the namespace URI of the attribute to retrieve; can be null
                 * @param {string} options.localName the local name of the attribute to retrieve
                 * @returns {Attr} the Attr node with the specified attribute local name and namespace URI or null if there is no such attribute
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the attribute cannot be retrieved for some reason
                 */
                this.getAttributeNodeNS = function getAttributeNodeNS(options)
                {
                    var namespaceURI = null, localName = null;

                    if (options && (options.hasOwnProperty('namespaceURI') || options.hasOwnProperty('localName')))
                    {
                        namespaceURI = options.namespaceURI;
                        localName = options.localName;
                    }
                    else
                    {
                        namespaceURI = options;
                        localName = arguments[1];
                    }
                    checkArgs([localName], ['localName'], 'Element.getAttributeNodeNS');
                    assertStringNullable(namespaceURI, 'namespaceURI');
                    assertString(localName, 'localName');

                    var result = checkThenInvoke(_deleg, 'getAttributeNodeNS', [namespaceURI == null ? null : namespaceURI, localName]);
                    return wrap(result);
                };

                /**
                 * Retrieves an attribute value by local name and namespace URI.
                 *
                 * @param {string} options.namespaceURI the namespace URI of the attribute to retrieve; can be null
                 * @param {string} options.localName the local name of the attribute to retrieve
                 * @returns {string} the Attr value as a string, or the empty string if that attribute does not have a specified or default value
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the attribute cannot be retrieved for some reason
                 */
                this.getAttributeNS = function getAttributeNS(options)
                {
                    var namespaceURI = null, localName = null;

                    if (options && (options.hasOwnProperty('namespaceURI') || options.hasOwnProperty('localName')))
                    {
                        namespaceURI = options.namespaceURI;
                        localName = options.localName;
                    }
                    else
                    {
                        namespaceURI = options;
                        localName = arguments[1];
                    }
                    checkArgs([localName], ['localName'], 'Element.getAttributeNS');
                    assertStringNullable(namespaceURI, 'namespaceURI');
                    assertString(localName, 'localName');

                    return checkThenInvoke(_deleg, 'getAttributeNS', [namespaceURI == null ? null : namespaceURI, localName]);
                };

                /**
                 * Returns an array of all descendant Elements with a given tag name, in document order.
                 *
                 * @param {string} options.tagName the name of the tag to match on; the special value "*" matches all tags; for XML, the tagName parameter is case-sensitive
                 * @returns {Element[]} an array of matching Element nodes
                 */
                this.getElementsByTagName = function getElementsByTagName(options)
                {
                    var tagName = (options && options.hasOwnProperty('tagName')) ? options.tagName : options;
                    checkArgs([tagName], ['tagName'], 'Element.getElementsByTagName');
                    assertString(tagName, 'tagName');

                    var elems = checkThenInvoke(_deleg, 'getElementsByTagName', [tagName]);
                    var result = [];
                    for (i = 0; i < elems.length; i++)
                    {
                        result.push(new Element(elems.item(i)));
                    }
                    return result;
                };

                /**
                 * Returns an array of all descendant Elements with a given local name and namespace URI in document order.
                 *
                 * @param {string} options.namespaceURI the namespace URI of the elements to match on; the special value "*" matches all namespaces
                 * @param {string} options.localName the local name of the elements to match on; the special value "*" matches all local names
                 * @returns {Element[]} an array of matching Element nodes
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the elements cannot be retrieved for some reason
                 */
                this.getElementsByTagNameNS = function getElementsByTagNameNS(options)
                {
                    var namespaceURI = null, localName = null;

                    if (options && (options.hasOwnProperty('namespaceURI') || options.hasOwnProperty('localName')))
                    {
                        namespaceURI = options.namespaceURI;
                        localName = options.localName;
                    }
                    else
                    {
                        namespaceURI = options;
                        localName = arguments[1];
                    }
                    checkArgs([namespaceURI, localName], ['namespaceURI', 'localName'], 'Element.getElementsByTagNameNS');
                    assertString(namespaceURI, 'namespaceURI');
                    assertString(localName, 'localName');

                    var elems = checkThenInvoke(_deleg, 'getElementsByTagNameNS', [namespaceURI, localName]);
                    var result = [];
                    for (i = 0; i < elems.length; i++)
                    {
                        result.push(new Element(elems.item(i)));
                    }
                    return result;
                };

                /**
                 * Returns true when an attribute with a given name is specified on this element or has a default value, false otherwise.
                 *
                 * @param {string} options.name the name of the attribute to look for
                 * @returns {boolean} true if an attribute with the given name is specified on this element or has a default value, false otherwise
                 */
                this.hasAttribute = function hasAttribute(options)
                {
                    var name = (options && options.hasOwnProperty('name')) ? options.name : options;
                    checkArgs([name], ['name'], 'Element.hasAttribute');
                    assertString(name, 'name');

                    return checkThenInvoke(_deleg, 'hasAttribute', [name]);
                };

                /**
                 * Returns true when an attribute with a given local name and namespace URI is specified on this element or has a default value, false otherwise.
                 *
                 * @param {string} options.namespaceURI the namespace URI of the attribute to look for; can be null
                 * @param {string} options.localName the local name of the attribute to look for
                 * @returns {boolean} true if an attribute with the given local name and namespace URI is specified or has a default value on this element, false otherwise
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the command cannot be performed for some reason
                 */
                this.hasAttributeNS = function hasAttributeNS(options)
                {
                    var namespaceURI = null, localName = null;

                    if (options && (options.hasOwnProperty('namespaceURI') || options.hasOwnProperty('localName')))
                    {
                        namespaceURI = options.namespaceURI;
                        localName = options.localName;
                    }
                    else
                    {
                        namespaceURI = options;
                        localName = arguments[1];
                    }
                    checkArgs([localName], ['localName'], 'Element.hasAttributeNS');
                    assertStringNullable(namespaceURI, 'namespaceURI');
                    assertString(localName, 'localName');

                    return checkThenInvoke(_deleg, 'hasAttributeNS', [namespaceURI == null ? null : namespaceURI, localName]);
                };

                /**
                 * Removes an attribute by name.
                 *
                 * @param {string} options.name the name of the attribute to remove
                 * @returns {void}
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the attribute cannot be removed for some reason
                 */
                this.removeAttribute = function removeAttribute(options)
                {
                    var name = (options && options.hasOwnProperty('name')) ? options.name : options;
                    checkArgs([name], ['name'], 'Element.removeAttribute');
                    assertString(name, 'name');

                    checkThenInvoke(_deleg, 'removeAttribute', [name]);
                };

                /**
                 * Removes the specified attribute node.
                 *
                 * @param {Attr} options.oldAttr the Attr node to remove from the attribute list
                 * @returns {Attr} the Attr node that was removed
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the attribute cannot be added for some reason
                 */
                this.removeAttributeNode = function removeAttributeNode(options)
                {
                    var oldAttr = (options && options.hasOwnProperty('oldAttr')) ? options.oldAttr : options;
                    checkArgs([oldAttr], ['oldAttr'], 'Element.removeAttributeNode');
                    assertNode(oldAttr, 'oldAttr');

                    var result = checkThenInvoke(_deleg, 'removeAttributeNode', [oldAttr._gd()]);
                    return wrap(result);
                };

                /**
                 * Removes an attribute by local name and namespace URI.
                 *
                 * @param {string} options.namespaceURI the namespace URI of the attribute to remove; can be null
                 * @param {string} options.localName the local name of the attribute to remove
                 * @returns {void}
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the attribute cannot be removed for some reason
                 */
                this.removeAttributeNS = function removeAttributeNS(options)
                {
                    var namespaceURI = null, localName = null;

                    if (options && (options.hasOwnProperty('namespaceURI') || options.hasOwnProperty('localName')))
                    {
                        namespaceURI = options.namespaceURI;
                        localName = options.localName;
                    }
                    else
                    {
                        namespaceURI = options;
                        localName = arguments[1];
                    }
                    checkArgs([localName], ['localName'], 'Element.removeAttributeNS');
                    assertStringNullable(namespaceURI, 'namespaceURI');
                    assertString(localName, 'localName');

                    checkThenInvoke(_deleg, 'removeAttributeNS', [namespaceURI == null ? null : namespaceURI, localName]);
                };

                /**
                 * Adds a new attribute. If an attribute with that name is already present in the element, its value is changed to be that of the value parameter.
                 *
                 * @param {string} options.name the name of the attribute to create or alter
                 * @param {string} options.value value to set in string form
                 * @returns {void}
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the attribute cannot be added for some reason
                 */
                this.setAttribute = function setAttribute(options)
                {
                    var name = null, value = null;

                    if (options && (options.hasOwnProperty('name') || options.hasOwnProperty('value')))
                    {
                        name = options.name;
                        value = options.value;
                    }
                    else
                    {
                        name = options;
                        value = arguments[1];
                    }
                    checkArgs([name, value], ['name', 'value'], 'Element.setAttribute');
                    assertString(name, 'name');
                    assertString(value, 'value');

                    return checkThenInvoke(_deleg, 'setAttribute', [name, value]);
                };

                /**
                 * Adds a new attribute node. If an attribute with that name is already present in the element, it is replaced by the new one.
                 *
                 * @param {Attr} options.newAttr the Attr node to add to the attribute list
                 * @returns {Attr} if the newAttr attribute replaces an existing attribute, the replaced Attr node is returned, otherwise null is returned
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the attribute cannot be added for some reason
                 */
                this.setAttributeNode = function setAttributeNode(options)
                {
                    var newAttr = (options && options.hasOwnProperty('newAttr')) ? options.newAttr : options;
                    checkArgs([newAttr], ['newAttr'], 'Element.setAttributeNode');
                    assertNode(newAttr, 'newAttr');

                    var result = checkThenInvoke(_deleg, 'setAttributeNode', [newAttr._gd()]);
                    return wrap(result);
                };

                /**
                 * Adds a new attribute node. If an attribute with that local name and that namespace URI is already present in the element, it is replaced by the new one.
                 *
                 * @param {Attr} options.newAttr the Attr node to add to the attribute list
                 * @returns {Attr} if the newAttr attribute replaces an existing attribute with the same local name and namespace URI, the replaced Attr node is returned, otherwise null is returned
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the attribute cannot be added for some reason
                 */
                this.setAttributeNodeNS = function setAttributeNodeNS(options)
                {
                    var newAttr = (options && options.hasOwnProperty('newAttr')) ? options.newAttr : options;
                    checkArgs([newAttr], ['newAttr'], 'Element.setAttributeNodeNS');
                    assertNode(newAttr, 'newAttr');

                    var result = checkThenInvoke(_deleg, 'setAttributeNodeNS', [newAttr._gd()]);
                    return wrap(result);
                };

                /**
                 * Adds a new attribute. If an attribute with the same local name and namespace URI is already present on the element, its prefix is changed
                 * to be the prefix part of the qualifiedName, and its value is changed to be the value parameter.
                 *
                 * @param {string} options.namespaceURI the namespace URI of the attribute to create or alter; can be null
                 * @param {string} options.qualifiedName the qualified name of the attribute to create or alter
                 * @param {string} options.value value to set in string form
                 * @returns {void}
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the attribute cannot be added for some reason
                 */
                this.setAttributeNS = function setAttributeNS(options)
                {
                    var namespaceURI = null, qualifiedName = null, value = null;

                    if (options && (options.hasOwnProperty('namespaceURI') || options.hasOwnProperty('qualifiedName') || options.hasOwnProperty('value')))
                    {
                        namespaceURI = options.namespaceURI;
                        qualifiedName = options.qualifiedName;
                        value = options.value;
                    }
                    else
                    {
                        namespaceURI = options;
                        qualifiedName = arguments[1];
                        value = arguments[2];
                    }
                    checkArgs([qualifiedName, value], ['qualifiedName', 'value'], 'Element.setAttributeNS');
                    assertStringNullable(namespaceURI, 'namespaceURI');
                    assertString(qualifiedName, 'qualifiedName');
                    assertString(value, 'value');

                    return checkThenInvoke(_deleg, 'setAttributeNS', [namespaceURI == null ? null : namespaceURI, qualifiedName, value]);
                };

                /**
                 * The name of the element.
                 * @name Element#tagName
                 * @type string
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'tagName', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getTagName', []);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'tagName' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                // Members inherited from Node

                this.appendChild = function appendChild(options)
                {
                    return _node.appendChild(options);
                };

                this.cloneNode = function cloneNode(options)
                {
                    return _node.cloneNode(options);
                };

                this.compareDocumentPosition = function compareDocumentPosition(options)
                {
                    return _node.compareDocumentPosition(options);
                };

                this.hasAttributes = function hasAttributes()
                {
                    return _node.hasAttributes();
                };

                this.hasChildNodes = function hasChildNodes()
                {
                    return _node.hasChildNodes();
                };

                this.insertBefore = function insertBefore()
                {
                    return _node.insertBefore.apply(_node, arguments);
                };

                this.isDefaultNamespace = function isDefaultNamespace(options)
                {
                    return _node.isDefaultNamespace(options);
                };

                this.isEqualNode = function isEqualNode(options)
                {
                    return _node.isEqualNode(options);
                };

                this.isSameNode = function isSameNode(options)
                {
                    return _node.isSameNode(options);
                };

                this.lookupNamespaceURI = function lookupNamespaceURI(options)
                {
                    return _node.lookupNamespaceURI(options);
                };

                this.lookupPrefix = function lookupPrefix(options)
                {
                    return _node.lookupPrefix(options);
                };

                this.normalize = function normalize()
                {
                    _node.normalize();
                };

                this.removeChild = function removeChild(options)
                {
                    return _node.removeChild(options);
                };

                this.replaceChild = function replaceChild()
                {
                    return _node.replaceChild.apply(_node, arguments);
                };

                Object.defineProperty(this, 'attributes', {
                    get: function ()
                    {
                        return _node.attributes;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'attributes' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'baseURI', {
                    get: function ()
                    {
                        return _node.baseURI;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'baseURI' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'childNodes', {
                    get: function ()
                    {
                        return _node.childNodes;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'childNodes' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'firstChild', {
                    get: function ()
                    {
                        return _node.firstChild;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'firstChild' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'lastChild', {
                    get: function ()
                    {
                        return _node.lastChild;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'lastChild' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'localName', {
                    get: function ()
                    {
                        return _node.localName;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'localName' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'namespaceURI', {
                    get: function ()
                    {
                        return _node.namespaceURI;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'namespaceURI' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'nextSibling', {
                    get: function ()
                    {
                        return _node.nextSibling;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'nextSibling' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'nodeName', {
                    get: function ()
                    {
                        return _node.nodeName;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'nodeName' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'nodeType', {
                    get: function ()
                    {
                        return _node.nodeType;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'nodeType' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'nodeValue', {
                    get: function ()
                    {
                        return _node.nodeValue;
                    },
                    set: function (val)
                    {
                        _node.nodeValue = val;
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                Object.defineProperty(this, 'ownerDocument', {
                    get: function ()
                    {
                        return _node.ownerDocument;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'ownerDocument' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'parentNode', {
                    get: function ()
                    {
                        return _node.parentNode;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'parentNode' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'prefix', {
                    get: function ()
                    {
                        return _node.prefix;
                    },
                    set: function (val)
                    {
                        _node.prefix = val;
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                Object.defineProperty(this, 'previousSibling', {
                    get: function ()
                    {
                        return _node.previousSibling;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'previousSibling' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'textContent', {
                    get: function ()
                    {
                        return _node.textContent;
                    },
                    set: function (val)
                    {
                        _node.textContent = val;
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                // Other members

                this._gd = function _gd()
                {
                    return _deleg;
                };

                this.toString = function toString()
                {
                    return TYPE;
                };
                this.toJSON = function toJSON()
                {
                    return _node.toJSON();
                };
            }

            Element.prototype = nsobject.getNewInstance();

            /**
             * Return a new instance of XML Attr.
             *
             * @classDescription Encapsulation of W3C DOM Attr
             * @return {Attr}
             * @protected
             * @constructor
             *
             * @since 2015.2
             */
            function Attr(xmlattr)
            {
                var TYPE = 'xml.Attr';

                checkArgs([xmlattr], ['xmlattr'], 'xml.Attr');

                var _deleg = xmlattr;

                // Attr members

                /**
                 * Returns the name of this attribute. If Node.localName is different from null, this property is a qualified name.
                 * @name Attr#name
                 * @type string
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'name', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getName', []);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'name' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The Element node this attribute is attached to or null if this attribute is not in use.
                 * @name Attr#ownerElement
                 * @type Element
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'ownerElement', {
                    get: function ()
                    {
                        var result = checkThenInvoke(_deleg, 'getOwnerElement', []);
                        return wrap(result);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'ownerElement' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * True if this attribute was explicitly given a value in the instance document, false otherwise.
                 * @name Attr#specified
                 * @type boolean
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'specified', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getSpecified', []);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'specified' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The attribute value. On retrieval, the value of the attribute is returned as a string. Character and general entity
                 * references are replaced with their values. On setting, this creates a Text node with the unparsed contents of the string,
                 * i.e. any characters that an XML processor would recognize as markup are instead treated as literal text.
                 * @name Attr#value
                 * @type string
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the value cannot be set for some reason
                 */
                Object.defineProperty(this, 'value', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getValue', []);
                    },
                    set: function (val)
                    {
                        assertString(val, 'value');
                        checkThenInvoke(_deleg, 'setValue', [val]);
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                // Other members

                this._gd = function _gd()
                {
                    return _deleg;
                };
                this.toString = function toString()
                {
                    return TYPE;
                };
                this.toJSON = function toJSON()
                {
                    return {
                        name: this.name,
                        ownerElement: this.ownerElement,
                        specified: this.specified,
                        value: this.value
                    };
                };
            }

            Attr.prototype = nsobject.getNewInstance();

            //====== Utility functions (to be replaced by util module when available) ====

            function assertString(arg, argName)
            {
                if (!isString(arg))
                    utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, argName,'string' );
            }

            function assertStringNullable(arg, argName)
            {
                if (arg != null)
                    assertString(arg, argName);
            }

            function assertNode(arg, argName)
            {
                if (!isNode(arg))
                    utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, argName,'xml.Node or subclass' );
            }

            function assertNodeNullable(arg, argName)
            {
                if (arg != null)
                    assertNode(arg, argName);
            }

            function isString(obj)
            {
                return Object.prototype.toString.call(obj) === '[object String]';
            }

            function isNode(obj)
            {
                return obj instanceof Node || obj instanceof Element || obj instanceof Attr || obj instanceof Document;
            }

            function checkArgs(funcArgs, funcArgNames, funcName)
            {
                for (var i = 0; i < funcArgs.length; i++)
                    if (funcArgs[i] == null) // also catches 'undefined'
                        utilityFunctions.throwSuiteScriptError(error.Type.MISSING_REQD_ARGUMENT, (funcName ? funcName + ': ' : ''),funcArgNames[i] );
            }

            function wrap(node)
            {
                if (!node)
                    return node; // do nothing

                switch (node.nodeType)
                {
                    case 1:
                        return new Element(node);
                    case 2:
                        return new Attr(node);
                    case 9:
                        return new Document(node);
                    default:
                        return new Node(node);
                }
            }

            //========================================================================

            function escape(options)
            {
                var xmlText = (options && options.hasOwnProperty('xmlText')) ? options.xmlText : options;
                checkArgs([xmlText], ['xmlText'], 'escape');
                assertString(xmlText, 'xmlText');

                return xmlText.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/'/g, '&apos;').replace(/"/g, '&quot;');
            }

            function validate(options)
            {
                var xml = null, xsdFilePathOrId = null, importFolderPathOrId = null;

                if (options && (options.hasOwnProperty('xml') || options.hasOwnProperty('xsdFilePathOrId') || options.hasOwnProperty('importFolderPathOrId')))
                {
                    xml = options.xml;
                    xsdFilePathOrId = options.xsdFilePathOrId;
                    importFolderPathOrId = options.importFolderPathOrId;
                }
                else
                {
                    xml = options;
                    xsdFilePathOrId = arguments[1];
                    importFolderPathOrId = arguments[2];
                }
                checkArgs([xml, xsdFilePathOrId], ['xml', 'xsdFilePathOrId'], 'validate');
                assertNode(xml, 'xml');

                var schema = file.load(xsdFilePathOrId).getContents();
                var schemaDoc = this.Parser.fromString(schema);

                invoker(xmlApi, 'nlapiValidateXML', [xml._gd(), schemaDoc._gd(), importFolderPathOrId != null ? importFolderPathOrId : null]);
            }

            //========================================================================

            return Object.freeze({
                /**
                 * Prepares a String for use in XML by escaping XML markup (for example, angle brackets, quotation marks, and ampersands).
                 *
                 * @param {string} options.xmlText the XML text to be escaped
                 * @returns {string} the escaped XML
                 *
                 * @since 2015.2
                 */
                escape: escape,

                /**
                 * Validates a supplied XML document against a supplied XML Schema (XSD Document).
                 *
                 * @param {Document} options.xml the XML document object
                 * @param {int|string} options.xsdFilePathOrId ID or path to the XSD file to validate the XML object against
                 * @param {int|string} options.importFolderPathOrId (optional) ID or path to a folder in the file cabinet containing additional XSD schemas which are imported by the parent XSD provided via "xsdFilePathOrId"
                 * @throws {SuiteScriptError} SSS_XML_DOES_NOT_CONFORM_TO_SCHEMA if XML provided is invalid with respect to the provided schema
                 * @throws {SuiteScriptError} SSS_INVALID_XML_SCHEMA_OR_DEPENDENCY if schema is an incorrectly structured XSD, or a dependent schema could not be found
                 * @returns {void}
                 *
                 * @since 2015.2
                 */
                validate: validate,

                /**
                 * XML Parser Object
                 *
                 * @type Parser
                 */
                Parser: new Parser(),

                /**
                 * XPath Query Object
                 *
                 * @type XPath
                 */
                XPath: new XPath(),

                /**
                 * @enum
                 */
                NodeType: NODE_TYPES_ENUM
            });
        });

/**
 * This file is an alias for SystemScripts - NLCommonScripts.getCurrencyFunctions(null)
 *
 * @private
 * @module N/util/currencyUtility
 */
define('N/util/currencyUtility',['N/utilityFunctions'],
	function(utilityFunctions){
		/* imports */
	   /**
		* @alias CURRENCY2_AND_RATE_PRECISION (NLCurrencyUtil.java)
		*/
		var CURRENCY2_AND_RATE_PRECISION = 8;

		/**
		 * @alias getDefaultCurrencyPrecision (NLCurrencyUtil.java)
		 */
		function getDefaultCurrencyPrecision()
		{
			return 2;
		}

		/**
		 * @alias dollars_string (NLAppUtil.jsp)
		 *
		 */
		function dollars_string(amount)
		{
			var temp = amount;
			var DigitStrings = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'];
			var TeenStrings = ['ten', 'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen', 'eightteen', 'nineteen'];
			var DecadeStrings = ['zero', 'ten', 'twenty', 'thirty', 'forty', 'fifty', 'sixty', 'seventy', 'eighty', 'ninety'];
			var result = '';
			if (temp >= 1000)
			{
				result = result + dollars_string(Math.floor(temp/1000)) + 'thousand ';
				temp = temp % 1000;
			}
			if (temp >= 100)
			{
				result = result + DigitStrings[Math.floor(temp/100)] + ' hundred ';
				temp = temp % 100;
			}
			if (temp >= 20)
			{
				result = result + DecadeStrings[Math.floor(temp/10)] + ' ';
				temp = temp % 10;
			}
			if (temp >= 10)
			{
				result = result + TeenStrings[Math.floor(temp-10)] + ' ';
			}
			else if ((amount == 0) || (temp > 0))
			{
				result = result + DigitStrings[Math.floor(temp)] + ' ';
			}
			return result;
		}

		function amount_string(amount)
		{
			var cents = Math.floor((amount-Math.floor(amount))*100+0.5);
			var centstring = (cents < 10) ? '0'+cents.toString() : cents.toString();
			var dollarstring = dollars_string(Math.floor(amount));
			return dollarstring.charAt(0).toUpperCase() + dollarstring.substr(1) + 'and ' + centstring + '/100';
		}


		function format_rate(a,p, recordContext)
		{
			var s;
			var cs;
			var n;
			var returnMe;
			if (isNaN(parseFloat(a)))
			{
				returnMe= '';
			}
			else
			{
				var precision = get_precision(recordContext);

				if (precision>1 || p) /*precision is 2 or its a % */
				{
					s=(a<0);
					if (s) a=-a;
					var d=Math.floor(a);
					var c=Math.floor((a-d)*(p?10:100)+0.5);

					if (a == d+c/(p?10:100))
					{
						if (c==(p?10:100))
						{
							d++;
							c=0;
						}
						cs=p?c.toString():((c < 10)?'0'+c.toString():c.toString());
						returnMe = (s?'-':'')+d.toString()+'.'+cs+(p?'%':'');
					}
					else
						returnMe = (s?'-':'')+a+(p?'%':'');
				}
				else if (precision === 1)
				{
					s=(a<0);
					if (s) a=-a;
					cs = a.toString();
					n = cs.indexOf('.');
					if (n==-1) cs = cs.toString() + '.0';
					else if (n==0) cs = '0.' + cs.toString() ;
					else if (n==cs.length-1) cs = cs.toString() + '0' ;
					returnMe = (s?'-':'') + cs ;
				}
				else if (precision === 0)
				{
					s=(a<0);
					if (s) a=-a;
					cs = a.toString();
					n = cs.indexOf('.');
					if (n==0) cs = '0.' + cs.toString() ;
					else if (n==cs.length-1) cs = cs.substring(0, cs.length-2);
					returnMe = (s?'-':'') + cs ;
				}
			}
			return returnMe;
		}

		// Cannot assume that nlapiGetFieldValue is accessible to all.
		// Protect from JS errors, and assume the USD default (2 decimal places) if no value is specified
		function getCurrencyPrecisionFieldValue(recordContext)
		{
			var precision = 2;
			if (!!recordContext)
			{
				precision = recordContext.getFieldValue('currencyprecision');
			}
			else if (typeof nlapiGetFieldValue === "function")
			{
				precision = nlapiGetFieldValue('currencyprecision');
			}

			return precision;
		}

		/*
		The 38 bit oracle representation for floating point numbers does things differently than
		the IEEE754 Spec that is used for floating point math in Java/JavaScript.  In Java/Javascript

		233 * .075 = 17.474999999999998

		In Oracle

		233 * .075 = 17.475

		To fix this so that both values will be the same, we first round to 5 decimal places
		(agreed upon) internal representation.  And then round to the two decimal places that
		we present to the user.

		Extending the above to round to either 0,1 or 2 places of decimal
		WARNING !!! This works for rounding to 0, 1, 2 places of decimal only
		 */
		function get_precision(recordContext)
		{
			var cp = getCurrencyPrecisionFieldValue(recordContext);
			var precision = getDefaultCurrencyPrecision();
			if (cp != null)
			{
				var tprecision = parseFloat(cp.value);
				if (!isNaN(tprecision))
				{
					precision=tprecision;
				}
			}
			return precision;
		}

		function round_currency(amount, numofdecimals, method, recordContext)
		{
			var precision = numofdecimals;
			// Try reloading the precision if it wasnt passed in
			if ( precision == null )
				precision = get_precision(recordContext);
			var amountStr = amount + '';
			if ( amount > 1E10 && amountStr.indexOf('.') >= 0 && (amountStr.length - amountStr.indexOf('.') - 1 <= precision) ) //if it's already rounded, just return, don't go through the IEEE754 business
				return amount;
			var b = Math.abs(amount);// Take the abs, sign will be restored afterwards, this makes the rounding independant of sign

			// Round to five places (this is for the IEEE754 business described above)
			// Note we use Math.floor instead of Math.round to avoid problems switching from int to float.
			// This caused problems in the Safari browser, but didn't seem to affect IE.
			// See Bugs 65624 and 66338 - RGrisso, 4/1/04
			b = Math.floor((b * 100000.0)+0.5) / 100000.0 + 0.000001;

			// the + 0.000001 rounds up anything that's significant enough to affect the next rounding pass e.g. ####.459999999 (in binary)
			// e.g. a = 139.825

			// And now Round to the correct places
			var factor = Math.pow(10,precision);
			if (!method || method =='OFF') b = Math.floor((b * factor)+0.5) / factor;
			else if (method == 'UP')   b = Math.round(Math.ceil(Math.abs(amount) * factor)) / factor;
			else if (method == 'DOWN') b = Math.round(Math.floor(Math.abs(amount) * factor)) / factor;
			// return the sign
			b = b * (amount >= 0.0 ? 1.0 : -1.0);
			if( b === 0.0 )
				return 0.0;
			return b;
		}

		// Round to 8 decimal places
		function round_float(a)
		{
			return round_float_to_n_places(a,8);
		}

		// Round to n decimal places
		function round_float_to_n_places(a,n)
		{  // Take the abs, sign will be restored afterwards, this makes the rounding independant of sign
			var str = a + '';
			if(str.indexOf('.') < 0) // if it's an integer, just return
				return a;
			if(str.length-str.indexOf('.')-1 <= n) // if the decimal digits length after decimal point is less than the targeted precistion, just return
				return a;
			var b = Math.abs(a);
			b = b + 0.00000000000001; //SMALLER_NUMBER See NLRounding.round();
			var factor = Math.pow(10,n);
			b = Math.floor((b * factor)+0.5) / factor;
			// return the sign
			b = b * (a >= 0.0 ? 1.0 : -1.0);
			if( b == 0.0 )
				return 0.0;
			return b;
		}

		function pad_to_atleast_two_decimal_places(a)
		{
			var s;
			if(a == null)
			{
				s = '';
			}
			else
			{
				s = a.toString();
				var n = s.indexOf('.');
				if(n === -1)
				{
					s = s + '.00';
				}
				else if(n === s.length-1)
				{
					s = s + '00';
				}
				else if(n === s.length-2)
				{
					s = s + '0';
				}
				if (n === 0)
				{
					s = '0' + s;
				}
			}
			return s;
		}

		function pad_decimal_places(a, noOfDecimalPlaces)
		{
			var s;
			if(a == null)
			{
				s = '';
			}
			else
			{
				s = a.toString();
				var n = s.indexOf('.');
				if (noOfDecimalPlaces === 0)
				{
					if(a == 0.0)
					{
						s = '0';
					}
					else if(n > -1)
					{
						s = s.substring(0, n) ;
					}
				}
				else if (noOfDecimalPlaces ===1)
				{
					if(n == -1)
					{
						s = s + '.0';
					}
					else if(n == s.length-1)
					{
						s = s + '0';
					}
					else if (n == 0)
					{
						s = '0' + s;
					}
				}
				else
				{
					if(n == -1)
					{
						s = s + '.00';
					}
					else if(n == s.length-1)
					{
						s = s + '00';
					}
					else if(n == s.length-2)
					{
						s = s + '0';
					}
					if (n == 0)
					{
						s = '0' + s;
					}
				}
			}
			return s;
		}

		/**
		 *
		 * algorithm used should yield the same result as NLCurrency.Round...
		 * we should keep them consistent. There is now an additional param
		 * which will not attempt to round to 2 sig figures. All it does is
		 * to just add zeros at the end if it needs it. This is used for
		 * billing rates such as $0.4565 per gallon of paint and such.

		 * This method should optionally round the number passed in and then
		 * truncate it two digits past the decimal
		 */
		function format_currency(a, bDoNotRound, recordContext)
		{
			if(isNaN(a))
				return '';

			var cp = getCurrencyPrecisionFieldValue(recordContext);
			var noOfDecimalPlaces = getDefaultCurrencyPrecision();
			if (cp !== null)
			{
				noOfDecimalPlaces = parseFloat(cp);
				if (isNaN(noOfDecimalPlaces))
				{
					noOfDecimalPlaces = getDefaultCurrencyPrecision();
				}
			}
			var returnMe;
			if( !(bDoNotRound == true))   //This mess is necessary so that when do not round is not set it evaluates correctly
			{
				returnMe = round_currency(a, noOfDecimalPlaces);
			}
			else
			{
				returnMe = a;
			}
			returnMe = pad_decimal_places(returnMe, noOfDecimalPlaces);
			return returnMe;
		}

		//Use this for rounding Currency2
		function format_currency2(n, recordContext)
		{
			if(isNaN(n))
			{
				return '';
			}
			var returnMe;
			if( (n+'').indexOf('.') < 0 ) // if it's an integer, don't even try to do the rounding
				returnMe = n;
			else
				returnMe = round_float_to_n_places(n,CURRENCY2_AND_RATE_PRECISION);
			var precision = get_precision(recordContext);
			if (precision === 2) { //We pad zeros only if the precision on the currency is 2 (standard). For everything else, we show howsoevermany places you entered.
				returnMe = pad_to_atleast_two_decimal_places(returnMe);
			}

			return returnMe;
		}

		function format_percent(p) {
			if(typeof p == 'string')
				p = parseFloat(p);
			return p + ( p === Math.floor(p) ? '.0%' : '%');
		}

		function process_currency_field_value(value, fieldType, recordContext) {
			if (!fieldType || fieldType.indexOf('currency') == -1)
				return value;
			if (utilityFunctions.isValEmpty(value) || ('' + value).indexOf('.') != -1 || isNaN(parseFloat(value)))
				return value;
			var precision = fieldType.indexOf('currency2') >= 0 ? 2 : get_precision(recordContext);
			return pad_decimal_places('' + value, precision);
		}

		/* assign util.currency package */
		return Object.freeze({
			amount_string: amount_string,
			format_percent: format_percent,
			format_rate: format_rate,
			format_currency: format_currency,
			format_currency2: format_currency2,
			get_precision: get_precision,
			pad_decimal_places: pad_decimal_places,
			pad_to_atleast_two_decimal_places: pad_to_atleast_two_decimal_places,
			process_currency_field_value: process_currency_field_value,
			round_currency: round_currency,
			round_float: round_float,
			round_float_to_n_places: round_float_to_n_places
		});
	}
);

/**
 * SuiteScript module
 *
 * @private
 * @module N/util/date
 * @suiteScriptVersion 2.x
 */
define( 'N/util/date',['N/FieldValidationHelper'],
	function(FieldValidationHelper){
		var MONTHLENGTH = [[31,28,31,30,31,30,31,31,30,31,30,31],[31,29,31,30,31,30,31,31,30,31,30,31]];
		var OLDEST_VALID_DATE = new Date(1601, 3, 1); // Via Issue 139785, Any date before 4/1/1601 is invalid
		var yearCharCN = "";
		var monthCharCN = "";
		var dayCharCN = "";
		var TIME_FORMAT_WITH_POSSIBLE_AMPM_SUFFIX = /^(\d+)(\D)(\d+)((\D)(\d+))?\s*([aApP][mM])?/;
		var TIME_FORMAT_WITH_POSSIBLE_AMPM_PREFIX = /^([aApP][mM])(\d+)(\D)(\d+)(\D)((\d+)(\D))?/;
		var TIME_FORMAT_WITH_ASIAN_FORMATTING	  = /^(\d+)(\D)(\d+)(\D)((\d+)(\D))?/;

        function getMonthIndexFromArray(array, val, ignorecase)
        {
            for ( var i = 0; array != null && i < array.length; i++ )
                if ( val == array[i] || (ignorecase && val != null && array[i] != null && val.toLowerCase() == array[i].toLowerCase()) )
                    return i;
            return -1;
        }

		/**
		 *
		 * @alias nlGetFullYear
		 *
		 * @param d
		 * @returns {*}
		 */
		function getFullYear(d)
		{
			if (typeof window !== 'undefined' && window.navigator != null && window.navigator.appName == "Netscape")
			{
				if (!d.getFullYear)
					return d.getYear();
			}
			return d.getFullYear();
		}
	
		var heiseiStartDate = new Date(1989,0,8);
		var showaStartDate = new Date(1926,11,25);
		var taishoStartDate = new Date(1912,6,30);
		var meijiStartDate = new Date(1868,8,8);
		function getJapaneseImperialEra(d)
		{
			if(d >= heiseiStartDate)
				return "";
			else if(d >= showaStartDate)
				return "";
			else if(d >= taishoStartDate)
				return "";
			else
				return "";
		}
		function getShortJapaneseImperialEra(d)
		{
			if(d >= heiseiStartDate)
				return "H";
			else if(d >= showaStartDate)
				return "S";
			else if(d >= taishoStartDate)
				return "D";
			else
				return "M";
		}
		function getJapaneseImperialYear(d)
		{
			if(d >= heiseiStartDate)
				return getFullYear(d) - 1988;
			else if(d >= showaStartDate)
				return getFullYear(d) - 1925;
			else if(d >= taishoStartDate)
				return getFullYear(d) - 1911;
			else
				return getFullYear(d) - 1867;
		}
		function getGregorianYear(japaneseImperialYear, era)
		{
			if(era === "" || era === "H")
				return japaneseImperialYear + 1988;
			else if(era === "" || era === "S")
				return japaneseImperialYear + 1925;
			else if(era === "" || era === "D")
				return japaneseImperialYear + 1911;
			else
				return japaneseImperialYear + 1867;
		}
	
		function getMonthIndex(sMonth)
		{
			var m = -1;
			sMonth = sMonth.toUpperCase()
			for ( var i=0; i < FieldValidationHelper.datetime_short_months.length; i++ )
			{
				if ( FieldValidationHelper.datetime_short_months[i].toUpperCase() === sMonth )
				{
					m = i + 1; break;
				}
			}
			if(m !== -1)
				return m;
			for ( var i=0; i < FieldValidationHelper.datetime_months.length; i++ )
			{
				if ( FieldValidationHelper.datetime_months.toUpperCase() === sMonth )
				{
					m = i + 1; break;
				}
			}
	
			return m;
		}
		/**
		 *
		 * @alias nlSetFullYear
		 *
		 * @param d
		 * @param val
		 */
		function setFullYear(d,val)
		{
			if (typeof window !== 'undefined'  && window.navigator !== null && window.navigator.appName === "Netscape")
			{
				if (!d.setFullYear)
					d.setYear(val);
			}
			d.setFullYear(val);
		}
	
		function isLeapYear(year)
		{
			return (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0));
		}
	
	
		function getMonthLength(year, month)
		{
			return MONTHLENGTH[isLeapYear(year) ? 1 : 0][month];
		}

		function addMonths(d, mtoadd)
		{
			if (mtoadd != 0)
			{
				var year = getFullYear(d);
				var dom = d.getDate();
				var month = d.getMonth() + mtoadd;
				if (month < 0)
				{
					month += 1;
					year = year + Math.ceil(month / 12) - 1;
					setFullYear(d, year);
					month = 11 + (month % 12);
				}
				else if (month > 11)
				{
					year = year + Math.floor(month / 12);
					setFullYear(d, year);
					month %= 12;

					// JS rounds leap days up (2/29/2016 + 1 yr = 3/1/2017),
					// whereas Java rounds them down (2/29/2016 + 1 yr = 2/28/2017).
					// Make JS behave like Java to be consistent with server side.
					if(dom === 29)
						d.setDate(dom); //This only works because we're setting the month later
				}
				var eom = getMonthLength(year, month);
				if (dom > eom)
					d.setDate(eom);

				d.setMonth(month);
			}
			return d;
		}

		function addDays(d, daystoadd)
		{
			if (!(d instanceof Date || Object.prototype.toString.call(d) === '[object Date]'))
				return d;
	
			var d2 = new Date(d.getTime() + 86400 * daystoadd * 1000);
			if (d2.getHours() !== d.getHours())
			{
				if ((d.getHours() > 0 && d2.getHours() < d.getHours()) || (d.getHours() === 0 && d2.getHours() === 23))
					d2.setTime(d2.getTime() + 3600*1000);
				else
					d2.setTime(d2.getTime() - 3600*1000);
			}
			d.setTime(d2.getTime());
			return d;
		}
	
		function isValidYearMonthDay(year, month, day)
		{
			return !(isNaN(year) || year < 0 || isNaN(month) || month < 0 || month > 11 || isNaN(day) || day < 1 || day > getMonthLength(year, month));
		}
	
		function trimString(str)
		{
			str = "" + str;
			return str.replace(/^\s+/,"").replace(/\s+$/,"");
		}
	
		// -- handle shorthand time notation i.e. 5p -> 5:00 pm, 18 -> 6:00 pm, 900 -> 9:00 am, 1433p -> 2:33 pm
		function hhmmToTimeString( hhmm )
		{
			//noinspection JSUnresolvedVariable
			var AM = FieldValidationHelper.datetime_am_string || "";
			//noinspection JSUnresolvedVariable
			var PM = FieldValidationHelper.datetime_pm_string || "";
			var fldvalue = hhmm;
			var hour, minute;
			if ( AM.charAt(0) === PM.charAt(0) )
				re = new RegExp("^[0-9]{1,4}("+AM+"|"+PM+")*$", "i");
			else
				re = new RegExp("^[0-9]{1,4}(["+AM.charAt(0)+"|"+PM.charAt(0)+"]?)$","i");
			if ( re.test(fldvalue) )
			{
				var aorp = '';
				if ( RegExp.$1 )
				{
					if ( AM.charAt(0) === PM.charAt(0) )
						aorp = RegExp.$1.toLowerCase() === PM ? PM : AM;
					else
						aorp = RegExp.$1.toLowerCase().charAt(0) === PM.charAt(0) ? PM : AM;
				}
				if ( fldvalue.length < 3 || ( fldvalue.length === 3 && RegExp.$1 ) )
				{
					var hh = RegExp.$1 ? fldvalue.substring(0,fldvalue.length-1) : fldvalue;
					hour = parseInt( hh, 10 ) == 0 ? 12 : ( parseInt( hh, 10 ) > 12 ? parseInt( hh, 10 ) % 12 : hh ) ;
					minute = 0;
					var ampm = RegExp.$1 ? aorp :
							   ( parseInt( fldvalue, 10 ) > 11 ? PM : AM );
				}
				else if (fldvalue.length === 3 || (fldvalue.length === 4 && RegExp.$1) )
				{
					var hh = fldvalue.substring(0,1) === "0" ? "12" : fldvalue.substring(0,1);
					hour = parseInt( hh, 10 );
					var mm = RegExp.$1 ? fldvalue.substring(1,3) : fldvalue.substring(1);
					minute = parseInt( mm, 10 );
					var ampm = RegExp.$1 ? aorp : AM;
				}
				else
				{
					var hh = fldvalue.substring(0,2);
					hour = parseInt( hh, 10 ) === 0 ? 12 : ( parseInt( hh, 10 ) > 12 ? parseInt( hh, 10 ) % 12 : hh );
					var mm = RegExp.$1 ? fldvalue.substring(2,4) : fldvalue.substring(2);
					minute = parseInt( mm, 10 );
					var ampm = parseInt( fldvalue.substring(0,2), 10 ) > 11 ? PM : AM;
					ampm = RegExp.$1 ? aorp : ampm;
				}
				if (ampm === AM && hour === 12)
					hour = 0;
				else if(ampm === PM && hour !== 12)
					hour = parseInt(hour) + 12;
				var time = new Date();
				time.setHours(hour,minute,0,0);
				fldvalue = getTimeString(time, AM, PM);
			}
			return fldvalue;
		}
	
		function regexStringToTime(date, time, includeSeconds, returnNullIfInvalid)
		{
			//noinspection JSUnresolvedVariable
			var timeformat = FieldValidationHelper.timeformat || "fmHH:fmMI am";
			//noinspection JSUnresolvedVariable
			var timeformatWithSeconds = FieldValidationHelper.timeformatwithseconds || "fmHH:fmMI:SS am";
			var flddate = date != null ? stringToDate(date, "", returnNullIfInvalid) : new Date();
            if (flddate == null)
                return null;
			if (time != null && String(time).length != 0 && String(time).search(/\S/) >= 0)
			{
				var hours = NaN;
				var minutes = NaN;
				var seconds = NaN;
	
				var delimitors;
				time = trimString(time);
	
				var TIME_FORMAT_MAP =
				{
					"HH:MI:SS am": { rcase: 0, hend: ':', mend: ':', send: ' '},
					"HH-MI-SS am": { rcase: 0, hend: '-', mend: '-', send: ' '},
					"HH24:MI:SS": { rcase: 0, hend: ':', mend: ':', send: null},
					"HH24-MI-SS": { rcase: 0, hend: '-', mend: '-', send: null},
					"amHHMISS": { rcase:1, hend:'', mend:'', send:''},
					"amHHMISS": { rcase:1, hend:'', mend:'', send:''},
					"amHHMISS": { rcase:1, hend:'', mend:'', send:''},
					"HH24MISS": { rcase:2, hend:'', mend:'', send:''},
					"HH24MISS": { rcase:2, hend:'', mend:'', send:''},
					"HH24MISS": { rcase:2, hend:'', mend:'', send:''},
					"HH:MI am": { rcase: 0, hend: ':', mend: ' ', send: null},
					"HH-MI am": { rcase: 0, hend: '-', mend: ' ', send: null},
					"HH24:MI": { rcase: 0, hend: ':', mend: null, send: null},
					"HH24-MI": { rcase: 0, hend: '-', mend: null, send: null},
					"amHHMI": { rcase:1, hend:'', mend:'', send:null},
					"amHHMI": { rcase:1, hend:'', mend:'', send:null},
					"amHHMI": { rcase:1, hend:'', mend:'', send:null},
					"HH24MI": { rcase:2, hend:'', mend:'', send:null},
					"HH24MI": { rcase:2, hend:'', mend:'', send:null},
					"HH24MI":{ rcase:2, hend:'', mend:'', send:null}
				};
	
				var format = includeSeconds ? timeformatWithSeconds.replace(/fm/g, "") : timeformat.replace(/fm/g, "");
				format = trimString(format);
				delimitors = TIME_FORMAT_MAP[format];
	
				var m;
				var ampm = null;
				var hend = null;
				var mend = null;
				var send = null;
				if (delimitors != null)
				{
					switch (delimitors.rcase)
					{
						case 0:
						{
							m = TIME_FORMAT_WITH_POSSIBLE_AMPM_SUFFIX.exec(time);
							if (m !== null)
							{
								hours = parseInt(m[1], 10);
								hend = m[2];
								minutes = parseInt(m[3], 10);
								mend = m[5];
								if (includeSeconds && m[4] != null)
									seconds = parseInt(m[6], 10);
								else
									seconds = 0;
								ampm = m[7];
							}
							break;
						}
						case 1:
						{
							var amtime=time.replace(/||/g,'am');
							amtime=amtime.replace(/||/g,'pm');
							m = TIME_FORMAT_WITH_POSSIBLE_AMPM_PREFIX.exec(amtime);
							if (m !== null)
							{
								hours = parseInt(m[2], 10);
								hend = m[3];
								minutes = parseInt(m[4], 10);
								mend = m[5];
								if (includeSeconds && m[6] != null)
								{
									seconds = parseInt(m[7], 10);
									send = m[8];
								}
								else
									seconds = 0;
								ampm = m[1];
							}
							break;
						}
						case 2:
						{
							m = TIME_FORMAT_WITH_ASIAN_FORMATTING.exec(time);
							if (m !== null)
							{
								hours = parseInt(m[1], 10);
								hend = m[2];
								minutes = parseInt(m[3], 10);
								mend = m[4];
								if (includeSeconds && m[5] != null)
								{
									seconds = parseInt(m[6], 10);
									send = m[7];
								}
								else
									seconds = 0;
							}
							break;
						}
					}
					if (isNaN(hours) || isNaN(minutes) || isNaN(seconds) || hours >= 24 || hours < 0 || minutes >= 60 || minutes < 0 || seconds >= 60 || seconds < 0)
						return NaN;
	
					if (hend != delimitors.hend || (includeSeconds && (mend != null && mend != delimitors.mend) || (send != null && send != delimitors.send)))
						return NaN;
	
					if (ampm != null)
					{
						//noinspection JSUnresolvedVariable
						hours = getHoursIn24HourFormat((ampm.toLowerCase() == FieldValidationHelper.datetime_pm_string), hours);
					}
					flddate.setHours(hours, minutes, seconds, 0);
				} else
					flddate = NaN;
			}
			return flddate;
		}
	
		// to replace parseMMYYDateString (if possible)
		function stringToMMYYDate(arg, dateformat, returnNullIfInvalid)
		{
			if(!dateformat)
			{
				if(typeof(window.dateformat) !== "undefined")
					dateformat = window.dateformat;
				else
					dateformat = "MM/DD/YYYY";
			}
			var returnValIfError = returnNullIfInvalid ? null : new Date();
	
			var parts, mm, yy;
			var yearCharIndex, monthCharIndex, dayCharIndex, era;
			var comps = arg.split(/[\.\/-]/);
	
			if(!/^[0-9\-\/\.]+$/.test(arg)) // contains other characters
			{
				if (comps.length !== 2)
					return returnValIfError;
				else
				{
					mm = getMonthIndex(comps[0]) - 1;
					yy = parseInt(comps[1], 10);
				}
			}
			else // only contains numbers and - / or .
			{
				if (comps.length === 1)
				{
					if ((arg.length === 4) || (arg.length === 6))
					{
						mm = parseInt(arg.slice(0, 2), 10) - 1;
						yy = parseInt(arg.slice(2), 10)
					}
				}
				else if (comps.length === 2)
				{
					mm = parseInt(comps[0], 10) - 1;
					yy = parseInt(comps[1], 10);
				}
			}
	
			if (yy < 50)
				yy += 2000;
			else if (yy < 100)
				yy += 1900;
	
			if (!isValidYearMonthDay(yy, mm, 1))
				return returnValIfError;
			else
				return new Date(yy, mm);
		}
	
		function splitDateAndTime(dateTime)
		{
			var spaceCount = 0;
			var dateformat = FieldValidationHelper.dateformat || "MM/DD/YYYY";
			dateTime = trimString(dateTime)
	
			switch (dateformat)
			{
				case "MM/DD/YYYY":
				case "DD/MM/YYYY":
				case "DD.MM.YYYY":
				case "DD-Mon-YYYY":
				case "DD-MONTH-YYYY":
				case "YYYY/MM/DD":
				case "YYYY-MM-DD":
				case "EEYYMMDD":
				case "YYYYMMDD":
				case "EYY.MM.DD":
					spaceCount = 0;
					break;
	
				case "DD. MON YYYY":
				case "YYYY MM DD":
				case "DD MONTH, YYYY":
				case "DD MONTH YYYY":
					spaceCount = 2;
					break;
	
				case "DD de MONTH de YYYY":
					spaceCount = 4;
					break;
	
				default:
					return {date: dateTime, time: null};
			}
	
			var myRegex = (spaceCount === 0) ? new RegExp("^(\\S+)\\s+(.*)$") : new RegExp("^(\\S+(\\s+\\S+){" + spaceCount + "})\\s+(.*)$");
			var matches = dateTime.match(myRegex);

			if (matches)
			{
				return {date: matches[1], time: (spaceCount === 0) ? matches[2] : matches[3]}
			}
			else // assume just date if not a match
			{
				return {date: dateTime, time: null};
			}
		}
	
		function stringToDate(d, dateformat, returnNullIfInvalid, formattype)
		{
			var comps;
			var month, day, year;
			var yearCharIndex, monthCharIndex, dayCharIndex, era;
			if(!dateformat)
			{
				//noinspection JSUnresolvedVariable
				dateformat = FieldValidationHelper.dateformat || "MM/DD/YYYY";
			}
			var dateStrLength = d.length;
			var endStr; //the end segment in date string (mainly used for date seg since year string's length is always 4)
			var yearLength = 4;
			var returnValIfError = returnNullIfInvalid ? null : new Date();
	
			if(d.length > 0)
			{
				switch(dateformat)
				{
					case "MM/DD/YYYY":
						comps = d.split("/");
						if(comps.length < 3)	   // the format can contains time hh:mm:ss or hh-mm-ss
							return returnValIfError;
						month = parseInt(comps[0], 10) - 1;
						day = parseInt(comps[1], 10);
						year = parseInt(comps[2].substring(0, yearLength), 10);
						dateStrLength = comps[0].length + comps[1].length + yearLength + 2;
						break;
					case "DD/MM/YYYY":
						comps = d.split("/");
						if(comps.length < 3)	 // the format can contains time hh:mm:ss or hh-mm-ss
							return returnValIfError;
						day = parseInt(comps[0], 10);
						month = parseInt(comps[1], 10) - 1;
						year = parseInt(comps[2].substring(0, yearLength), 10);
						dateStrLength = comps[0].length + comps[1].length + yearLength + 2;
						break;
					case "DD.MM.YYYY":
						comps = d.split(".");
						if(comps.length < 3)	 // the format can contains time hh:mm:ss or hh-mm-ss
							return returnValIfError;
						day = parseInt(comps[0], 10);
						month = parseInt(comps[1], 10) - 1;
						year = parseInt(comps[2].substring(0, yearLength), 10);
						dateStrLength = comps[0].length + comps[1].length + yearLength + 2;
						break;
					case "DD-Mon-YYYY":
						comps = d.split("-");
						if(comps.length < 3)	 // the format can contains time hh:mm:ss or hh-mm-ss
							return returnValIfError;
						day = parseInt(comps[0], 10);
						month = getMonthIndex(comps[1]) - 1;
						year = parseInt(comps[2].substring(0, yearLength), 10);
						dateStrLength = comps[0].length + comps[1].length + yearLength + 2;
						break;
					case "DD-MONTH-YYYY":
						comps = d.split("-");
						if(comps.length < 3)	 // the format can contains time hh:mm:ss or hh-mm-ss
							return returnValIfError;
						day = parseInt(comps[0], 10);
						//noinspection JSUnresolvedVariable
						month = getMonthIndexFromArray(FieldValidationHelper.datetime_months, comps[1], true);
						year = parseInt(comps[2].substring(0, yearLength), 10);
						dateStrLength = comps[0].length + comps[1].length + yearLength + 2;
						break;
					case "YYYY/MM/DD":
						comps = d.split("/");
						if(comps.length < 3)	 // the format can contains time hh:mm:ss or hh-mm-ss
							return returnValIfError;
						endStr = comps[2].split(" ")[0];
						day = parseInt(endStr, 10);
						month = parseInt(comps[1], 10) - 1;
						year = parseInt(comps[0], 10);
						dateStrLength = comps[1].length + endStr.length + yearLength + 2;
						break;
					case "YYYY-MM-DD":
						comps = d.split("-");
						if(comps.length < 3)	 // the format can contains time hh:mm:ss or hh-mm-ss
							return returnValIfError;
						endStr = comps[2].split(" ")[0];
						day = parseInt(endStr, 10);
						month = parseInt(comps[1], 10) - 1;
						year = parseInt(comps[0], 10);
						dateStrLength = comps[1].length + endStr.length + yearLength + 2;
						break;
					case "EEYYMMDD":
						yearCharIndex = d.indexOf(yearCharCN);
						monthCharIndex = d.indexOf(monthCharCN);
						dayCharIndex = d.indexOf(dayCharCN);
						if(yearCharIndex < 0 || monthCharIndex < 0 || dayCharIndex < 0)
							return returnValIfError;
						day = parseInt(d.substring(monthCharIndex+1,dayCharIndex), 10);
						month = parseInt(d.substring(yearCharIndex+1,monthCharIndex), 10) - 1;
						era = d.substring(0, 2);
						year = getGregorianYear(parseInt(d.substring(2,yearCharIndex), 10), era);
						dateStrLength = dayCharIndex + 1;
						break;
					case "YYYYMMDD":
						yearCharIndex = d.indexOf(yearCharCN);
						monthCharIndex = d.indexOf(monthCharCN);
						dayCharIndex = d.indexOf(dayCharCN);
						if(yearCharIndex < 0 || monthCharIndex < 0 || dayCharIndex < 0)
							return returnValIfError;
						day = parseInt(d.substring(monthCharIndex+1,dayCharIndex), 10);
						month = parseInt(d.substring(yearCharIndex+1,monthCharIndex), 10) - 1;
						year = parseInt(d.substring(0,yearCharIndex), 10);
						dateStrLength = dayCharIndex + 1;
						break;
					case "EYY.MM.DD":
						comps = d.split(".");
						if(comps.length < 3)	 // the format can contains time hh:mm:ss or hh-mm-ss
							return returnValIfError;
						endStr = comps[2].split(" ")[0];
						day = parseInt(endStr, 10);
						month = parseInt(comps[1], 10) - 1;
						era = comps[0].substring(0, 1);
						year = getGregorianYear(parseInt(comps[0].substring(1,comps[0].length), 10), era);
						dateStrLength = comps[0].length + comps[1].length + endStr.length + 2;
						break;
					case "DD. MON YYYY":
						comps = d.split(" ");
						if(comps.length < 3)	 // the format can contains time hh:mm:ss or hh-mm-ss
							return returnValIfError;
						day = parseInt(comps[0].substring(0, comps[0].length - 1), 10);
						//noinspection JSUnresolvedVariable
						month = getMonthIndexFromArray(FieldValidationHelper.datetime_short_months, comps[1]);
						year = parseInt(comps[2].substring(0, yearLength), 10);
						dateStrLength = comps[0].length + comps[1].length + yearLength + 2;
						break;
					case "DD de MONTH de YYYY":
						comps = d.split(" de ");
						if(comps.length < 3)	 // the format can contains time hh:mm:ss or hh-mm-ss
							return returnValIfError;
						day = parseInt(comps[0], 10);
						month = getMonthIndex(comps[1]) - 1;
						year = parseInt(comps[2].substring(0, yearLength), 10);
						dateStrLength = comps[0].length + comps[1].length + yearLength + 8;
						break;
					case "YYYY MM DD":
						comps = d.split(" ");
						if(comps.length < 3)	 // the format can contains time hh:mm:ss or hh-mm-ss
							return returnValIfError;
						day = parseInt(comps[2].substring(0, comps[2].length-1), 10);
						month = parseInt(comps[1].substring(0, comps[1].length-1), 10) - 1;
						year = parseInt(comps[0].substring(0, comps[0].length-1), 10);
						dateStrLength = yearLength + comps[1].length + comps[2].length + 5;
						break;
					case "DD MONTH YYYY":
						comps = d.split(" ");
						if(comps.length < 3) //the format could be "DD MONTH YYYY HH:MI:SS AM" . length =4
							return returnValIfError;
						day = parseInt(comps[0], 10);
						//noinspection JSUnresolvedVariable
						month = getMonthIndexFromArray(FieldValidationHelper.datetime_months, comps[1], true);
						year = parseInt(comps[2].substring(0, yearLength), 10);
						dateStrLength = comps[0].length + comps[1].length + yearLength + 2;
						break;
					case "DD MONTH, YYYY":
						comps = d.split(" ");
						if(comps.length < 3) //the format could be "DD MONTH YYYY HH:MI:SS PM" . length = 4
							return returnValIfError;
						day = parseInt(comps[0], 10);
						//noinspection JSUnresolvedVariable
						month = getMonthIndexFromArray(FieldValidationHelper.datetime_months, comps[1].substring(0, comps[1].length-1), true);
						year = parseInt(comps[2].substring(0, yearLength), 10);
						dateStrLength = comps[0].length + comps[1].length + yearLength + 2;
						break;
				}
			}
	
			if (!isValidYearMonthDay(year, month, day))
				return returnValIfError;
	
			// now handle the time segment
			var result;
			var t = d.substring(dateStrLength);
			if (t != null && t.length > 0)
			{
				if (formattype == 'datetimetz')
					result = regexStringToTime(d.substring(0,dateStrLength),t, true, returnNullIfInvalid);
				else if (formattype == 'datetime' || formattype == 'timeofday')
					result = regexStringToTime(d.substring(0,dateStrLength),t, false, returnNullIfInvalid);
				else
					result = stringToTime(d.substring(0,dateStrLength),t);
			}
			else
				result = new Date(year,month,day);
			if (year < 50)
				setFullYear(result, year + 2000);
			else if (year < 100)
				setFullYear(result, year + 1900);
			return result;
		}
	
		function getHoursIn24HourFormat(isPM, hours)
		{
			if (!isPM && hours == 12)
				return 0;
			else if (isPM && hours < 12)
				return hours + 12;
			else
				return hours;
		}
	
		function stringToTime(date, time)
		{
			//noinspection JSUnresolvedVariable
			var timeformat = FieldValidationHelper.timeformat || "fmHH:fmMI am";
			//noinspection JSUnresolvedVariable
			var AM = FieldValidationHelper.datetime_am_string || "";
			//noinspection JSUnresolvedVariable
			var PM = FieldValidationHelper.datetime_pm_string || "";
			var flddate = date !== null ? stringToDate(date) : new Date();
			if (time !== null && String(time).length != 0 && String(time).search(/\S/) >= 0)
			{
				var hours;
				var minutes;
				var isPM;
				var hourCharIndex;
	
				var format = timeformat.replace(/fm/g, "");
				if (format === "HH:MI am" || format === "HH-MI am" || format === "HH24:MI" || format === "HH24-MI")
				{
					var m = /^\s*(\d+)[-:](\d+)\s*(.*)/.exec(time);
					if (!m) return NaN;
					hours = parseInt(m[1], 10);
					minutes = parseInt(m[2], 10);
					if (format.substring(6) === "am")
					{
						isPM = (m[3].toLowerCase() === PM);
						hours = getHoursIn24HourFormat(isPM, hours);
					}
				}
				else if(format === "amHHMI" || format === "amHHMI" || format === "amHHMI")
				{
					hourCharIndex = time.indexOf("");
					if(hourCharIndex < 0)
						hourCharIndex = time.indexOf("");
					if(hourCharIndex < 0)
						hourCharIndex = time.indexOf("");
					var hour_start_index = 0;
					isPM = false;
	
					if(time.indexOf(AM) == 0)
						hour_start_index = AM.length;
					else if(time.indexOf(AM) == 0)
					{
						hour_start_index = AM.length;
						isPM = true;
					}
					hours = parseInt(time.substring(hour_start_index, hourCharIndex), 10);
					hours = getHoursIn24HourFormat(isPM, hours);
					minutes = parseInt(time.substring(hourCharIndex + 1, time.length - 1), 10);
				}
				else if(format === "HH24MI" || format === "HH24MI" || format === "HH24MI")
				{
					hourCharIndex = time.indexOf("");
					if(hourCharIndex < 0)
						hourCharIndex = time.indexOf("");
					if(hourCharIndex < 0)
						hourCharIndex = time.indexOf("");
					hours = parseInt(time.substring(0, hourCharIndex), 10);
					minutes = parseInt(time.substring(hourCharIndex + 1, time.length - 1), 10);
				}
				if(isNaN(hours) || isNaN(minutes) || hours >= 24 || hours < 0 || minutes >= 60 || minutes < 0)
					return NaN;
				flddate.setHours(hours, minutes, 0, 0);
			}
			return flddate;
		}
	
	
		function getTimeString(time, amvar, pmvar)
		{
			if (!(time instanceof Date || Object.prototype.toString.call(time) === '[object Date]'))
				return time;
			//noinspection JSUnresolvedVariable
			var timeformat = FieldValidationHelper.timeformat || "fmHH:fmMI am";
			var hours = time.getHours();
			if(!amvar || !pmvar)
			{
				//noinspection JSUnresolvedVariable
				amvar = FieldValidationHelper.datetime_am_string || '';
				//noinspection JSUnresolvedVariable
				pmvar = FieldValidationHelper.datetime_pm_string || '';
			}
			var ampm = hours < 12 ? amvar : pmvar;
			if(timeformat.indexOf("HH24") < 0)
			{
				hours = hours % 12;
				if(hours == 0)
					hours = 12;
			}
			var minutes = time.getMinutes() < 10 ? '0' + time.getMinutes() : time.getMinutes();
			//noinspection JSUnresolvedVariable
			var timeStr = FieldValidationHelper.timeformat || "fmHH:fmMI am";
			timeStr = timeStr.replace("24", "");
			timeStr = timeStr.replace("fmHH", hours);
			timeStr = timeStr.replace("fmMI", minutes);
			if(timeformat.indexOf("HH24") < 0)
				timeStr = timeStr.replace("am", ampm);
			return timeStr;
		}
	
		function getDateString(d, format)
		{
			// if dateformat is specified, use it from the format parameter
			// else use the window property (set from user preference)
			var dateformat;
			if (format)
				dateformat = format;
			else
			{
				//noinspection JSUnresolvedVariable
				dateformat = FieldValidationHelper.dateformat || "MM/DD/YYYY";
			}

			// replace format literals with date field values
			dateformat = dateformat.replace("YYYY", getFullYear(d));
			dateformat = dateformat.replace("MM", (d.getMonth() + 1));
			dateformat = dateformat.replace("DD", d.getDate());
			//noinspection JSUnresolvedVariable
			dateformat = dateformat.replace(/month/i, FieldValidationHelper.datetime_months[d.getMonth()]);
			//noinspection JSUnresolvedVariable
			dateformat = dateformat.replace(/mon/i, FieldValidationHelper.datetime_short_months[d.getMonth()]);
	
			// japan specific
			if (dateformat.indexOf("EEYY") == 0)
				dateformat = dateformat.replace("EEYY", getJapaneseImperialEra(d) + getJapaneseImperialYear(d));
			else if (dateformat.indexOf("EYY") == 0)
				dateformat = dateformat.replace("EYY", getShortJapaneseImperialEra(d) + getJapaneseImperialYear(d));

			return dateformat;
		}
	
		function getTimeWithSecondsString(time,amvar,pmvar)
		{
			if (!(time instanceof Date || Object.prototype.toString.call(time) === '[object Date]'))
				return time;
			//noinspection JSUnresolvedVariable
			var timeformatWithSeconds = FieldValidationHelper.timeformatwithseconds || "fmHH:fmMI:SS am";
			var hours = time.getHours();
			if(!amvar || !pmvar)
			{
				//noinspection JSUnresolvedVariable
				amvar = FieldValidationHelper.datetime_am_string || '';
				//noinspection JSUnresolvedVariable
				pmvar = FieldValidationHelper.datetime_pm_string || '';
			}
			var ampm = hours < 12 ? amvar : pmvar;
			if(timeformatWithSeconds.indexOf("HH24") < 0)
			{
				hours = hours % 12;
				if(hours == 0)
					hours = 12;
			}
			var minutes = time.getMinutes() < 10 ? '0' + time.getMinutes() : time.getMinutes();
			var seconds = time.getSeconds() < 10 ? '0' + time.getSeconds() : time.getSeconds();
			var timeStr = timeformatWithSeconds.replace(/fm/g, "");

			timeStr = timeStr.replace("24", "");
			timeStr = timeStr.replace("HH", hours);
			timeStr = timeStr.replace("MI", minutes);
			timeStr = timeStr.replace("SS", seconds);
			if(timeformatWithSeconds.indexOf("HH24") < 0)
				timeStr = timeStr.replace("am", ampm);

			return timeStr;
		}
	
		function getMMYYString(date)
		{
			var dateformat = FieldValidationHelper.dateformat || "MM/DD/YYYY";
	
			switch(dateformat)
			{
				case "DD-Mon-YYYY":
				case "DD-MONTH-YYYY":
					return FieldValidationHelper.datetime_short_months[date.getMonth()] + "-" + date.getFullYear();
	
				case "DD. MON YYYY":
				case "DD MONTH YYYY":
				case "DD de MONTH de YYYY":
				case "DD MONTH, YYYY":
					return FieldValidationHelper.datetime_short_months[date.getMonth()] + "/" + date.getFullYear();
	
				case "YYYY-MM-DD":
					return (date.getMonth() + 1) + "-" + date.getFullYear();
	
				case "DD.MM.YYYY":
				case "EYY.MM.DD":
					return (date.getMonth() + 1) + "." + date.getFullYear();
	
				case "YYYYMMDD":
				case "EEYYMMDD":
				case "YYYY MM DD":
				case "YYYY/MM/DD":
				case "MM/DD/YYYY":
				case "DD/MM/YYYY":
				default:
					return (date.getMonth() + 1) + "/" + date.getFullYear();
			}
		}
	
	
		function getDatetimeString(date)
		{
			return getDateString(date) + " " + getTimeString(date);
		}
	
		function getDatetimetzString(date)
		{
			return getDateString(date) + " " + getTimeWithSecondsString(date);
		}
	
		var m_j_d = [[0,31,59,90,120,151,181,212,243,273,304,334],[0,31,60,91,121,152,182,213,244,274,305,335]];
	
		var j_d = [];
		j_d[1970]=0;
		j_d[1971]=365;
		j_d[1972]=730;
		j_d[1973]=1096;
		j_d[1974]=1461;
		j_d[1975]=1826;
		j_d[1976]=2191;
		j_d[1977]=2557;
		j_d[1978]=2922;
		j_d[1979]=3287;
		j_d[1980]=3652;
		j_d[1981]=4018;
		j_d[1982]=4383;
		j_d[1983]=4748;
		j_d[1984]=5113;
		j_d[1985]=5479;
		j_d[1986]=5844;
		j_d[1987]=6209;
		j_d[1988]=6574;
		j_d[1989]=6940;
		j_d[1990]=7305;
		j_d[1991]=7670;
		j_d[1992]=8035;
		j_d[1993]=8401;
		j_d[1994]=8766;
		j_d[1995]=9131;
		j_d[1996]=9496;
		j_d[1997]=9862;
		j_d[1998]=10227;
		j_d[1999]=10592;
		j_d[2000]=10957;
		j_d[2001]=11323;
		j_d[2002]=11688;
		j_d[2003]=12053;
		j_d[2004]=12418;
		j_d[2005]=12784;
		j_d[2006]=13149;
		j_d[2007]=13514;
		j_d[2008]=13879;
		j_d[2009]=14245;
		j_d[2010]=14610;
		j_d[2011]=14975;
		j_d[2012]=15340;
		j_d[2013]=15706;
		j_d[2014]=16071;
		j_d[2015]=16436;
		j_d[2016]=16801;
		j_d[2017]=17167;
		j_d[2018]=17532;
		j_d[2019]=17897;
		j_d[2020]=18262;
		j_d[2021]=18628;
		j_d[2022]=18993;
		j_d[2023]=19358;
		j_d[2024]=19723;
		j_d[2025]=20089;
		j_d[2026]=20454;
		j_d[2027]=20819;
		j_d[2028]=21184;
		j_d[2029]=21550;
		j_d[2030]=21915;
	
		function getMonthJulian(year, month)
		{
			return m_j_d[isLeapYear(year)?1:0][month];
		}
	
	
		function get_julian_date(d)
		{
			return j_d[d.getFullYear()]+getMonthJulian(d.getFullYear(),d.getMonth())+d.getDate()-1;
		}
	
		function isDateTooOld(timeString)
		{
			return timeString < OLDEST_VALID_DATE;
		}
	
		function getOldestDateString()
		{
			return getDateString(OLDEST_VALID_DATE);
		}
	
		function _hhmm_to_mins(time) {
			return time.hrs * 60 + time.mins;
		}

		function round_hhmm_nearest(hrs, mins, round_by) {
			var up_time = round_hhmm_up(hrs, mins, round_by);
			var down_time = round_hhmm_down(hrs, mins, round_by);

			orig_mins = _hhmm_to_mins({
				hrs: hrs,
				mins: mins
			});
			up_mins = _hhmm_to_mins(up_time);
			down_mins = _hhmm_to_mins(down_time);

			if (up_mins - orig_mins > orig_mins - down_mins) {
				return down_time;
			} else {
				return up_time;
			}
		}

		function round_hhmm_up(hrs, mins, round_by) {
			mins += (mins % round_by > 0 ? (round_by - (mins % round_by)) : 0);
			if (mins >= 60) {
				var _hhmm_delta = Math.floor(mins / 60);
				mins -= (_hhmm_delta * 60);
				hrs += _hhmm_delta;
			}
			return {
				hrs: hrs,
				mins: mins
			};
		}

		function round_hhmm_down(hrs, mins, round_by) {
			mins -= (mins > 0 ? (mins % round_by) : 0);
			return {
				hrs: hrs,
				mins: mins
			};
		}

		function round_hhmm(val, round_by, direction) {
			if (val == "") return val;
			var re = /^([0-9]+?):([0-9]+)$/;
			var result = re.exec(val);
			if (result == null) {
				result = format_hhmm(val);
				if (result == null) return val;
			}
			var hrs = parseFloat(result[1]);
			var mins = parseFloat(result[2]);
			var time;
			if (direction == 'UP') {
				time = round_hhmm_up(hrs, mins, round_by);
			} else if (direction == 'DOWN') {
				time = round_hhmm_down(hrs, mins, round_by);
			} else if (direction == 'NEAR') {
				time = round_hhmm_nearest(hrs, mins, round_by);
			} else {
				throw direction + ' is not vald direction: [UP,DOWN,NEAREST]';
			}
			if (time.mins < 10) time.mins = '0' + time.mins;
			return time.hrs + ':' + time.mins;
		}

		function format_hhmm(val) {
			var hours;
			var minutes;

			var re = /([0-9][0-9]?)?(:[0-9][0-9]+)?/
			var result = re.exec(val)
			if (result == null || result.index > 0 || result[0].length != val.length) {
				timeval = parseFloat(val);
				if (isNaN(timeval)) hours = -1;
				else {
					hours = Math.floor(timeval);
					minutes = Math.floor((timeval - hours) * 60 + 0.5);
				}
			} else {
				if (RegExp.$1.length > 0) hours = parseInt(RegExp.$1, 10);
				else hours = 0;
				if (typeof (RegExp.$2) != "undefined" && RegExp.$2.length > 0) {
					minutes = parseInt(RegExp.$2.substr(1), 10);
					// if the user entered a value >= 60 for minutes, add the extra hours to the hours var and reduce
					// minutes to be less than 60
					if (minutes >= 60) {
						var hours_delta = Math.floor(minutes / 60);
						minutes -= (hours_delta * 60);
						hours += hours_delta;
					}
				} else minutes = 0;
			}
			if (hours >= 0 && minutes >= 0 && minutes < 60) {
				return [val, hours, minutes];
			}
		}

		function parse_time(val) {

			if (val == null || val.trim().length == 0)
				return null;

			var time = {hours: 0, minutes: 0, negative: false};

			var rexp = /^(\-?)(\d*)(:(\d+))?$/;
			var rexpRes = rexp.exec(val);

			if (rexpRes == null) {
				var timeval = parseFloat(val);
				if (isNaN(timeval)) {
					return null;
				} else {
					if (timeval < 0) {
						timeval = Math.abs(timeval);
						time.negative = true;
					}
					time.hours = Math.floor(timeval);
					time.minutes = Math.round((timeval - time.hours) * 60);
				}
			} else {

				if (typeof rexpRes[2] != "undefined" && rexpRes[2].trim().length > 0) {
					time.hours = parseInt(rexpRes[2], 10);
				}

				if (typeof rexpRes[4] != "undefined" && rexpRes[4].trim().length > 0) {
					time.minutes = parseInt(rexpRes[4], 10);
					// if the user entered a value >= 60 for minutes, add the extra hours to the hours var and reduce minutes to be less than 60
					if (time.minutes >= 60) {
						var delta = Math.floor(time.minutes / 60);
						time.hours += delta;
						time.minutes -= delta * 60;
					}
				}
				if (rexpRes[1] == '-' && (time.hours > 0 || time.minutes > 0))
					time.negative = true;
			}
			return time;
		}

		function round_hhmm2(val, round_by, direction) {

			var result = parse_time(val);
			if (result == null) {
				return val;
			}
			var hrs = result.hours;
			var mins = result.minutes;
			var time;
			if (direction == 'UP') {
				time = round_hhmm_up(hrs, mins, round_by);
			} else if (direction == 'DOWN') {
				time = round_hhmm_down(hrs, mins, round_by);
			} else if (direction == 'NEAR') {
				time = round_hhmm_nearest(hrs, mins, round_by);
			} else {
				throw direction + ' is not vald direction: [UP,DOWN,NEAREST]';
			}
			if (time.mins < 10) time.mins = '0' + time.mins;
			return (result.negative ? '-' : '') + time.hrs + ':' + time.mins;
		}

		/* assign dateutil package */
		return Object.freeze({
			addMonths: addMonths,
			addDays: addDays,
			hhmmToTimeString: hhmmToTimeString,
			regexStringToTime: regexStringToTime,
			stringToTime: stringToTime,
			splitDateAndTime: splitDateAndTime,
			stringToDate: stringToDate,
			stringToMMYYDate: stringToMMYYDate,
			getTimeWithSecondsString: getTimeWithSecondsString,
			getTimeString: getTimeString,
			getDateString: getDateString,
			getMMYYString: getMMYYString,
			getDatetimeString: getDatetimeString,
			getDatetimetzString: getDatetimetzString,
			get_julian_date: get_julian_date,
			isDateTooOld: isDateTooOld,
			getOldestDateString: getOldestDateString,
			round_hhmm: round_hhmm,
			round_hhmm2: round_hhmm2
		});
	}
);

/**
 * SuiteScript module
 *
 * @private
 * @module N/dateTimeZone
 * @NApiVersion 2.x
 *
 */
define('N/dateTimeZone',['N/restricted/bridge', 'N/restricted/invoker' ],
   function(apiBridge, invoker)
   {
        var TIME_ZONES = Object.freeze({
                                           ETC_GMT_PLUS_12: 'Etc/GMT+12',
                                           PACIFIC_SAMOA: 'Pacific/Samoa',
                                           PACIFIC_HONOLULU: 'Pacific/Honolulu',
                                           AMERICA_ANCHORAGE: 'America/Anchorage',
                                           AMERICA_LOS_ANGELES: 'America/Los_Angeles',
                                           AMERICA_TIJUANA: 'America/Tijuana',
                                           AMERICA_DENVER: 'America/Denver',
                                           AMERICA_PHOENIX: 'America/Phoenix',
                                           AMERICA_CHIHUAHUA: 'America/Chihuahua',
                                           AMERICA_CHICAGO: 'America/Chicago',
                                           AMERICA_REGINA: 'America/Regina',
                                           AMERICA_GUATEMALA: 'America/Guatemala',
                                           AMERICA_MEXICO_CITY: 'America/Mexico_City',
                                           AMERICA_NEW_YORK: 'America/New_York',
                                           US_EAST_INDIANA: 'US/East-Indiana',
                                           AMERICA_BOGOTA: 'America/Bogota',
                                           AMERICA_CARACAS: 'America/Caracas',
                                           AMERICA_HALIFAX: 'America/Halifax',
                                           AMERICA_LA_PAZ: 'America/La_Paz',
                                           AMERICA_MANAUS: 'America/Manaus',
                                           AMERICA_SANTIAGO: 'America/Santiago',
                                           AMERICA_ST_JOHNS: 'America/St_Johns',
                                           AMERICA_SAO_PAULO: 'America/Sao_Paulo',
                                           AMERICA_BUENOS_AIRES: 'America/Buenos_Aires',
                                           ETC_GMT_PLUS_3: 'Etc/GMT+3',
                                           AMERICA_GODTHAB: 'America/Godthab',
                                           AMERICA_MONTEVIDEO: 'America/Montevideo',
                                           AMERICA_NORONHA: 'America/Noronha',
                                           ETC_GMT_PLUS_1: 'Etc/GMT+1',
                                           ATLANTIC_AZORES: 'Atlantic/Azores',
                                           EUROPE_LONDON: 'Europe/London',
                                           GMT: 'GMT',
                                           ATLANTIC_REYKJAVIK: 'Atlantic/Reykjavik',
                                           EUROPE_WARSAW: 'Europe/Warsaw',
                                           EUROPE_PARIS: 'Europe/Paris',
                                           ETC_GMT_MINUS_1: 'Etc/GMT-1',
                                           EUROPE_AMSTERDAM: 'Europe/Amsterdam',
                                           EUROPE_BUDAPEST: 'Europe/Budapest',
                                           AFRICA_CAIRO: 'Africa/Cairo',
                                           EUROPE_ISTANBUL: 'Europe/Istanbul',
                                           ASIA_JERUSALEM: 'Asia/Jerusalem',
                                           ASIA_AMMAN: 'Asia/Amman',
                                           ASIA_BEIRUT: 'Asia/Beirut',
                                           AFRICA_JOHANNESBURG: 'Africa/Johannesburg',
                                           EUROPE_KIEV: 'Europe/Kiev',
                                           EUROPE_MINSK: 'Europe/Minsk',
                                           AFRICA_WINDHOEK: 'Africa/Windhoek',
                                           ASIA_RIYADH: 'Asia/Riyadh',
                                           EUROPE_MOSCOW: 'Europe/Moscow',
                                           ASIA_BAGHDAD: 'Asia/Baghdad',
                                           AFRICA_NAIROBI: 'Africa/Nairobi',
                                           ASIA_TEHRAN: 'Asia/Tehran',
                                           ASIA_MUSCAT: 'Asia/Muscat',
                                           ASIA_BAKU: 'Asia/Baku',
                                           ASIA_YEREVAN: 'Asia/Yerevan',
                                           ETC_GMT_MINUS_3: 'Etc/GMT-3',
                                           ASIA_KABUL: 'Asia/Kabul',
                                           ASIA_KARACHI: 'Asia/Karachi',
                                           ASIA_YEKATERINBURG: 'Asia/Yekaterinburg',
                                           ASIA_TASHKENT: 'Asia/Tashkent',
                                           ASIA_CALCUTTA: 'Asia/Calcutta',
                                           ASIA_KATMANDU: 'Asia/Katmandu',
                                           ASIA_ALMATY: 'Asia/Almaty',
                                           ASIA_DHAKA: 'Asia/Dhaka',
                                           ASIA_RANGOON: 'Asia/Rangoon',
                                           ASIA_BANGKOK: 'Asia/Bangkok',
                                           ASIA_KRASNOYARSK: 'Asia/Krasnoyarsk',
                                           ASIA_HONG_KONG: 'Asia/Hong_Kong',
                                           ASIA_KUALA_LUMPUR: 'Asia/Kuala_Lumpur',
                                           ASIA_TAIPEI: 'Asia/Taipei',
                                           AUSTRALIA_PERTH: 'Australia/Perth',
                                           ASIA_IRKUTSK: 'Asia/Irkutsk',
                                           ASIA_MANILA: 'Asia/Manila',
                                           ASIA_SEOUL: 'Asia/Seoul',
                                           ASIA_TOKYO: 'Asia/Tokyo',
                                           ASIA_YAKUTSK: 'Asia/Yakutsk',
                                           AUSTRALIA_DARWIN: 'Australia/Darwin',
                                           AUSTRALIA_ADELAIDE: 'Australia/Adelaide',
                                           AUSTRALIA_SYDNEY: 'Australia/Sydney',
                                           AUSTRALIA_BRISBANE: 'Australia/Brisbane',
                                           AUSTRALIA_HOBART: 'Australia/Hobart',
                                           PACIFIC_GUAM: 'Pacific/Guam',
                                           ASIA_VLADIVOSTOK: 'Asia/Vladivostok',
                                           ASIA_MAGADAN: 'Asia/Magadan',
                                           PACIFIC_KWAJALEIN: 'Pacific/Kwajalein',
                                           PACIFIC_AUCKLAND: 'Pacific/Auckland',
                                           PACIFIC_TONGATAPU: 'Pacific/Tongatapu'
                                       });

        function getTimeZone(timezone)
        {
            if (timezone === null || timezone === undefined)
            {
                return null;
            }

            return isNaN(timezone) ? timezone : parseInt(timezone, 10);
        }

        function parse(value, timezone)
        {
            timezone = getTimeZone(timezone);
            try
            {
                var timeSinceEpochInMS = invoker(apiBridge, 'parseWithTimeZone', [value, timezone]);
                return new Date(timeSinceEpochInMS);
            }
            catch (e)
            {
                return value;
            }
        }

        function format(value, timezone)
        {
            if (!util.isDate(value))
                return value;

            timezone = getTimeZone(timezone);
            try
            {
                return invoker(apiBridge, 'formatWithTimeZone', [value.getTime(), timezone]);
            }
            catch (e)
            {
                return value;
            }
        }

        return Object.freeze({
	        parse: parse,
            format: format,
            
            /**
             * @enum
             */
            Timezone: TIME_ZONES
        });
    });

/**
 * SuiteScript module
 *
 * @private
 * @module N/fieldTypeConstants
 * @NApiVersion 2.x
 */
define('N/fieldTypeConstants',[],
       function ()
       {
           var FIELD_TYPES = Object.freeze({
                                               DATE: "date",
                                               TIME: "time",
                                               TIMETRACK: "timetrack",
                                               TIMEOFDAY: "timeofday",
                                               DATETIME: "datetime",
                                               DATETIMETZ: "datetimetz",
                                               INTEGER: "integer",
                                               POSINTEGER: "posinteger",
                                               PERCENT: "percent",
                                               RATE: "rate",
                                               RATEHIGHPRECISION: "ratehighprecision",
                                               FLOAT: "float",
                                               POSFLOAT: "posfloat",
                                               NONNEGFLOAT: "nonnegfloat",
                                               POSCURRENCY: "poscurrency",
                                               NONNEGCURRENCY: "nonnegcurrency",
                                               CURRENCY: "currency",
                                               CURRENCY2: "currency2",
                                               EMAIL: "email",
                                               EMAILS: "emails",
                                               URL: "url",
                                               CHECKBOX: "checkbox",
                                               CCNUMBER: "ccnumber",
                                               RADIO: "radio",
                                               PHONE: "phone",
                                               FULLPHONE: "fullphone",
                                               IDENTIFIER: "identifier",
                                               IDENTIFIERANYCASE: "identifieranycase",
                                               FUNCTION: "function",
                                               QUOTEDFUNCTION: "'function'",
                                               MMYYDATE: "mmyydate",
                                               CCEXPDATE: "ccexpdate",
                                               CCVALIDFROM: "ccvalidfrom",
                                               COLOR: "color",
                                               PACKAGE: "package",
                                               FURIGANA: "furigana",
                                               ADDRESS: "address",
                                               TEXT: "text"
                                           });

           return Object.freeze({
                                    /**
                                     * @enum
                                     */
                                    Type: FIELD_TYPES
                                });
    }
);

/**
 * SuiteScript module
 *
 * @private
 * @module N/util/formatter
 * @suiteScriptVersion 2.x
 */
define(
	'N/util/formatter',['N/util/currencyUtility', 'N/util/date','N/FieldValidationHelper', 'N/dateTimeZone','N/error', 'N/utilityFunctions', 'N/fieldTypeConstants'],
	function (CurrencyUtil, DateUtil, FieldValidationHelper, dateTimeZone, error, utilityFunctions, fieldTypeConstants){
		/** FORMATTING FUNCTIONS - Used to convert INTO a user's preference format **/

		/**
		 * Takes in a numerical value and returns a string reformatted to match the user's format preference.
		 * (Negative representation, number groupings, decimal representation)
		 *
		 * Adapted/Improved from NLUtil.jsp's NLNumberToString
		 * @param num - a javascript friendly numerical value. Ex: -23456.93
		 * @param addPercentSign - adds a percent sign at the end of the string (or before the negative suffix)
		 * @returns a String version of the numerical value meeting the user's format preference. Ex: (23.456,93)
		 */
		function formatNumber(num, addPercentSign)
		{
			if (isNaN(num) || utilityFunctions.isValEmpty(num))
				return num;
	
			var str = '' + num;
			var parts = str.split(".");
			var integerPart = parts[0];
			var decimalPart = parts.length > 1 ? FieldValidationHelper.decimalseparator + parts[1] : '';
	
			if (FieldValidationHelper.groupseparator !== '')
			{
				var regex = /(\d+)(\d{3})/;
				while (regex.test(integerPart))
				{
					integerPart = integerPart.replace(regex, '$1' + FieldValidationHelper.groupseparator + '$2');
				}
			}
	
			if (num < 0 && FieldValidationHelper.negativeprefix !== '-')
			{
				return FieldValidationHelper.negativeprefix + integerPart.replace('-', '') + decimalPart
							   + (!!addPercentSign ? "%" : "") + FieldValidationHelper.negativesuffix;
			}
			else
			{
				return integerPart + decimalPart + (!!addPercentSign ? "%" : "");
			}
	
		}
	
		/**
		 * Takes in a string representing a phone number and attempts to format it in the set user preference
		 *
		 * Will only perform reformatting if ALL of the following are true:
		 *  - A user preference is set
		 *  - phoneStr consists of only digits, spaces, periods, dashes, and parentheses
		 *  - There are exactly 7 or 10 digits, or 11 digits and phoneStr begins with a 1
		 *  Otherwise it will return back the string, unmodified
		 *
		 * @param phoneStr - a string that contains a phone number
		 * @returns a string reformatted in the user's preference (if possible)
		 */
		function formatPhoneNumber(phoneStr)
		{
			if (utilityFunctions.isValEmpty(phoneStr))
				return phoneStr;
	
			var phoneFormatPref = FieldValidationHelper.phoneformat;
			var returnMe = "" + phoneStr;
			if (phoneFormatPref === null || typeof phoneFormatPref === "undefined" || /[A-Za-z]/.test(returnMe))
				return returnMe;
	
			var valueStripped = phoneStr.replace(/[\s\.\-\(\)]/g, "");
			if (/^[0-9]+$/.test(valueStripped))
			{
				var ETX_CHAR = String.fromCharCode(3);
				var phoneformat = phoneFormatPref.replace(new RegExp( "[360]", "g" ),ETX_CHAR);
				if (valueStripped.length === 7)
					returnMe = phoneformat.replace(phoneformat.substring(0,phoneformat.indexOf('4')),'')
										  .replace('45'+ETX_CHAR,valueStripped.substring(0,3))
										  .replace('789'+ETX_CHAR,valueStripped.substring(3));
				else if (valueStripped.length === 10)
					returnMe = phoneformat.replace('12'+ETX_CHAR,valueStripped.substring(0,3))
										  .replace('45'+ETX_CHAR,valueStripped.substring(3,6))
										  .replace('789'+ETX_CHAR,valueStripped.substring(6));
				else if (valueStripped.length === 11 && valueStripped.substring(0,1) === '1')
					returnMe = '1 ' + phoneformat.replace('12'+ETX_CHAR,valueStripped.substring(1,4))
												 .replace('45'+ETX_CHAR,valueStripped.substring(4,7))
												 .replace('789'+ETX_CHAR,valueStripped.substring(7));
			}
			return returnMe;
		}
	
		// changes a Date object into a String that follows the user's Date Preference
		function formatDate(dateObj)
		{
			if (dateObj instanceof Date || Object.prototype.toString.call(dateObj) === '[object Date]')
			{
				dateObj = new Date(dateObj);
				return DateUtil.getDateString(dateObj);
			}
			else
				return dateObj;
		}
	
		// changes a Date object into a String that follows the user's Time Preference
		function formatTime(timeObj)
		{
			if (timeObj instanceof Date || Object.prototype.toString.call(timeObj) === '[object Date]')
			{
				timeObj = new Date(timeObj);
				return DateUtil.getTimeString(timeObj);
			}
			else
				return timeObj;
		}

        // changes a Date object into a String that follows the user's Date+Time Preference
		function formatDateTimeTz(dateTimeObj)
		{
			if (dateTimeObj instanceof Date || Object.prototype.toString.call(dateTimeObj) === '[object Date]')
				return dateTimeZone.format(dateTimeObj);
			else
				return dateTimeObj;
		}
	
		// changes a Date object into a String that follows the user's Date Preference (but only the MM/YYYY portion)
		function formatMMYYDate(dateObj)
		{
			if (dateObj instanceof Date || Object.prototype.toString.call(dateObj) === '[object Date]')
				return DateUtil.getMMYYString(dateObj);
			else
				return dateObj;
		}
	
		// converts a numerical number (units: hours) into HH:MM format
		function formatToHHMM(numHrs)
		{
			if (isNaN(numHrs) || utilityFunctions.isValEmpty(numHrs))
				return numHrs;
	
			var isNeg = false;
			if (numHrs < 0)
			{
				isNeg = true;
				numHrs *= -1
			}
	
			var hrs = Math.floor(numHrs);
			var mins = Math.floor((numHrs-hrs)*60+0.5);
			var sign = isNeg ? "-" : "";

			return sign + hrs + ":" + (mins < 10 ? "0" : "") + mins;
		}
	
		// formats currency based on precision / field type
		// isCurrency2 should be true for CURRENCY2 types
		function formatCurrency(num, isCurrency2)
		{
			if (utilityFunctions.isValEmpty(num))
				return num;
	
			var formattedCurrency = isCurrency2 ? CurrencyUtil.format_currency2(num)
												: CurrencyUtil.format_currency(num);
	
			return (formattedCurrency === '') ? num : formatNumber(formattedCurrency, false);
		}
	
		// Adds a % if specified, and rounds to the precision defined by currencyprecision (...why?)
		// includePercentSign - Adds % if true, also rounds to 10ths place if true, 100ths if false (... why?)
		function formatRate(rateNum, includePercentSign)
		{
			if (isNaN(rateNum) || utilityFunctions.isValEmpty(rateNum))
				return rateNum;
	
			var returnMe = CurrencyUtil.format_rate(rateNum, includePercentSign).replace("%", "");
			return (returnMe === '') ? rateNum : formatNumber(returnMe, includePercentSign);
		}
	
		// Adds a .0 if has no decimal places and will always add a % sign
		function formatPercent(percentNum)
		{
			if (isNaN(percentNum) || utilityFunctions.isValEmpty(percentNum))
				return percentNum;
	
			var returnMe = CurrencyUtil.format_percent(percentNum).replace("%", "");
			return formatNumber(returnMe, true);
		}

		function formatCheckbox(checkboxValue)
		{
			return (typeof checkboxValue === 'boolean' && checkboxValue) || checkboxValue === 'T' ? 'T' : 'F';
		}
	
		function format(value, type, isNum, isCurr, includePercentSign)
		{
			var returnMe;
			var isNumeric = isNum || (type === fieldTypeConstants.Type.INTEGER) || (type === fieldTypeConstants.Type.POSINTEGER)
									|| (type === fieldTypeConstants.Type.FLOAT)   || (type === fieldTypeConstants.Type.POSFLOAT)
									|| (type === fieldTypeConstants.Type.NONNEGFLOAT) || (type === fieldTypeConstants.Type.PERCENT)
									|| (type === fieldTypeConstants.Type.RATE) || (type === fieldTypeConstants.Type.RATEHIGHPRECISION);
			var isCurrency = isCurr || (type === fieldTypeConstants.Type.POSCURRENCY) || (type === fieldTypeConstants.Type.CURRENCY)
									|| (type === fieldTypeConstants.Type.CURRENCY2) || (type === fieldTypeConstants.Type.NONNEGCURRENCY);
	
			if (utilityFunctions.isValEmpty(value))
				return value;
			if (type === fieldTypeConstants.Type.DATE)
			{
				return formatDate(value);
			}
			else if (type === fieldTypeConstants.Type.TIMEOFDAY)
			{
				return formatTime(value);
			}
            else if ( (type === fieldTypeConstants.Type.DATETIME) || (type === fieldTypeConstants.Type.DATETIMETZ) )
			{
				return formatDateTimeTz(value);
			}
			else if (type === fieldTypeConstants.Type.MMYYDATE)
			{
				return formatMMYYDate(value);
			}
			else if ( (type === fieldTypeConstants.Type.TIME) || (type === fieldTypeConstants.Type.TIMETRACK) )
			{
				return formatToHHMM(value);
			}
			else if ( (type === fieldTypeConstants.Type.RATE) || (type === fieldTypeConstants.Type.RATEHIGHPRECISION) )
			{
				return formatRate(value, includePercentSign);
			}
			else if (type === fieldTypeConstants.Type.PERCENT)
			{
				return formatPercent(value);
			}
			else if (type === fieldTypeConstants.Type.CHECKBOX)
			{
				return formatCheckbox(value);
			}
			else if (!!isNumeric)
			{
				return formatNumber(value, false);
			}
			else if (!!isCurrency)
			{
				return formatCurrency(value, type === fieldTypeConstants.Type.CURRENCY2 )
			}
			else if ( (type === fieldTypeConstants.Type.PHONE) || (type === fieldTypeConstants.Type.FULLPHONE) )
			{
				return formatPhoneNumber(value);
			}
	
			return value;
		}

		//keep this in sync with groupSeparatorPositionsValid in Formatter.java
		function groupSeparatorPositionsValid(str)
		{
			if(FieldValidationHelper.negativeprefix !== '-' && str.indexOf(FieldValidationHelper.negativeprefix) === 0)
				str = '-' + str.replace(FieldValidationHelper.negativeprefix, '').replace(FieldValidationHelper.negativesuffix, '');
			if (str.length < 3)
				return false;
			var lastDecimal = util.isString(FieldValidationHelper.decimalseparator) ? str.lastIndexOf(FieldValidationHelper.decimalseparator) : -1;
			if (lastDecimal >= 0)
				str = str.substr(0, lastDecimal);
			var parts = str.split(FieldValidationHelper.groupseparator);
			if (parts.length > 1)
			{
				for (var i = 1; i < parts.length; i++)
				{
					if (parts[i].length != 3)
						return false;
				}
			}
			return true;
		}
	
		/** PARSING FUNCTIONS - used to help make values into its appropriate format for validation **/
	
		/**
		 * Takes in a string formatted in the user's format preference and returns the numerical value
		 * (Negative representation, number groupings, decimal representation)
		 *
		 * Adapted/Improved from NLUtil.jsp's NLStringToNumber
		 * @param str - A number in a string in the user's format preference. Ex: "(23.456,93)"
		 * @param autoplace - boolean indicating whether to divide by 100 if no decimal separator is present.
		 * @returns a Numerical value that Javascript can read (isNaN will return that it is a number). Ex: -23456.93
		 */
		function formatUserPrefStringToJSNumber(str, autoplace)
		{
			str = "" + str;
			if(utilityFunctions.isValEmpty(str))
				return "";
			if(FieldValidationHelper.groupseparator && FieldValidationHelper.groupseparator !== '' && groupSeparatorPositionsValid(str))
				str = str.replace(new RegExp( '\\' + FieldValidationHelper.groupseparator, 'g'), '');
			if(FieldValidationHelper.negativeprefix !== '-' && str.indexOf(FieldValidationHelper.negativeprefix) === 0)
				str = '-' + str.replace(FieldValidationHelper.negativeprefix, '').replace(FieldValidationHelper.negativesuffix, '');
			if(FieldValidationHelper.decimalseparator === ',')
				str = str.replace(FieldValidationHelper.decimalseparator, '.');
	
			if (isNaN(str))
				return str;
			else if (autoplace && (str.indexOf(".") === -1))
				return parseFloat(str) / 100;
			else
				return parseFloat(str);
		}
	
		/**
		 * Takes in a timeStr (or a number) and converts it into a number in hours
		 *
		 * If in HH:MM format, it will return HH + MM/60
		 * If !isNaN, it will just return the parseFloat of the value
		 * Otherwise it will return null.
		 *
		 * @param timeStr - a time string in HH:MM format, or a number
		 */
		function convertTimeStringToHours(timeStr)
		{
			var isPositive = true;
            var convertedStr = "" + timeStr;
	
			if (convertedStr.slice(0, 1) === "-")
			{
				isPositive = false;
                convertedStr = convertedStr.slice(1);
			}
			var pattern = /([0-9]*)?:([0-9]+)?/;
			var result = pattern.exec(convertedStr);
	
			if (result === null) // not HH:MM format
			{
				if (isNaN(convertedStr)) // not a number
				{
					return timeStr;
				}
				else // a number
				{
					return (isPositive ? 1 : -1) * parseFloat(convertedStr);
				}
			}
			else // is in HH:MM format
			{
				var hours;
				var minutes;
				if (RegExp.$1.length > 0)
				{
					hours = parseInt(RegExp.$1, 10);
				}
				else
				{
					hours = 0;
				}
				if (typeof(RegExp.$2) !== "undefined" && RegExp.$2.length > 0)
				{
					minutes = parseInt(RegExp.$2, 10);
				}

				return (isNaN(hours) || isNaN(minutes)) ? timeStr : (isPositive ? 1 : -1) * (hours + minutes/60);
			}
		}
	
		/**
		 *  Attempts to evaluate a math equation
		 *
		 *  Will ignore a leading equals sign (=)
		 *  and perform addition(+), subtraction(-), multiplication(*), and division(/)\
		 *
		 *  Returns 'equation' back if it is empty, null, undefined, if it's a number already, or an invalid equation
		 *
		 *  @params equation: must only consist of + - * / . ( ) and digits
		 *  @returns the equation evaluated
		 */
		function evaluateMath(equation)
		{
			if (utilityFunctions.isValEmpty(equation) || !isNaN(equation))
				return equation;
	
			var calcMe = equation;
			if(equation.charAt(0) === '=')
				calcMe = equation.substr(1);
	
			if(!!FieldValidationHelper.groupseparator && !!FieldValidationHelper.decimalseparator)
				calcMe = calcMe.replace(new RegExp( '\\' + FieldValidationHelper.groupseparator, 'g'), '')
							   .replace(new RegExp( '\\' + FieldValidationHelper.decimalseparator, 'g'), '.');
	
			if (isNaN(calcMe) && calcMe.match(/[\+\-\*\/0-9\.\(\)\s]+/))
			{
				try
				{
					calcMe = eval.apply(utilityFunctions.getGlobalScope(), [calcMe]);
				}
				catch (e)
				{
					calcMe = equation;
				}
			}
			else
			{
				calcMe = equation;
			}
	
			return calcMe;
		}
	
		/**
		 *  Attempts to convert shorthanded time into time in the user's preference
		 *
		 *  Removes leading and trailing spaces
		 *  The Time portion of timeStr must be in the form of:
		 *	  1-4 digits followed by the first character of the user's AM/PM string
		 *  Will return an empty string if equation is empty, null, or undefined
		 *
		 *  Consult DateUtil.hhmmToTimeString for further details on how it is converted to proper form
		 *
		 *  @params timeStr - a string containing a time or a date and time (separated by a space)
		 *  @returns the string back with the time portion converted to the user's preference
		 */
		function formatShorthandedTime(timeStr)
		{
			timeStr = util.trim(timeStr);
			if (utilityFunctions.isValEmpty(timeStr))
				return "";
			var lastSpaceIdx = timeStr.lastIndexOf(" ");
			if (lastSpaceIdx > 0) // "date time" form
			{
				return timeStr.slice(0, lastSpaceIdx + 1) + DateUtil.hhmmToTimeString(timeStr.slice(lastSpaceIdx + 1))
			}
			else // "time" form
			{
				return DateUtil.hhmmToTimeString(timeStr);
			}
		}
	
		// If the string '://' is not found then pre-pend the default protocol prefix
		function addHTTPIfNecessary(urlString)
		{
			if (urlString.indexOf("://") === -1)
				urlString = "http://" + urlString;
	
			return urlString;
		}
	
		// Accepts 456?7890 or depending on user format [which is either (123) 456-7890 or 123?456?7890]
		// If matches and only numbers remain, returns a string that only contains digits.
		// Otherwise it will return back the original string.
		// Does nothing if no user preference format is selected
		function stripPhoneSeparators(phoneStr)
		{
			var phoneFormat = FieldValidationHelper.phoneformat;
			if ( typeof phoneFormat === "undefined" )
				return phoneStr;
	
			phoneStr = util.trim(phoneStr);
	
			var formatHasParens = (phoneFormat.indexOf("(") === 0);
			var formatDelimiter = phoneFormat.slice(-5, -4);
			var hasNoAreaCode   = (phoneStr.length === 8);

            if (formatDelimiter === ".")
                formatDelimiter = "\\.";
			var formatRegex = new RegExp("^(" + (formatHasParens ? "\\(" : "") + "(\\d{3})" + (formatHasParens ? "\\)\\ " : formatDelimiter) + ")?"
											  + "(\\d{3})" + formatDelimiter
											  + "(\\d{4})$");
	
			var matchResult = phoneStr.match(formatRegex);
	
			if (matchResult === null)
			{
				return phoneStr;
			}
			else
			{
				return (matchResult[2] ? matchResult[2] : "") + matchResult[3] + matchResult[4];
			}
		}
	
		function parseCCDateStr(ccStr)
		{
			var parts = ccStr.split("/");
			var returnStr = "";
			if (parts.length === 2)
			{
				if (isNaN(parts[0]) || isNaN(parts[1]))
					return ccStr;
				var monthPart = parseInt(parts[0], 10)
				var yearPart  = parseInt(parts[1], 10)
				if (isNaN(monthPart) || isNaN(yearPart) || monthPart <= 0 || yearPart < 0)
					return ccStr;
	
				if (monthPart < 10)
					returnStr = "0" + monthPart + "/";
				else
					returnStr = monthPart + "/";
	
				if (yearPart < 50)
					returnStr += 2000 + yearPart;
				else if (yearPart < 100)
					returnStr += 1900 + yearPart;
				else
					returnStr += yearPart;
	
				return returnStr;
			}
			else
				return ccStr;
		}

        function convertToUserPreferenceTZDate(dateTimeObj)
        {
            return dateTimeZone.parse(dateTimeObj);
        }
	
		function parse(value, type, isNum, isCurr, validationType, autoplace)
		{
			var returnMe;
			var isNumeric = isNum || (type === fieldTypeConstants.Type.INTEGER) || (type === fieldTypeConstants.Type.POSINTEGER)
								  || (type === fieldTypeConstants.Type.FLOAT)   || (type === fieldTypeConstants.Type.POSFLOAT)
								  || (type === fieldTypeConstants.Type.NONNEGFLOAT) || (type === fieldTypeConstants.Type.PERCENT)
								  || (type === fieldTypeConstants.Type.RATE) || (type === fieldTypeConstants.Type.RATEHIGHPRECISION);
			var isCurrency = isCurr || (type === fieldTypeConstants.Type.POSCURRENCY) || (type === fieldTypeConstants.Type.CURRENCY)
									|| (type === fieldTypeConstants.Type.CURRENCY2) || (type === fieldTypeConstants.Type.NONNEGCURRENCY);
	
			if (utilityFunctions.isValEmpty(value))
				return value;
	
			if ( (type !== fieldTypeConstants.Type.TEXT) && (type !== fieldTypeConstants.Type.IDENTIFIER) &&
				 (type !== fieldTypeConstants.Type.IDENTIFIERANYCASE) && (type !== fieldTypeConstants.Type.ADDRESS) &&
				 (/[\uff01-\uff5e]/.exec(value) !== null) )
				value = value.replace(/[\uff01-\uff5e]/g, function(ch) { return String.fromCharCode(ch.charCodeAt(0) - 0xfee0); });
	
			if (type === fieldTypeConstants.Type.DATE)
			{
				returnMe = DateUtil.regexStringToTime(value, null, false, true);
				return (isNaN(returnMe) || (returnMe === null)) ? value : returnMe;
			}
			else if (type === fieldTypeConstants.Type.TIMEOFDAY)
			{
				returnMe = DateUtil.regexStringToTime(null, formatShorthandedTime(value), false, true);
				return (isNaN(returnMe) || (returnMe === null)) ? value : returnMe;
			}
            else if ( (type === fieldTypeConstants.Type.DATETIME) || (type === fieldTypeConstants.Type.DATETIMETZ) )
            {
                returnMe = convertToUserPreferenceTZDate(value);
                return (isNaN(returnMe) || (returnMe === null)) ? value : returnMe;
            }
			else if (type === fieldTypeConstants.Type.MMYYDATE)
			{
				returnMe = DateUtil.stringToMMYYDate(value, FieldValidationHelper.dateformat, true);
				return (isNaN(returnMe) || (returnMe === null)) ? value : returnMe;
			}
			else if ( (type === fieldTypeConstants.Type.TIME) || (type === fieldTypeConstants.Type.TIMETRACK) )
			{
				return convertTimeStringToHours(value);
			}
			else if (!!isNumeric || !!isCurrency)
			{
                var strValue = "" + value;
				if ( (type === fieldTypeConstants.Type.PERCENT) || (type === fieldTypeConstants.Type.RATE) || (type === fieldTypeConstants.Type.RATEHIGHPRECISION) )
				{
					if (strValue.slice(-1) === "%")
                        strValue = strValue.slice(0, -1);
				}
                var evalValue = strValue;
                var evalPerformed = false;
                if (!!isCurrency && ( strValue.substr(1).search(/[\+\-\*\/]/g) !== -1))
                {
                    evalValue = evaluateMath(strValue);
                    // autoplace does not happen if an equation has been evaluated (value (equation) is not the same evalValue)
                    if (evalValue !== strValue)
                        evalPerformed = true;
                }
                var performAutoPlace = (autoplace && ( !!isCurrency || (type === fieldTypeConstants.Type.RATE) || (type === fieldTypeConstants.Type.RATEHIGHPRECISION)))
                returnMe = evalPerformed ? evalValue : formatUserPrefStringToJSNumber(evalValue, performAutoPlace);

				return isNaN(returnMe) ? value : returnMe;
			}
			else if ( (type === fieldTypeConstants.Type.URL) )
			{
				return addHTTPIfNecessary(value);
			}
			else if ( (type === fieldTypeConstants.Type.PHONE) || (type === fieldTypeConstants.Type.FULLPHONE) )
			{
				return stripPhoneSeparators(value);
			}
			else if (type === fieldTypeConstants.Type.CHECKBOX)
			{
				return value === 'T';
			}
			else if (type === fieldTypeConstants.Type.IDENTIFIER)
			{
				return value.toLowerCase();
			}
			else if (type === fieldTypeConstants.Type.CCNUMBER )
			{
				return ("" + value).replace(/ /g, "").replace(/\-/g, "");
			}
			else if ( (type === fieldTypeConstants.Type.CCEXPDATE) || (type === fieldTypeConstants.Type.CCVALIDFROM) )
			{
				return parseCCDateStr(value);
			}
			else if (type === fieldTypeConstants.Type.COLOR)
			{
				return ( ((value.charAt(0) !== "#") && (value.length === 6)) ? "#" : "") + value;
			}
			else if ((type === fieldTypeConstants.Type.FUNCTION) ||
                     ( (validationType !== null) && (typeof validationType !== "undefined") &&
					  (validationType.toLowerCase() === fieldTypeConstants.Type.QUOTEDFUNCTION) ) )
			{
				if (value.indexOf('(') > 0)
					return value.substr(0,value.indexOf('('));
			}
	
			return value;
		}
	
		function formatValueAsString(value, fieldType)
		{
			if(util.isArray(value))
				return value.join(String.fromCharCode(5));
			/* if field does not exist or field is currency/numeric, return value */
			else if (value == null)
				return value;
			else if(!fieldType)
				return String(value);
			else
				return String(format(value, fieldType))
		}

		/* assign util.formatter package */
		return Object.freeze({
			 format: format,
			 evaluateMath: evaluateMath,
			 formatValueAsString: formatValueAsString,
			 parse: parse,
			 convertTimeStringToHours: convertTimeStringToHours
		});
	}
);

/**
 * SuiteScript format module
 *
 * @module N/format
 * @NApiVersion 2.x
 *
 */
define('N/format',['N/util/formatter', 'N/utilityFunctions', 'N/dateTimeZone', 'N/fieldTypeConstants'],
    function (formatter, utilityFunctions, dateTimeZone, fieldTypeConstants)
    {
        function doParse(options, type)
        {
            var value,
                timezone = null,
                undef = undefined;

            if (type !== undef)
            {
                value = options;
            }
            else if (options !== undef && options !== null)
            {
                value = options.value;
                type = options.type;
                timezone = options.timezone || null;
            }

            utilityFunctions.checkArgs([value, type], ['value', 'type'], 'parse');

            switch (type)
            {
                case fieldTypeConstants.Type.DATE:
                case fieldTypeConstants.Type.TIME:
                case fieldTypeConstants.Type.TIMETRACK:
                case fieldTypeConstants.Type.TIMEOFDAY:
                case fieldTypeConstants.Type.URL:
                case fieldTypeConstants.Type.CHECKBOX:
                case fieldTypeConstants.Type.CCNUMBER:
                case fieldTypeConstants.Type.PHONE:
                case fieldTypeConstants.Type.FULLPHONE:
                case fieldTypeConstants.Type.IDENTIFIER:
                case fieldTypeConstants.Type.MMYYDATE:
                case fieldTypeConstants.Type.CCEXPDATE:
                case fieldTypeConstants.Type.CCVALIDFROM:
                case fieldTypeConstants.Type.COLOR:
                case fieldTypeConstants.Type.FUNCTION:
                    return formatter.parse(value, type);

                case fieldTypeConstants.Type.INTEGER:
                case fieldTypeConstants.Type.POSINTEGER:
                case fieldTypeConstants.Type.PERCENT:
                case fieldTypeConstants.Type.FLOAT:
                case fieldTypeConstants.Type.POSFLOAT:
                case fieldTypeConstants.Type.NONNEGFLOAT:
                case fieldTypeConstants.Type.RATE:
                case fieldTypeConstants.Type.RATEHIGHPRECISION:
                    return formatter.parse(value, type, true);

                case fieldTypeConstants.Type.POSCURRENCY:
                case fieldTypeConstants.Type.NONNEGCURRENCY:
                case fieldTypeConstants.Type.CURRENCY:
                case fieldTypeConstants.Type.CURRENCY2:
                    return formatter.parse(value, type, false, true);

                case fieldTypeConstants.Type.DATETIME:
                case fieldTypeConstants.Type.DATETIMETZ:
                    return dateTimeZone.parse(value, timezone);

                default:
                    return value;
            }
        }

        function doFormat(options, type)
        {

            var value,
                timezone = null,
                undef = undefined;

            if (type !== undef)
            {
                value = options;
            }
            else if (options !== undef && options !== null)
            {
                value = options.value;
                type = options.type;
                timezone = options.timezone || null;
            }

            utilityFunctions.checkArgs([value, type], ['value', 'type'], 'format');

            switch (type)
            {
                case fieldTypeConstants.Type.DATE:
                case fieldTypeConstants.Type.TIME:
                case fieldTypeConstants.Type.TIMETRACK:
                case fieldTypeConstants.Type.TIMEOFDAY:
                case fieldTypeConstants.Type.INTEGER:
                case fieldTypeConstants.Type.POSINTEGER:
                case fieldTypeConstants.Type.PERCENT:
                case fieldTypeConstants.Type.FLOAT:
                case fieldTypeConstants.Type.POSFLOAT:
                case fieldTypeConstants.Type.NONNEGFLOAT:
                case fieldTypeConstants.Type.POSCURRENCY:
                case fieldTypeConstants.Type.NONNEGCURRENCY:
                case fieldTypeConstants.Type.CURRENCY:
                case fieldTypeConstants.Type.CURRENCY2:
                case fieldTypeConstants.Type.CHECKBOX:
                case fieldTypeConstants.Type.PHONE:
                case fieldTypeConstants.Type.FULLPHONE:
                case fieldTypeConstants.Type.MMYYDATE:
                case fieldTypeConstants.Type.RATE:
                case fieldTypeConstants.Type.RATEHIGHPRECISION:
                    return formatter.format(value, type);

                case fieldTypeConstants.Type.DATETIME:
                case fieldTypeConstants.Type.DATETIMETZ:
                    return dateTimeZone.format(value, timezone);

                default:
                    return value;
            }
        }

        return Object.freeze({
                                 /**
                                  * Parse a value from the appropriate preference formatted-value to a raw value.
                                  *
                                  * @param {Object} options
                                  * @param {string} options.value the data you wish to parse
                                  * @param {string} options.type the field type i.e. DATE, CURRENCY, INTEGER
                                  * @param {string} options.timezone (optional & applicable to type DATETIME only) specifies which timezone the value is from.
                                  *                                  default is the timezone set in the user's preferences
                                  *
                                  * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if either value or type is missing
                                  *
                                  * @return {Date|string|number} If parseable, the parsed value. If not or given an invalid Type, the value passed in options.value
                                  *
                                  * @since 2015.2
                                  */
                                parse: doParse,
                                 /**
                                  * Parse a value from the raw value to its appropriate preference formatted-value.
                                  *
                                  * @param {Object} options
                                  * @param {Date|string|number} options.value the data you wish to format
                                  * @param {string} options.type the field type i.e. DATE, CURRENCY, INTEGER
                                  * @param {string} options.timezone (optional & applicable to type DATETIME only) specifies which timezone to format to.
                                  *                                  default is the timezone set in the user's preferences
                                  *
                                  * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if either value or type is missing
                                  *
                                  * @return {string} If format-able, the formatted value. If not or given an invalid Type, the value passed in options.value
                                  *
                                  * @since 2015.2
                                  */
                                format: doFormat,
                                 /**
                                  * Enum for field types.
                                  * @enum {string}
                                  */
                                 Type: fieldTypeConstants.Type,
                                 /**
                                  * Enum for Time Zones.
                                  * @enum {string}
                                  */
                                Timezone: dateTimeZone.Timezone
                             });
    });

/**
 * @private
 */
define('N/restricted/currencyApi',['N/restricted/reflet'], function(reflet){ return reflet; });

/**
 * SuiteScript currency module
 *
 * @module N/currency
 * @NApiVersion 2.x
 *
 */
define('N/currency',['N/restricted/invoker', 'N/restricted/currencyApi', 'N/format', 'N/fieldTypeConstants', 'N/utilityFunctions', 'N/error'],
    function (invoker, currencyApi, format, fieldTypeConstants, utilityFunctions, error)
    {
        function getExchRate(options)
        {
            var sourceCurrency, targetCurrency;

            if (options != null && (options.hasOwnProperty('source') || options.hasOwnProperty('target')))
            {
                sourceCurrency = options.source;
                targetCurrency = options.target;
            }

            utilityFunctions.checkArgs([sourceCurrency, targetCurrency], ['source', 'target'], 'exchangeRate');
            var effectiveDate = options.date || new Date();

            if (!util.isDate(effectiveDate))
            {
                utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'options.date', 'date');
            }
            else
            {
                effectiveDate = format.format(effectiveDate, fieldTypeConstants.Type.DATE);
            }

            try
            {
                return parseFloat(invoker(currencyApi, 'nlapiExchangeRate', [sourceCurrency, targetCurrency, effectiveDate], null, false));
            }
            catch (e)
            {
                var err = e;
                var msg = !!e.message ? e.message.replace("fromCurrency", "source").replace("toCurrency", "target") : "";
                if (e.name === "INVALID_CUR")
                {
                    utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_CURRENCY_ID, msg);
                }
                throw err;
            }
        }

        return Object.freeze({
                                 /**
                                  * Retrieves the exchange rate between two currencies based on the specified date.
                                  * The return value comes from the Exchange Rate column of the Currency Exchange Rates record.
                                  *
                                  * @governance 10 units
                                  *
                                  * @param {Object} options
                                  * @param {int|string} options.source The source currency ID or String
                                  * @param {int|string} options.target The target currency ID or String
                                  * @param {Date} options.date [optional] The date of the desired effective currency rate. Defaults to today.
                                  *
                                  * @return {number}
                                  *
                                  * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if id parameter is missing
                                  * @throws {SuiteScriptError} SSS_INVALID_CURRENCY_ID if an invalid currency (source or target) is specified
                                  *
                                  * @since 2015.2
                                  */
                                exchangeRate: getExchRate
                             })
    });

/**
 * @private
 */
define('N/restricted/scriptSessionContext',['N/restricted/reflet'], function(reflet){ return reflet; });

/**
 * @private
 */
define('N/restricted/scriptDeploymentContext',['N/restricted/reflet'], function(reflet){ return reflet; });

/**
 * @private
 */
define('N/restricted/scriptSessionObjectService',['N/restricted/reflet'], function(reflet){ return reflet; });

/**
 * @private
 */
define('N/restricted/scriptWorkQueueContext',['N/restricted/reflet'], function(reflet){ return reflet; });

/**
 * SuiteScript module
 *
 * @module N/runtime
 * @NApiVersion 2.x
 *
 */
define('N/runtime',['N/restricted/scriptSessionContext',
		'N/restricted/scriptDeploymentContext',
		'N/restricted/scriptSessionObjectService',
		'N/restricted/scriptWorkQueueContext',

		'N/restricted/bridge',
		'N/error',
		'N/nsobject',
		'N/restricted/invoker',
		'N/utilityFunctions',
		'N/util/formatter',
		'N/util'
	],
        function (scriptSessionContext, scriptDeploymentContext, scriptSessionObjectService, scriptWorkQueueContext,
                  apiBridge, error, nsobject, invoker, utilityFunctions, formatter, util)
        {

            var ENV_TYPES = Object.freeze({
                SANDBOX: 'SANDBOX',
                PRODUCTION: 'PRODUCTION',
                BETA: 'BETA',
                INTERNAL: 'INTERNAL'
            });

            var PERMISSION = Object.freeze({
                FULL: 4,
                EDIT: 3,
                CREATE: 2,
                VIEW: 1,
                NONE: 0
            });

            // this has to be a lazy load
	        var getLegacyContextObject = (function() {
	        	var legacyContextObject;
		        return function () {
		        	if (!legacyContextObject)
			            legacyContextObject = invoker(apiBridge, 'nlapiGetContext');
		        	return legacyContextObject;
		        };
	        })();

	        function getDelegate()
	        {
	        	return getLegacyContextObject();
	        }

	        function getScriptDeploymentContext()
	        {
		        return (scriptDeploymentContext === apiBridge) ? getLegacyContextObject() : scriptDeploymentContext;
	        }

	        function getScriptSessionContext()
	        {
		        return (scriptSessionContext === apiBridge) ? getLegacyContextObject() : scriptSessionContext;
	        }

	        function getScriptSessionObjectService()
	        {
	        	return (scriptSessionObjectService === apiBridge) ? getLegacyContextObject() : scriptSessionObjectService;
	        }

	        function getScriptWorkQueueContext()
	        {
	        	return (scriptWorkQueueContext === apiBridge) ? getLegacyContextObject() : scriptWorkQueueContext;
	        }

            /**
             * @protected
             * @constructor
             */
            function Script()
            {
                /**
                 * Current script log level
                 * @name Script#logLevel
                 * @type string
                 * @readonly
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'logLevel', {
                    get: function ()
                    {
                        return invoker(getScriptDeploymentContext(), 'getLogLevel');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.Script.logLevel' );
                    },
                    enumerable: true,
                    configurable: false
                });

                /**
                 * Current script id
                 * @name Script#id
                 * @type string
                 * @readonly
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'id', {
                    get: function ()
                    {
                        return invoker(getScriptDeploymentContext(), 'getScriptId');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.Script.id' );
                    },
                    enumerable: true,
                    configurable: false
                });

                /**
                 * Current script runtime version
                 * @name Script#apiVersion
                 * @type string
                 * @readonly
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'apiVersion', {
                    get: function ()
                    {
                        return invoker(getScriptDeploymentContext(), 'getRuntimeVersion');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.Script.apiVersion' );
                    },
                    enumerable: true,
                    configurable: false
                });

                /**
                 * The deploymentId for the current script deployment
                 * @name Script#deploymentId
                 * @type string
                 * @readonly
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'deploymentId', {
                    get: function ()
                    {
                        return invoker(getScriptDeploymentContext(), 'getDeploymentId');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.Script.deploymentId' );
                    },
                    enumerable: true,
                    configurable: false
                });

                /**
                 * The bundle IDs the current script belongs to
                 * @name Script#bundleIds
                 * @type string[]
                 * @readonly
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'bundleIds', {
                    get: function ()
                    {
                        return invoker(getScriptDeploymentContext(), 'getBundleIds').map(String);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.Script.bundleIds' );
                    },
                    enumerable: true,
                    configurable: false
                });

                /**
                 * Returns the remaining amount of unit usage for the current script
                 * @return {number}
                 *
                 */
                this.getRemainingUsage = function getRemainingUsage()
                {
                    return invoker(getScriptSessionContext(), 'getRemainingUsage');
                };

                /**
                 * Returns script parameter value which is defined per script
                 *
                 * @param {Object} options
                 * @param { string } options.name The name of the parameter
                 * @return {number|Date|string|Array}
                 *
                 */
                this.getParameter = function getParameter(options)
                {
                    var name = options;
                    if (utilityFunctions.isObject(options))
                    {
                        name = options.name;
                    }
                    utilityFunctions.checkArgs([name], ['name'], 'Script.getParameter');
                    if (!util.isString(name))
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'name','string' );
                    }
                    var pValue = invoker(getScriptDeploymentContext(), 'getPreferenceObject', [name]);
                    var pType = invoker(getScriptDeploymentContext(), 'getPreferenceType', [name]);
                    return formatter.parse(pValue, pType);
                };

	            /**
	             * Percentage complete specified for the current scheduled script execution
	             * @name Script#percentComplete
	             * @type number
	             * @throws {SuiteScriptError} SSS_OPERATION_UNAVAILABLE
	             * @since 2015.2
	             */
	            Object.defineProperty(this, 'percentComplete', {
		            get: function ()
		            {
			            return invoker(getScriptWorkQueueContext(), 'getPercentComplete');
		            },
		            set: function (val)
		            {
			            return invoker(getScriptWorkQueueContext(), 'setPercentComplete', [val]);
		            },
		            enumerable: true,
		            configurable: false
	            });

                // Functions for debugger
                function toJSON()
                {
                    return {
                        'id': this.id,
                        'deploymentId': this.deploymentId,
                        'logLevel': this.logLevel,
                        'bundleIds': this.bundleIds
                    };
                }

                function toString()
                {
                    return 'runtime.Script';
                }

                /**
                 * get JSON format of the object
                 * @return {string}
                 *
                 */
                this.toJSON = toJSON;
                /**
                 * @return {string}
                 *
                 */
                this.toString = toString;
            }

            /**
             * @protected
             * @constructor
             */
            function Session()
            {
                /**
                 * Get the value of a user-defined session object for the current user.
                 * @param {Object} options
                 * @param { string } options.name The key used to store the session object
                 * @return {string}
                 *
                 */
                this.get = function get(options)
                {
                    var name = options;
                    if (utilityFunctions.isObject(options))
                    {
                        name = options.name;
                    }
                    utilityFunctions.checkArgs([name], ['name'], 'Session.get');
                    return invoker(getScriptSessionObjectService(), 'getSessionObject', [name]);
                }

                /**
                 * Add or set the value of a user-defined session object for the current user.
                 * @param {Object} options
                 * @param { string } options.name The key used to store the session object
                 * @param { string } options.value The value to associate with this key in the user's session
                 * @return {undefined}
                 *
                 */
                this.set = function set(options, value)
                {
                    var name = options;
                    if (utilityFunctions.isObject(options))
                    {
                        name = options.name;
                        value = options.value;
                    }

                    utilityFunctions.checkArgs([name], ['name'], 'Session.set');

                    return invoker(getScriptSessionObjectService(), 'setSessionObject', [name, value]);
                }

                // Functions for debugger

                function toJSON()
                {
                    var keys = invoker(getScriptSessionObjectService(), 'getAllSessionObjects');
                    var result = new Object();
                    for (var i = 0; i < keys.length; i++)
                    {
                        result[keys[i]] = invoker(getScriptSessionObjectService(), 'getSessionObject', [keys[i]]);
                    }
                    return result;
                }

                function toString()
                {
                    return "runtime.Session";
                }

                /**
                 * get JSON format of the object
                 * @return {string}
                 *
                 */
                this.toJSON = toJSON;
                /**
                 * @return {string}
                 *
                 */
                this.toString = toString;
            }

            /**
             * @protected
             * @constructor
             */
            function User()
            {
                /**
                 * Returns the currently logged in user's e-mail address
                 * @name User#email
                 * @type string
                 * @readonly
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'email', {
                    get: function ()
                    {
                        return invoker(getScriptSessionContext(), 'getEmail');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.User.email' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * Returns the currently logged in user's name
                 * @name User#name
                 * @type string
                 * @readonly
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'name', {
                    get: function ()
                    {
                        return invoker(getScriptSessionContext(), 'getName');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.User.name' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * Returns the internal ID of the currently logged in user's location
                 * @name User#location
                 * @type number
                 * @readonly
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'location', {
                    get: function ()
                    {
                        return invoker(getScriptSessionContext(), 'getLocation');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.User.location' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * Returns the internal ID of the currently logged in user's department
                 * @name User#department
                 * @type number
                 * @readonly
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'department', {
                    get: function ()
                    {
                        return invoker(getScriptSessionContext(), 'getDepartment');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.User.department' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * Returns the internal ID of the currently logged in user's role
                 * @name User#role
                 * @type number
                 * @readonly
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'role', {
                    get: function ()
                    {
                        return invoker(getScriptSessionContext(), 'getRole');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.User.role' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * Returns the internal ID of the currently logged in user's center type (role center)
                 * @name User#roleCenter  The string value of the logged in user's center - for example, SALES, ACCOUNTING, CLASSIC.
                 * @type string
                 * @readonly
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'roleCenter', {
                    get: function ()
                    {
                        return invoker(getScriptSessionContext(), 'getRoleCenter');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.User.roleCenter' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * Returns the custom scriptId of the role (as opposed to the internal numerical ID).
                 * @name User#roleId
                 * @type string
                 * @readonly
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'roleId', {
                    get: function ()
                    {
                        return invoker(getScriptSessionContext(), 'getRoleId');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.User.roleId' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * Returns the currently logged in user's internal ID
                 * @name User#id
                 * @type number
                 * @readonly
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'id', {
                    get: function ()
                    {
                        return invoker(getScriptSessionContext(), 'getUser');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.User.id' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * Returns the internal ID of the currently logged in user's subsidiary
                 * @name User#subsidiary
                 * @type number
                 * @readonly
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'subsidiary', {
                    get: function ()
                    {
                        return invoker(getScriptSessionContext(), 'getSubsidiary');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.User.subsidiary' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * Get a user's permission level for a given permission
                 * @param {Object} options
                 * @param { string } options.name The internal ID of a permission
                 * @return {number} one value of the Permission
                 *
                 */
                this.getPermission = function getPermission(options)
                {
                    var name = options;

                    if (utilityFunctions.isObject(options))
                    {
                        name = options.name;
                    }
                    utilityFunctions.checkArgs([name], ['name'], 'User.getPermission');
                    if (typeof name != "string")
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'name','string' );
                    }
                    return invoker(getScriptSessionContext(), 'getPermission', [name]);
                }

                /**
                 * Get the value of a NetSuite preference
                 * @param {Object} options
                 * @param { string } name The internal ID of the preference
                 * @return {string} The value of a system or script preference for the current user
                 *
                 */
                this.getPreference = function getPreference(options)
                {
                    var name = options;

                    if (utilityFunctions.isObject(options))
                    {
                        name = options.name;
                    }
                    utilityFunctions.checkArgs([name], ['name'], 'User.getPreference');
                    if (!util.isString(name))
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'name','string' );
                    }
                    var pValue = invoker(getScriptDeploymentContext(), 'getPreference', [name]);
                    var pType = invoker(getScriptDeploymentContext(), 'getPreferenceType', [name]);
                    if (('T' === pValue || 'F' === pValue) && ('boolean' === pType))
                        return 'T' === pValue;
                    else
                        return pValue;
                }

                // Functions for debugger

                function toJSON()
                {
                    return {
                        'id': this.id,
                        'name': this.name,
                        'email': this.email,
                        'location': this.location,
                        'department': this.department,
                        'role': this.role,
                        'roleId': this.roleId,
                        'roleCenter': this.roleCenter,
                        'subsidiary': this.subsidiary
                    };
                }


                function toString()
                {
                    return 'runtime.User';
                }

                /**
                 * get JSON format of the object
                 * @return {string}
                 *
                 */
                this.toJSON = toJSON;
                /**
                 * @return {string}
                 *
                 */
                this.toString = toString;
            }

            Session.prototype = nsobject.getNewInstance();
            User.prototype = nsobject.getNewInstance();
            Script.prototype = nsobject.getNewInstance();

            function Runtime()
            {
            	var _contextTypes;
                /**
                 * Get the current log in user object
                 * @return {User}
                 */
                this.getCurrentUser = function getCurrentUser()
                {
                    return Object.freeze(new User());
                }

                /**
                 * Get the current executing Script object
                 * @return {Script}
                 */
                this.getCurrentScript = function getCurrentScript()
                {
                    return Object.freeze(new Script());
                }

                /**
                 * Get the current session object
                 * @return {Session}
                 */
                this.getCurrentSession = function getCurrentSession()
                {
                    return Object.freeze(new Session());
                }

                /**
                 * Check if a feature is turned on and in effect
                 * @param {Object} options
                 * @param { string } options.feature id of the feature
                 * @return {boolean}
                 */
                this.isFeatureInEffect = function isFeatureInEffect(options)
                {
                    var feature = options;
                    if (utilityFunctions.isObject(options))
                    {
                        feature = options.feature;
                    }

                    utilityFunctions.checkArgs([options], ['options.feature'], 'runtime.isFeatureInEffect');

                    if (!util.isString(feature))
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'feature', 'string' );
                    }
                    return invoker(getScriptSessionContext(), 'getFeature', [feature]);
                };

                /**
                 * @name runtime#queueCount
                 * @type number
                 * @readonly
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'queueCount', {
                    get: function ()
                    {
                        return invoker(getScriptWorkQueueContext(), 'getQueueCount');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'queueCount' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

	            /**
	             * @name runtime#processorCount
	             * @type number
	             * @readonly
	             * @since 2018.1
	             */
	            Object.defineProperty(this, 'processorCount', {
		            get: function ()
		            {
			            return invoker(getScriptWorkQueueContext(), 'getProcessorCount');
		            },
		            set: function (val)
		            {
			            utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'processorCount' );
		            },
		            enumerable: true,
		            configurable: false,
		            writeable: false
	            });


                /**
                 * The version of NetSuite the current account is runnning.
                 *
                 * @name runtime#version
                 * @type string
                 * @readonly
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'version', {
                    get: function ()
                    {
                        return invoker(getScriptSessionContext(), 'getVersion');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'version' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });


                /**
                 * @name runtime#accountId
                 * @type string
                 * @readonly
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'accountId', {
                    get: function ()
                    {
                        return invoker(getScriptSessionContext(), 'getCompany');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'accountId' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * @name runtime#envType
                 * @type string
                 * @readonly
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'envType', {
                    get: function ()
                    {
                        return invoker(getScriptSessionContext(), 'getEnvironment');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'envType' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * @name runtime#executionContext
                 * @type string
                 * @readonly
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'executionContext', {
                    get: function ()
                    {
                    	var toRet = invoker(getScriptSessionContext(), 'getExecutionContext');
                        return  toRet == null ? null : toRet.toUpperCase();
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'executionContext' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                // Functions for debugger
                /**
                 * get JSON format of the object
                 * @return {Object}
                 *
                 */
                this.toJSON = function toJSON()
                {
                    return {};
                }

                /**
                 * @return {string}
                 *
                 */
                this.toString = function toString()
                {
                    return "runtime";
                }

                this.setupScriptRun = function setupScriptRun(scriptObject)
                {
                    invoker(apiBridge, "setupScript", [scriptObject]);
                }

                /**
                 * @enum
                 */
                this.EnvType = ENV_TYPES;

                /**
                 * @name runtime#ContextType
                 * @type object
                 * @readonly
                 * @since 2018.1
                 */
                Object.defineProperty(this, 'ContextType', {
                    get: function ()
                    {
                        if (!_contextTypes)
                            _contextTypes = invoker(getScriptSessionContext(), 'getExecutionContextTypes');
                        return _contextTypes;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'ContextType' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * @enum
                 */
                this.Permission = PERMISSION;
            };
            Runtime.prototype = nsobject.getNewInstance();
            /** @alias N/runtime */
            return Object.freeze(new Runtime());
        });

/**
 * SuiteScript record action module
 *
 * @module N/action
 * @suiteScriptVersion 2.x
 */
define('N/action',['N/restricted/bridge', 'N/restricted/remoteApiBridge', 'N/restricted/invoker', 'N/utilityFunctions', 'N/error'],
	function (apiBridge, remoteApi, invoker, utilityFunctions, error)
	{
		var actionCache = {};

		function promiseTo(fn, options, postProcess)
		{
			var myPromise = new Promise(function (resolve, reject)
			{
				function callback(result)
				{
					if (result instanceof Error)
					{
						reject(result);
						return;
					}
					resolve(postProcess ? postProcess(result, options) : result);
				}

				try
				{
					fn(options, callback);
				}
				catch (e)
				{
					reject(e);
				}
			});
			return myPromise;
		}

		function doExecuteAction(options, callback)
		{
			var recordType, recordId, pkg, actionId, params;
			if (options)
			{
				recordType = options.recordType;
				params = utilityFunctions.isObject(options.params) ? options.params : {};
				recordId = params.recordId;
				actionId = options.id;
				pkg = options['package'] || null;
			}
			utilityFunctions.checkArgs([recordType, recordId, actionId], ['recordType', 'params.recordId', 'id'], 'action.executeAction');

			return invoker(remoteApi, 'executeAction', [recordType, pkg, actionId, recordId, params], callback, false);
		}

		function executeAction(options)
		{
			return JSON.parse(doExecuteAction(options, null));
		}
		executeAction.promise = function(options)
		{
			return promiseTo(doExecuteAction, options, JSON.parse);
		};

		function createAction(options)
		{
			var TYPE = 'Action';

			var recordType = options.recordType.toLowerCase();
			var pkg = options['package'] || null;
			var actionId = options.id;

			var Action = function(params)
			{
				return executeAction(combineOpts(params, recordType, actionId, pkg));
			};
			Action.execute = function(params)
			{
				return executeAction(combineOpts(params, recordType, actionId, pkg));
			};
			Action.promise = function(params)
			{
				return promiseTo(doExecuteAction, combineOpts(params, recordType, actionId, pkg), JSON.parse);
			};
			Action.execute.promise = Action.promise;

			Action.id = actionId;
			Action.recordType = recordType;
			Action['package'] = pkg;
			Action.label = options.label || null;
			Action.description = options.description || null;
			var params = {};
			options.parameters.forEach(function(p) {
				params[p.id] = p;
				delete p.id;
			});
			Action.parameters = params;
			Action.toJSON = function toJSON(concise)
			{
				var res = {};
				for (var p in Action)
				{
					if (Action.hasOwnProperty(p) && typeof Action[p] !== 'function')
					{
						if (!concise || (Action[p] != null && (Action[p].constructor !== Object || Object.keys(Action[p]).length > 0)))
							res[p] = Action[p];
					}
				}
				return res;
			};
			Action.toString = function toString()
			{
				return TYPE + JSON.stringify(Action.toJSON(true));
			};

			return Object.freeze(Action);
		}

		function combineOpts(params, recordType, actionId, pkg)
		{
			var combinedOpts = {};
			combinedOpts.params = params;
			combinedOpts.recordType = recordType;
			combinedOpts.id = actionId;
			combinedOpts['package'] = pkg;
			return combinedOpts;
		}

		function processGetActionsResult(jsonRes, options)
		{
			var metadata = JSON.parse(jsonRes);
			actionCache[options.recordType.toLowerCase()] = jsonRes;
			if (metadata.length === 0)
				utilityFunctions.throwSuiteScriptError(error.Type.SSS_NO_SUCH_RECORD_ACTION);

			var Actions = {};
			for (var i = 0; i < metadata.length; i++)
			{
				var action = createAction(metadata[i]);
				var fullId = action['package'] ? action['package'] + '.' + action.id : action.id;
				Actions[fullId] = action;
			}
			return Object.freeze(Actions);
		}

		function doGetActions(options, callback)
		{
			var recordType = options ? options.recordType : null;

			utilityFunctions.checkArgs([recordType], ['recordType'], 'action.getActions');

			recordType = recordType.toLowerCase();
			if (!actionCache[recordType])
				return invoker(remoteApi, 'getRecordActions', [recordType], callback, false);

			if (callback)
				callback(actionCache[recordType]);
			else
				return actionCache[recordType];
		}

		function getActions(options)
		{
			return processGetActionsResult(doGetActions(options, null), options);
		}
		getActions.promise = function(options)
		{
			return promiseTo(doGetActions, options, processGetActionsResult);
		};

		function processGetActionResult(jsonRes, options)
		{
			var metadata = JSON.parse(jsonRes);
			actionCache[options.recordType.toLowerCase()] = jsonRes;

			var result = null;
			var pkg = options['package'] || '';
			for (var i = 0; i < metadata.length; i++)
			{
				var curPkg = metadata[i]['package'] || '';
				if (curPkg === pkg && options.id === metadata[i].id)
				{
					result = createAction(metadata[i]);
					break;
				}
			}
			if (result === null)
				utilityFunctions.throwSuiteScriptError(error.Type.SSS_NO_SUCH_RECORD_ACTION);
			return result;
		}

		function doGetAction(options, callback)
		{
			var recordType, actionId;
			if (options)
			{
				recordType = options.recordType;
				actionId = options.id;
			}
			utilityFunctions.checkArgs([recordType, actionId], ['recordType', 'id'], 'action.getAction');

			return doGetActions(options, callback);
		}

		function getAction(options)
		{
			return processGetActionResult(doGetAction(options, null), options);
		}
		getAction.promise = function(options)
		{
			return promiseTo(doGetAction, options, processGetActionResult);
		};

		return Object.freeze({
			/**
			 * Object corresponding to a record action. It contains the necessary action information
			 * and can be executed (both synchronously and asynchronously using Action.promise).
			 * @name Action
			 * @function
			 * @param {Object} params action arguments
			 * @param {string} params.recordId record instance ID
			 * @returns {Object} action result; the actual return value returned by the action implementation is stored in the response property
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if params.recordId is missing or undefined
			 */

			/**
			 * Provides available record actions for the given record type.
			 * @param {Object} options
			 * @param {string} options.recordType record type
			 * @returns {Object} a set of actions (@see Action) defined on the record type indexed by action ID
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.recordType is missing or undefined
			 */
			getActions: getActions,

			/**
			 * Returns an executable record action for the given record type. Record ID is provided upon execution of the returned action.
			 * @param {Object} options
			 * @param {string} options.recordType record type
			 * @param {string} options.id action ID
			 * @returns {Action} record action executor for action specified by options
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.recordType or options.id is missing or undefined
			 */
			getAction: getAction,

			/**
			 * Executes record action and returns its result.
			 * @param {Object} options
			 * @param {string} options.recordType record type
			 * @param {string} options.id action ID
			 * @param {Object} options.params action arguments
			 * @param {string} options.params.recordId record instance ID
			 * @returns {Object} action result; the actual return value returned by the action implementation is stored in the response property
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.recordType or options.id or options.params.recordId is missing or undefined
			 */
			executeAction: executeAction
		});
	}
);

/**
 * @private
 */
define('N/restricted/queryApiBridge',['N/restricted/reflet'], function(reflet){ return util.extend({bridge :'queryApiBridge'}, reflet); });

/**
 * @private
 */
define('N/restricted/searchApi',['N/restricted/reflet'], function(reflet){ return reflet; });

/**
 * SuiteScript search paging util module
 * @private Ignore for JSDoc stub generation
 * @module N/search/pagingUtil
 * @NApiVersion 2.x
 *
 */
define('N/search/pagingUtil',[], function (){
	var PAGE_SIZE_MIN = 5,
		PAGE_SIZE_MAX = 1000,
		PAGE_SIZE_DEFAULT = 50;

    function regulatePageSize(pageSize)
    {
	    var size = parseInt(pageSize);
	    var result = isNaN(size) ? PAGE_SIZE_DEFAULT : size;

        result = result < PAGE_SIZE_MIN ? PAGE_SIZE_MIN : result;
        result = result > PAGE_SIZE_MAX ? PAGE_SIZE_MAX : result;

        return result;
    }

    return {
        regulatePageSize: regulatePageSize
    };
});

/**
 * SuiteScript searchPaging module (Client Side)
 * @private Ignore for JSDoc stub generation
 * @module N/search/searchPaging
 * @NApiVersion 2.x
 *
 */
define('N/search/searchPaging',['N/restricted/invoker', 'N/restricted/bridge', 'N/error', 'N/nsobject', 'N/search/pagingUtil'],
function (invoker, api, error, nsobject, pagingUtil){
    function RemotePageRange(options)
    {
        var index = options.index,
            compoundKey = options.compoundKey,
            compoundLabel = options.compoundLabel;

        this.getIndex = function getIndex(){return index;};
        this.getCompoundKey = function getCompoundKey(){return compoundKey;};
        this.getCompoundLabel = function getCompoundLabel(){return compoundLabel;};
    }
    RemotePageRange.prototype = nsobject.getNewInstance();

    function RemotePage(options)
    {
        var data = options.data,
            pageRange = new RemotePageRange(options.pageRange),
            _isFirst = options.isFirst,
            _isLast = options.isLast;

        this.getData = function getData(){return data;};
        this.getPageRange = function getPageRange(){return pageRange};
        this.isFirst = function isFirst(){return _isFirst;};
        this.isLast = function isLast(){return _isLast;};
    }
    RemotePage.prototype = nsobject.getNewInstance();

    function RemotePagedData(options)
    {
        var recordType = options.recordType,
            searchId = options.searchId,
            filters = options.filters,
            columns = options.columns,
            totalRows = isNaN(options.totalRows) ? -1 : options.totalRows,
            pageSize = isNaN(options.pageSize) ? -1 : options.pageSize,
            pageRanges = Array.isArray(options.pageRanges) && options.pageRanges.map(function(v,i,a){return new RemotePageRange(v);}) || [];

        this.getPageSize = function getPageSize(){return pageSize;};
        this.getTotalRows = function getTotalRows(){return totalRows;};
        this.getPageRanges = function getTotalRows(){return pageRanges;};
        this.getPage = function getPage(index){
            var pageRange = pageRanges[index],
                pageCount = pageRanges.length;

            return new RemotePage(invoker(api, 'getSearchPage', [recordType, searchId, filters, columns,
                pageRange.getCompoundKey(), pageRange.getCompoundLabel(), pageRange.getIndex(),
                pageSize,
                pageRanges[0].getCompoundKey(), pageRanges[pageCount - 1].getCompoundKey(),
                pageCount, null]));
        };
        this.getPagePromise = function getPagePromise(index)
        {
            return new Promise(function(resolve, reject){
                function callback(result) {
                    if (result instanceof Error)
                    {
                        reject(result);
                    }
                    else
                    {
                        resolve(new RemotePage(result));
                    }
                }

                try
                {
                    var pageRange = pageRanges[index],
                        pageCount = pageRanges.length;

                    invoker(
                        api,
                        'getSearchPage',
                        [recordType, searchId, filters, columns,
                            pageRange.getCompoundKey(), pageRange.getCompoundLabel(), pageRange.getIndex(),
                            pageSize,
                            pageRanges[0].getCompoundKey(), pageRanges[pageCount - 1].getCompoundKey(),
                            pageCount, null],
                        callback);
                }
                catch(e)
                {
                    reject(e);
                }
            });
        }
    }
    RemotePagedData.prototype = nsobject.getNewInstance();

    var SearchPaging = {};

    SearchPaging.create = function create(options){
        var recordType = options.searchDefinition.searchType,
            searchId = options.searchDefinition.searchId,
            filters = options.filters,//options.searchDefinition.filters,
            columns = options.columns,//options.searchDefinition.columns,
            pageSize = pagingUtil.regulatePageSize(options.pageSize);

        var result = invoker(api, 'getSearchPages', [recordType, searchId, filters, columns, pageSize, null]);
        result.recordType = recordType;
        result.searchId = searchId;
        result.filters = filters;
        result.columns = columns;

        return new RemotePagedData(result);
    };

    SearchPaging.create.promise = function createPromise(options){
        var recordType = options.searchDefinition.searchType,
            searchId = options.searchDefinition.searchId,
            filters = options.filters,//options.searchDefinition.filters,
            columns = options.columns,//options.searchDefinition.columns,
            pageSize = pagingUtil.regulatePageSize(options.pageSize);

        return new Promise(function(resolve, reject){
            function callback(result) {
                if (result instanceof Error)
                {
                    reject(result);
                }
                else
                {
                    result.recordType = recordType;
                    result.searchId = searchId;
                    result.filters = filters;
                    result.columns = columns;

                    resolve(new RemotePagedData(result));
                }
            }

            try
            {
                invoker(api, 'getSearchPages', [recordType, searchId, filters, columns, pageSize, null], callback);
            }
            catch(e)
            {
                reject(e);
            }
        });
    };

    return SearchPaging;
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/pagination/paginationObject
 * @NApiVersion 2.x
 */
define('N/pagination/paginationObject',['N/nsobject', 'N/restricted/invoker', 'N/error', 'N/utilityFunctions'],
       function (nsobject, invoker, error, utilityFunctions)
       {
           var interfaces = {};
           /**
            * PagedData interface
            *
            * @protected
            * @param {Object} delegate PagedData implementation
            * @return {PagedData}
            * @constructor
            */
           function PagedData(delegate)
           {
               var that = this;
               var pageRanges;

               function validateFetchParameter(options)
               {
                   var index;
                   index = options !== undefined && options !== null && !util.isNumber(options) && !util.isString(options) ? options.index : options;
                   utilityFunctions.checkArgs([index],['index'], 'PagedData.fetch');
                   return validateIndex(index);
               }

               function validateIndex(index)
               {
                   var i = parseInt(index, 10);
                   if(isNaN(i))
                       utilityFunctions.throwSuiteScriptError(error.Type.INVALID_PAGE_INDEX, index);

                   return i;
               }
               /**
                * total row count at the time when runPaged is executed.
                * @name PagedData#count
                * @type {Number}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
                */
               Object.defineProperty(this, 'count', {
                   get: function () {
                       return delegate.count;
                   },
                   set: function (val) {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'count' );
                   },
                   enumerable: true,
                   configurable: false
               });
               /**
                * list of PageRange objects that break the entire result set into smaller groups.
                * @name PagedData#pageRanges
                * @type {PageRange[]}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
                */
               Object.defineProperty(this, 'pageRanges', {
                   get: function () {
                       if(!pageRanges)
                       {
                           pageRanges = [];
                           delegate.pageRanges.forEach(function (v) { pageRanges.push(new PageRange(v)); });
                       }
                       return pageRanges;
                   },
                   set: function () {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'pageRanges' );
                   },
                   enumerable: true,
                   configurable: false
               });
               /**
                * Record type of the result.
                * @name PagedData#pageSize
                * @type {Number}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
                */
               Object.defineProperty(this, 'pageSize', {
                   get: function () {
                       return delegate.pageSize;
                   },
                   set: function (val) {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'pageSize' );
                   },
                   enumerable: true,
                   configurable: false
               });
               /**
                * search definition executed for the current pagination result
                * @name PagedData#searchDefinition
                * @type {Search}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
                */
               Object.defineProperty(this, 'searchDefinition', {
                   get: function () {
                       return utilityFunctions.freezeObjectIfPossible(delegate.searchDefinition);
                   },
                   set: function () {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'searchDefinition' );
                   },
                   enumerable: true,
                   configurable: false
               });
               /**
                * fetch data bounded by page index
                * @governance 5 units
                * @param {Object} options the options object
                * @param {Number} options.index the index of the page
                * @return {Page}
                */
               this.fetch = function(options){
                   var index = validateFetchParameter(options);
                   return delegate.fetch(index);
               };

               if(delegate.fetch.promise)
               {
                   /**
                    * fetch data bounded by the pageRange parameter through Promise.
                    * @governance 5 units
                    * @param {Object} options the options object
                    * @param {Number} options.index the index of the page
                    * @return {Promise}
                    */
                   this.fetch.promise = function(options){
                       var index = validateFetchParameter(options);
                       return delegate.fetch.promise(index);
                   }
               }




               function toJSON(){
                   return {
                       count: that.count,
                       pageRanges: that.pageRanges,
                       pageSize: that.pageSize,
                       searchDefinition: that.searchDefinition
                   }
               }

               function toString(){
                   return "search.PagedData";
               }

               /**
                * JSON.stringify() implementation.
                * @returns {Object}
                */
               this.toJSON = toJSON;
               /**
                * Returns the object type name
                * @returns {string}
                */
               this.toString = toString;
           }
           PagedData.prototype = nsobject.getNewInstance();
           utilityFunctions.freezeObjectIfPossible(PagedData);
           interfaces.PagedData = PagedData;


           function ReadonlyPagedData(pagedData)
           {
               var pageRanges;
               Object.defineProperty(this, 'pageRanges', {
                   get: function () {
                       if(!pageRanges)
                       {
                           pageRanges = [];
                           pagedData.pageRanges.forEach(function (v) { pageRanges.push(new PageRange(v)); });
                       }
                       return pageRanges;
                   },
                   enumerable: true,
                   configurable: false
               });
               Object.defineProperty(this, 'count', {
                   value : pagedData.count,
                   enumerable: true,
                   configurable: false,
                   writable: false
               });
               Object.defineProperty(this, 'pageSize', {
                   value : pagedData.pageSize,
                   enumerable: true,
                   configurable: false,
                   writable: false
               });
               Object.defineProperty(this, 'searchDefinition', {
                   value : pagedData.searchDefinition,
                   enumerable: true,
                   configurable: false,
                   writable: false
               });
               /**
                * JSON.stringify() implementation.
                * @returns {Object}
                */
               this.toJSON = pagedData.toJSON;
               /**
                * Returns the object type name
                * @returns {string}
                */
               this.toString = function (){ return "search.PagedData(readonly)"; }
           }
           utilityFunctions.freezeObjectIfPossible(ReadonlyPagedData);

           /**
            * Page interface
            *
            * @protected
            * @param {Object} delegate Page implementation
            * @return {Page}
            * @constructor
            */
           function Page(delegate)
           {
               var that = this;
               var _pageRange, readonlyPagedData;

               function getReadOnlyPagedDataInstance()
               {
                   if (!readonlyPagedData)
                       readonlyPagedData = utilityFunctions.freezeObjectIfPossible(new ReadonlyPagedData(delegate.pagedData));

                   return readonlyPagedData;
               }

               /**
                * the PagedData object that was used to fetch this Page.
                * @name Page#pageData
                * @type {PagedData}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
                */
               Object.defineProperty(this, 'pagedData', {
                   get: function () {
                       return getReadOnlyPagedDataInstance(delegate.pagedData);
                   },
                   set: function () {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'pagedData' );
                   },
                   enumerable: true,
                   configurable: false
               });
               /**
                * page range that describes the boundaries for the data.
                * @name Page#pageRange
                * @type {PageRange}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
                */
               Object.defineProperty(this, 'pageRange', {
                   get: function () {
                       if(!_pageRange)
                       {
                           _pageRange = new PageRange(delegate.pageRange);
                       }
                       return _pageRange;
                   },
                   set: function (val) {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'pageRange' );
                   },
                   enumerable: true,
                   configurable: false
               });
               /**
                * indicates this is the first page of data.
                * @name Page#isFirst
                * @type {boolean}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
                */
               Object.defineProperty(this, 'isFirst', {
                   get: function () {
                       return delegate.isFirst;
                   },
                   set: function (val) {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isFirst' );
                   },
                   enumerable: true,
                   configurable: false
               });
               /**
                * indicates this is the last page of data.
                * @name Page#isLast
                * @type {boolean}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
                */
               Object.defineProperty(this, 'isLast', {
                   get: function () {
                       return delegate.isLast;
                   },
                   set: function (val) {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isLast' );
                   },
                   enumerable: true,
                   configurable: false
               });
               /**
                * the result set.
                * @name Page#data
                * @type {Result[]}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
                */
               Object.defineProperty(this, 'data', {
                   get: function () {
                       return delegate.data;
                   },
                   set: function (val) {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'data' );
                   },
                   enumerable: true,
                   configurable: false
               });
               /**
                * fetch the data bounded by the next pageRange
                * @governance 5 units
                * @return {Page}
                * @throws {SuiteScriptError}
                */
               this.next = delegate.next;
               if(delegate.next.promise)
               {
                   /**
                    * fetch the data bounded by the next pageRange through Promise
                    * @governance 5 units
                    * @return {Promise}
                    */
                   this.next.promise = delegate.next.promise;
               }
               /**
                * fetch the data bounded by the previous pageRange
                * @governance 5 units
                * @return {Page}
                * @throws {SuiteScriptError}
                */
               this.prev = delegate.prev;
               if(delegate.prev.promise)
               {
                   /**
                    * fetch data bounded by the pageRange parameter through Promise.
                    * @governance 5 units
                    * @return {Promise}
                    */
                   this.prev.promise = delegate.prev.promise;
               }

               function toJSON(){
                   return{
                       pagedData: that.pagedData,
                       pageRange: that.pageRange,
                       isFirst: that.isFirst,
                       isLast: that.isLast,
                       data: that.data
                   }
               }

               function toString(){
                   return "search.Page";
               }

               /**
                * JSON.stringify() implementation.
                * @returns {Object}
                */
               this.toJSON = toJSON;
               /**
                * Returns the object type name
                * @returns {string}
                */
               this.toString = toString;

           }
           Page.prototype = nsobject.getNewInstance();
           utilityFunctions.freezeObjectIfPossible(Page);
           interfaces.Page = Page;

           /**
            * PageRange interface
            *
            * @protected
            * @param {Object} delegate PageRange implementation
            * @return {PageRange}
            * @constructor
            */
           function PageRange(delegate)
           {
               var that = this;
               /**
                * the index of the pageRange.
                * @name PageRange#index
                * @type {Number}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                */
               Object.defineProperty(this, 'index', {
                   get: function () {
                       return invoker(delegate,'getIndex', []);
                   },
                   set: function (val) {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'index' );
                   },
                   enumerable: true,
                   configurable: false
               });
               /**
                * Human readable label with beginning and ending range identifiers
                * @name PageRange#compoundLabel
                * @type {String}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                */
               Object.defineProperty(this, 'compoundLabel', {
                   get: function () {
                       return invoker(delegate,'getCompoundLabel', []);
                   },
                   set: function (val) {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'compoundLabel' );
                   },
                   enumerable: true,
                   configurable: false
               });
               function toJSON(){
                   return {
                       index: that.index,
                       compoundLabel: that.compoundLabel
                   }
               }

               function toString(){
                   return "search.PageRange";
               }
               /**
                * JSON.stringify() implementation.
                * @returns {Object}
                */
               this.toJSON = toJSON;
               /**
                * Returns the object type name
                * @returns {string}
                */
               this.toString = toString;
           }
           PageRange.prototype = nsobject.getNewInstance();
           utilityFunctions.freezeObjectIfPossible(PageRange);
           interfaces.PageRange = PageRange;


           return Object.freeze(interfaces);
       });

/**
 * SuiteScript search object constructor
 *
 * @private
 * @module N/search/searchObject
 * @NApiVersion 2.x
 *
 */
define('N/search/searchObject',['N/restricted/searchApi', 'N/restricted/remoteApiBridge', 'N/error', 'N/nsobject', 'N/restricted/invoker', 'N/search/searchPaging', 'N/pagination/paginationObject', 'N/utilityFunctions'],
       function (searchApi, remoteApi, error, nsobject, invoker, searchPaging, paginationObject, utilityFunctions)
       {
           var allowPromise = false;
           var OPERATORS = Object.freeze({
                                             AFTER: 'after',
                                             ALLOF: 'allof',
                                             ANY: 'any',
                                             ANYOF: 'anyof',
                                             BEFORE: 'before',
                                             BETWEEN: 'between',
                                             CONTAINS: 'contains',
                                             DOESNOTCONTAIN: 'doesnotcontain',
                                             DOESNOTSTARTWITH: 'doesnotstartwith',
                                             EQUALTO: 'equalto',
                                             GREATERTHAN: 'greaterthan',
                                             GREATERTHANOREQUALTO: 'greaterthanorequalto',
                                             HASKEYWORDS: 'haskeywords',
                                             IS: 'is',
                                             ISEMPTY: 'isempty',
                                             ISNOT: 'isnot',
                                             ISNOTEMPTY: 'isnotempty',
                                             LESSTHAN: 'lessthan',
                                             LESSTHANOREQUALTO: 'lessthanorequalto',
                                             NONEOF: 'noneof',
                                             NOTAFTER: 'notafter',
                                             NOTALLOF: 'notallof',
                                             NOTBEFORE: 'notbefore',
                                             NOTBETWEEN: 'notbetween',
                                             NOTEQUALTO: 'notequalto',
                                             NOTGREATERTHAN: 'notgreaterthan',
                                             NOTGREATERTHANOREQUALTO: 'notgreaterthanorequalto',
                                             NOTLESSTHAN: 'notlessthan',
                                             NOTLESSTHANOREQUALTO: 'notlessthanorequalto',
                                             NOTON: 'noton',
                                             NOTONORAFTER: 'notonorafter',
                                             NOTONORBEFORE: 'notonorbefore',
                                             NOTWITHIN: 'notwithin',
                                             ON: 'on',
                                             ONORAFTER: 'onorafter',
                                             ONORBEFORE: 'onorbefore',
                                             STARTSWITH: 'startswith',
                                             WITHIN: 'within'
                                         });
	       var ARRAY_BASED_OPERATORS = [OPERATORS.ANYOF, OPERATORS.NONEOF, OPERATORS.ALLOF, OPERATORS.NOTALLOF];
	       var PERIOD_OPERATORS = Object.freeze({
		       ABS: "ABS",
		       REL: "REL"
	       });
           var SUMMARY_TYPES = Object.freeze({
                                                 GROUP: 'GROUP',
                                                 COUNT: 'COUNT',
                                                 SUM: 'SUM',
                                                 AVG: 'AVG',
                                                 MIN: 'MIN',
                                                 MAX: 'MAX'
                                             });
           var FUNCTIONS = Object.freeze({
                                             absoluteValue: '',
                                             ageInHours: '',
                                             ageInDays: '',
                                             ageInMonths: '',
                                             ageInWeeks: '',
                                             ageInYears: '',
                                             calendarWeek: '',
                                             day: '',
                                             month: '',
                                             negate: '',
                                             numberAsTime: '',
                                             percentOfTotal: '',
                                             quarter: '',
                                             rank: '',
                                             round: '',
                                             roundToHundredths: '',
                                             roundToTenths: '',
                                             weekOfYear: '',
                                             year: ''
                                         });
           var SORT = Object.freeze({
                                        ASC: 'ASC',
                                        DESC: 'DESC',
                                        NONE: 'NONE'
                                    });

           function allowPromises(allow)
           {
               allowPromise = allow;
           }
           function applyValidationFunctionToArrayElement(array, func)
           {
               if (!util.isArray(array))
                   return false;
               for (var i = 0; i < array.length; ++i)
               {
                   if (!func(array[i]))
                       return false;
               }
               return true;
           }
           function resolveUndefined(obj)
           {
               return obj === undefined ? null : obj;
           }
           function resolveUndefinedForArguments(args)
           {
               return args.map(function (v, i, a){ return resolveUndefined(v); });
           }

	       function convertJsFiltersToJavaFilters(jsFilters)
	       {
		       var javaFilters = [];
		       for (var i = 0; jsFilters && i < jsFilters.length; i++)
		       {
			       var filterState = jsFilters[i].toJSON();

			       var useArray = filterState.operator && ARRAY_BASED_OPERATORS.indexOf(filterState.operator.toLowerCase()) > -1;
			       var firstValue = (util.isArray(filterState.values)) ? useArray ? filterState.values : filterState.values[0] : null;
			       var secondValue = (util.isArray(filterState.values) && !useArray) ? filterState.values[1] : null;
			       javaFilters[i] = invoker(searchApi, 'createSearchFilter', [filterState.name, filterState.join || null, filterState.operator, firstValue, secondValue]);

			       if (util.isString(filterState.formula))
				       javaFilters[i].setFormula(filterState.formula);
			       if (util.isString(filterState.summarytype))
				       javaFilters[i].setSummaryType(filterState.summarytype);
			       if (util.isBoolean(filterState.isor))
				       javaFilters[i].setOr(filterState.isor);
			       if (util.isBoolean(filterState.isnot))
				       javaFilters[i].setNot(filterState.isnot);
			       if (util.isNumber(filterState.leftparens))
				       javaFilters[i].setLeftParens(filterState.leftparens);
			       if (util.isNumber(filterState.rightparens))
				       javaFilters[i].setRightParens(filterState.rightparens);
		       }
		       return javaFilters;
	       }

	       function convertJsColumnsToJavaColumns(jsColumns)
	       {
		       var javaColumns = [];
		       for (var i = 0; jsColumns && i < jsColumns.length; i++)
		       {
			       var columnState = jsColumns[i].toJSON();

			       javaColumns[i] = invoker(searchApi, 'createSearchColumn', [columnState.name, columnState.join || null, columnState.summary || null]);

			       if (util.isString(columnState.label))
				       javaColumns[i].setLabel(columnState.label);
			       if (util.isString(columnState.sortdir) && columnState.sortdir !== SORT.NONE)
				       javaColumns[i].setSort(/*isDescending*/ columnState.sortdir === SORT.DESC);
			       if (util.isString(columnState.formula))
				       javaColumns[i].setFormula(columnState.formula);
			       if (util.isString(columnState['function']))
				       javaColumns[i].setFunction(columnState['function']);
			       if (util.isString(columnState.whenorderedby))
				       javaColumns[i].setWhenOrderedBy(columnState.whenorderedby, columnState.whenorderedbyjoin);
		       }
		       return javaColumns;
	       }

	       /**
            * Return a new instance of search.Search object.
            *
            * @classDescription Encapsulation of a search.
            * @constructor
            * @param {string} typeOrJavaSearch (optional)  the record type you are searching
            * @param {number} id  the internal ID of the search
            * @param {Filter | array of search.Filter} filters (optional)  a single filter object or an array of filters used to
            *     filter the search
             * @param {Column|string|Column[]|string[]} columns (optional)  columns to be returned from the search
            * @return {Search}
             * @throws {SuiteScriptError} SSS_INVALID_SRCH_FILTER when provided filters contain a different type than search.Filter
             * @throws {SuiteScriptError} SSS_INVALID_SRCH_COLUMN when provided columns contain a different type than search.Column
             *     or string
            *
            * @since 2015.2
            */
           function Search(typeOrJavaSearch, searchId, filters, columns)
           {
               var that = this;
               var TYPE = 'search.Search';

               /* private vars */
               var javaSearch = !util.isString(typeOrJavaSearch) ? typeOrJavaSearch : undefined;
               var jsSearch;
               var _type = util.isString(typeOrJavaSearch) ? typeOrJavaSearch : null;
               var _searchId = searchId;
               var _filters;
               var _columns;
               var _title = null;
               var _scriptId = null;
               var _isPublic = false;
	           
	           /* helper method for loadSearch() */
               this._load = function load(callback)
               {
                   if(!javaSearch)
                       javaSearch = invoker(searchApi, 'nlapiLoadSearch', [_type, _searchId], callback ? loadCallback : null);

                   if (!callback)
                       loadCallback(javaSearch);

                   function loadCallback(javaSearch)
                   {
                       if (javaSearch instanceof Error)
                       {
                           callback(javaSearch)
                       }
                       jsSearch = invoker(remoteApi, 'transform', [javaSearch]);

                       _isPublic = jsSearch.ispublic;
                       _searchId = (jsSearch.searchId === undefined || jsSearch.searchId === null) ? null : parseInt(jsSearch.searchId, 10);
                       _scriptId = jsSearch.scriptid;
                       _type = jsSearch.type;
                        _filters = utilityFunctions.unmarshalArray(jsSearch, 'filter', Filter.unmarshalFilter);
                        _columns = utilityFunctions.unmarshalArray(jsSearch, 'column', Column.unmarshalColumn);
                       if (callback)
                           callback();
                   }
               };

               /**
                * Search type.
                * @name Search#searchType
                * @type string
                * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                */
               Object.defineProperty(this, 'searchType', {
                   get: function ()
                   {
                       return _type;
                   },
                   set: function (val)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'searchType' );
                   },
                   enumerable: true,
                   configurable: false
               });
               /**
                * Internal ID of the search.
                * @name Search#searchId
                * @type number
                * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                */
               Object.defineProperty(this, 'searchId', {
                   get: function ()
                   {
                       return _searchId;
                   },
                   set: function (val)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'searchId' );
                   },
                   enumerable: true,
                   configurable: false
               });
               /**
                * Search filters.
                * @name Search#filters
                * @type Filter[] (setter accepts also a single search.Filter object)
                 * @throws {SuiteScriptError} SSS_INVALID_SRCH_FILTER when setting value of different type than search.Filter
                */
               Object.defineProperty(this, 'filters', {
                   get: function ()
                   {
                       return _filters;
                   },
                   set: function (filters)
                   {
                       _filters = filters ? (util.isArray(filters) ? filters : [filters]) : null;
                       if (_filters !== null)
                       {
                           for (i = 0; i < _filters.length; i++)
                           {
                                if (util.isObject(_filters[i]) )
                                    _filters[i] = createFilter( _filters[i] )
                                else if (!(_filters[i] instanceof Filter))
                                    utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'filters['+i+']', 'Filter' );
                           }
                       }
                   },
                   enumerable: true,
                   configurable: false
               });

               Object.defineProperty(this, '_rawFilters', {
                   get: function ()
                   {
                       return Filter.marshalFilters(_filters);
                   },
                   enumerable: false,
                   configurable: false
               });

               /**
                * Allows to set or get the search filters in the form of a search filter expression.
                * @name Search#filterExpression
                * @type Array[]
                 * @throws {SuiteScriptError} SSS_INVALID_SRCH_FILTER_EXPR when setting invalid search filter expression
                */
               Object.defineProperty(this, 'filterExpression', {
                   get: function ()
                   {
                       var rawFilters = Filter.marshalFilters(_filters);
                       var payload = invoker(remoteApi, 'buildSearchFilterExpression', [rawFilters]);
                       payload = invoker(remoteApi, 'transform', [payload]);
                       return Filter.unmarshalFilterExpression(payload);
                   },
                   set: function (filterExpression)
                   {
                       filterExpression = Filter.normalizeFilters(filterExpression);
                       utilityFunctions.assertTrue(!applyValidationFunctionToArrayElement(filterExpression, Filter.isFilterObject), error.Type.WRONG_PARAMETER_TYPE, 'filterExpression', 'Filter');
                       _filters = Filter.parseFilterExpression(filterExpression);
                   },
                   enumerable: true,
                   configurable: false
               });
               /**
                * Columns to be returned from the search.
                * @name Search#columns
                * @type Column[]|string[] (setter accepts also a single search.Column or string)
                 * @throws {SuiteScriptError} SSS_INVALID_SRCH_COLUMN when setting value of different type than search.Column or
                 *     string
                */
               Object.defineProperty(this, 'columns', {
                   get: function ()
                   {
                       return _columns;
                   },
                   set: function (columns)
                   {
                       _columns = columns ? (util.isArray(columns) ? columns : [columns]) : null;
                       if (_columns !== null)
                       {
                           for (var i = 0; i < _columns.length; i++)
                           {
                                if (util.isObject(_columns[i]))
                                    _columns[i] = createColumn( _columns[i] )
                                else if (util.isString(_columns[i]))
                                   _columns[i] = new Column(getNameFromColumn(_columns[i]), getJoinFromColumn(_columns[i]), null);
                               else if (!(_columns[i] instanceof Column))
                                    utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'columns['+i+']', 'Column' );

                               _columns[i]._setIndex(i + 1);
                           }
                       }
                   },
                   enumerable: true,
                   configurable: false
               });

               Object.defineProperty(this, '_rawColumns', {
                   get: function ()
                   {
                       return Column.marshalColumns(_columns);
                   },
                   enumerable: false,
                   configurable: false
               });

               /**
                * Name of the saved search. Needs to be set before saving the search.
                * @name Search#title
                * @type string
                */
               Object.defineProperty(this, 'title', {
                   get: function ()
                   {
                       return _title;
                   },
                   set: function (val)
                   {
                       _title = val;
                   },
                   enumerable: true,
                   configurable: false
               });
               /**
                * Customer ID of the saved search (string starting with 'customsearch'). If not set, then it is automatically
                * generated upon save.
                * @name Search#id
                * @type string
                */
               Object.defineProperty(this, 'id', {
                   get: function ()
                   {
                       return _scriptId;
                   },
                   set: function (val)
                   {
                       _scriptId = val;
                   },
                   enumerable: true,
                   configurable: false
               });
               /**
                * Specifies whether the search is public or private.
                * @name Search#isPublic
                * @type boolean
                */
               Object.defineProperty(this, 'isPublic', {
                   get: function ()
                   {
                       return _isPublic;
                   },
                   set: function (val)
                   {
                       _isPublic = val;
                   },
                   enumerable: true,
                   configurable: false
               });

               function doSave(callback)
               {
                   var rawFilters = Filter.marshalFilters(_filters);
                   var rawColumns = Column.marshalColumns(_columns);
                   return invoker(searchApi, 'nlapiSaveSearch', [_title, _scriptId, _type, _searchId, rawFilters, rawColumns, _isPublic], callback);
               }

               /**
                * Saves the current search as a saved search. Before calling save() the title property must be set. The optional
                * id property may also be set, if it's not then it's automatically generated. The title and id properties may be
                * set:
                * 1) upon creation (parameters title and id of the options object)
                * 2) by explicitly setting the properties (e.g. Search.title = 'foo'; Search.id = 'customsearch_bar'; )
                * 3) by loading a previously saved search (the properties are inherited)
                * @governance 5 units
                * @returns {number} the internal search ID of the saved search
                 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if title property is not set
                 * @throws {SuiteScriptError} NAME_ALREADY_IN_USE if the search name (title property) is not unique
                 * @throws {SuiteScriptError} SSS_DUPLICATE_SEARCH_SCRIPT_ID if the search ID (id property) is not unique
                * @since 2015.2
                */
               this.save = function save()
               {
                   return parseInt(doSave(), 10);
               };
               if (allowPromise)
               {
					/**
					 * Saves the current search as a saved search. Before calling save() the title property must be set. The
					 * optional id property may also be set, if it's not then it's automatically generated. The title and id
					 * properties may be set:
					 * 1) upon creation (parameters title and id of the options object)
					 * 2) by explicitly setting the properties (e.g. Search.title = 'foo'; Search.id = 'customsearch_bar'; )
					 * 3) by loading a previously saved search (the properties are inherited)
					 * @governance 5 units
					 * @returns {Promise} Promise resolves the internal search ID of the saved search
					 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if title property is not set
					 * @throws {SuiteScriptError} NAME_ALREADY_IN_USE if the search name (title property) is not unique
					 * @throws {SuiteScriptError} SSS_DUPLICATE_SEARCH_SCRIPT_ID if the search ID (id property) is not unique
					 * @since 2015.2
					 */
                   this.save.promise = function ()
                   {
                       var myPromise = new Promise(function (resolve, reject)
                       {
                           try
                           {
                               doSave(callback)
                           }
                           catch (e)
                           {
                               reject(e);
                           }

                           function callback(result)
                           {
                               if (result instanceof Error)
                               {
                                   reject(result)
                               }
                               else
                               {
                                   try
                                   {
                                       resolve(parseInt(result, 10));
                                   }
                                   catch (e)
                                   {
                                       reject(e);
                                   }
                               }
                           }
                       });
                       return myPromise;
                   }
               }
               /**
                * Runs the current search.
                * @returns {ResultSet} the result set object
                * @since 2015.2
                */
               this.run = function run()
               {
                   return new ResultSet(clone());
               };
               /**
                * Runs the current search with a paged interface.
                * @returns {SearchPagedData} PagedData object that allows user to page through the search result
                * @since 2016.1
                */
               this.runPaged = function runPaged(options)
               {
                   var pageSize = options && options.pageSize;

                   var pagedData = new SearchPagedData({
                       delegate: searchPaging.create({
                                                         searchDefinition: that,
                                                         filters: Filter.marshalFilters(that.filters),
                                                         columns: Column.marshalColumns(that.columns),
                                                         pageSize: pageSize
                                                     }),
                       searchDefinition: that
                   });
                   return new paginationObject.PagedData(pagedData);
               };
               /**
                * Runs the current search with a paged interface.
                * @returns {Promise} A promise object returning a PagedData object that allows user to page through the search
                *     result
                * @since 2016.1
                */
               if(allowPromise)
               {
                   this.runPaged.promise = function runPaged(options)
                   {
                       var pageSize = options && options.pageSize;

                       return searchPaging.create.promise({
                                                              searchDefinition: that,
                                                              filters: Filter.marshalFilters(that.filters),
                                                              columns: Column.marshalColumns(that.columns),
                                                              pageSize: pageSize
                                                          }).then(function(value){
                           var pagedData = new SearchPagedData({
                               delegate: value,
                               searchDefinition: that
                           });
                           return new paginationObject.PagedData(pagedData);
                       });
                   };
               }
               /**
                * Returns the object type name (search.Search)
                * @returns {string}
                */
               this.toString = function toString()
               {
                   return TYPE;
               };
               /**
                * JSON.stringify() implementation.
                * @returns {Object}
                */
               this.toJSON = function toJSON()
               {
                   return {
                       type: _type,
                       id: _searchId,
                       filters: _filters,
                       columns: _columns,
                       title: _title,
                       scriptId: _scriptId,
                       isPublic: _isPublic
                   };
               };

               /* private methods */
               function clone()
               {
                   var i;
                   var filtersCopy = [];
                   for (i = 0; _filters && i < _filters.length; ++i)
                       filtersCopy.push(_filters[i]._clone());

                   var columnsCopy = [];
                   for (i = 0; _columns && i < _columns.length; ++i)
                       columnsCopy.push(_columns[i]._clone());
                   var clone = new Search(_type, _searchId, filtersCopy, columnsCopy);
                   clone.title = _title;
                   clone.id = _scriptId;
                   clone.isPublic = _isPublic;
                   return clone;
               }

	           this.redirectToSearch = function redirectToSearch()
	           {
		           var javaFilters = convertJsFiltersToJavaFilters(_filters);
		           var javaColumns = convertJsColumnsToJavaColumns(_columns);

		           if (!javaSearch) {
			           if (_searchId === -1 || searchId === '-1')
				           javaSearch = invoker(searchApi, 'nlapiCreateSearch', [_type, javaFilters, javaColumns]);
			           else
			           {
				           javaSearch = invoker(searchApi, 'nlapiLoadSearch', [_type, _searchId]);
				           javaSearch.addFilters(javaFilters);
				           javaSearch.addColumns(javaColumns);
			           }
		           }

		           return invoker(javaSearch, 'setRedirectURLToSearch', []);
	           };

	           this.redirectToSearchResults = function redirectToSearchResults()
	           {
		           var javaFilters = convertJsFiltersToJavaFilters(_filters);
		           var javaColumns = convertJsColumnsToJavaColumns(_columns);

		           if (!javaSearch)
		           {
			           if (_searchId === -1 || searchId === '-1')
				           javaSearch = invoker(searchApi, 'nlapiCreateSearch', [_type, javaFilters, javaColumns]);
			           else
			           {
				           javaSearch = invoker(searchApi, 'nlapiLoadSearch', [_type, _searchId]);
				           javaSearch.addFilters(javaFilters);
				           javaSearch.addColumns(javaColumns);
			           }
		           }

		           return invoker(javaSearch, 'setRedirectURLToSearchResults', []);
	           };

               // this ensures that the checks in filter/column setters are also executed upon construction
               this.filters = filters;
               this.columns = columns;
           }
           Search.prototype = nsobject.getNewInstance();

           /**
            * Return a new instance of search.Filter object.
            *
            * @classDescription Encapsulation of a search filter.
            * @protected
            * @constructor
             * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
             * @throws {SuiteScriptError} SSS_INVALID_SRCH_OPERATOR if an unknown operator is provided
            *
            * @since 2015.2
            */
           function Filter(name, join, operator, values)
           {
               var TYPE = 'search.Filter';

               //constructor logic
                utilityFunctions.checkArgs([name, operator], ['name', 'operator'], 'search.Filter');

               /* private instance vars */
               var _name = name;
               var _join = join;
               if (!util.isString(operator) || (!OPERATORS[operator.toUpperCase()] && !PERIOD_OPERATORS[operator.toUpperCase()]))
                    utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_SRCH_OPERATOR, operator + "", "[" + Object.keys(OPERATORS).join(", ") + "]");

               var _operator = operator;
               var _values = null;
               var formula = null;
               var summarytype = null;
               var isor = false;
               var isnot = false;
               var leftparens = 0;
               var rightparens = 0;

               addValue(values);

               /* private methods */
               function addValue(val)
               {
                   if (!_values)
                       _values = [];
                   if (util.isArray(val))
                   {
                       for (var i = 0; i < val.length; i++)
                       {
                           if (val[i] || val[i] === 0)
                               _values.push(val[i].toString());
                       }
                   }
                   else if (val !== null && val !== undefined)
                       _values.push(val.toString());

                   return _values;
               }

               /* public undocumented methods */
               this._clone = function _clone()
               {
                   var clone = new Filter(_name, _join, _operator, _values);
                   clone._unmarshal(this._marshal());
                   return clone;
               };
               this._unmarshal = function _unmarshal(filterJSON)
               {
                   formula = filterJSON.formula;
                   summarytype = filterJSON.summarytype;
                   isor = filterJSON.isor;
                   isnot = filterJSON.isnot;
                   leftparens = filterJSON.leftparens;
                   rightparens = filterJSON.rightparens;
               };
               this._marshal = function _marshal()
               {
                   var filterObject = {};
                   filterObject.name = _name;
                   filterObject.join = _join;
                   filterObject.operator = _operator;
                   filterObject.values = (!_values || _values.length === 0) ? null : _values;
                   filterObject.formula = formula;
                   filterObject.summarytype = summarytype;
                   filterObject.isor = isor;
                   filterObject.isnot = isnot;
                   filterObject.leftparens = leftparens;
                   filterObject.rightparens = rightparens;
                   return filterObject;
               };

               /**
                * Field name for this search filter.
                * @name Filter#name
                * @type string
                * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                */
               Object.defineProperty(this, 'name', {
                   get: function ()
                   {
                       return _name;
                   },
                   set: function (val)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'name' );
                   },
                   enumerable: true,
                   configurable: false
               });
               /**
                * Join ID for this search filter.
                * @name Filter#join
                * @type string
                * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                */
               Object.defineProperty(this, 'join', {
                   get: function ()
                   {
                       return _join;
                   },
                   set: function (val)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'join' );
                   },
                   enumerable: true,
                   configurable: false
               });
               /**
                * Filter operator.
                * @name Filter#operator
                * @type string
                * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                */
               Object.defineProperty(this, 'operator', {
                   get: function ()
                   {
                       return _operator;
                   },
                   set: function (val)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'operator' );
                   },
                   enumerable: true,
                   configurable: false
               });
               /**
                * Summary type for this search filter.
                * @name Filter#summary
                 * @type string
                 * @throws {SuiteScriptError} SSS_INVALID_SRCH_FILTER_SUM when setting invalid summary type
                */
               Object.defineProperty(this, 'summary', {
                   get: function ()
                   {
                       return summarytype;
                   },
                   set: function (type)
                   {
                       if (!util.isString(type) || !SUMMARY_TYPES[type.toUpperCase()])
                            utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'summary', JSON.stringify(Object.keys(SUMMARY_TYPES)) );

                       summarytype = type.toUpperCase();
                   },
                   enumerable: true,
                   configurable: false
               });
               /**
                * Formula used for this search filter.
                * @name Filter#formula
                * @type string
                */
               Object.defineProperty(this, 'formula', {
                   get: function ()
                   {
                       return formula;
                   },
                   set: function (sformula)
                   {
                       formula = sformula;
                   },
                   enumerable: true,
                   configurable: false
               });
               /**
                * Returns the object type name (search.Filter)
                * @returns {string}
                */
               this.toString = function toString()
               {
                   return TYPE;
               };
               /**
                * JSON.stringify() implementation.
                * @returns {Object}
                */
               this.toJSON = function toJSON()
               {
                   return {
                       name: _name,
                       join: _join,
                       operator: _operator,
                       values: _values,
                       formula: formula,
                       summarytype: summarytype,
                       isor: isor,
                       isnot: isnot,
                       leftparens: leftparens,
                       rightparens: rightparens
                   };
               }
           }
           Filter.prototype = nsobject.getNewInstance();

           /* public static methods */
           /*----- Helper function used for parse search filter expression -----*/
           Filter.parseFilterExpression = function (filterExpression, callback)
           {
               if (applyValidationFunctionToArrayElement(filterExpression, Filter.isFilterObject))
               {
                   if (callback)
                   {
                       callback(filterExpression);
                       return;
                   }
                   else
                   {
                       return filterExpression;
                   }
               }
               checkFilterExpression(filterExpression, 'filters');
               var marshaled = Filter.marshalFiltersOrExpression(filterExpression);
               if (!callback)
               {
                   var javaResult = invoker(remoteApi, 'parseSearchFilterExpression', [marshaled]);
                   return filterCallback(javaResult);
               }
               else
               {
                   invoker(remoteApi, 'parseSearchFilterExpression', [marshaled], filterCallback)
               }

               function filterCallback(javaResult)
               {
                   var nativeResult = invoker(remoteApi, 'transform', [javaResult]);
                   var result = [];
                   for (var i = 0; nativeResult && i < nativeResult.length; i++)
                   {
                       result.push(Filter.unmarshalFilter(nativeResult[i]));
                   }
                   if (callback)
                       callback(result);
                   else
                       return result;
               }
           };

           /*----- Helper function used for marshalling js search.Filter for Remote API -----*/
           Filter.marshalFiltersOrExpression = function (filtersOrExpression)
           {
               if (typeof filtersOrExpression === 'undefined' || filtersOrExpression === null)
                   return null;
                utilityFunctions.assertTrue(util.isArray(filtersOrExpression), error.Type.WRONG_PARAMETER_TYPE,filtersOrExpression,'Array');
                return utilityFunctions.arrayToMap(filtersOrExpression, function (elem)
               {
                   if (Filter.isFilterObject(elem))
                       return elem._marshal();
                   var container = {javaClass: "java.util.HashMap"};
                   if (util.isArray(elem))
                       container.arrayValue = Filter.marshalFiltersOrExpression(elem);
                   else
                       container.stringValue = elem;
                   return container;
               });
           };

           Filter.isFilterObject = function (obj)
           {
                return (obj instanceof Filter) || util.isObject(obj);
           };

           Filter.marshalFilters = function (filters)
           {
               filters = utilityFunctions.getAsArray(filters);
                utilityFunctions.assertArrayElementsOfSameType(filters, Filter, 'filters');

               /* add filter. */
               var rawFilters = [];
               for (var i = 0; filters && i < filters.length; i++)
               {
                   rawFilters.push(filters[i]._marshal());
               }
               return rawFilters;
           };

           Filter.unmarshalFilterExpression = function (mapArrayPayload)
           {
                return utilityFunctions.arrayToMap(mapArrayPayload, function (map)
               {
                   if (map.arrayValue != null)
                       return Filter.unmarshalFilterExpression(map.arrayValue);
                   if (map.stringValue != null)
                       return map.stringValue;
                   return Filter.unmarshalFilter(map);
               });
           };

           /*----- Helper function used for unmarshalling search.Filter from server. -----*/
           Filter.unmarshalFilter = function (filterJSON)
           {
               var filter = new Filter(filterJSON.name, filterJSON.join, filterJSON.operator, filterJSON.values);
               filter._unmarshal(filterJSON);
               return filter;
           };

           Filter.normalizeFilters = function (filters)
           {
               return (Filter.isFilterObject(filters) || isFilterExpressionArray(filters)) ? [filters] : (!filters ? null : filters);
           };

           /*----- Helper function to validate search filter expression (advanced search) -----*/
           function checkFilterExpression(array, name)
           {
               utilityFunctions.assertTrue(!array || applyValidationFunctionToArrayElement(array, isFilterExpTerm), error.Type.WRONG_PARAMETER_TYPE, name, 'Array');
           }

           function isFilterExpTerm(obj)
           {
               if (typeof obj === 'undefined' || !obj)
                   return false;
               if (util.isString(obj))
                   return /not|and|or/i.test(obj);
               if (isFilterExpressionArray(obj))
                   return true;
               return applyValidationFunctionToArrayElement(obj, isFilterExpTerm);
           }

           function isFilterExpressionArray(array)
           {
               return util.isArray(array) && array.length >= 3 && util.isString(array[0]) && util.isString(array[1]) && !/^not$/i.test(array[0]);
           }

           /**
            * Return a new instance of search.Column object.
            *
            * @classDescription Encapsulation of a search column.
            * @protected
            * @constructor
             * @throws {SuiteScriptError} SSS_INVALID_SRCH_COLUMN_SUM if an unknown summary type is provided
            *
            * @since 2015.2
            */
           function Column(name, join, summary)
           {
               var TYPE = 'search.Column';

               //constructor logic
                utilityFunctions.checkArgs([name], ['name'], 'search.Column');

               if (summary != null && (!util.isString(summary) || !SUMMARY_TYPES[summary.toUpperCase()]))
                    utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'summary', Object.keys(SUMMARY_TYPES) );

               /* private vars */
               var that = this;
               var type = null;
               var label = null;
               var functionid = null;
               var formula = null;
               var sortdir = SORT.NONE;
               var index = -1;
               var userindex = -1;
               var whenorderedby = null;
               var whenorderedbyjoin = null;

               /**
                * The name of the search column.
                * @name Column#name
                * @type string
                * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                */
               Object.defineProperty(this, 'name', {
                   get: function ()
                   {
                       return name;
                   },
                   set: function (val)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'name');
                   },
                   enumerable: true,
                   configurable: false
               });
               /**
                * The join ID for this search column.
                * @name Column#join
                * @type string
                * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                */
               Object.defineProperty(this, 'join', {
                   get: function ()
                   {
                       return join;
                   },
                   set: function (val)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'join');
                   },
                   enumerable: true,
                   configurable: false
               });
               /**
                * The summary type for this search column.
                * @name Column#summary
                 * @type string
                * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                */
               Object.defineProperty(this, 'summary', {
                   get: function ()
                   {
                       return summary != null ? summary.toUpperCase() : null;
                   },
                   set: function (val)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'summary');
                   },
                   enumerable: true,
                   configurable: false
               });
               /**
                * The formula used for this search column.
                * @name Column#formula
                * @type string
                */
               Object.defineProperty(this, 'formula', {
                   get: function ()
                   {
                       return formula;
                   },
                   set: function (sformula)
                   {
                       formula = sformula;
                   },
                   enumerable: true,
                   configurable: false
               });
               /**
                * The label used for this search column.
                * @name Column#label
                * @type string
                */
               Object.defineProperty(this, 'label', {
                   get: function ()
                   {
                       return label;
                   },
                   set: function (slabel)
                   {
                       label = slabel;
                   },
                   enumerable: true,
                   configurable: false
               });
               /**
                * The function used in this search column.
                * @name Column#function
                * @type string
                 * @throws {SuiteScriptError} INVALID_SRCH_FUNCTN when setting an unknown function is attempted
                */
               Object.defineProperty(this, 'function', {
                   get: function ()
                   {
                       return functionid == null ? 'none' : functionid;
                   },
                   set: function (sfunctionid)
                   {
                       if (sfunctionid === 'none' || sfunctionid === null)
                           functionid = null;
                       else
                       {
                            utilityFunctions.assertTrue(sfunctionid && FUNCTIONS[sfunctionid] != null, error.Type.WRONG_PARAMETER_TYPE, sfunctionid, Object.keys(FUNCTIONS) );
                           functionid = sfunctionid;
                       }
                   },
                   enumerable: true,
                   configurable: false
               });
               /**
                * The sort direction for this search column. Use values from the Sort enum.
                * @name Column#sort
                * @type string
                */
               Object.defineProperty(this, 'sort', {
                   get: function ()
                   {
                       return sortdir;
                   },
                   set: function (direction)
                   {
                        utilityFunctions.assertTrue(direction && SORT[direction], error.Type.WRONG_PARAMETER_TYPE, direction, Object.keys(SORT));
                       sortdir = SORT[direction];
                   },
                   enumerable: true,
                   configurable: false
               });
               /**
                * Returns the search column for which the minimal or maximal value should be found when returning the search.Column
                * value. For example, can be set to find the most recent or earliest date, or the largest or smallest amount for a
                * record, and then the search.Column value for that record is returned. Can only be used when summary type is MIN
                * or MAX.
                * @param {Object} options  the options object
                * @param {string} options.name  name of the search column for which the minimal or maximal value should be found
                * @param {string} options.join  join id for this search column
                 * @returns {Column} this search column
                * @since 2015.2
                */
               this.setWhenOrderedBy = function setWhenOrderedBy(options)
               {
                   var name = null, join = null;

                   if (options && (options.hasOwnProperty('name') || options.hasOwnProperty('join')))
                   {
                       name = options.name;
                       join = options.join;
                   }
                   else
                   {
                       name = options;
                       join = arguments[1];
                   }
                    utilityFunctions.checkArgs([name, join], ['name', 'join'], 'Column.setWhenOrderedBy');
                   whenorderedby = name;
                   whenorderedbyjoin = join;
                   return that;
               };
               /**
                * Returns the object type name (search.Column)
                * @returns {string}
                */
               this.toString = function toString()
               {
                   return TYPE;
               };
               /**
                * JSON.stringify() implementation.
                * @returns {Object}
                */
               this.toJSON = function toJSON()
               {
                   return {
                       name: name,
                       join: join,
                       summary: summary,
                       label: label,
                       type: type,
                       'function': functionid,
                       formula: formula,
                       sortdir: sortdir,
                       whenorderedby: whenorderedby,
                       whenorderedbyjoin: whenorderedbyjoin
                   };
               };

               /* public undocumented methods */
               this._setType = function _setType(sType) { type = sType; };
               this._getIndex = function _getIndex() { return index };
               this._setIndex = function _setIndex(nIndex)
               {
                   index = nIndex;
                   return that;
               };
               this._setUserIndex = function _setUserIndex(nUserIndex)
               {
                   userindex = nUserIndex;
                   return that;
               };
               this._clone = function _clone()
               {
                   var clone = new Column(name, join, summary);
                   clone._unmarshal(this._marshal());
                   clone._setIndex(index);
                   clone._setUserIndex(userindex);
                   return clone;
               };
               this._unmarshal = function _unmarshal(columnJSON)
               {
                   label = columnJSON.label;
                   type = columnJSON.type;
                   functionid = columnJSON.functionid;
                   formula = columnJSON.formula;
                   sortdir = columnJSON.sortdir ? columnJSON.sortdir : SORT.NONE;
                   whenorderedby = columnJSON.whenorderedby;
                   whenorderedbyjoin = columnJSON.whenorderedbyjoin;
                   return that;
               };
               this._marshal = function _marshal()
               {
                   return {
                       name: name,
                       join: join,
                       summary: summary,
                       label: label,
                       type: type,
                       functionid: functionid,
                       formula: formula,
                       sortdir: sortdir === SORT.NONE ? null : sortdir,
                       index: index,
                       userindex: userindex,
                       whenorderedby: whenorderedby,
                       whenorderedbyjoin: whenorderedbyjoin
                   };
               };
           }

           Column.prototype = nsobject.getNewInstance();

           /* public static methods */
           /*----- Helper function used for marshalling js search.Column for Remote API -----*/
           Column.marshalColumns = function marshalColumns(columns)
           {
               columns = utilityFunctions.getAsArray(columns);
                utilityFunctions.assertArrayElementsOfSameType(columns, Column, 'columns');

               /* add columns. */
               var rawColumns = [];
               for (var i = 0; columns && i < columns.length; i++)
               {
                   columns[i]._setUserIndex(i + 1);
                   rawColumns.push(columns[i]._marshal());
               }
               return rawColumns;
           };

           Column.unmarshalColumn = function unmarshalColumn(columnJSON)
           {
               var col = new Column(columnJSON.name, columnJSON.join, columnJSON.summary);
               return col._unmarshal(columnJSON);
           };

           function getNameFromColumn(column)
           {
               return column.indexOf('.') !== -1 ? column.substring(column.indexOf('.') + 1) : column;
           }

           function getJoinFromColumn(column)
           {
               return column.indexOf('.') !== -1 ? column.substring(0, column.indexOf('.')) : null;
           }

           /**
            * Return a new instance of search.ResultSet object.
            *
            * @classDescription Encapsulation of a search result set.
            * @protected
            * @constructor
            *
            * @since 2015.2
            */
           function ResultSet(searchObject)
           {
               var TYPE = 'search.ResultSet';

               var search = searchObject;
               var FOR_EACH_RESULT_MAX_ROWS = 4000;
               var FOR_EACH_RESULT_MAX_ROWS_ERR_MSG = 'No more than ' + FOR_EACH_RESULT_MAX_ROWS + ' search results may be returned at one time from ResultSet.each(). Please revise your search criteria or modify the callback logic so that no more than ' + FOR_EACH_RESULT_MAX_ROWS + ' results are returned.';

               /**
                * List of columns contained in this result set.
                * @name ResultSet#columns
                * @type Column[]
                * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                */
               Object.defineProperty(this, 'columns', {
                   get: function ()
                   {
                       return search.columns;
                   },
                   set: function (val)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'columns' );
                   },
                   enumerable: true,
                   configurable: false
               });


               Object.defineProperty(this, '_getResultset', {
                   get: function ()
                   {
                       var start = 0, end = 1000;
                       var rawFilters = Filter.marshalFilters(search.filters);
                       var rawColumns = Column.marshalColumns(search.columns);
                       var javaResults = invoker(searchApi, 'nlapiSearchRange', [search.searchType, search.id, rawFilters, rawColumns, start, end]);
                       return javaResults;
                   },
                   enumerable: false,
                   configurable: false
               });

               function getRange_postProcess(javaResults)
               {
                   var rawResults = invoker(remoteApi, 'transform', [javaResults]);
                   return Result.extractResults(rawResults, search.columns, javaResults);
               }

               /**
                * Retrieve a slice of the search result set. Only 1000 results can be returned at a time. If there are fewer results
                * available than requested, then the array will be truncated.
                * @governance 10 units
                * @param {Object} options  the options object
                * @param {number} options.start  the index number of the first result to return, inclusive
                * @param {number} options.end  the index number of the last result to return, exclusive
                * @returns {Result[]} the requested slice of the search result set
                * @since 2015.2
                */
               this.getRange = function getRange()
               {
                   var start = null, end = null;
                   if (arguments[0] && (arguments[0].hasOwnProperty('start') || arguments[0].hasOwnProperty('end')))
                   {
                       start = arguments[0].start;
                       end = arguments[0].end;
                   }
                   else
                   {
                       start = arguments[0];
                       end = arguments[1];
                   }
                    utilityFunctions.checkArgs([start, end], ['start', 'end'], 'ResultSet.getRange');

                    utilityFunctions.assertTrue(start >= 0, error.Type.SSS_INVALID_SEARCH_RESULT_INDEX);
                    utilityFunctions.assertTrue((end - start) <= 1000, error.Type.SSS_SEARCH_RESULT_LIMIT_EXCEEDED);
                   if (start >= end)
                       return [];

                   var rawFilters = Filter.marshalFilters(search.filters);
                   var rawColumns = Column.marshalColumns(search.columns);
                   var javaResults = invoker(searchApi, 'nlapiSearchRange', [search.searchType, search.id, rawFilters, rawColumns, start, end]);
                   return getRange_postProcess(javaResults);
               };
               if (allowPromise)
               {
                   this.getRange.promise = function ()
                   {
                       var args = arguments;
                       var myPromise = new Promise(function (resolve, reject)
                       {
                           try
                           {
                               var start = null, end = null;
                               if (args[0] && (args[0].hasOwnProperty('start') || args[0].hasOwnProperty('end')))
                               {
                                   start = args[0].start;
                                   end = args[0].end;
                               }
                               else
                               {
                                   start = args[0];
                                   end = args[1];
                               }
                               utilityFunctions.checkArgs([start, end], ['start', 'end'], 'ResultSet.getRange');

                               utilityFunctions.assertTrue(start >= 0, error.Type.SSS_INVALID_SEARCH_RESULT_INDEX);
                               utilityFunctions.assertTrue((end - start) <= 1000, error.Type.SSS_SEARCH_RESULT_LIMIT_EXCEEDED);
                               if (start >= end)
                                   resolve([]);

                               var rawFilters = Filter.marshalFilters(search.filters);
                               var rawColumns = Column.marshalColumns(search.columns);
                               invoker(searchApi, 'nlapiSearchRange', [search.searchType, search.id, rawFilters, rawColumns, start, end], callback);
                           }
                           catch (e)
                           {
                               reject(e);
                           }

                           function callback(result)
                           {
                               if (result instanceof Error)
                               {
                                   reject(result)
                               }
                               else
                               {
                                   try
                                   {
                                       resolve(getRange_postProcess(result));
                                   }
                                   catch (e)
                                   {
                                       reject(e);
                                   }
                               }
                           }
                       });
                       return myPromise
                   }
               }

               /**
                * Calls the developer-defined callback function for every result in this set. The result set processed by each()
                * may have maximum 4000 rows. The callback function has the following signature: boolean callback(result.Result
                * result); If the return value of the callback is false, the iteration over results is stopped, otherwise it
                * continues. Note that the work done in the context of the callback function counts towards the governance of the
                * script that called it.
                * @governance 10 units
                * @param {Function} callback  the function called for each result in the result set
                * @returns {undefined}
                * @since 2015.2
                */
               this.each = function each(callback)
               {
                   var remoteId = null;
                   var rawFilters = Filter.marshalFilters(search.filters);
                   var rawColumns = Column.marshalColumns(search.columns);

                   var returnedRowCount = 0;
                   var PAGE_SIZE = 500;  // number of search results per request
                   var continueIteration = true;
                   var start = 0;
                   try
                   {
                       while (continueIteration)
                       {
                           var javaResults = invoker(searchApi, 'nlapiContinueSearch', [search.searchType, search.id, rawFilters, rawColumns, remoteId, start, start + PAGE_SIZE]);
                           var rawResults = invoker(remoteApi, 'transform', [javaResults]);
                           var searchResults = Result.extractResults(rawResults, search.columns);
                           if (searchResults == null || searchResults.length == 0)
                               break;

                           for (var i = 0; continueIteration && i < searchResults.length; i++)
                           {
                                utilityFunctions.assertTrue(returnedRowCount < FOR_EACH_RESULT_MAX_ROWS, error.Type.SSS_SEARCH_FOR_EACH_LIMIT_EXCEEDED, FOR_EACH_RESULT_MAX_ROWS);
                               continueIteration = callback(searchResults[i]);
                               returnedRowCount++;
                           }

                           if (!remoteId)
                               remoteId = rawResults[0].remoteid;

                           if (searchResults.length < PAGE_SIZE)
                               break;
                           start += PAGE_SIZE;
                       }
                   }
                   finally
                   {
                       invoker(searchApi, 'nlapiEndSearch', [remoteId]);
                   }
               };

               if (allowPromise)
               {
                   this.each.promise = function promise(callback)
                   {
                       var remoteId = null;
                       var rawFilters = Filter.marshalFilters(search.filters);
                       var rawColumns = Column.marshalColumns(search.columns);

                       var returnedRowCount = 0;
                       var PAGE_SIZE = 500;  // number of search results per request
                       var continueIteration = true;
                       var start = 0;

                       var myPromise = new Promise(
                               function (resolve, reject)
                               {
                                   var loop = function ()
                                   {
                                       return new Promise(function (resolveInner, rejectInner)
                                       {
                                           invoker(searchApi, 'nlapiContinueSearch', [search.searchType, search.id, rawFilters, rawColumns, remoteId, start, start + PAGE_SIZE], resolveInner);
                                       }).then(function (result)
                                               {
                                                   var rawResults = invoker(remoteApi, 'transform', [result]);
                                                   var searchResults = Result.extractResults(rawResults, search.columns);
                                                   if (searchResults == null || searchResults.length == 0)
                                                   {
                                                       resolve(true);
                                                       return false;
                                                   }

                                                   for (var i = 0; continueIteration && i < searchResults.length; i++)
                                                   {
                                                       utilityFunctions.assertTrue(returnedRowCount < FOR_EACH_RESULT_MAX_ROWS, error.Type.SSS_SEARCH_FOR_EACH_LIMIT_EXCEEDED, FOR_EACH_RESULT_MAX_ROWS);
                                                       continueIteration = callback(searchResults[i]);
                                                       returnedRowCount++;
                                                   }

                                                   if (!remoteId)
                                                       remoteId = rawResults[0].remoteid;

                                                   if (searchResults.length < PAGE_SIZE)
                                                   {
                                                       resolve(true);
                                                       return false;
                                                   }
                                                   start += PAGE_SIZE;
                                                   return true;
                                               })
                                               .then(function (keepGoing) { if (keepGoing) loop() })
                                               .then(undefined, function (reason) { reject(reason) });
                                   };

                                   loop().then(function () { invoker(searchApi, 'nlapiEndSearch', [remoteId]) });
                               }
                       );
                       return myPromise
                   }
               }
               /**
                * Returns the object type name (search.ResultSet)
                * @returns {string}
                */
               this.toString = function toString()
               {
                   return TYPE;
               };
               /**
                * JSON.stringify() implementation.
                 * @returns {Object}
                */
               this.toJSON = function toJSON()
               {
                   return {
                       columns: search.columns
                   };
               }
           }

           ResultSet.prototype = nsobject.getNewInstance();

           /**
            * Return a new instance of search.Result object.
            *
            * @classDescription Encapsulation of a search result.
            * @protected
            * @constructor
            *
            * @since 2015.2
            */
           function Result(type, id, rawValues, rawColumns, javaResult)
           {
               var TYPE = 'search.Result';

               /* index values by legacy key for performance - lazy loaded */
               var valuesByKey = {};
               var valuesByKeyMapPopulated = false;

               /* private methods */
               function getCellAttribute(nameOrColumn, join, summary, func, attribute)
               {
                   var cell = null;
                   if (util.isString(nameOrColumn))
                   {
	                   var name = nameOrColumn
                       populateValueByKeyMap();
                       cell = valuesByKey[getKey(name, join, summary, undefined, func)];
                   }
                   else if (nameOrColumn instanceof Column)
                   {
	                   var column = nameOrColumn;
                       if (column._getIndex() !== -1)
                           cell = rawValues[column._getIndex() - 1];
                       if (!cell)
                       {
                           populateValueByKeyMap();
                           cell = valuesByKey[getKey(column.name, column.join, column.summary, column.formula)]
                       }
                   }
                   return (cell != null && cell[attribute] != null) ? cell[attribute] : null;
               }

               function getKey(name, join, summary, formula, func)
               {
                   return (join ? join.toLowerCase() + '_' : '')
	                   + name.toLowerCase()
	                   + (summary ? '_' + summary.toLowerCase() : '')
	                   + (formula ? '_' + formula.toLowerCase() : '')
	                   + (func && func !== 'none' ? '_' + func.toLowerCase() : '');
               }

               function populateValueByKeyMap()
               {
                   if (!valuesByKeyMapPopulated)
                   {
                       // populate the map
                       for (var i = 0; rawValues != null && i < rawValues.length; i++)
                       {
	                       var name = rawColumns[i]['name'];
	                       var join = rawColumns[i]['join'];
	                       var summary = rawColumns[i]['summary'];
	                       var formula = rawColumns[i]['formula'];
	                       var func = rawColumns[i]['function'];
	                       var key;

	                       key = getKey(name, join, summary, formula, func);
	                       valuesByKey[key] = rawValues[i];

	                       key = getKey(name, join, summary, formula, null);
	                       if (valuesByKey[key] === undefined)
		                       valuesByKey[key] = rawValues[i];

	                       /*
	                        For backwards compatibility, we continue to support the ability to refer to a formula column via its
	                        non-unique name, for example 'formulatext'. If multiple formula columns of the same type are present,
	                        the last one will overwrite any previous values which is obviously odd. This behavior should not be
	                        ported to future major versions of this API.
	                        */
	                       if (func)
	                       {
		                       key = getKey(name, join, summary, null, func);
		                       valuesByKey[key] = rawValues[i];

		                       key = getKey(name, join, summary, null, null);
		                       if (valuesByKey[key] === undefined)
			                       valuesByKey[key] = rawValues[i];
	                       }
                       }
                       valuesByKeyMapPopulated = true;
                   }
               }

               /**
                * Record type of the result.
                * @name Result#recordType
                * @type string
                * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                */
               Object.defineProperty(this, 'recordType', {
                   get: function ()
                   {
                       return type;
                   },
                   set: function (val)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'recordType' );
                   },
                   enumerable: true,
                   configurable: false
               });
               /**
                * Record internal ID of the result.
                * @name Result#id
                * @type number
                * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                */
               Object.defineProperty(this, 'id', {
                   get: function ()
                   {
                       return id;
                   },
                   set: function (val)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'id' );
                   },
                   enumerable: true,
                   configurable: false
               });
               /**
                * List of columns contained in this result.
                * @name Result#columns
                * @type Column[]
                * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                */
               Object.defineProperty(this, 'columns', {
                   get: function ()
                   {
                       return rawColumns;
                   },
                   set: function (val)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'columns' );
                   },
                   enumerable: true,
                   configurable: false
               });


               Object.defineProperty(this, '_saveToTemplateRenderer', {
                   get: function ()
                   {
                       return javaResult;
                   },
                   set: function (val)
                   {
                       return;
                   },
                   enumerable: false,
                   configurable: false
               });

               /**
                * Returns the value of a specified search return column. The column may be specified in two ways:
                * 1) by providing a search.Column object
                * 2) by providing name, join and summary parameters
                * @param {search.Column} column  search return column object whose value you want to return
                * - or -
                * @param {Object} options  the options object
                * @param {string} options.name  the name of the search column whose value you want to return
                * @param {string} options.join (optional)  the join ID for this search column
                 * @param {string} options.summary (optional)  the summary type used for this search column
                * @returns {string} string value of the search result column
                * @since 2015.2
                */
               this.getValue = function getValue(options)
               {
                   var name, join, summary, func;
                   if(!!options && !util.isString(options))
                   {
                       name = options.name;
                       join = options.join;
                       summary = options.summary;
	                   func = options.func || options['function'];
                   }
                   else
                   {
                       name = options;
                   }

                   if(options instanceof Column)
                   {
                       name = options;
                       join = undefined;
                       summary = undefined;
	                   func = undefined;
                   }

                    utilityFunctions.checkArgs([name], ['name'], 'Result.getValue');

                   return getCellAttribute(name, join != null ? join : null, summary != null ? summary : null, func != null ? func : null, 'value');
               };
               /**
                * Returns the UI display name (i.e. the text value) of a specified search return column.
                * Note that this method is supported on select, image and document fields only.
                * The column may be specified in two ways:
                * 1) by providing a search.Column object
                * 2) by providing name, join and summary parameters
                * @param {Column} column  search return column object whose value you want to return
                * - or -
                * @param {Object} options  the options object
                * @param {string} options.name  the name of the search column whose value you want to return
                * @param {string} options.join (optional)  the join ID for this search column
                * @param {Summary} options.summary (optional)  the summary type used for this search column
                * @returns {string} UI display name (text value) of the search result column
                * @since 2015.2
                */
               this.getText = function getText(options)
               {
                   var name, join, summary, func;

                   if(!!options && !util.isString(options))
                   {
                       name = options.name;
                       join = options.join;
                       summary = options.summary;
	                   func = options.func;
                   }
                   else
                   {
                       name = options;
                   }

                   if(options instanceof Column)
                   {
                       name = options;
                       join = undefined;
                       summary = undefined;
	                   func = undefined;
                   }

                    utilityFunctions.checkArgs([name], ['name'], 'Result.getText');

                   return getCellAttribute(name, join != null ? join : null, summary != null ? summary : null, func != null ? func : null, 'text');
               };
               /**
                * Returns the object type name (search.Result)
                * @returns {string}
                */
               this.toString = function toString()
               {
                   return TYPE;
               };
               /**
                * JSON.stringify() implementation.
                * @returns {Object}
                */
               this.toJSON = function toJSON()
               {
                   return {
                       recordType: type,
                       id: id,
                       values: this.getAllValues()
                   };
               };

               /* public undocumented methods */
               /*
                * Return all the result data in a simple object of the following form:
                * {
                *     foo: 'bar',
                *     name.join: 'othervalue',
                *     select: [{
                *         value: '123',
                *         text: 'Some UI text'
                *     }],
                *     multiselect1: [],
                *     multiselect2: [{
                *         value: '3',
                *         text: 'Green'
                *     },{
                *         value: '5',
                *         text: 'Pinkish yellow'
                *     }],
                *     'MAX(name2.join2)': '324'
                * }
                * This is used in the toJSON() method.
                */
               this.getAllValues = function getAllValues()
               {
                   var names = {};
                   function disabiguateName(name)
                   {
                       var retVal = name;
                       if (names[name])
                       {
                       		var postFix = names[name];
                       		names[name]++;
                       		retVal = retVal + "_" + postFix;
                       }
                       else
                       {
                           names[name]=1;
                       }
                       return retVal;
                   }
                   var results = {};
                   var name = null;
                   var join = null;
                   var sum = null;
	               var func = null;

                   for (var i = 0; rawColumns && i < rawColumns.length; i++)
                   {
                       name = rawColumns[i].name;
                       join = rawColumns[i].join;
                       sum = rawColumns[i].summary;
	                   func = rawColumns[i]['function'];
                       var nameJoin = (join ? join + '.' : '') + name;
                       if (sum)
                           nameJoin = sum + '(' + nameJoin + ')';
                       var isrectype = name.toLowerCase() === 'recordtype';
	                   var param = (util.isString(name) && name.length >= 7 && name.substr(0,7) === "formula") ? rawColumns[i] : {name: name, join: join, summary: sum, func: func};
                       var txt = isrectype ? null : this.getText(param);
                       var val = isrectype ? type : this.getValue(param);
                       nameJoin  = disabiguateName ( nameJoin )
                       if (txt !== null && val !== null && txt !== undefined && val !== undefined)
                       {
                           if (txt.length === 0 && val.length === 0) // multiselect with nothing chosen
                           {
                               results[nameJoin] = [];
                           }
                           else
                           {
                               var multival = val.split(',');
                               var multitxt = txt.split(",");
                               if (multival.length === 1)
                               {
                                   val = [];
                                   val.push({value: multival[0], text: txt});
                                   results[nameJoin] = val;
                               }
                               else if (multival.length === multitxt.length) // parallel arrays match
                               {
                                   val = [];
                                   for (j = 0; j < multival.length; j++)
                                   {
                                       val.push({value: multival[j], text: multitxt[j]});
                                   }
                                   results[nameJoin] = val;
                               }
                               else // fallback
                               {
                                   results[nameJoin] = {value: val, text: txt};
                               }
                           }
                       }
                       else
                       {
                           results[nameJoin] = val;
                       }
                   }
                   return results;
               };
           }

           Result.prototype = nsobject.getNewInstance();

           /* public static methods */
           /*------------ Helper function used for unmarshalling search results from server. ------------*/
           Result.extractResults = function extractResults(rawResults, columns, javaResults)
           {
               var rows = [];
               if (rawResults != null && rawResults.length > 0)
               {
	               var recordTypeColumn = null;
	               var columnArray = utilityFunctions.getAsArray(columns)
	               if (columnArray != null)
		               recordTypeColumn = columnArray.filter(function(el) { return el.name === "recordtype"; })[0];
                   columns = rawResults[0].columns;
                   for (var i = 0; columns != null && i < columns.length; i++)
                   {
                       var obj = null;
                       var col = columns[i];
                       if (col.userindex == -1)
                       {
                           obj = Column.unmarshalColumn(col);
                       }
                       else if (columnArray != null)
                       {
                           obj = columnArray[col.userindex - 1];
                       }
                       obj._setIndex(col.index);
                       obj._setType(col.type);
                       columns[i] = obj;
                   }

                   if (!!recordTypeColumn)
                   {
                       if (util.isArray(columns))
                       {
                           if (columns.filter(function(el) { return el.name === "recordtype"; }).length === 0)
                               columns.push(recordTypeColumn);
                       }
	                   else
	                   	    columns = [recordTypeColumn];
                   }
                   for (i = 0; i < rawResults.length; i++)
                   {
                       rows[rows.length] = new Result(rawResults[i].recordType, rawResults[i].id, rawResults[i].cells, columns, (javaResults && javaResults[i]) ? javaResults[i] : null)
                   }
               }
               return rows;
           };
            /**
             *
             * @protected
             * @constructor
             */
           function SearchPageRange(options)
           {
               var that = this;
               var delegate;

               if (options)
               {
                   delegate = options.delegate;
               }

                utilityFunctions.checkArgs([delegate], ['delegate'], 'PageRange');

               function getIndex()
               {
                   return invoker(delegate, 'getIndex');
               }
               function getCompoundKey()
               {
                   return invoker(delegate, 'getCompoundKey');
               }
               function getCompoundLabel()
               {
                   return invoker(delegate, 'getCompoundLabel');
               }

                /**
                 * @return {number}
                 */
               this.getIndex = getIndex;
                /**
                 *
                 * @return {string}
                 */
               this.getCompoundKey = getCompoundKey;
                /**
                 *
                 * @return {string}
                 */
               this.getCompoundLabel = getCompoundLabel;
           }
           SearchPageRange.prototype = nsobject.getNewInstance();

           function SearchPage(options)
           {
               var that = this;
               var delegate;
               var pagedData;
               var pageIndex;
               var data;

               if (options)
               {
                   delegate = options.delegate;
                   pagedData = options.pagedData;
                   pageIndex = options.pageIndex;
               }

                utilityFunctions.checkArgs([delegate, pagedData, pageIndex], ['delegate', 'pagedData', 'pageIndex'], 'Page');

               Object.defineProperty(this, 'pagedData', {
                   configurable: false,
                   enumerable: true,
                   get: function ()
                   {
                       return pagedData;
                   }
               });

               Object.defineProperty(this, 'pageRange', {
                   configurable: false,
                   enumerable: true,
                   get: function ()
                   {
                       return pagedData.pageRanges[pageIndex];
                   }
               });

               Object.defineProperty(this, 'data', {
                   configurable: false,
                   enumerable: true,
                   get: function ()
                   {
                       var javaResults, rawResults;

                       if(!data){
                           javaResults = invoker(delegate, 'getData');
                           rawResults = invoker(remoteApi, 'transform', [javaResults]);

                           data = Result.extractResults(rawResults, pagedData.searchDefinition.columns, javaResults);
                       }

                       return data;
                   }
               });

               Object.defineProperty(this, 'isFirst', {
                   configurable: false,
                   enumerable: true,
                   get: function ()
                   {
                       return invoker(delegate, 'isFirst');
                   }
               });

               Object.defineProperty(this, 'isLast', {
                   configurable: false,
                   enumerable: true,
                   get: function ()
                   {
                       return invoker(delegate, 'isLast');
                   }
               });

               this.next = function next(){
                   var result;

                   if(that.isLast)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.INVALID_PAGE_RANGE, 'next' );
                   }
                   else
                   {
                       result = pagedData.fetch(pagedData.pageRanges[pageIndex + 1].getIndex());
                   }

                   return result;
               };

               this.prev = function prev(){
                   var result;

                   if(that.isFirst)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.INVALID_PAGE_RANGE, 'prev' );
                   }
                   else
                   {
                       result = pagedData.fetch(pagedData.pageRanges[pageIndex - 1].getIndex());
                   }

                   return result;
               };

               if(allowPromise)
               {
                   this.next.promise = function nextPromise()
                   {
                       var result;

                       if (that.isLast)
                       {
                           result = Promise.reject(error.create({
                                                                    name: error.Type.INVALID_PAGE_RANGE,
                                                                    message: 'Invalid page range: next.promise.',
                                                                    notifyOff: false
                                                                }));
                       }
                       else
                       {
                           result = pagedData.fetch.promise(pagedData.pageRanges[pageIndex + 1].getIndex());
                       }

                       return result;
                   };

                   this.prev.promise = function prevPromise()
                   {
                       var result;

                       if (that.isFirst)
                       {
                           result = Promise.reject(error.create({
                                                                    name: error.Type.INVALID_PAGE_RANGE,
                                                                    message: 'Invalid page range: prev.promise.',
                                                                    notifyOff: false
                                                                }));
                       }
                       else
                       {
                           result = pagedData.fetch.promise(pagedData.pageRanges[pageIndex - 1].getIndex());
                       }

                       return result;
                   };
               }
           }
           SearchPage.prototype = nsobject.getNewInstance();

           function ReadonlySearch(delegate)
           {
               function cloneArrayOfFiltersOrColumns(o)
               {
                   var toRet = [];
                   if(o && util.isArray(o))
                   {
                       o.forEach(function(obj){
                           if(obj instanceof Filter || obj instanceof Column)
                                toRet.push(utilityFunctions.freezeObjectIfPossible(obj._clone()));
                       })
                   }
                    return utilityFunctions.freezeObjectIfPossible(toRet)
               }

               Object.defineProperty(this, 'searchType', {
                   get : function(){ return delegate.searchType; },
                   enumerable: true,
                   configurable: false
               });
               Object.defineProperty(this, 'searchId', {
                   get : function(){ return delegate.searchId; },
                   enumerable: true,
                   configurable: false
               });
               Object.defineProperty(this, 'title', {
                   get : function(){ return delegate.title },
                   enumerable: true,
                   configurable: false
               });
               Object.defineProperty(this, 'id', {
                   get : function(){ return delegate.id; },
                   enumerable: true,
                   configurable: false
               });
               Object.defineProperty(this, 'isPublic', {
                   get : function(){ return delegate.isPublic; },
                   enumerable: true,
                   configurable: false
               });
               Object.defineProperty(this, 'columns', {
                   get : function(){ return cloneArrayOfFiltersOrColumns(delegate.columns); },
                   enumerable: true,
                   configurable: false
               });

               Object.defineProperty(this, 'filters', {
                   get : function(){ return cloneArrayOfFiltersOrColumns(delegate.filters); },
                   enumerable: true,
                   configurable: false
               });
               this.toJSON = delegate.toJSON;
               this.toString = function (){ return delegate.toString() + "(readonly)"; }
           }
           ReadonlySearch.prototype = nsobject.getNewInstance();

			/**
			 * @protected
			 * @constructor
			 */
           function SearchPagedData(options)
           {
               var that = this;
               var delegate, searchDefinition;
               var pageRanges = null;

               if (options)
               {
                   delegate = options.delegate;
                   searchDefinition = options.searchDefinition;
               }

                utilityFunctions.checkArgs([delegate, searchDefinition], ['delegate', 'searchDefinition'], 'PagedData');

               function getPage(index)
               {
                   if(index < 0 || index >= that.pageRanges.length)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.INVALID_PAGE_RANGE, 'fetch' );
                   }

                   var page = new SearchPage({
                       delegate: invoker(delegate, 'getPage', resolveUndefinedForArguments([index])),
                       pagedData: that,
                       pageIndex: index
                   });
                   return new paginationObject.Page(page);
               }

               function getPagePromise(index)
               {
                   var result;
                   if(index < 0 || index >= that.pageRanges.length)
                   {
                       result = Promise.reject(error.create({
                                                                name: error.Type.INVALID_PAGE_RANGE,
                                                                message: 'Invalid page range: fetch.promise.',
                                                                notifyOff: false
                                                            }));
                   }
                   else
                   {
                       result = invoker(delegate, 'getPagePromise', resolveUndefinedForArguments([index])).
                       then(function (value){
                           var page = new SearchPage({
                               delegate: value,
                               pagedData: that,
                               pageIndex: index
                           });
                           return new paginationObject.Page(page)
                       });
                   }

                   return result;
               }

                /**
                 * rows per page - defined in search definition [5 - 1000]
                 * @type {number}
                 */
               Object.defineProperty(this, 'pageSize', {
                   configurable: false,
                   enumerable: true,
                   get: function ()
                   {
                       return invoker(delegate, 'getPageSize');
                   }
               });
                /**
                 * total row count
                 * @type {number}
                 */
               Object.defineProperty(this, 'count', {
                   configurable: false,
                   enumerable: true,
                   get: function ()
                   {
                       return invoker(delegate, 'getTotalRows');
                   }
               });
                /**
                 * @type {SearchPageRange}
                 */
               Object.defineProperty(this, 'pageRanges', {
                   configurable: false,
                   enumerable: true,
                   get: function ()
                   {
                       if(!pageRanges){
                           pageRanges = invoker(delegate, 'getPageRanges').map(function(v,i,a){
                               return new SearchPageRange({delegate: v});
                           });
                       }

                       return pageRanges;
                   }
               });

               this.searchDefinition = new ReadonlySearch(searchDefinition);
               this.fetch = getPage;
               if(allowPromise)
               {
                   this.fetch.promise = getPagePromise;
               }
           }
           SearchPagedData.prototype = nsobject.getNewInstance();


           function createSearch(type, searchId, filters, columns) {
               return new Search(type, searchId, filters, columns);
           }

           function createFilter(options) {
               var name = null, join = null, operator = null, values = null;
               var isOpts = false;

               if (options && (options.hasOwnProperty('name') || options.hasOwnProperty('join') || options.hasOwnProperty('operator') || options.hasOwnProperty('values')))
               {
                   name = options.name;
                   join = options.join;
                   operator = options.operator;
                   values = options.values;
                   isOpts = true;
               }
               else
               {
                   name = options;
                   join = arguments[1];
                   operator = arguments[2];
                   values = arguments[3];
               }
               utilityFunctions.checkArgs([name, operator], ['name', 'operator'], 'search.createFilter');

               var filter = new Filter(name, join, operator, values);
               if (isOpts)
               {
                   if (options.formula)
                       filter.formula = options.formula;
                   if (options.summary)
                       filter.summary = options.summary;
               }
               return filter;
           }

           function createColumn(options) {
               var name = null, join = null, summary = null;
               var isOpts = false;

               if (options && (options.hasOwnProperty('name') || options.hasOwnProperty('join') || options.hasOwnProperty('summary')))
               {
                   name = options.name;
                   join = options.join;
                   summary = options.summary;
                   isOpts = true;
               }
               else
               {
                   name = options;
                   join = arguments[1];
                   summary = arguments[2];
               }
               utilityFunctions.checkArgs([name], ['name'], 'search.createColumn');

               var column = new Column(name, join ? join : null, summary ? summary : null);
               if (isOpts)
               {
                   if (options.formula)
                       column.formula = options.formula;
                   if (options.func)
	                   column['function'] = options.func;
                   else if (options['function'])
                       column['function'] = options['function'];
                   if (options.label)
                       column.label = options.label;
                   if (options.sort !== undefined)
                       column.sort = options.sort;
               }
               return column;
           }

           return {
               createSearch : createSearch,
               createFilter : createFilter,
               Filter : Filter,
               createColumn : createColumn,
               Column : Column,
               Result : Result,
               /**
                * @enum
                */
               SUMMARY_TYPES : SUMMARY_TYPES,
               /**
                * @enum
                */
               OPERATORS: OPERATORS,
               /**
                * @enum
                */
               SORT: SORT,
               util : {
                   getNameFromColumn : getNameFromColumn,
                   getJoinFromColumn : getJoinFromColumn,
                   allowPromises: allowPromises
               }
           }
       }
);

/**
 * SuiteScript search util module
 *
 * @private
 * @module N/search/searchUtil
 * @NApiVersion 2.x
 *
 */
define('N/search/searchUtil',['N/restricted/searchApi', 'N/restricted/remoteApiBridge', 'N/error', 'N/restricted/invoker', 'N/search/searchObject', 'N/utilityFunctions', 'N/creationFunctionWrapper'],
        function (searchApi, remoteApi, error, invoker, searchObject, utilityFunctions, funcWrapper)
        {
            var Filter = searchObject.Filter;
            var Column = searchObject.Column;
            var Result = searchObject.Result;
            var searchUtilityFunctions = searchObject.util;

            //========================================================================

            function validateAndParseFilterExpression(options, callback)
            {
                var type = null,
                        filters = null;

                if (options)
                {
                    type = options.type;
                    filters = options.filters;
                }
                utilityFunctions.checkArgs([type], ['type'], 'search.create');
                invoker(searchApi, 'assertValidSearchType', [type]);

                filters = Filter.normalizeFilters(filters);

                return Filter.parseFilterExpression(filters, callback);
            }

            function doCreateSearch(options)
            {
                var columns = options.columns != null ? options.columns : null;
                var result = searchObject.createSearch(options.type, -1, options.filters, columns);
                if (options.title)
                    result.title = options.title;
                if (options.id)
                    result.id = options.id;
                return result;
            }

            // === load
            function doLoad(options, callback)
            {
                var id = (options && options.hasOwnProperty('id')) ? options.id : options;
                utilityFunctions.checkArgs([id], ['id'], 'search.load');
                var type = (options && options.hasOwnProperty('type')) ? options.type : null;
                if (!!type)
                    invoker(searchApi, 'assertValidSearchType', [type]);

                var search = searchObject.createSearch(type, id, null, null);
                search._load(callback);
                return search;
            }

            // === delete

            function doDelete(options, callback)
            {
                var id = (options && options.hasOwnProperty('id')) ? options.id : options;
                utilityFunctions.checkArgs([id], ['id'], 'search.delete');

                invoker(searchApi, 'nlapiDeleteSearch', [id], callback);
            }

            // === searchDuplicates

            function doSearchDuplicates(options, callback)
            {
                var type = null, fields = null, id = 0;
                if (options)
                {
                    type = options.type;
                    fields = options.fields || null;
                    id = options.id || 0;
                }

                utilityFunctions.checkArgs([type], ['type'], 'search.duplicates');

                var javaResults = invoker(searchApi, 'nlapiSearchDuplicate', [type, fields, id], callback);

                if (!callback)
                {
                    var rawResults = invoker(remoteApi, 'transform', [javaResults]);
                    return rawResults;
                }
            }

            function doSearchDuplicates_postProcess(rawResults)
            {
                var searchResults = Result.extractResults(rawResults, null);
                return searchResults ? searchResults : [];
            }

            // === searchGlobal
            function doSearchGlobal(options, callback)
            {
                var keywords = (options && options.hasOwnProperty('keywords')) ? options.keywords : options;
                utilityFunctions.checkArgs([keywords], ['keywords'], 'search.global');

                return invoker(searchApi, 'nlapiSearchGlobal', [keywords], callback);
            }

            function doSearchGlobal_postProcess(javaResults)
            {
                var rawResults = invoker(remoteApi, 'transform', [javaResults]);
                var searchResults = Result.extractResults(rawResults, null);
                return searchResults ? searchResults : [];
            }

            // === lookupFields

            function getLookupArgs(options)
            {
                var type = null, id = null, columns = null;

                if (options)
                {
                    type = options.type;
                    id = options.id;
                    columns = utilityFunctions.getAsArray(options.columns);
                }

                utilityFunctions.checkArgs([type, id, columns], ['type', 'id', 'columns'], 'search.lookupFields');
                return {type: type, id: id, columns: columns};
            }

            function getLookupSearchColumns(columns)
            {
                var searchColumns = [];
                for (var i = 0; i < columns.length; i++)
                    if (util.isString(columns[i]) && columns[i].toLowerCase() !== 'recordtype')
                        searchColumns[searchColumns.length] = searchObject.createColumn(searchUtilityFunctions.getNameFromColumn(columns[i]), searchUtilityFunctions.getJoinFromColumn(columns[i]), null);
                return searchColumns;
            }

	        function getPostProcessColumns(searchColumns, asksRecordType)
	        {
		        if (asksRecordType)
			        searchColumns[searchColumns.length] = searchObject.createColumn("recordtype", null, null);
		        return searchColumns;
	        }

            function doLookupFields(argObj, searchColumns, callback)
            {
                argObj.columns = Column.marshalColumns(searchColumns);
                return invoker(searchApi, 'nlapiLookupFields', [argObj.type, argObj.id, argObj.columns], callback);
            }

            function doLookupFields_postProcess(javaResults, searchColumns)
            {
                var rawResults = invoker(remoteApi, 'transform', [javaResults]);
                var searchResult = Result.extractResults(rawResults, searchColumns);

                if (searchResult && searchResult.length > 0)
                    return searchResult[0].getAllValues();
                return {};
            }

            //========================================================================

            return {
                validateAndParseFilterExpression: validateAndParseFilterExpression,
                doCreateSearch: funcWrapper.wrap ( doCreateSearch ),
                doLoad: doLoad,
                doDelete: doDelete,
                doSearchDuplicates: doSearchDuplicates,
                doSearchDuplicates_postProcess: doSearchDuplicates_postProcess,
                doSearchGlobal: doSearchGlobal,
                doSearchGlobal_postProcess: doSearchGlobal_postProcess,
                getLookupArgs: getLookupArgs,
                getLookupSearchColumns: getLookupSearchColumns,
	            getPostProcessColumns: getPostProcessColumns,
                doLookupFields: doLookupFields,
                doLookupFields_postProcess: doLookupFields_postProcess,

                /**
                 * @return {Column}
                 */
                createColumn: funcWrapper.wrap ( searchObject.createColumn ),
                /**
                 * @return {Filter}
                 */
                createFilter: funcWrapper.wrap ( searchObject.createFilter ),
                allowPromises: searchUtilityFunctions.allowPromises,
                /**
                 * @enum
                 */
                OPERATORS: searchObject.OPERATORS,
                /**
                 * @enum
                 */
                SUMMARY_TYPES: searchObject.SUMMARY_TYPES,
                /**
                 * @enum
                 */
                SORT: searchObject.SORT
            }
        });

/**
 * SuiteScript search common module
 *
 * @module N/search
 * @suiteScriptVersion 2.x
 *
 */
define('N/common/search',['N/search/searchUtil', 'N/restricted/searchApi', 'N/restricted/invoker'],
        function (searchUtil, api, invoker)
        {
            searchUtil.allowPromises(false);

            function createSearch(options)
            {
                var parsedFilters = searchUtil.validateAndParseFilterExpression(options)
                options.filters = parsedFilters;

                return searchUtil.doCreateSearch(options);
            }

            function loadSearch(options)
            {
                return searchUtil.doLoad(options);
            }

            function deleteSearch(options)
            {
                return searchUtil.doDelete(options);
            }

            function searchDuplicates(options)
            {
                var rawResults = searchUtil.doSearchDuplicates(options);
                return searchUtil.doSearchDuplicates_postProcess(rawResults);
            }

            function searchGlobal(options)
            {
                var rawResults = searchUtil.doSearchGlobal(options);
                return searchUtil.doSearchGlobal_postProcess(rawResults);
            }

            function lookupFields(options)
            {
                var lookupArgs = searchUtil.getLookupArgs(options);
                var asksRecordType = lookupArgs.columns.indexOf('recordtype') >= 0;
                var searchColumns = searchUtil.getLookupSearchColumns(lookupArgs.columns);
                var javaResults = searchUtil.doLookupFields(lookupArgs, searchColumns);
                if (options.v1call)
                    api.chargeUsage("nlapiLookupFields_v1", options.type);
                return searchUtil.doLookupFields_postProcess(javaResults, searchUtil.getPostProcessColumns(searchColumns, asksRecordType));
            }

            return Object.freeze({
                /**
                 * Creates a new search. The search can be modified and run as an ad-hoc search, without saving it. Alternatively,
                 * calling Search.save() will save the search to the database, so it can be reused later in the UI or using search.load().
                 * @param {Object} options  the options object
                 * @param {string} options.type  the record internal ID of the record type you are searching
                 * @param {Filter|Filter[]|Array[]} options.filters (optional)  a single filter object or an array of filter objects or a search filter expression
                 * @param {Column|Column[]|string} options.columns (optional)  a single search.Column or string or an array that contains elements of the two types
                 * @param {string} options.title (optional)  name of the search (when saved)
                 * @param {string} options.id (optional)  customer ID of the search (when saved), it's a string starting with 'customsearch'
                 * @returns {Search} the created search
                 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
                 * @throws {SuiteScriptError} SSS_INVALID_SRCH_FILTER_EXPR when filters parameter is not a valid filter, array of filters or filter expression
                 * @throws {SuiteScriptError} SSS_INVALID_SRCH_COL when columns parameter is not a valid column, string, or array of the two
                 * @since 2015.2
                 */
                create: createSearch,

                /**
                 * Loads an existing saved search. The saved search could have been created using the UI, or created using search.create()
                 * in conjunction with Search.save().
                 * @governance 5 units
                 * @param {Object} options  the options object
                 * @param {string} options.id  the customer ID or internal ID of the search
                 * @returns {Search} the loaded search
                 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
                 * @throws {SuiteScriptError} INVALID_SEARCH when a search with the given ID is not found
                 * @since 2015.2
                 */
                load: loadSearch,

                /**
                 * Deletes an existing saved search.
                 * @governance 5 units
                 * @param {Object} options  the options object
                 * @param {string} options.id  the customer ID or internal ID of the search
                 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
                 * @throws {SuiteScriptError} INVALID_SEARCH when a search with the given ID is not found
                 * @since 2015.2
                 */
                'delete': deleteSearch,

                /**
                 * Performs a search for duplicate records based on the account's Duplicate Detection configuration.
                 * Note that this API only works for records that support duplicate record detection. These records include
                 * customers, leads, prospects, contacts, partners, and vendors. Use either field or id parameter depending
                 * on how you want to search for duplicates.
                 * @governance 10 units
                 * @param {Object} options  the options object
                 * @param {string} options.type  the record type you are checking duplicates for
                 * @param {Object} options.fields (optional)  a set of key/value pairs used to detect duplicate (e.g. email:'foo@bar.com')
                 * @param {number} options.id (optional)  internalId of existing record
                 * @returns {Result[]} array of result objects corresponding to the duplicate records; results are limited to 1000 rows; returns empty array if nothing is found
                 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
                 * @since 2015.2
                 */
                duplicates: searchDuplicates,

                /**
                 * Performs a global search against a single keyword or multiple keywords.
                 * @governance 10 units
                 * @param {Object} options  the options object
                 * @param {string} options.keywords  global search keywords string or expression
                 * @returns {Result[]} array of result objects containing the following four columns: name, type (as shown in the UI), info1, and info2
                 *                                   results are limited to 1000 rows; returns empty array if nothing is found
                 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
                 * @since 2015.2
                 */
                global: searchGlobal,

                /**
                 * Performs a search for one or more body fields on a record. This function supports joined-field lookups.
                 * Note that the notation for joined fields is: join_id.field_name
                 * @governance 1 unit
                 * @param {Object} options  the options object
                 * @param {string} options.type  the record internal ID of the record type you are searching
                 * @param {string} options.id  the internalId of the record
                 * @param {string|string[]} options.columns  array of column/field names to look up, or a single column/field name
                 * @returns {Object} search results in the form of key/value pairs; example:
                 *     {
                         *         foo: 'bar',
                         *         name.join: 'othervalue',
                         *         select: [{
                         *             value: '123',
                         *             text: 'Some UI text'
                         *         }],
                         *         multiselect1: [],
                         *         multiselect2: [{
                         *             value: '3',
                         *             text: 'Green'
                         *         },{
                         *             value: '5',
                         *             text: 'Pinkish yellow'
                         *         }]
                         *     }
                 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
                 * @since 2015.2
                 */
                lookupFields: lookupFields,

                /**
                 * Creates a search.Column object.
                 * @param {Object} options  the options object
                 * @param {string} options.name  the search return column name
                 * @param {string} options.join (optional)  the join ID for this search return column
                 * @param {Summary} options.summary (optional)  the summary type for this column
                 * @param {string} options.formula (optional)  formula used for this column
                 * @param {string} options.function (optional)  function used for this column
                 * @param {string} options.label (optional)  label used for this column
                 * @param {string} options.sort (optional)  sort direction for this column; use values from the Sort enum
                 * @returns {Column} the created column object
                 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
                 * @throws {SuiteScriptError} SSS_INVALID_SRCH_COLUMN_SUM if an unknown summary type is provided
                 * @throws {SuiteScriptError} INVALID_SRCH_FUNCTN if an unknown function is provided
                 * @since 2015.2
                 */
                createColumn: searchUtil.createColumn,

                /**
                 * Creates a search.Filter object.
                 * @param {Object} options  the options object
                 * @param {string} options.name  internal ID of the search field
                 * @param {string} options.join (optional)  if executing a joined search, this is the join ID used for the search field specified in the name parameter
                 * @param {string} options.operator  search operator
                 * @param {string|Date|number|string[]|Date[]} options.values (optional)  values to be used as filter parameters
                 * @param {string} options.formula (optional)  formula used for this filter
                 * @param {Summary} options.summary (optional)  summary type used for this filter
                 * @returns {Filter} the created filter object
                 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
                 * @throws {SuiteScriptError} SSS_INVALID_SRCH_OPERATOR if an unknown operator is provided
                 * @throws {SuiteScriptError} INVALID_SRCH_SUMMARY_TYP if an unknown summary type is provided
                 * @since 2015.2
                 */
                createFilter: searchUtil.createFilter,

                /**
                 * Enum for search operators.
                 * @enum {string}
                 */
                Operator: searchUtil.OPERATORS,

                /**
                 * Enum for search summary types.
                 * @enum {string}
                 */
                Summary: searchUtil.SUMMARY_TYPES,

                /**
                 * Enum for sort directions.
                 * @enum {string}
                 */
                Sort: searchUtil.SORT,
                /*
                 * module enums
                 */
                get Type()
                {
                    if(!searchUtil.searchTypes)
                        searchUtil.searchTypes = invoker(api, 'getStandardTypeEnumMap', ['search']);
                    return searchUtil.searchTypes;
                }
            });
        });

/**
 * SuiteScript search module (Client Side)
 *
 * @module N/search
 * @suiteScriptVersion 2.x
 *
 */

define('N/search',['N/common/search', 'N/search/searchUtil'],
       function(searchCommon, searchUtil)
       {
           searchUtil.allowPromises(true);

		   /**
			* Creates a new search. The search can be modified and run as an ad-hoc search, without saving it. Alternatively,
			* calling Search.save() will save the search to the database, so it can be reused later in the UI or using search.load().
			* @param {Object} options  the options object
			* @param {string} options.type  the record internal ID of the record type you are searching
			* @param {Filter|Filter[]|Array[]} options.filters (optional)  a single filter object or an array of filter objects or a search filter expression
			* @param {Column|Column[]|string} options.columns (optional)  a single search.Column or string or an array that contains elements of the two types
			* @param {string} options.title (optional)  name of the search (when saved)
			* @param {string} options.id (optional)  customer ID of the search (when saved), it's a string starting with 'customsearch'
			* @returns {Promise} Resolves to the created Search object
			* @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
			* @throws {SuiteScriptError} SSS_INVALID_SRCH_FILTER_EXPR when filters parameter is not a valid filter, array of filters or filter expression
			* @throws {SuiteScriptError} SSS_INVALID_SRCH_COLUMN when columns parameter is not a valid column, string, or array of the two
			* @since 2015.2
			*/
           searchCommon.create.promise = function(options)
           {
               return new Promise(
                       function(resolve, reject)
                       {
                           try
                           {
                               searchUtil.validateAndParseFilterExpression(options, callback);
                           }
                           catch(e)
                           {
                               reject(e);
                           }

                           function callback(result) {
                               if (result instanceof Error)
                               {
                                   reject(result);
                                   return;
                               }
                               try
                               {
                                   options.filters = result;
                                   resolve(searchUtil.doCreateSearch(options));
                               }
                               catch(e)
                               {
                                   reject(e);
                               }
                           }
                       }
               );
           };

           searchCommon.load.promise = function(options)
           {
               return new Promise(
                       function(resolve, reject)
                       {
                           try
                           {
                               var search = searchUtil.doLoad(options, callback);
                           }
                           catch(e)
                           {
                               reject(e);
                           }

                           function callback(result) {
                               if (result instanceof Error)
                               {
                                   reject(result);
                                   return;
                               }
                               try
                               {
                                   resolve(search);
                               }
                               catch(e)
                               {
                                   reject(e);
                               }
                           }
                       }
               );
           };

           searchCommon["delete"].promise = function(options)
           {
               return new Promise(
                       function(resolve, reject)
                       {
                           try
                           {
                               searchUtil.doDelete(options, callback);
                           }
                           catch(e)
                           {
                               reject(e);
                           }

                           function callback(result) {
                               if (result instanceof Error)
                               {
                                   reject(result);
                                   return;
                               }
                               try
                               {
                                   resolve();
                               }
                               catch(e)
                               {
                                   reject(e);
                               }
                           }
                       }
               );
           };
           searchCommon.duplicates.promise = function(options)
           {
               return new Promise(
                       function(resolve, reject)
                       {
                           try
                           {
                               searchUtil.doSearchDuplicates(options, callback);
                           }
                           catch(e)
                           {
                               reject(e);
                           }

                           function callback(result) {
                               if (result instanceof Error)
                               {
                                   reject(result);
                                   return;
                               }
                               try
                               {
                                   resolve(searchUtil.doSearchDuplicates_postProcess(result));
                               }
                               catch(e)
                               {
                                   reject(e);
                               }
                           }
                       }
               );
           };
           searchCommon.global.promise = function(options)
           {
               return new Promise(
                       function(resolve, reject)
                       {
                           try
                           {
                               searchUtil.doSearchGlobal(options, callback);
                           }
                           catch(e)
                           {
                               reject(e);
                           }

                           function callback(result) {
                               if (result instanceof Error)
                               {
                                   reject(result);
                                   return;
                               }
                               try
                               {
                                   resolve(searchUtil.doSearchGlobal_postProcess(result));
                               }
                               catch(e)
                               {
                                   reject(e);
                               }
                           }
                       }
               );
           };
           searchCommon.lookupFields.promise = function(options)
           {
               return new Promise(
                       function(resolve, reject)
                       {
                           try
                           {
                               var lookupArgs = searchUtil.getLookupArgs(options);
                               var searchColumns = searchUtil.getLookupSearchColumns(lookupArgs.columns);
                               searchUtil.doLookupFields(lookupArgs, searchColumns, callback);
                           }
                           catch(e)
                           {
                               reject(e);
                           }

                           function callback(result) {
                               if (result instanceof Error)
                               {
                                   reject(result);
                                   return;
                               }
                               try
                               {
                                   resolve(searchUtil.doLookupFields_postProcess(result, searchColumns));
                               }
                               catch(e)
                               {
                                   reject(e);
                               }
                           }
                       }
               );
           };

           return Object.freeze(searchCommon)
       }
);

/**
 * SuiteScript new-generation search common module
 *
 * @module N/query
 * @suiteScriptVersion 2.x
 */
define('N/query',['N/restricted/queryApiBridge', 'N/restricted/searchApi', 'N/restricted/invoker', 'N/nsobject', 'N/utilityFunctions', 'N/error', 'N/search', 'N/common/pattern/iterator', 'N/search/pagingUtil'],
	function (queryApi, searchApi, invoker, nsobject, utilityFunctions, error, search, iteratorFactory, pagingUtil)
	{
		var MOD_PREFIX = 'query.';

		var SORT = Object.freeze({
			ASC: 'ASC',
			DESC: 'DESC'
		});

		var OPERATOR = Object.freeze({
			AFTER: 'AFTER',
			AFTER_NOT: 'AFTER_NOT',
			ANY_OF: 'ANY_OF',
			ANY_OF_NOT: 'ANY_OF_NOT',
			BEFORE: 'BEFORE',
			BEFORE_NOT: 'BEFORE_NOT',
			BETWEEN: 'BETWEEN',
			BETWEEN_NOT: 'BETWEEN_NOT',
			CONTAIN: 'CONTAIN',
			CONTAIN_NOT: 'CONTAIN_NOT',
			EMPTY: 'EMPTY',
			EMPTY_NOT: 'EMPTY_NOT',
			ENDWITH: 'ENDWITH',
			ENDWITH_NOT: 'ENDWITH_NOT',
			EQUAL: 'EQUAL',
			EQUAL_NOT: 'EQUAL_NOT',
			GREATER: 'GREATER',
			GREATER_NOT: 'GREATER_NOT',
			GREATER_OR_EQUAL: 'GREATER_OR_EQUAL',
			GREATER_OR_EQUAL_NOT: 'GREATER_OR_EQUAL_NOT',
			IS: 'IS',
			IS_NOT: 'IS_NOT',
			LESS: 'LESS',
			LESS_NOT: 'LESS_NOT',
			LESS_OR_EQUAL: 'LESS_OR_EQUAL',
			LESS_OR_EQUAL_NOT: 'LESS_OR_EQUAL_NOT',
			ON: 'ON',
			ON_NOT: 'ON_NOT',
			ON_OR_AFTER: 'ON_OR_AFTER',
			ON_OR_AFTER_NOT: 'ON_OR_AFTER_NOT',
			ON_OR_BEFORE: 'ON_OR_BEFORE',
			ON_OR_BEFORE_NOT: 'ON_OR_BEFORE_NOT',
			START_WITH: 'START_WITH',
			START_WITH_NOT: 'START_WITH_NOT',
			WITHIN: 'WITHIN',
			WITHIN_NOT: 'WITHIN_NOT'
		});

		var ALLOWED_ARITY = Object.freeze({
			"AFTER" : [2, 2],
			"AFTER_NOT" : [2, 2],
			"ANY_OF" : [2, Number.MAX_VALUE],
			"ANY_OF_NOT" : [2, Number.MAX_VALUE],
			"BEFORE" : [2, 2],
			"BEFORE_NOT" : [2, 2],
			"BETWEEN" : [3, 3],
			"BETWEEN_NOT" : [3, 3],
			"CONTAIN" : [2, 2],
			"CONTAIN_NOT" : [2, 2],
			"EMPTY" : [1, 1],
			"EMPTY_NOT" : [1, 1],
			"ENDWITH" : [2, 2],
			"ENDWITH_NOT" : [2, 2],
			"EQUAL" : [2, 2],
			"EQUAL_NOT" : [2, 2],
			"GREATER" : [2, 2],
			"GREATER_NOT" : [2, 2],
			"GREATER_OR_EQUAL" : [2, 2],
			"GREATER_OR_EQUAL_NOT" : [2, 2],
			"IS" : [2, 2],
			"IS_NOT" : [2, 2],
			"LESS" : [2, 2],
			"LESS_NOT" : [2, 2],
			"LESS_OR_EQUAL" : [2, 2],
			"LESS_OR_EQUAL_NOT" : [2, 2],
			"ON" : [2, 2],
			"ON_NOT" : [2, 2],
			"ON_OR_AFTER" : [2, 2],
			"ON_OR_AFTER_NOT" : [2, 2],
			"ON_OR_BEFORE" : [2, 2],
			"ON_OR_BEFORE_NOT" : [2, 2],
			"START_WITH" : [2, 2],
			"START_WITH_NOT" : [2, 2],
			"WITHIN" : [3, 3],
			"WITHIN_NOT" : [3, 3]
		});

		var AGGREGATE = Object.freeze({
			AVERAGE: 'AVERAGE',
			COUNT: 'COUNT',
			GROUP: 'GROUP',
			MAXIMUM: 'MAXIMUM',
			MINIMUM: 'MINIMUM',
			SUM: 'SUM'
		});

		var RETURN_TYPE = Object.freeze({
			BOOLEAN: 'BOOLEAN',
			DATE: 'DATE',
			DATETIME: 'DATETIME',
			FLOAT: 'FLOAT',
			INTEGER: 'INTEGER',
			STRING: 'STRING',
			DURATION: 'DURATION',
			CURRENCY: 'CURRENCY',
			KEY: 'KEY',
			RELATIONSHIP: 'RELATIONSHIP',
			ANY: 'ANY',
			UNKNOWN: 'UNKNOWN'
		});

		/**
		 * The search definition.
		 */
		function Search(type)
		{
			var TYPE = MOD_PREFIX + 'Search';

			/* private vars */
			var _type = type;
			var _searchId;
			var _condition = null;
			var _columns = [];
			var _sort = [];
			var _root = new Component(type, null);

			/**
			 * Search type. Returns the search type given upon the creation of the search object.
			 * @name Search#type
			 * @type string
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'type', {
				get: function ()
				{
					return _type;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'type');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Search condition.
			 * @name Search#condition
			 * @type Condition
			 * @throws {error.SuiteScriptError} WRONG_PARAMETER_TYPE when setting value of different type than search.Condition
			 */
			Object.defineProperty(this, 'condition', {
				get: function ()
				{
					return _condition;
				},
				set: function (condition)
				{
					if (!(condition instanceof Condition))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'condition', 'Condition');
					_condition = condition;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Columns to be returned from the search.
			 * @name Search#columns
			 * @type Column[]
			 * @throws {error.SuiteScriptError} WRONG_PARAMETER_TYPE when setting value of different type than search.Column array
			 */
			Object.defineProperty(this, 'columns', {
				get: function ()
				{
					return _columns;
				},
				set: function (columns)
				{
					if (!util.isArray(columns))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'columns', 'Column[]');
					for (var i = 0; i < columns.length; i++)
					{
						if (!(columns[i] instanceof Column))
							utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'columns', 'Column[]');
					}
					_columns = columns;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Specifies how the results will be sorted.
			 * @name Search#sort
			 * @type Sort[]
			 * @throws {error.SuiteScriptError} WRONG_PARAMETER_TYPE when setting value of different type than search.Sort array
			 */
			Object.defineProperty(this, 'sort', {
				get: function ()
				{
					return _sort;
				},
				set: function (sort)
				{
					if (!util.isArray(sort))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'sort', 'Sort[]');
					for (var i = 0; i < sort.length; i++)
					{
						if (!(sort[i] instanceof Sort))
							utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'columns', 'Sort[]');
					}
					_sort = sort;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Children of the root component of the search. It is an object with key/value pairs where key is the name of the
			 * child component and value is the corresponding Component object. This is a shortcut for the Search.root.child expression.
			 * @name Search#child
			 * @type Object
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'child', {
				get: function ()
				{
					return _root.child;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'child');
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Access the root component of the search. It is the component that corresponds to the search type given upon the
			 * creation of the whole Search object.
			 * @name Search#root
			 * @type Component
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'root', {
				get: function ()
				{
					return _root;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'root');
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Execute the search and return results.
			 * @governance 10 points
			 * @returns {ResultSet} the result set object
			 */
			this.run = function run()
			{
				var data = invoker(queryApi, 'runSearch', [this.marshal()]);
				var resultSet = new ResultSet(data, _columns);
				return resultSet;
			};

/**
	     * Execute the search and return paged results.
	     * @governance 10 points
	     * @returns {PagedData} the paged search object
	     */
	    this.runPaged = function runPaged(options)
	    {
		    var pageSize = (options && options.hasOwnProperty('pageSize')) ? options.pageSize : options;
		    pageSize = pagingUtil.regulatePageSize(pageSize);
		    utilityFunctions.checkArgs([pageSize], ['pageSize'], 'Search.runPaged');
		    var searchDefinition = this.marshal();
		    var searchData = invoker(queryApi, "pagedSearch", [pageSize, searchDefinition]);
		    return new PagedData({
			   pageSize: pageSize,
			   searchDefinition: searchDefinition,
			   searchData: searchData,
			   columns: _columns
		    });
	    };

	    function promiseToSearch()
	    {
		    var marshalled = this.marshal();
		    return new Promise(
			    function(resolve, reject) {
				    try {
					    invoker(queryApi, 'runSearch', [marshalled], callback);
				    }
				    catch (e) {
					    reject(e);
				    }

				    function callback(result) {
					    if (result instanceof Error) {
						    reject(result);
						    return;
					    }
					    try {
						    var resultSet = new ResultSet(result, _columns);
						    resolve(resultSet);
					    }
					    catch (e) {
						    reject(e);
					    }
				    }
			    }
		    );
	    }

	    function promiseToPaged(options)
	    {
		    var marshalled = this.marshal();
		    var pageSize = (options && options.hasOwnProperty('pageSize')) ? options.pageSize : options;
		    pageSize = pagingUtil.regulatePageSize(pageSize);
		    return new Promise(
			    function(resolve, reject) {
				    try {
					    utilityFunctions.checkArgs([pageSize], ['pageSize'], 'Search.runPaged');
					    invoker(queryApi, "pagedSearch", [pageSize, marshalled], callback);
				    }
				    catch (e) {
					    reject(e);
				    }

				    function callback(result) {
					    if (result instanceof Error) {
						    reject(result);
						    return;
					    }
					    try {
						    resolve(new PagedData({
							    pageSize: pageSize,
							    searchDefinition: marshalled,
							    searchData: result
						    }));
					    }
					    catch (e) {
						    reject(e);
					    }
				    }
			    }
		    );
	    }

			/**
			 * Asynchronously execute the search and return results.
			 * @governance 10 points
			 * @returns {ResultSet} the result set object
			 */
			this.run.promise = promiseToSearch.bind(this);

			/**
			 * Asynchronously execute the search and return results.
			 * @governance 10 points
			 * @returns {ResultSet} the result set object
			 */
			this.runPaged.promise = promiseToPaged.bind(this);

			/**
			 * join the root component of the Search with another search type. This is a shortcut for Search.root.join.
			 * @see Component#join
			 */
			this.join = function join(options)
			{
				return _root.join(options);
			};

			/**
			 * Create a Condition object based on the root component of the Search. This is a shortcut for Search.root.createCondition.
			 * @see Component#createCondition
			 */
			this.createCondition = function createCondition(options)
			{
				return _root.createCondition(options);
			};

			/**
			 * Create a Column object based on the root component of the Search. This is a shortcut for Search.root.createColumn.
			 * @see Component#createColumn
			 */
			this.createColumn = function createColumn(options)
			{
				return _root.createColumn(options);
			};

			/**
			 * Create a Sort object based on the root component of the Search. This is a shortcut for Search.root.createSort.
			 * @see Component#createSort
			 */
			this.createSort = function createSort(options)
			{
				return _root.createSort(options);
			};

			function convertConditions(options)
			{
				var newArguments = null;
				if (util.isObject(options) && options.hasOwnProperty("conditions"))
					newArguments = options.conditions;
				else if (util.isArray(options))
					newArguments = options;
				else
					newArguments = Array.prototype.slice.call(arguments);
				return newArguments;
			}

			/**
			 * Create a new Condition object that corresponds to a logical conjunction (AND) of the Condition objects given to
			 * the method as arguments. The arguments must be one or more Condition objects.
			 * @param {Condition} condition1
			 * @param {Condition} condition2
			 * @param {Condition} condition<n>
			 * @returns {Condition}
			 */
			this.and = function and()
			{
				utilityFunctions.checkArgs([arguments.length > 0], ['argument count'], 'Search.and');
				return new Condition(convertConditions.apply(null, arguments), 'AND', null);
			};

			/**
			 * Create a new Condition object that corresponds to a logical disjunction (OR) of the Condition objects given to
			 * the method as arguments. The arguments must be one or more Condition objects.
			 * @param {Condition} condition1
			 * @param {Condition} condition2
			 * @param {Condition} condition<n>
			 * @returns {Condition}
			 */
			this.or = function or()
			{
				utilityFunctions.checkArgs([arguments.length > 0], ['argument count'], 'Search.or');
				return new Condition(convertConditions.apply(null, arguments), 'OR', null);
			};

			/**
			 * Create a new Condition object that corresponds to a logical negation (NOT) of the Condition object given to the method
			 * as argument.
			 * @param {Condition} condition
			 * @returns {Condition}
			 */
			this.not = function not()
			{
				utilityFunctions.checkArgs([arguments.length == 1], ['argument count'], 'Search.not');
				return new Condition(convertConditions.apply(null, arguments), 'NOT', null);
			};

			/**
			 * Returns the object type name.
			 * @returns {string}
			 */
			this.toString = function toString()
			{
				return TYPE;
			};

			/**
			 * JSON.stringify() implementation.
			 * @returns {Object}
			 */
			this.toJSON = function toJSON()
			{
				return {
					type: _type,
					id: _searchId,
					condition: _condition ? _condition.toJSON() : null,
					columns: jsonifyArray(_columns),
					sort: jsonifyArray(_sort),
					child: _root ? jsonifyObject(_root.child) : null,
					root: _root ? _root.toJSON() : null
				};
			};

			this.marshal = function marshal()
			{
				var col = [];
				for (var i = 0; i < _columns.length; i++)
					col.push(_columns[i].marshal());
				return JSON.stringify({
					type: _type,
					id: _searchId,
					condition: _condition ? _condition.marshal() : null,
					columns: col,
					sort: jsonifyArray(_sort, true, _columns)
				});
			};
		}

		Search.prototype = nsobject.getNewInstance();

		function jsonifyArray(arr, marshal, aux)
		{
			if (arr == null)
				return null;
			var result = [];
			for (var i = 0; i < arr.length; i++)
			{
				result.push(marshal ? arr[i].marshal(aux) : arr[i].toJSON());
			}
			return result;
		}

		function jsonifyObject(obj, marshal)
		{
			if (obj == null)
				return null;
			var result = {};
			for (var i in obj)
			{
				if (obj.hasOwnProperty(i))
					result[i] = marshal ? obj[i].marshal() : obj[i].toJSON();
			}
			return result;
		}

		/**
		 * One component of the search definition. The Search object always contains at least one Component object called the root
		 * component. Searches with multi-level joins contain multiple Component objects linked together into a parent/child hierarchy.
		 */
		function Component(type, polymorphic, inverse, parent)
		{
			var TYPE = MOD_PREFIX + 'Component';

			var _type = type;
			var _parent = parent;
			var _polymorphic = polymorphic;
			var _inverse = inverse;
			var _children = {};

			/**
			 * Search type. Returns the search type of this component.
			 * @name Component#type
			 * @type string
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'type', {
				get: function ()
				{
					return _type;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'type');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Inverse target. Returns the inverse target of this component.
			 * @name Component#inverse
			 * @type string
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'inverse', {
				get: function ()
				{
					return _inverse;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'inverse');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Polymorphic target. Returns the polymorphic target of this component.
			 * @name Component#polymorphic
			 * @type string
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'polymorphic', {
				get: function ()
				{
					return _polymorphic;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'polymorphic');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Returns the Component that corresponds to the ancestor of this component in the search object model.
			 * @name Component#parent
			 * @type string
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'parent', {
				get: function ()
				{
					return _parent;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'parent');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Children of this component. It is an object with key/value pairs where key is the name of the child component
			 * and value is the corresponding Component object.
			 * @name Component#child
			 * @type Object
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'child', {
				get: function ()
				{
					return _children;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'child');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * join this component with another search type. A new component corresponding to the given relationship is created
			 * and joined with this one.
			 * @param {Object} options
			 * @param {string} options.relationship The name of the relationship that will be used to determine the search type of the
			 *                                      newly joined component and also the columns on which the search types will be joined
			 *                                      together. For example "salesrep".
			 * @param {string} options.polymorphic (optional) The name of polymorphic join
			 * @param {string} options.inverse (optional) The name of inverse join
			 * @throws {error.SuiteScriptError} MISSING_REQD_ARGUMENT if relationship is undefined
			 * @throws {error.SuiteScriptError} RELATIONSHIP_ALREADY_USED if relationship is already used
			 * @returns {Component}
			 */
			this.join = function join(options)
			{
				var type = (options && options.hasOwnProperty('relationship')) ? options.relationship : options;
				var polymorphic = (options && options.hasOwnProperty('polymorphic')) ? options.polymorphic : null;
				var inverse = (options && options.hasOwnProperty('inverse')) ? options.inverse : null;
				if (inverse && polymorphic && inverse !== polymorphic)
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_ARGUMENT_DISCREPANCY, polymorphic, inverse, "polymorphic", "inverse");
				utilityFunctions.checkArgs([type], ['relationship'], 'Component.join');
				if (!!_children[type])
					utilityFunctions.throwSuiteScriptError(error.Type.RELATIONSHIP_ALREADY_USED, type);
				var result = new Component(type, polymorphic, inverse, this);
				_children[type] = result;
				return result;
			};

			/**
			 * Create a Condition object based on this search component. Use either name + operator + values or formula + (optional)
			 * type.
			 * @param {Object} options
			 * @param {string} options.name Field (column) name
			 * @param {string} options.operator Operator. Use the Operator enum.
			 * @param {string[]} options.values Array of values
			 * @param {string} options.formula Formula
			 * @param {string} options.type (optional) Explicitly define value type in case it is not determined correctly from the
			 *                                         formula. Use the ReturnType enum.
			 * @param {string} options.aggregate (optional) Aggregate function. Use the Aggregate enum.
			 * @throws {error.SuiteScriptError} MISSING_REQD_ARGUMENT if options are undefined
			 * @throws {error.SuiteScriptError} WRONG_PARAMETER_TYPE if options isn't object
			 * @throws {error.SuiteScriptError} OPERATOR_ARITY_MISMATCH if requested operator cannot work with specified number of
			 *     arguments
			 * @throws {error.SuiteScriptError} INVALID_SEARCH_OPERATOR if wrong search operator is used
			 * @returns {Condition}
			 */
			this.createCondition = function createCondition(options)
			{
				utilityFunctions.checkArgs([options], ['options'], 'Component.createCondition');
				if (!util.isObject(options))
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'options', 'Object');
				return new Condition(null, options, this);
			};

			/**
			 * Create a Column object based on this search component. Use either name or formula + (optional) type.
			 * @param {Object} options
			 * @param {string} options.name Field (column) name
			 * @param {string} options.formula Formula
			 * @param {string} options.type (optional) Explicitly define value type in case it is not determined correctly from the
			 *                                         formula. Use the ReturnType enum.
			 * @param {string} options.aggregate (optional) Aggregate function. Use the Aggregate enum.
			 * @param {boolean} options.groupBy (optional) Indicates that we want the results grouped by this column; used together
			 *                                             with aggregate function defined on other columns.
			 * @throws {error.SuiteScriptError} MISSING_REQD_ARGUMENT if options are undefined
			 * @throws {error.SuiteScriptError} WRONG_PARAMETER_TYPE if options isn't object
			 * @throws {error.SuiteScriptError} MUTUALLY_EXCLUSIVE_ARGUMENTS when two mutually arguments are defined
			 * @throws {error.SuiteScriptError} NEITHER_ARGUMENT_DEFINED when neither of two mandatory arguments is defined
			 * @returns {Column}
			 */
			this.createColumn = function createColumn(options)
			{
				utilityFunctions.checkArgs([options], ['options'], 'Component.createColumn');
				if (!util.isObject(options))
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'options', 'Object');
				return new Column(options, this);
			};

			/**
			 * Create a Sort object based on this search component.
			 * @param {Object} options
			 * @param {string} options.column The Column by which we want to sort.
			 * @param {string} options.direction (optional) The sort direction. Use the Direction enum. If not specified, Direction.ASC
			 *                                              is the default value.
			 * @returns {Sort}
			 */
			this.createSort = function createSort(options)
			{
				var column, direction;
				if (options && options.hasOwnProperty('column'))
				{
					column = options.column;
					direction = options.direction;
				}
				else
				{
					column = options;
					direction = arguments[1];
				}
				utilityFunctions.checkArgs([column], ['column'], 'Component.createSort');
				if (!(column instanceof Column))
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'column', 'Column');
				return new Sort(column, direction);
			};

			this.toString = function toString()
			{
				return TYPE;
			};
			this.toJSON = function toJSON()
			{
				return {
					type: _type,
					inverse: _inverse,
					polymorphic: _polymorphic,
					parent: _parent
				};
			};
			this.getJoins = function getJoins(field, includeRoot)
			{
				var result = field;
				for (var comp = this; (includeRoot ? comp : comp.parent) != null; comp = comp.parent)
					result = comp.type + '.' + result;
				return String(result);
			}
		}

		Component.prototype = nsobject.getNewInstance();

		/**
		 * Specifies a return column.
		 */
		function Column(options, component)
		{
			var TYPE = MOD_PREFIX + 'Column';

			var _name = options.name ? options.name : null;
			var _component = component;
			var _formula = options.formula ? options.formula : null;
			var _type = options.type ? options.type : null;
			var _aggregate = options.aggregate ? options.aggregate : null;
			var _groupBy = options.groupBy === true;

			if (!_name && !_formula)
				utilityFunctions.throwSuiteScriptError(error.Type.NEITHER_ARGUMENT_DEFINED, 'name', 'formula');
			else if (_name && _formula)
				utilityFunctions.throwSuiteScriptError(error.Type.MUTUALLY_EXCLUSIVE_ARGUMENTS, 'name', 'formula');
			if (_aggregate && _groupBy)
				utilityFunctions.throwSuiteScriptError(error.Type.MUTUALLY_EXCLUSIVE_ARGUMENTS, 'aggregate', 'groupBy');

			/**
			 * Column name.
			 * @name Column#name
			 * @type string
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'name', {
				get: function ()
				{
					return _name;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'name');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Search component. Returns the Component to which this column belongs.
			 * @name Column#component
			 * @type Component
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'component', {
				get: function ()
				{
					return _component;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'component');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Formula.
			 * @name Column#formula
			 * @type string
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'formula', {
				get: function ()
				{
					return _formula;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'formula');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Desired value type of the formula (if it was explicitly stated upon Column creation).
			 * @name Column#type
			 * @type string
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'type', {
				get: function ()
				{
					return _type;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'type');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Aggregate function.
			 * @name Column#aggregate
			 * @type string (value from Aggregate enum)
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'aggregate', {
				get: function ()
				{
					return _aggregate;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'aggregate');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * The group-by flag.
			 * @name Column#groupBy
			 * @type boolean
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'groupBy', {
				get: function ()
				{
					return _groupBy;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'groupBy');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			this.toString = function toString()
			{
				return TYPE;
			};
			this.toJSON = function toJSON()
			{
				return {
					name: _component ? _component.getJoins(_name, true) : _name,
					component: _component ? _component.toJSON() : null,
					formula: _formula,
					type: _type,
					aggregate: _aggregate,
					groupBy: _groupBy
				};
			};
			this.marshal = function marshal()
			{
				var res = {};
				if (_formula)
				{
					res.formula = _formula;
					if (_type)
						res.type = _type;
				}
				else
				{
					res.name = this.getJoins();
				}
				if (_aggregate)
					res.aggregate = _aggregate;
				if (_groupBy)
					res.groupBy = _groupBy;
				if (_component)
				{
					if (_component.polymorphic)
						res.polymorphic = _component.polymorphic;
					if (_component.inverse)
						res.inverse = _component.inverse;
				}
				return res;
			};
			this.getJoins = function getJoins()
			{
				return _component ? _component.getJoins(_name) : _name;
			}
		}

		Column.prototype = nsobject.getNewInstance();

		/**
		 * Specifies sorting by the values of a given column and the sort direction.
		 */
		function Sort(column, direction)
		{
			var TYPE = MOD_PREFIX + 'Sort';

			var _column = column;
			var _direction = direction ? direction : SORT.ASC;

			/**
			 * The search column by which we want to sort.
			 * @name Sort#column
			 * @type Column
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'column', {
				get: function ()
				{
					return _column;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'column');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Sort direction.
			 * @name Sort#direction
			 * @type string (value from the Sort enum)
			 * @throws {error.SuiteScriptError} WRONG_PARAMETER_TYPE when setting wrong sort order is attempted
			 */
			Object.defineProperty(this, 'direction', {
				get: function ()
				{
					return _direction;
				},
				set: function (direction)
				{
					if (direction !== SORT.ASC && direction !== SORT.DESC)
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'direction', 'Sort.direction');
					_direction = direction;
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			this.toString = function toString()
			{
				return TYPE;
			};
			this.toJSON = function toJSON()
			{
				return {
					column: _column ? _column.toJSON() : null,
					direction: _direction
				};
			};
			this.marshal = function marshal(columns)
			{
				var colOfs = -1;
				for (var i = 0; i < columns.length; i++)
				{
					if (columns[i] === _column)
					{
						colOfs = i;
						break;
					}
				}
				var res = {
					col: colOfs,
					direction: _direction
				};

				if (_column.component.polymorphic)
					res.polymorphic = _column.component.polymorphic;
				if (_column.component.inverse)
					res.inverse = _column.component.inverse;

				return res;
			};
		}

		Sort.prototype = nsobject.getNewInstance();

		/**
		 * Specifies the condition used to filter the results. It can consist of other Condition objects.
		 */
		function Condition(children, options, component)
		{
			var TYPE = MOD_PREFIX + 'Condition';

			var undef = undefined;
			var _children = null;
			var _name = null;
			var _op = null;
			var _values = null;
			var _formula = null;
			var _type = null;
			var _aggregate = null;
			var _component = null;

			if (children)
			{
				_children = children;
				_op = options;
			}
			else
			{
				_name = options.name ? options.name : null;
				_op = options.operator ? options.operator : null;
				_values = options.values === undef ? null : options.values;
				_formula = options.formula ? options.formula : null;
				_type = options.type ? options.type : null;
				_aggregate = options.aggregate ? options.aggregate : null;
				_component = component;

				if (!_name && !_formula)
					utilityFunctions.throwSuiteScriptError(error.Type.NEITHER_ARGUMENT_DEFINED, 'name', 'formula');
				else if (_name && _formula)
					utilityFunctions.throwSuiteScriptError(error.Type.MUTUALLY_EXCLUSIVE_ARGUMENTS, 'name', 'formula');
				utilityFunctions.checkArgs([_op], ['operator'], 'Component.createCondition');
				if (!OPERATOR[_op])
					utilityFunctions.throwSuiteScriptError(error.Type.INVALID_SEARCH_OPERATOR, _op);
				if (util.isArray(_values))
					_values = _values.filter(function(el){return el !== null && el !== undef});
				var numValues = util.isArray(_values) ? _values.length : _values === null ? 0 : 1;
				var arity = ALLOWED_ARITY[_op];
				if (numValues + 1 > arity[1] || numValues + 1 < arity[0])
					utilityFunctions.throwSuiteScriptError(error.Type.OPERATOR_ARITY_MISMATCH, _op);
			}

			/**
			 * This is only applicable to "non-leaf" conditions that were created by AND-ing, OR-ing or NOT-ing other Condition objects.
			 * In such case this property holds the child Component objects that are arguments of the logical operation.
			 * @name Condition#children
			 * @type Condition[]
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'children', {
				get: function ()
				{
					return _children;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'children');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Field name. This is only applicable to "leaf" conditions (equivalent to the former Filter).
			 * @name Condition#name
			 * @type string
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'name', {
				get: function ()
				{
					return _name;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'name');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Operator. This is only applicable to "leaf" conditions (equivalent to the former Filter).
			 * @name Condition#operator
			 * @type string (values from the Operator enum)
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'operator', {
				get: function ()
				{
					return _op;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'operator');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Values. This is only applicable to "leaf" conditions (equivalent to the former Filter).
			 * @name Condition#values
			 * @type string[]
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'values', {
				get: function ()
				{
					return _values;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'values');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Formula. This is only applicable to "leaf" conditions (equivalent to the former Filter).
			 * @name Condition#formula
			 * @type string
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'formula', {
				get: function ()
				{
					return _formula;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'formula');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Return type of the formula, if explicitly specified. This is only applicable to "leaf" conditions (equivalent to the
			 * former Filter).
			 * @name Condition#type
			 * @type string (values from the ReturnType enum)
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'type', {
				get: function ()
				{
					return _type;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'type');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Aggregate function. This is only applicable to "leaf" conditions (equivalent to the former Filter).
			 * @name Condition#aggregate
			 * @type string (values from the Aggregate enum)
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'aggregate', {
				get: function ()
				{
					return _aggregate;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'aggregate');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Search component to which this condition belongs. This is only applicable to "leaf" conditions (equivalent to the
			 * former Filter).
			 * @name Condition#component
			 * @type string
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'component', {
				get: function ()
				{
					return _component;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'component');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			this.toString = function toString()
			{
				return TYPE;
			};
			this.toJSON = function toJSON()
			{
				return {
					children: jsonifyArray(_children),
					name: _name,
					operator: _op,
					formula: _formula,
					type: _type,
					aggregate: _aggregate,
					values: _values,
					component: _component ? _component.toJSON() : null
				};
			};
			this.marshal = function marshal()
			{
				var res = {};
				if (_children)
				{
					res.children = jsonifyArray(_children, true);
					res.operator = _op;
				}
				else
				{
					if (_formula)
					{
						res.formula = _formula;
						res.type = _type;
					}
					else
						res.field = _component ? _component.getJoins(_name) : _name;

					res.operator = _op;
					res.values = _values;

					if (_component)
					{
						if (_component.polymorphic)
							res.polymorphic = _component.polymorphic;
						if (_component.inverse)
							res.inverse = _component.inverse;
					}

					if (_aggregate)
						res.aggregate = _aggregate;
				}
				return res;
			};
		}

		Condition.prototype = nsobject.getNewInstance();

		/**
		 * Set of results returned by the search.
		 */
		function ResultSet(data, columns)
		{
			var TYPE = MOD_PREFIX + 'ResultSet';

			var _columns = columns;
			var _results = [];
			for (var i = 0; i < data.count; i++)
			{
				_results.push(new Result(Array.prototype.slice.call(data['v' + i]), columns));
			}
			var _types = [];
			for (var i = 0; i < data.types.length; i++)
			{
				_types.push(data.types[i]);
			}

			/**
			 * Standard object for iterating through results.
			 * @governance 10 points for each page returned
			 * @returns {Iterator}
			 */
			this.iterator = function iterator() {
				return iteratorFactory.create(new ResultsIterator(_results));
			};

			/**
			 * The actual search results.
			 * @name ResultSet#results
			 * @type Result[]
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'results', {
				get: function ()
				{
					return _results;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'results' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * The types of the return values. Array of values from the ReturnType enum. Number and order of values in the array
			 * exactly matches the ResultSet#columns property.
			 * @name ResultSet#types
			 * @type string[]
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'types', {
				get: function ()
				{
					return _types;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'types' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * The return columns.
			 * @name ResultSet#columns
			 * @type Column[]
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'columns', {
				get: function ()
				{
					return _columns;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'columns' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			this.toString = function toString()
			{
				return TYPE;
			};
			this.toJSON = function toJSON()
			{
				return {
					columns: _columns,
					types: _types,
					results: _results
				};
			}
		}

		ResultSet.prototype = nsobject.getNewInstance();

		function ResultsIterator(results) {
			var i = 0;
			this.hasNext = function hasNext() {
				return i < results.length;
			}

			this.next = function next() {
				return results[i++];
			}
		}
		ResultsIterator.prototype = nsobject.getNewInstance();

		/**
		 * Corresponds to a single row of the ResultSet.
		 */
		function Result(values, columns)
		{
			var TYPE = MOD_PREFIX + 'Result';

			var _values = values;
			var _columns = columns;

			this.getValue = function getValue(options)
			{
				return _values[options];
			};

			/**
			 * The result values. Value types correspond to the ResultSet#types property. Number and order of values in the array
			 * exactly matches the ResultSet#types, ResultSet#columns or Result#columns property.
			 * @name Result#values
			 * @type string|number[]
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'values', {
				get: function ()
				{
					return _values;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'values' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * The return columns. This is equivalent to ResultSet#columns.
			 * @name Result#columns
			 * @type Column[]
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'columns', {
				get: function ()
				{
					return _columns;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'columns' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			this.toString = function toString()
			{
				return TYPE;
			};
			this.toJSON = function toJSON()
			{
				return {
					values: _values,
					columns: _columns
				};
			};
		}

		Result.prototype = nsobject.getNewInstance();

		/**
		 * Create a Search object with a single search component based on the given search type.
		 * @param {Object} options
		 * @param {string} options.type The search type. Use the Type enum.
		 * @throws {error.SuiteScriptError} INVALID_RCRD_TYPE when search type is invalid
		 * @returns {Search}
		 */
		function createSearch(options)
		{
			var type = (options && options.hasOwnProperty('type')) ? options.type : options;
			utilityFunctions.checkArgs([type], ['type'], 'createSearch');
			invoker(searchApi, 'assertValidSearchType', [type]);
			var result = new Search(type);
			return result;
		}

		/*
		 * Object for handling paged searches
		 */
		function PagedData(options)
		{
			var TYPE = MOD_PREFIX + 'PagedData';

			var pageSize = options.pageSize;
			var search = options.searchDefinition;
			var searchData = options.searchData;
			var columns = options.columns;
			var pageRanges = function()
			{
				var ranges = [];
				for (var i = 0; i < searchData.numPages; i++)
					ranges.push(new PageRange({index:i, size: pageSize > 0 ? pageSize * (i + 1) > searchData.total ? searchData.total % pageSize : pageSize : 0}));
				return ranges;
			}();

			function validateAndGetIndex(options, length)
			{
				var index = (options && options.hasOwnProperty('index')) ? options.index : options;
				utilityFunctions.checkArgs([index], ['index'], 'PagedData.fetch');
				index = parseInt(index);
				if (isNaN(index))
					utilityFunctions.throwSuiteScriptError(error.Type.INVALID_PAGE_INDEX, index);
				if(index < 0 || index >= length)
					utilityFunctions.throwSuiteScriptError(error.Type.INVALID_PAGE_RANGE, 'fetch');
				return index;
			}

			/**
			 * Get page with given index
			 * @param {Object} options
			 * @param {string} options.index Index of page to return
			 * @throws {error.SuiteScriptError} MISSING_REQD_ARGUMENT if options are undefined
			 * @throws {error.SuiteScriptError} WRONG_PARAMETER_TYPE if options isn't object nor number
			 * @governance 10 points
			 * @returns {Page}
			 */
			this.fetch = function(options)
			{
				var index = validateAndGetIndex(options, searchData.pages.length);
				return new Page({resultSet: new ResultSet(invoker(queryApi, 'getQueryPage', [searchData.pages[index], search]), columns), index: index, size: pageSize, total: searchData.total, pagedData: this, pageRange: pageRanges[index]});

			};

			function pagedPromise(search, searchData, columns, pageSize, options)
			{
				var pagedData = this;
				return new Promise(
					function(resolve, reject) {
						try {
							var index = validateAndGetIndex(options, searchData.pages.length);
							invoker(queryApi, 'getQueryPage', [searchData.pages[index], search], callback);
						}
						catch (e) {
							reject(e);
						}

						function callback(result) {
							if (result instanceof Error) {
								reject(result);
								return;
							}
							try {
								resolve(new Page({resultSet:new ResultSet(result, columns), index: index, size: pageSize, total: searchData.total, pagedData: pagedData, pageRange: pageRanges[index]}));
							}
							catch (e) {
								reject(e);
							}
						}
					}
				);
			}

			/**
			 * Asynchronously get page with given index
			 * @param {Object} options
			 * @param {string} options.index Index of page to return
			 * @throws {error.SuiteScriptError} MISSING_REQD_ARGUMENT if options are undefined
			 * @throws {error.SuiteScriptError} WRONG_PARAMETER_TYPE if options isn't object nor number
			 * @returns {Page}
			 */
			this.fetch.promise = pagedPromise.bind(this, search, searchData, columns, pageSize);

			/**
			 * Standard object for iterating through pages.
			 * @governance 10 points for each page returned
			 * @returns {Iterator}
			 */
			this.iterator = function iterator() {
				return iteratorFactory.create(new PageIterator(this, searchData));
			};

			/**
			 * Size of the page
			 * @name PageData#pageSize
			 * @type number
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'pageSize', {
				get: function ()
				{
					return pageSize;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'pageSize' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Total number of results
			 * @name PagedData#count
			 * @type number
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'count', {
				get: function ()
				{
					return searchData.total;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'totalResults' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Number of pages
			 * @name PagedData#searchDefinition
			 * @type number
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'searchDefinition', {
				get: function ()
				{
					return search;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'searchDefinition' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * PageRanges of PagedData
			 * @name PagedData#pageRanges
			 * @type PageRange[]
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'pageRanges', {
				get: function ()
				{
					return pageRanges;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'pageRanges' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			this.toString = function toString()
			{
				return TYPE;
			};

			this.toJSON = function toJSON()
			{
				return {
					pageRanges: pageRanges,
					count: searchData.total,
					pageSize: pageSize,
					searchDefinition: search
				};
			};
		}

		PagedData.prototype = nsobject.getNewInstance();

		function PageIterator(search, searchData) {
			var i = 0;
			this.hasNext = function hasNext() {
				return i < searchData.numPages;
			}

			this.next = function next() {
				return search.fetch(i++);
			}
		}

		PageIterator.prototype = nsobject.getNewInstance();

		/*
		 * PageRange object
		 */
		function PageRange(options)
		{
			var index = options.index;
			var size = options.size;
			/**
			 * Index of this page range in array
			 * @name PageRange#index
			 * @type number
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'index', {
				get: function ()
				{
					return index;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'index' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Number of results in this page range
			 * @name PageRange#size
			 * @type number
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'size', {
				get: function ()
				{
					return size;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'size' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});
		}

		/*
		 * Object corresponding to one page of results
		 */
		function Page(options)
		{
			var TYPE = MOD_PREFIX + 'Page';

			var resultSet = options.resultSet;
			var pagedData = options.pagedData;
			var pageRange = options.pageRange;
			var isFirst = !!pageRange && pageRange.index == 0;
			var isLast = !!pageRange && pagedData.pageRanges[pagedData.pageRanges.length - 1] == pageRange;

			/**
			 * ResultSet of the page
			 * @name Page#data
			 * @type ResultSet
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'data', {
				get: function ()
				{
					return resultSet;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'data' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * PagedData from which was this page taken
			 * @name QueryPage#pagedData
			 * @type PagedData
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'pagedData', {
				get: function ()
				{
					return pagedData;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'pagedData' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * PageRange object for this page
			 * @name QueryPage#pageRange
			 * @type PageRange
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'pageRange', {
				get: function ()
				{
					return pageRange;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'pageRange' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Indication whether this page is the first one
			 * @name Page#isFirst
			 * @type Boolean
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'isFirst', {
				get: function ()
				{
					return isFirst;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isFirst' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Indication whether this page is the last one
			 * @name Page#isLast
			 * @type Boolean
			 * @readonly
			 * @throws {error.SuiteScriptError} READ_ONLY when setting the property is attempted
			 */
			Object.defineProperty(this, 'isLast', {
				get: function ()
				{
					return isLast;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isLast' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			this.toString = function toString()
			{
				return TYPE;
			};

			this.toJSON = function toJSON()
			{
				return {
					pagedData: pagedData,
					data: resultSet,
					isFirst: isFirst,
					isLast: isLast,
					pageRange: pageRange
				};
			};
		}

		Page.prototype = nsobject.getNewInstance();

		/**
		 * TODO not yet implemented
		 * @param options
		 */
		function loadSearch(options)
		{
		}


		return Object.freeze({
			create: createSearch,

			load: loadSearch,

			SortDirection: SORT,

			Operator: OPERATOR,

			Aggregate: AGGREGATE,

			ReturnType: RETURN_TYPE,

			get Type()
			{
				return search.Type;
			}
		});
	});

/**
 * @private
 */
define('N/restricted/scriptArguments',[], function (){ return {}; });

/**
 * @private
 */
define('N/restricted/httpApi',['N/restricted/reflet'], function(reflet){ return reflet; });

/**
 * SuiteScript module - common functionality between http and https modules
 *
 * @private
 * @module N/http/httpUtil
 * @NApiVersion 2.x
 *
 */
define('N/http/httpUtil',['N/restricted/bridge', 'N/restricted/scriptArguments', 'N/error', 'N/file', 'N/nsobject', 'N/restricted/invoker', 'N/utilityFunctions', 'N/restricted/httpApi'],
       function (apiBridge, scriptArguments, error, file, nsobject, invoker, utilityFunctions, httpApi)
       {
           //enums
           var METHODS = Object.freeze({
                                             GET: 'GET',
                                             POST: 'POST',
                                             PUT: 'PUT',
                                             DELETE: 'DELETE',
                                             HEAD: 'HEAD'
                                         });

           var CACHE_DURATIONS = Object.freeze({
                                                     UNIQUE: 'UNIQUE',
                                                     SHORT: 'SHORT',
                                                     MEDIUM: 'MEDIUM',
                                                     LONG: 'LONG'
                                                 });

           var REDIRECT_TYPES = Object.freeze({
               RECORD: 'RECORD',
               SUITELET: 'SUITELET',
               RESTLET: 'RESTLET',
               MEDIA_ITEM: 'MEDIAITEM',
               TASK_LINK: 'TASKLINK'
           });

           /**
            * Return a new instance of ClientResponse used to store the result of a HTTP request.
            *
            * @protected
            * @classDescription Encapsulation of the response returned by a web server as a response to our HTTP request.
            * @return {http.ClientResponse}
            * @constructor
            *
            * @since 2015.2
            */
           function ClientResponse(delegate)
           {
               var TYPE = 'http.ClientResponse';
               /**
                * Response code.
                * @name ClientResponse#code
                * @type number
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
                */
               Object.defineProperty(this, 'code', {
                   get: function ()
                   {
                       return delegate.getCode ? delegate.getCode() : delegate.code;
                   },
                   set: function (val)
                   {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'code' );
                   },
                   enumerable: true,
                   configurable: false,
                   writeable: false
               });
               /**
                * Response headers.
                * @name ClientResponse#headers
                * @type Object
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
                */
               Object.defineProperty(this, 'headers', {
                   get: function ()
                   {
                       var headers = {};
                       if (delegate.getAllHeaders)
                       {
                           var headerNames = delegate.getAllHeaders();
                           var headers = {};
                           for (var i = 0; i < headerNames.length; i++)
                               headers[headerNames[i]] = delegate.getHeader(headerNames[i]);
                       }
                       else
                       {
                           headers = delegate.headers;
                       }
                       return headers;
                   },
                   set: function (val)
                   {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'headers' );
                   },
                   enumerable: true,
                   configurable: false,
                   writeable: false
               });
               /**
                * Response body.
                * @name ClientResponse#body
                * @type string
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
                */
               Object.defineProperty(this, 'body', {
                   get: function ()
                   {
                       return delegate.getBody ? delegate.getBody() : delegate.body;
                   },
                   set: function (val)
                   {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'body' );
                   },
                   enumerable: true,
                   configurable: false,
                   writeable: false
               });
               /**
                * Returns the object type name (http.ClientResponse)
                *
                * @returns {string}
                */
                this.toString = function toString()
               {
                   return TYPE;
               };
               /**
                * JSON.stringify() implementation.
                *
                * @returns {{type: string, code: *, headers: *, body: *}}
                */
                this.toJSON = function toJSON()
               {
                   return {
                       type: TYPE,
                       code: this.code,
                       headers: this.headers,
                       body: this.body
                   };
               }
           }

           ClientResponse.prototype = nsobject.getNewInstance();

           function checkParams(config, required, optional)
           {
               checkConfig(config);
               for (var i = 0; i < required.length; i++)
               {
                   if (!config[required[i]] && config[required[i]] !== 0)
                       utilityFunctions.throwSuiteScriptError(error.Type.MISSING_REQD_ARGUMENT, "options." + required[i] );

               }
           }

           function checkConfig(config)
           {
               if (!config)
                   utilityFunctions.throwSuiteScriptError(error.Type.MISSING_REQD_ARGUMENT, 'options object' );
           }

           function runRequest(options, callback)
           {
               var hasBody = options.method === this.Method.POST || options.method === this.Method.PUT;
               this.checkParams(options, hasBody ? ['method', 'url', 'body'] : ['method', 'url'], ['headers']);
               var url = '' + options.url;
               utilityFunctions.assertTrue((url.indexOf("https:") !== 0), error.Type.SSS_INVALID_URL, "HTTP");
               var headers = options.headers || null;
               var isClient = typeof document != 'undefined';
               if (url[0] == '/')
               {
                   utilityFunctions.assertTrue(isClient, error.Type.SSS_INVALID_URL, "HTTP");
                   url = 'http://' + document.location.host + url;
               }
               if (isClient)
               {
                   if (!headers)
                       headers = {};
               }
               headers = invoker(apiBridge, "nsObjectToMap", [headers]);
               return invoker(httpApi, "nlapiRequestURL", [url, hasBody ? options.body : null, headers, options.method], callback);
           }

           /** @alias N/http */
           return Object.freeze(
                   {
                       /**
                        * Enum for HTTP methods.
                        * @enum {string}
                        */
                       Method: METHODS,
                       /**
                        * Enum for caching durations.
                        * @enum {string}
                        */
                       CacheDuration: CACHE_DURATIONS,
                       /**
                        * Enum for redirect types.
                        * @enum {string}
                        */
                       RedirectType: REDIRECT_TYPES,
                       /**
                        * Send a HTTP GET request and return server response.
                        *
                        * @governance 10 units
                        * @restriction Server SuiteScript only
                        *
                        * @param {Object} options
                        * @param {string} options.url the HTTP URL being requested
                        * @param {Object} options.headers (optional) request HTTP headers
                        * @return {ClientResponse}
                        *
                        * @throws {SuiteScriptError} REQUIRED_PARAM_MISSING if a required parameter is missing
                        * @throws {SuiteScriptError} UNKNOWN_PARAM if an unknown parameter is present in options
                        * @throws {SuiteScriptError} SSS_INVALID_URL if an incorrect protocol is used (ex: http in the HTTPS module)
                        *
                        * @since 2015.2
                        */
                       get: function get(config, headers, httpClient)
                       {
                           checkConfig(config);
                           if (!utilityFunctions.isObject(config))
                           {
                               var url = config;
                               config = {url: url, headers: headers || null};
                           }
                           config.method = this.Method.GET;
                           return this.request(config, httpClient);
                       },
                       /**
                        * Send a HTTP POST request and return server response.
                        *
                        * @governance 10 units
                        * @restriction Server SuiteScript only
                        *
                        * @param {Object} options
                        * @param {string} options.url the HTTP URL being requested
                        * @param {string|Object} options.body POST data
                        * @param {Object} options.headers (optional) request HTTP headers
                        * @return {ClientResponse}
                        *
                        * @throws {SuiteScriptError} REQUIRED_PARAM_MISSING if a required parameter is missing
                        * @throws {SuiteScriptError} UNKNOWN_PARAM if an unknown parameter is present in options
                        * @throws {SuiteScriptError} SSS_INVALID_URL if an incorrect protocol is used (ex: http in the HTTPS module)
                        *
                        * @since 2015.2
                        */
                       post: function post(config, httpClient)
                       {
                           checkConfig(config);
                           config.method = this.Method.POST;
                           return this.request(config, httpClient);
                       },
                       /**
                        * Send a HTTP PUT request and return server response.
                        *
                        * @governance 10 units
                        * @restriction Server SuiteScript only
                        *
                        * @param {Object} options
                        * @param {string} options.url the HTTP URL being requested
                        * @param {string|Object} options.body PUT data
                        * @param {Object} options.headers (optional) request HTTP headers
                        * @return {ClientResponse}
                        *
                        * @throws {SuiteScriptError} REQUIRED_PARAM_MISSING if a required parameter is missing
                        * @throws {SuiteScriptError} UNKNOWN_PARAM if an unknown parameter is present in options
                        * @throws {SuiteScriptError} SSS_INVALID_URL if an incorrect protocol is used (ex: http in the HTTPS module)
                        *
                        * @since 2015.2
                        */
                       put: function put(config, httpClient)
                       {
                           checkConfig(config);
                           config.method = this.Method.PUT;
                           return this.request(config, httpClient);
                       },
                       /**
                        * Send a HTTP DELETE request and return server response.
                        *
                        * @governance 10 units
                        * @restriction Server SuiteScript only
                        *
                        * @param {Object} options
                        * @param {string} options.url the HTTP URL being requested
                        * @param {Object} options.headers (optional) request HTTP headers
                        * @return {ClientResponse}
                        *
                        * @throws {SuiteScriptError} REQUIRED_PARAM_MISSING if a required parameter is missing
                        * @throws {SuiteScriptError} UNKNOWN_PARAM if an unknown parameter is present in options
                        * @throws {SuiteScriptError} SSS_INVALID_URL if an incorrect protocol is used (ex: http in the HTTPS module)
                        *
                        * @since 2015.2
                        */
                       'delete': function (config, headers, httpClient)
                       {
                           checkConfig(config);
                            if (!utilityFunctions.isObject(config))
                           {
                               var url = config;
                               config = {url: url, headers: headers || null};
                           }
                           config.method = this.Method.DELETE;
                           return this.request(config, httpClient);
                       },
                       /**
                        * Send a HTTP request and return server response.
                        *
                        * @governance 10 units
                        * @restriction Server SuiteScript only
                        *
                        * @param {Object} options
                        * @param {http.Method} options.method HTTP method of the request
                        * @param {string} options.url the HTTP URL being requested
                        * @param {string|Object} options.body POST data; must be present if and only if method is POST
                        * @param {Object} options.headers (optional) request HTTP headers
                        * @return {ClientResponse}
                        *
                        * @throws {SuiteScriptError} REQUIRED_PARAM_MISSING if a required parameter is missing
                        * @throws {SuiteScriptError} UNKNOWN_PARAM if an unknown parameter is present in options
                        * @throws {SuiteScriptError} SSS_INVALID_URL if an incorrect protocol is used (ex: http in the HTTPS module)
                        *
                        * @since 2015.2
                        */
                       request: function request(options, httpClient)
                       {
                           return httpClient.doRequest(options);
                       },
                       setRequester: function setRequester(val)
                       {
                           requester = val;
                       },
                       createClientResponse: function createClientResponse(val)
                       {
                           return new ClientResponse(val);
                       },
                       checkConfig: checkConfig,
                       checkParams: checkParams,
                       runRequest: runRequest,
                   });
       });

/**
 * SuiteScript module - defines the Suitelet response and request objects
 *
 * @module N/suiteletContext
 * @NApiVersion 2.x
 *
 */

define('N/suiteletContext',['N/restricted/scriptArguments', 'N/error', 'N/file', 'N/nsobject', 'N/restricted/invoker', 'N/utilityFunctions'],
        function (scriptArguments, error, file, nsobject, invoker, utilityFunctions)
        {
			/**
			 * Return a new instance of ServerRequest object that carries incoming HTTP request info.
			 *
			 * @classDescription Encapsulation of the HTTP request incoming to the suitelet.
			 * @return {http.ServerRequest}
			 * @constructor
			 *
			 * @since 2015.2
			 */
			function ServerRequest(delegate)
			{
				var TYPE = 'http.ServerRequest';
				/**
				 * Server request headers.
				 * @name ServerRequest#headers
				 * @type Object
				 * @readonly
				 * @throws {error.SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
				 */
				Object.defineProperty(this, 'headers', {
					get: function ()
					{
						return invoker(delegate, 'getAllHeaders', []);
					},
					set: function (val)
					{
						throw error.create({name: error.Type.READ_ONLY_PROPERTY, message: 'headers'});
					},
					enumerable: true,
					configurable: false
				});
				/**
				 * Server request clientIpAddress.
				 * @name ServerRequest#clientIpAddress
				 * @type Object
				 * @readonly
				 * @throws {error.SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
				 */
				Object.defineProperty(this, 'clientIpAddress', {
					get: function ()
					{
						return invoker(delegate, 'getClientIpAddress', []);
					},
					set: function (val)
					{
						throw error.create({name: error.Type.READ_ONLY_PROPERTY, message: 'clientIpAddress'});
					},
					enumerable: true,
					configurable: false
				});
				/**
				 * Server request parameters.
				 * @name ServerRequest#parameters
				 * @type Object
				 * @readonly
				 * @throws {error.SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
				 */
				Object.defineProperty(this, 'parameters', {
					get: function ()
					{
						return invoker(delegate, 'getAllParameters', []);
					},
					set: function (val)
					{
						throw error.create({name: error.Type.READ_ONLY_PROPERTY, message: 'parameters'});
					},
					enumerable: true,
					configurable: false
				});
				/**
				 * Server request files.
				 * @name ServerRequest#files
				 * @type Object
				 * @readonly
				 * @throws {error.SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
				 */
				Object.defineProperty(this, 'files', {
					get: function ()
					{
						var fileMap = invoker(delegate, 'getAllFiles', []);
						var files = {};
						for (name in fileMap)
							files[name] = file.wrap(fileMap[name]);
						return files;
					},
					set: function (val)
					{
						throw error.create({name: error.Type.READ_ONLY_PROPERTY, message: 'files'});
					},
					enumerable: true,
					configurable: false
				});
				/**
				 * Server request body.
				 * @name ServerRequest#body
				 * @type string
				 * @readonly
				 * @throws {error.SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
				 */
				Object.defineProperty(this, 'body', {
					get: function ()
					{
						return invoker(delegate, 'getBody', []);
					},
					set: function (val)
					{
						throw error.create({name: error.Type.READ_ONLY_PROPERTY, message: 'body'});
					},
					enumerable: true,
					configurable: false
				});
				/**
				 * Server request HTTP method.
				 * @name ServerRequest#method
				 * @type string
				 * @readonly
				 * @throws {error.SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
				 */
				Object.defineProperty(this, 'method', {
					get: function ()
					{
						return invoker(delegate, 'getMethod', []);
					},
					set: function (val)
					{
						throw error.create({name: error.Type.READ_ONLY_PROPERTY, message: 'method'});
					},
					enumerable: true,
					configurable: false
				});
				/**
				 * Server request URL.
				 * @name ServerRequest#url
				 * @type string
				 * @readonly
				 * @throws {error.SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
				 */
				Object.defineProperty(this, 'url', {
					get: function ()
					{
						return invoker(delegate, 'getURL', []);
					},
					set: function (val)
					{
						throw error.create({name: error.Type.READ_ONLY_PROPERTY, message: 'url'});
					},
					enumerable: true,
					configurable: false
				});
				/**
				 * Returns the number of lines in a sublist.
				 * @param {Object} options
				 * @param {string} options.group sublist internal ID
				 * @returns {integer} the integer value of the number of line items in the sublist
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
				 */
				this.getLineCount = function getLineCount(options)
				{
					var group = (options && options.hasOwnProperty('group')) ? options.group : options;
					utilityFunctions.checkArgs([group], ['group'], 'ServerRequest.getLineCount');
					return invoker(delegate, 'getLineItemCount', [group]);
				};
				/**
				 * Returns the value of a sublist line item.
				 * @param {Object} options
				 * @param {string} options.group sublist internal ID
				 * @param {string} options.name the name of the field whose value is returned
				 * @param {string} options.line the line number for this field (1-based)
				 * @returns {string} the string value of the line item
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
				 */
				this.getSublistValue = function getSublistValue(options)
				{
					var group = null, name = null, line = null;

					if (options && (options.hasOwnProperty('group') || options.hasOwnProperty('name') || options.hasOwnProperty('line')))
					{
						group = options.group;
						name = options.name;
						line = options.line;
					}
					else
					{
						group = options;
						name = arguments[1];
						line = arguments[2];
					}

					utilityFunctions.checkArgs([group, name, line], ['group', 'name', 'line'], 'ServerRequest.getSublistValue');
					return invoker(delegate, 'getLineItemValue', [group, name, line + 1]);
				};
				/**
				 * Returns the object type name (http.ServerRequest)
				 *
				 * @returns {string}
				 */
				this.toString = function toString()
				{
					return TYPE;
				};
				/**
				 * JSON.stringify() implementation.
				 *
				 * @returns {Object}
				 */
				this.toJSON = function toJSON()
				{
					return {
						type: TYPE,
						method: this.method,
						url: this.url,
						parameters: this.parameters,
						headers: this.headers,
						clientIpAddress: this.clientIpAddress,
						files: this.files,
						body: this.body
					};
				}
			}

			ServerRequest.prototype = nsobject.getNewInstance();

			/**
			 * Return a new instance of ServerResponse object that carries the response to an incoming HTTP request.
			 *
			 * @classDescription Encapsulation of the HTTP response that will be returned to the browser.
			 * @return {http.ServerResponse}
			 * @constructor
			 *
			 * @since 2015.2
			 */
			function ServerResponse(delegate)
			{
				var TYPE = 'http.ServerResponse';
				/**
				 * Server response headers.
				 * @name ServerResponse#headers
				 * @type Object
				 * @returns {Object} key/value pairs with all the headers; if multiple values are assigned to one header name, they are returned as an array
				 * @readonly
				 * @throws {error.SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
				 */
				Object.defineProperty(this, 'headers', {
					get: function ()
					{
						var headerNames = invoker(delegate, 'getAllHeaders', []);
						var headers = {};
						for (var i = 0; i < headerNames.length; i++)
						{
							var values = delegate.getHeaders(headerNames[i]);
							headers[headerNames[i]] = values.length == 1 ? values[0] : values;
						}
						return headers;
					},
					set: function (val)
					{
						throw error.create({name: error.Type.READ_ONLY_PROPERTY, message: 'headers'});
					},
					enumerable: true,
					configurable: false
				});
				/*
				 * Helper function for ui.Assistant.sendRedirect()
				 */
				Object.defineProperty(this, '_assistantSendRedirect', {
					set: function (val)
					{
						invoker(val.delegate, 'sendRedirect', [delegate]);
					},
					enumerable: false,
					configurable: false
				});

				/*
				 * Helper function for render.TemplateRenderer.renderToResponse()
				 */
				Object.defineProperty(this, '_renderToResponse', {
					set: function (val)
					{
						return invoker(val, 'renderToResponse', [delegate]);
					},
					enumerable: false,
					configurable: false
				});

				/**
				 * Sets the value of a response header.
				 * @param {Object} options
				 * @param {string} options.name the name of the header
				 * @param {string} options.value the value used to set the header
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
				 * @throws {error.SuiteScriptError} SSS_INVALID_HEADER if the header name or value is invalid
				 */
				this.setHeader = function setHeader(options)
				{
					var name = null, value = null;
					if (options && (options.hasOwnProperty('name') || options.hasOwnProperty('value')))
					{
						name = options.name;
						value = options.value;
					}
					else
					{
						name = options;
						value = arguments[1];
					}
					utilityFunctions.checkArgs([name, value], ['name', 'value'], 'ServerResponse.setHeader');
					invoker(delegate, 'setHeader', [name, value]);
				};
				/**
				 * Adds a header to the response. If this header has already been set, this will add another line for that header.
				 * @param {Object} options
				 * @param {string} options.name the name of the header
				 * @param {string} options.value the value used to set the header
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
				 * @throws {error.SuiteScriptError} SSS_INVALID_HEADER if the header name or value is invalid
				 */
				this.addHeader = function addHeader(options)
				{
					var name = null, value = null;
					if (options && (options.hasOwnProperty('name') || options.hasOwnProperty('value')))
					{
						name = options.name;
						value = options.value;
					}
					else
					{
						name = options;
						value = arguments[1];
					}
					utilityFunctions.checkArgs([name, value], ['name', 'value'], 'ServerResponse.addHeader');
					invoker(delegate, 'addHeader', [name, value]);
				};
				/**
				 * Sets the redirect URL by resolving to a NetSuite resource. Note that all parameters must be prefixed with custparam.
				 * @param {Object} options
				 * @param {string} options.type the base type for this resource - one of RECORD, TASKLINK or SUITELET
				 * @param {string} options.identifier the primary id for this resource
				 * @param {string} options.id (optional) the secondary id for this resource
				 * @param {boolean} options.editMode (optional) for RECORD calls, this determines whether to return a URL for the record in edit mode or view mode
				 * @param {Object} options.parameters (optional) additional URL parameters as name/value pairs
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
				 * @throws {error.SuiteScriptError} SSS_INVALID_URL_CATEGORY if type is none of RECORD, TASKLINK or SUITELET
				 * @throws {error.SuiteScriptError} SSS_INVALID_TASK_ID if type is TASKLINK and an invalid task identifier is passed in the options.identifier parameter
				 * @throws {error.SuiteScriptError} SSS_INVALID_RECORD_TYPE if type is RECORD and an invalid record type is passed in the options.identifier parameter
				 * @throws {error.SuiteScriptError} SSS_INVALID_SCRIPT_ID_1 if type is SUITELET and an invalid script ID and deployment ID are passed in the options.identifier and options.id parameters
				 */
				this.sendRedirect = function sendRedirect(options)
				{
					var type = null, identifier = null, id = null, editMode = false, parameters = null;
					if (options && (options.hasOwnProperty('type') || options.hasOwnProperty('identifier')))
					{
						type = options.type;
						identifier = options.identifier;
						id = options.id ? options.id : null;
						editMode = util.isBoolean(options.editMode) ? options.editMode : false;
						parameters = typeof(options.parameters) === 'object' ? options.parameters : null;
					}
					else
					{
						type = options;
						identifier = arguments[1];
						id = arguments[2] ? arguments[2] : null;
						editMode = util.isBoolean(arguments[3]) ? arguments[3] : false;
						parameters = typeof(arguments[4]) === 'object' ? arguments[4] : null;
					}
					utilityFunctions.checkArgs([type, identifier], ['type', 'identifier'], 'ServerResponse.sendRedirect');
					invoker(delegate, 'sendRedirect', [type, identifier, id, editMode, parameters]);
				};
				/**
				 * Write information (text/xml/html) to the response.
				 * @param {Object} options
				 * @param {string} options.output string or file being written
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
				 * @throws {error.SuiteScriptError} WRONG_PARAMETER_TYPE if the file parameter is not a string
				 */
				this.write = function write(options)
				{
					var output = (options && options.hasOwnProperty('output')) ? options.output : options;
					utilityFunctions.checkArgs([output], ['output'], 'ServerResponse.write');
					utilityFunctions.assertTrue(util.isString(output), error.Type.WRONG_PARAMETER_TYPE, 'output');
					invoker(delegate, 'write', [output]);
				};
				/**
				 * Write line information (text/xml/html) to the response.
				 * @param {Object} options
				 * @param {string} options.output string being written
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
				 * @throws {error.SuiteScriptError} WRONG_PARAMETER_TYPE if the file parameter is not a string
				 */
				this.writeLine = function writeLine(options)
				{
					var output = (options && options.hasOwnProperty('output')) ? options.output : options;
					utilityFunctions.checkArgs([output], ['output'], 'ServerResponse.writeLine');
					utilityFunctions.assertTrue(util.isString(output), error.Type.WRONG_PARAMETER_TYPE, 'output');
					invoker(delegate, 'writeLine', [output]);
				};
				/**
				 * Generates a page using a page element object.
				 * @param {Object} options
				 * @param {serverWidget.Assistant|serverWidget.Form|serverWidget.List} options.pageObject standalone page object: assistant, form or list
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
				 */
				this.writePage = function writePage(options)
				{
					var pageObject = (options && options.hasOwnProperty('pageObject')) ? options.pageObject : options;
					utilityFunctions.checkArgs([pageObject], ['pageObject'], 'ServerResponse.writePage');
					pageObject._writeTo = {'delegate': delegate}
				};
				/**
				 * Write a file to the response.
				 * @param {Object} options
				 * @param {file.File} options.file the file to be written
				 * @param {boolean} options.isInline (optional) true if the file is inline
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
				 * @throws {error.SuiteScriptError} WRONG_PARAMETER_TYPE if the file parameter is not a file.File object
				 */
				this.writeFile = function writeFile(options)
				{
					var fileObj = options && options['file'] !== undefined ? options['file'] : options;
					var isInline = options && options['isInline'] !== undefined ? options['isInline'] : arguments[1];
					utilityFunctions.checkArgs([fileObj], ['file'], 'ServerResponse.writeFile');
					if (fileObj.toString() != 'file.File')
					{
						throw error.create({name: error.Type.WRONG_PARAMETER_TYPE, message: 'file'});
					}
					fileObj._writeTo = {'delegate': delegate, 'isInline': isInline};
				};
				/**
				 * Returns the value for a header returned in the response.
				 * @param {Object} options
				 * @param {string} options.name the header name
				 * @returns {string|Array} the value of the header; if multiple values are assigned to the header name, they are returned as an array
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
				 */
				this.getHeader = function getHeader(options)
				{
					var name = (options && options.hasOwnProperty('name')) ? options.name : options;
					utilityFunctions.checkArgs([name], ['name'], 'ServerResponse.getHeader');
					var values = invoker(delegate, 'getHeaders', [name]);
					return values != null ? (values.length == 1 ? values[0] : values) : null;
				};
				/**
				 * Generates and renders a PDF directly to the response.
				 * @param {Object} options
				 * @param {string} options.xmlString content of your PDF
				 * @governance 10 units
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
				 */
				this.renderPdf = function renderPdf(options)
				{
					var xmlString = (options && options.hasOwnProperty('xmlString')) ? options.xmlString : options;
					utilityFunctions.checkArgs([xmlString], ['xmlString'], 'ServerResponse.renderPdf');
					invoker(delegate, 'renderPDF', [xmlString]);
				};
				/**
				 * Sets CDN caching for a period of time.
				 * @param {Object} options
				 * @param {string} options.type constant value to represent the caching duration, see http.CacheDuration enum
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
				 */
				this.setCdnCacheable = function setCdnCacheable(options)
				{
					var type = (options && options.hasOwnProperty('type')) ? options.type : options;
					utilityFunctions.checkArgs([type], ['type'], 'ServerResponse.setCdnCacheable');
					invoker(delegate, 'setCDNCacheable', [type]);
				};
				/**
				 * Returns the object type name (http.ServerResponse)
				 * @returns {string}
				 */
				this.toString = function toString()
				{
					return TYPE;
				};
				/**
				 * JSON.stringify() implementation.
				 * @returns {Object}
				 */
				this.toJSON = function toJSON()
				{
					return {
						type: TYPE,
						headers: this.headers
					};
				}
			}

			ServerResponse.prototype = nsobject.getNewInstance();

            return Object.freeze(
                    {
                        createServerRequest: function createServerRequest(delegate)
                        {
                            return new ServerRequest(delegate);
                        },
                        createServerResponse: function createServerResponse(delegate)
                        {
                            return new ServerResponse(delegate);
                        },
	                    getServerRequest: function getServerRequest()
                        {
                            return new ServerRequest(scriptArguments.request);
                        },
                        getServerResponse: function getServerResponse()
                        {
                            return new ServerResponse(scriptArguments.response);
                        },
                        _ServerRequest: Object.freeze(ServerRequest)
                    }
            );
        }
);

/**
 * SuiteScript module
 *
 * @module N/common/http
 * @suiteScriptVersion 2.x
 *
 */
define('N/common/http',['N/http/httpUtil', 'N/suiteletContext'],
       function (httpUtil, suiteletContext)
       {

           function requestProcess(options)
           {
               var requestResponse = httpUtil.runRequest(options);
               return httpUtil.createClientResponse(requestResponse);
           }

           var httpClient = Object.freeze({doRequest: requestProcess});

           return Object.freeze(
                   {
					   /**
						* Enum describing available HTTP methods.
						* @enum
						* @readonly
						*/
                       Method: httpUtil.Method,
					   /**
						* Enum describing available Commerce API Cache Durations.
						* @enum
						* @readonly
						*/
                       CacheDuration: httpUtil.CacheDuration,
					   /**
						* Send a HTTP GET request and return server response.
						*
						* @governance 10 units
						* @restriction Server SuiteScript only
						*
						* @param {Object} config
						* @param {string} config.url the HTTP URL being requested
						* @param {Object} config.headers (optional) request HTTP headers
						* @return {ClientResponse}
						*
					    * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required argument is missing
						* @throws {SuiteScriptError} SSS_INVALID_URL if an incorrect protocol is used (ex: http in the HTTPS module)
						*
						* @since 2015.2
						*/
					   get: function(options, headers) { return httpUtil.get(options, headers, httpClient)},
					   /**
						* Send a HTTP POST request and return server response.
						*
						* @governance 10 units
						* @restriction Server SuiteScript only
						*
						* @param {Object} config
						* @param {string} config.url the HTTP URL being requested
						* @param {string|Object} config.body POST data
						* @param {Object} config.headers (optional) request HTTP headers
						* @return {ClientResponse}
						*
					    * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required argument is missing
						* @throws {SuiteScriptError} SSS_INVALID_URL if an incorrect protocol is used (ex: http in the HTTPS module)
						*
						* @since 2015.2
						*/
					   post: function(options) { return httpUtil.post(options, httpClient)},
					   /**
						* Send a HTTP PUT request and return server response.
						*
						* @governance 10 units
						* @restriction Server SuiteScript only
						*
						* @param {Object} config
						* @param {string} config.url the HTTP URL being requested
						* @param {string|Object} config.body PUT data
						* @param {Object} config.headers (optional) request HTTP headers
						* @return {ClientResponse}
						*
					    * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required argument is missing
						* @throws {SuiteScriptError} SSS_INVALID_URL if an incorrect protocol is used (ex: http in the HTTPS module)
						*
						* @since 2015.2
						*/
					   put: function(options) { return httpUtil.put(options, httpClient)},
					   /**
						* Send a HTTP DELETE request and return server response.
						*
						* @governance 10 units
						* @restriction Server SuiteScript only
						*
						* @param {Object} config
						* @param {string} config.url the HTTP URL being requested
						* @param {Object} config.headers (optional) request HTTP headers
						* @return {ClientResponse}
						*
					    * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required argument is missing
						* @throws {SuiteScriptError} SSS_INVALID_URL if an incorrect protocol is used (ex: http in the HTTPS module)
						*
						* @since 2015.2
						*/
					   'delete': function (options, headers) { return httpUtil['delete'](options, headers, httpClient)},
					   /**
						* Send a HTTP request and return server response.
						*
						* @governance 10 units
						* @restriction Server SuiteScript only
						*
						* @param {Object} config
						* @param {http.Method} config.method HTTP method of the request
						* @param {string} config.url the HTTP URL being requested
						* @param {string|Object} config.body POST data; must be present if and only if method is POST
						* @param {Object} config.headers (optional) request HTTP headers
						* @return {ClientResponse}
						*
					    * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required argument is missing
						* @throws {SuiteScriptError} SSS_INVALID_URL if an incorrect protocol is used (ex: http in the HTTPS module)
						*
						* @since 2015.2
						*/
					   request: function(options) { return httpUtil.request(options, httpClient)},
                       getServerRequest: suiteletContext.getServerRequest,
                       getServerResponse: suiteletContext.getServerResponse,
                       /**
                        * @enum
                        */
                       RedirectType : httpUtil.RedirectType
                   });

       });

/**
 * SuiteScript http module (Client Side)
 *
 * @module N/http
 * @suiteScriptVersion 2.x
 *
 */
define('N/http',['N/common/http', 'N/http/httpUtil'],
       function (httpCommon, httpUtil)
       {

           function requestProcessPromise(options)
           {
               var myPromise = new Promise(function (resolve, reject)
                                           {
                                               try
                                               {
                                                   httpUtil.runRequest(options, callback)
                                               }
                                               catch (e)
                                               {
                                                   reject(e);
                                               }

                                               function callback(result)
                                               {
                                                   if (result instanceof Error)
                                                   {
                                                       reject(result)
                                                   }
                                                   else
                                                   {
                                                       try
                                                       {
                                                           resolve(httpUtil.createClientResponse(result));
                                                       }
                                                       catch (e)
                                                       {
                                                           reject(e);
                                                       }
                                                   }
                                               }
                                           });
               return myPromise
           };

           var httpClientPromise = Object.freeze({doRequest: requestProcessPromise});

           httpCommon.get.promise = function(options, headers) { return httpUtil.get(options, headers, httpClientPromise)};
           httpCommon.post.promise = function (options) { return httpUtil.post(options, httpClientPromise)};
           httpCommon.put.promise = function (options) { return httpUtil.put(options, httpClientPromise)};
           httpCommon['delete'].promise = function (options, headers) { return httpUtil['delete'](options, headers, httpClientPromise)};
           httpCommon.request.promise = function (options) { return httpUtil.request(options, httpClientPromise)};

           return Object.freeze(httpCommon);
       });

/**
 * SuiteScript portlet module
 *
 * @module N/portlet
 * @NApiVersion 2.x
 *
 */
define('N/portlet',['N/error', 'N/utilityFunctions'],
	function (error, utilityFunctions)
	{
		var SUPPORTED_PORTLET_TYPE = 'form';

		function refresh()
		{
			if (typeof window.nlportlet === 'object' && window.nlportlet.type === SUPPORTED_PORTLET_TYPE)
				window.nlportlet.refreshfn();
			else
				utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_UI_OBJECT_TYPE, window.nlportlet.type, SUPPORTED_PORTLET_TYPE);
		}

		function resize()
		{
			if (typeof window.nlportlet === 'object' && window.nlportlet.type === SUPPORTED_PORTLET_TYPE)
				window.nlportlet.resizefn();
			else
				utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_UI_OBJECT_TYPE, window.nlportlet.type, SUPPORTED_PORTLET_TYPE);
		}

		return Object.freeze({
			/**
			 * Causes a FORM type portlet to immediately refresh.
			 *
			 * @throws {SuiteScriptError} SSS_INVALID_UI_OBJECT_TYPE if portlet is not FORM type
			 *
			 * @since 2016.1
			 */
			refresh: refresh,
			/**
			 * Causes a FORM type portlet to be immediately resized.
			 *
			 * @throws {SuiteScriptError} SSS_INVALID_UI_OBJECT_TYPE if portlet is not FORM type
			 *
			 * @since 2016.1
			 */
			resize: resize
		})
	}
);

/**
 * SuiteScript module
 *
 * @private
 * @module N/xmlHelpers
 * @NApiVersion 2.x
 */
define('N/restricted/xmlHelpers',['N/restricted/bridge'],
	function(apiBridge)
	{
		function selectValues(node, expr)
		{
			var selectedValues = [];
			var selections = apiBridge.nlapiSelectNodes(node, expr);
			if (selections != null)
			{
				selectedValues = [];
				for (var i = 0; i < selections.length; i++)
					selectedValues[i] = getXMLValue(selections[i]);
			}
			return selectedValues;
		}

		function selectValue(node, expr)
		{
			var selections = selectValues(node, expr);
			var selection = selections != null ? selections[0] : null;
			return selection;
		}

		function getXMLValue(node)
		{
			if (node.nodeType == 3 || node.nodeType == 4)	/* Text or CDATA Nodes */
				return node.nodeValue;
			if (node.nodeType == 2)
				return node.value;    /* Attr node will deprecate child nodes */
			if (node.nodeType == 9)	/* Document Node (Use root Element instead) */
				node = node.documentElement;

			var value = null;
			var elems = node.childNodes;
			for (var i = 0; i < elems.length; i++)
			{
				var elem = elems[i];
				if (elem.nodeType == 3 || elem.nodeType == 4)	/* Text or CDATA Nodes */
				{
					if (value == null)
						value = elem.nodeValue;
					else
						value += elem.nodeValue;
				}
			}
			return value;
		}

		return Object.freeze({
			nlapiSelectValue: selectValue
		});
	}
)
;
/**
 * SuiteScript module
 *
 * @private
 * @module N/ajaxHelpers
 * @NApiVersion 2.x
 */
define('N/restricted/ajaxHelpers',['N/restricted/bridge', 'N/restricted/xmlHelpers'],
	function(apiBridge, xmlHelpers)
	{
		var trim = String.prototype.trim || function(){
				return this.replace(/^\s+|\s+$/gm,'');
			};

		function isJson(body)
		{
			if(!body)
				return false;
			body = trim.call(body);
			return body && body.indexOf('{') === 0 && body.lastIndexOf('}') === body.length - 1;
		}

		function throwServerCallError(details, code, id)
		{
			var error = Error(details);
			error.name = code;
			error.id = id;
			throw error;
		}

		function handleServerCallError(responseCode, responseBody, handleJson)
		{
			if (responseBody && responseBody.toLowerCase().indexOf('error')>=0)
			{
				if (isJson(responseBody))
				{
					if (handleJson && responseBody.indexOf('{"error"') >= 0)
					{
						var errorBody = JSON.parse(responseBody);
						throwServerCallError(errorBody.error.message, errorBody.error.code);
					}
				}
				else if (responseBody.indexOf('<onlineError>') >= 0)
				{
					var errorBody = apiBridge.nlapiStringToXML(responseBody);
					throwServerCallError(xmlHelpers.nlapiSelectValue(errorBody, '/onlineError/detail'), xmlHelpers.nlapiSelectValue(errorBody, '/onlineError/code'), xmlHelpers.nlapiSelectValue(errorBody, '/onlineError/id'));
				}
				else if (responseBody.indexOf('<error>') >= 0)
				{
					var errorBody = apiBridge.nlapiStringToXML(responseBody);
					throwServerCallError(xmlHelpers.nlapiSelectValue(errorBody, '/error/message'), xmlHelpers.nlapiSelectValue(errorBody, '/error/code'));
				}
				else if (responseBody.indexOf('error code:') >= 0 && responseBody.indexOf('error message:') >= 0 && responseCode != 200)
				{
					var errorBody = responseBody.split("\n");
					throwServerCallError(errorBody[1].substring("error message: ".length), errorBody[0].substring("error code: ".length));
				}
			}
			else if (responseCode != 200 && responseCode != 206)
				throwServerCallError(responseBody, 'SERVER_RESPONSE_ERROR');
		}

		return Object.freeze({
			isJson: isJson,
			handleServerCallError: handleServerCallError
		});
	}
)
;
/**
 * SuiteScript https module (Client Side)
 * @private Ignore for JSDoc stub generation
 * @module N/clientHttps
 * @NApiVersion 2.x
 *
 */
define('N/https',['N/http/httpUtil','N/restricted/bridge', 'N/restricted/invoker', 'N/utilityFunctions', 'N/error', 'N/suiteletContext', 'N/restricted/httpApi', 'N/restricted/ajaxHelpers'],
       function (httpUtil, apiBridge, invoker, utilityFunctions, error, suiteletContext, httpApi, ajaxHelpers)
       {
	       function getHost()
	       {
		       return document.location.protocol + '//' + document.location.host;
	       }

           function extractResponse(xhr, async)
           {
	           try
	           {
		           ajaxHelpers.handleServerCallError(xhr.status, xhr.responseText, true);
	           }
	           catch (e)
	           {
		           if (async)
		           	    return e;
		           else
		           	    throw error.create(e);
	           }
               apiBridge.chargeUsage('nlapiRequestURL');
               var responseHeaders = xhr.getAllResponseHeaders();
               var headers = {};
               if (responseHeaders != null)
               {
                   var headerLines = responseHeaders.split("\r\n");
                   for (var i in headerLines)
                   {
                       var header = headerLines[i].split(":")[0];
                       if (!!header)
                           headers[header] = xhr.getResponseHeader(header);
                   }
               }
               else
                   headers = null;

               return {code: xhr.status, body: xhr.responseText, headers: headers};
           }

           function runRequest(options, callback)
           {
               utilityFunctions.checkArgs([ options ], ["options"], "request");
               utilityFunctions.checkArgs([ options.url ], ["options.url"], "request");
               var url = '' + options.url;
               utilityFunctions.assertTrue((url.indexOf("http:") !== 0), error.Type.SSS_INVALID_URL, "HTTPS");
               var body = (options.method === httpUtil.Method.POST || options.method === httpUtil.Method.PUT) ? options.body : null;
               var headers = options.headers || {};

	           if (typeof nsDefaultContextObj !== 'undefined' && nsDefaultContextObj !== null)
	           {
		           url += url.indexOf("?") > 0 ? "&" : "?";
		           url += "c=" + nsDefaultContextObj.company;
		           url += "&isExternal=T";
	           }

               if (url[0] == '/' || url.indexOf(getHost()) === 0)
               {
                   var async = typeof(callback) === "function";
                   var xhr = new XMLHttpRequest();
                   xhr.open(options.method, url, async);
                   if (async)
                   {
                       var scriptRun;
                       if (typeof apiBridge["getScript"] !== "undefined")
                       {
                           scriptRun = apiBridge["getScript"].apply(apiBridge, []);
                       }
                       xhr.onload = function ()
                       {
                           if (!!scriptRun && typeof apiBridge["recoverScript"] !== "undefined")
                           {
                               apiBridge["recoverScript"].apply(apiBridge, [scriptRun]);
                               window.NLScriptId = scriptRun.scriptId;
                           }
                           if (this.readyState === 4)
                               callback(extractResponse(xhr, true));
                       }
                   }

                   if (url.toLowerCase().indexOf("restlet.nl") >= 0)
                   {
                       if (util.isObject(body))
                       {
                           xhr.setRequestHeader("Content-Type", "application/json; charset=UTF-8");
                           body = JSON.stringify(body);
                       }
                       else
                       {
                           xhr.setRequestHeader("Content-Type", "text/plain; charset=UTF-8");
                       }
                   }
                   else
                   {
	                   xhr.setRequestHeader("NSXMLHttpRequest", "NSXMLHttpRequest");
                       if (util.isObject(body))
                       {
                           body = Object.keys(body).map(function (v) {return encodeURIComponent(v) + '=' + encodeURIComponent(body[v]);}).join('&');
                           xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');
                       }
                       else
                       {
                           xhr.setRequestHeader("Content-Type", "text/xml; charset=UTF-8");
                       }
                   }
                   xhr.send(body);
                   if (!async)
                       return extractResponse(xhr, false);
               }
               else
                   return invoker(httpApi, "nlapiRequestURLWithCredentials", [null, url, body, headers, options.method], callback);
           }

           var requestProcess = function(options)
           {
               var requestResponse = runRequest(options);
               return httpUtil.createClientResponse(requestResponse);
           };

           var requestProcessPromise = function (options)
           {
               var myPromise = new Promise( function(resolve, reject)
                                            {
                                                try
                                                {
                                                    runRequest(options, callback)
                                                }
                                                catch(e)
                                                {
                                                    reject(e);
                                                }

                                                function callback(result)
                                                {
                                                    if (result instanceof Error)
                                                    {
                                                        reject(result)
                                                    }
                                                    else
                                                    {
                                                        try
                                                        {
                                                            resolve(httpUtil.createClientResponse(result));
                                                        }
                                                        catch(e)
                                                        {
                                                            reject(e);
                                                        }
                                                    }
                                                }
                                            });
               return myPromise
           };
           var httpClient = Object.freeze({doRequest: requestProcess});
           var httpClientPromise = Object.freeze({doRequest: requestProcessPromise } );

           var doGet = function (options, headers) { return httpUtil.get(options, headers, httpClient)};
           doGet.promise = function(options, headers) { return httpUtil.get(options, headers, httpClientPromise)};

           var doPost = function (options) { return httpUtil.post(options, httpClient)};
           doPost.promise = function (options) { return httpUtil.post(options, httpClientPromise)};

           var doPut = function (options) { return httpUtil.put(options, httpClient)};
           doPut.promise = function (options) { return httpUtil.put(options, httpClientPromise)};

           var doDelete = function (options, headers) { return httpUtil['delete'](options, headers, httpClient)};
           doDelete.promise = function (options, headers) { return httpUtil['delete'](options, headers, httpClientPromise)};

           var doRequest = function (options) { return httpUtil.request(options, httpClient)};
           doRequest.promise = function (options) { return httpUtil.request(options, httpClientPromise)};

           return Object.freeze(
                   {
                       Method: httpUtil.Method,
                       CacheDuration: httpUtil.CacheDuration,
                       get: doGet,
                       post: doPost,
                       put: doPut,
                       'delete': doDelete,
                       request: doRequest,
                       getServerRequest: suiteletContext.getServerRequest,
                       getServerResponse: suiteletContext.getServerResponse
                   });

       });

/**
 * SuiteScript transaction util module
 *
 * @private
 * @module N/transaction/transactionUtil
 * @suiteScriptVersion 2.x
 *
 */

define('N/transaction/transactionUtil',['N/utilityFunctions'],
       function(utilityFunctions)
       {
            function getVoidTransactionArgs(options,id)
            {
                var type = options;
                if ( utilityFunctions.isObject(options))
                {
                    type = options.type;
                    id = options.id;
                }

                utilityFunctions.checkArgs([type, id], ['type', 'id'], 'void');
                return [type, id];
            }

            function doVoidTransaction(voidedId)
            {
                return parseInt(voidedId, 10);
            }

            return {
                getVoidTransactionArgs: getVoidTransactionArgs,
                doVoidTransaction: doVoidTransaction
            }
       });

/**
 * SuiteScript transaction common module
 *
 * @module N/transaction
 * @suiteScriptVersion 2.x
 *
 */

define('N/common/transaction',['N/transaction/transactionUtil', 'N/restricted/bridge', 'N/restricted/invoker'],
       function(transactionUtil, apiBridge, invoker)
       {
            function voidTransaction(options,id)
            {
                var voidArgs = transactionUtil.getVoidTransactionArgs(options, id);
                var voidResult = invoker(apiBridge, "nlapiVoidTransaction", voidArgs);

                return transactionUtil.doVoidTransaction(voidResult);
            }

            return Object.freeze({
                /**
                 * Void a transaction record object based on provided type, id
                 *
                 * @param {string} type record type to be voided
                 * @param {number|string} id record id to be voided
                 * @return {number} the id is the voided record or new reverse journal entry based on preference
                 *
                 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if type or id is missing
                 * @throws {SuiteScriptError} INVALID_RCRD_TYPE if type is not voidable
                 * @throws {SuiteScriptError} RCRD_DSNT_EXIST if record does not exist
                 *
                 * @since 2015.2
                 */
                "void": voidTransaction,
                /*
                 * module enums
                 */
                get Type()
                {
                    if(!transactionUtil.transactionTypes)
                        transactionUtil.transactionTypes = invoker(apiBridge, 'getStandardTypeEnumMap', ['transaction']);
                    return transactionUtil.transactionTypes;
                }
            });
       });

/**
 * SuiteScript transaction module (Client Side)
 *
 * @module N/transaction
 * @suiteScriptVersion 2.x
 *
 */

define('N/transaction',['N/common/transaction', 'N/transaction/transactionUtil', 'N/restricted/bridge', 'N/restricted/invoker'],
       function (transactionCommon, transactionUtil, apiBridge, invoker)
       {
           transactionCommon["void"].promise = function(options, id) {
               return new Promise(
                       function(resolve, reject)
                       {
                           try
                           {
                               var args = transactionUtil.getVoidTransactionArgs(options, id);
                               invoker(apiBridge, "nlapiVoidTransaction", args, callback);
                           }
                           catch(e)
                           {
                               reject(e);
                           }

                           function callback(result) {
                               if (result instanceof Error)
                               {
                                   reject(result);
                                   return;
                               }
                               try
                               {
                                   resolve(transactionUtil.doVoidTransaction(result));
                               }
                               catch(e)
                               {
                                   reject(e);
                               }
                           }
                       }
               );
           };

           return Object.freeze(transactionCommon);
       });

/**
 * SuiteScript email common module
 *
 * @module N/email
 * @suiteScriptVersion 2.x
 *
 */

define('N/common/email',['N/restricted/bridge', 'N/restricted/invoker', 'N/utilityFunctions', 'N/error'],
       function (apiBridge, invoker, utilityFunctions, error)
       {
           function EmailObject(options)
           {
               var files = [];
               this.doSendEmail = function doSendEmail(options, notifySenderOnBounce)
               {
                   var relatedRecords = new Object();
                   var undef = undefined;
                   utilityFunctions.checkArgs([options], ['options'], 'email.send');
                   if (!utilityFunctions.isObject(options))
                   {
                       utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'options', 'object' );
                   }
                   // check required parameters
                   var author = options !== undef && options !== null && options.author !== undef ?
                                options.author : undef;
                   var recipients = options !== undef && options !== null && options.recipients !== undef ?
                                    options.recipients : undef;
                   var body = options !== undef && options !== null && options.body !== undef ?
                              options.body : undef;
                   var subject = options !== undef && options !== null && options.subject !== undef ?
                                 options.subject : undef;

                   utilityFunctions.checkArgs([author, recipients, body, subject], ['options.author', 'options.recipients', 'options.body', 'options.subject'], 'email.send');

                   if (recipients instanceof Array)
                   {
                       recipients = recipients.join();
                   }

                   // check optional parameters
                   if (options.cc && !(options.cc instanceof Array))
                   {
                       utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'options.cc', 'Array' );
                   }
                   if (options.bcc && !(options.bcc instanceof Array))
                   {
                       utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'options.bcc', 'Array' );
                   }
                   if (options.isInternalOnly && !util.isBoolean(options.isInternalOnly))
                   {
                       utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'options.isInternalOnly', 'boolean' );
                   }

                   if (options.replyTo && !util.isString(options.replyTo))
                   {
                       utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'options.replyTo', 'string' );
                   }

                   if (options.attachments && !(util.isArray(options.attachments)))
                   {
                       utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'options.attachments', 'Array' );
                   }
                   if (options.attachments)
                   {
                       for (var index in options.attachments)
                       {
                           var file = options.attachments[index];
                           if (!file.hasOwnProperty('toString') || file.toString() !== 'file.File')
                           {
                               utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'options.attachments', 'file.File[]' );
                           }
                           file._attachToEmail = this;
                       }
                   }

                   if (options.relatedRecords && !utilityFunctions.isObject(options.relatedRecords))
                   {
                       utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'options.relatedRecords', 'object' );
                   }

                   if (options.relatedRecords)
                   {

                       if (options.relatedRecords.hasOwnProperty('transactionId'))
                       {
                           relatedRecords['transaction'] = options.relatedRecords.transactionId;
                       }

                       if (options.relatedRecords.hasOwnProperty('activityId'))
                       {
                           relatedRecords['activity'] = options.relatedRecords.activityId;
                       }

                       if (options.relatedRecords.hasOwnProperty('entityId'))
                       {
                           relatedRecords['entity'] = options.relatedRecords.entityId;
                       }

                       if (options.relatedRecords.hasOwnProperty('customRecord') && options.relatedRecords.customRecord)
                       {
                           if (options.relatedRecords.customRecord.hasOwnProperty('id') && options.relatedRecords.customRecord.hasOwnProperty('recordType'))
                           {
                               relatedRecords['record'] = options.relatedRecords.customRecord.id;
                               relatedRecords['recordtype'] = options.relatedRecords.customRecord.recordType;
                           }
                       }
                   }

                   return invoker(apiBridge, 'nlapiSendEmail', [author, recipients, subject, body, options.cc || null, options.bcc || null, relatedRecords, files || null, notifySenderOnBounce, options.isInternalOnly || false, options.replyTo || null]);

               };

               this._attach = function (f)
               {
                   files.push(f);
               };

               Object.defineProperty(this, '_attach', {
                   set: function (f)
                   {
                       files.push(f);
                   },
                   enumerable: false,
                   configurable: false,
                   writeable: true
               });
           }

           function doSendEmail(options, isNotBulk)
           {
               var emailObject = new EmailObject(options);
               return emailObject.doSendEmail(options, isNotBulk);
           }

           function doSendCampaignEventEmail(campaignEventId, recipientId)
           {
               utilityFunctions.checkArgs([campaignEventId, recipientId], ['campaignEventId', 'recipientId'], 'email.sendCampaignEvent');
               return invoker(apiBridge, 'nlapiSendCampaignEmail', [campaignEventId, recipientId]);
           }

           function sendEmail(options)
           {
               return doSendEmail(options, true);
           }

           function sendBulkEmail(options)
           {
               return doSendEmail(options, false);
           }

           function sendCampaignEventEmail(campaignEventId, recipientId)
           {
               return doSendCampaignEventEmail(campaignEventId, recipientId);
           }

           return {
               /**
                * Send email with bounce back
                *
                * @governance 20 units
                * @restriction Supported by all client and server side scirpts; The maximum number of total recipients (recipient + cc + bcc) allowed is 10
                *
                * RelatedRecords represents the NetSuite records to which an Email Message record should be attached.
                * @typedef {Object} RelatedRecords
                * @property {number} transactionId - Transaction record to attach Message record to.
                * @property {number} activityId - Activity record to attach Message record to.
                * @property {number} entityId - Entity record to attach Message record to.
                * @property {Object} customRecord - Custom record to attach Message record to.
                * @property {number} customRecord.id - Custom record instance ID to attach Message record to.
                * @property {string} customRecord.recordType - Custom Record record type to attach Message record to.
                *
                * @param {Object} options Email options
                * @param {number} options.author Sender of the email.
                * @param {number|string[]} options.recipients Recipients of the email, Interal ID or array of Email Addresses.
                * @param {string[]} options.cc CC (optional) recipients of the email, Interal ID or array of Email Addresses.
                * @param {string[]} options.bcc BCC (optional) recipients of the email as an EmailEntity, Interal ID or Email Address.
                * @param {string} options.subject Email subject.
                * @param {string} options.body Email Body/contents.
                * @param {string} options.replyTo (optional)
                * @param {file.File[]} options.attachments (optional) Email file attachments. Not supported in client side.
                * @param {RelatedRecords} options.relatedRecords (optional)
                * @param {boolean} options.isInternalOnly (optional) Do not show Message record when viewed from external Entity. Default to false
                * @returns {undefined}
                *
                */
               send: sendEmail,
               /**
                * Send email without bounce back
                *
                * @governance 10 units
                * @restriction Supported by all client and server side scirpts; The maximum number of total recipients (recipient + cc + bcc) allowed is 10
                *
                * RelatedRecords represents the NetSuite records to which an Email Message record should be attached.
                * @typedef {Object} RelatedRecords
                * @property {number} transactionId - Transaction record to attach Message record to.
                * @property {number} activityId - Activity record to attach Message record to.
                * @property {number} entityId - Entity record to attach Message record to.
                * @property {Object} customRecord - Custom record to attach Message record to.
                * @property {number} customRecord.id - Custom record instance ID to attach Message record to.
                * @property {string} customRecord.recordType - Custom Record record type to attach Message record to.
                *
                * @param {Object} options Email options
                * @param {number} options.author Sender of the email.
                * @param {number|string[]} options.recipients Recipients of the email, Interal ID or array of Email Addresses.
                * @param {string[]} options.cc CC (optional) recipients of the email, Interal ID or array of Email Addresses.
                * @param {string[]} options.bcc BCC (optional) recipients of the email as an EmailEntity, Interal ID or Email Address.
                * @param {string} options.subject Email subject.
                * @param {string} options.body Email Body/contents.
                * @param {string} options.replyTo (optional)
                * @param {file.File[]} options.attachments (optional) Email file attachments.  Not supported in client side.
                * @param {RelatedRecords} options.relatedRecords (optional)
                * @param {boolean} options.isInternalOnly (optional) Do not show Message record when viewed from external Entity. Default to false
                * @returns {undefined}
                *
                */
               sendBulk: sendBulkEmail,
               /**
                * Send a single "on-demand" campaign email to a specified recipient and return a campaign response ID to track the email
                * @governance 10 units
                * @restriction Supported by all client and server side scirpts
                *
                * @param {Number} campaignEventId  The internal ID of the campaign event.
                * @param {Number} recipientId The internal ID of the recipient. Note that the recipient must have an email.
                * @returns {Number} A campaign response ID (tracking code) as an integer, or -1 if the send fails
                *
                */
               sendCampaignEvent: sendCampaignEventEmail
           };
       });

/**
 * SuiteScript email module (Client Side)
 *
 * @module N/email
 * @suiteScriptVersion 2.x
 *
 */

define('N/email',['N/common/email'],
       function (emailCommon)
       {
           function craftPromise(resolveThis)
           {
               return new Promise(function (resolve, reject)
                                  {
                                      try
                                      {
                                          resolve(resolveThis());
                                      }
                                      catch (e)
                                      {
                                          reject(e);
                                      }
                                  });
           }

           emailCommon.send.promise = function (options)
           {
               var resolveThis = function() { return emailCommon.send(options); };
               return craftPromise(resolveThis);
           };

           emailCommon.sendBulk.promise = function (options)
           {
               var resolveThis = function() { return emailCommon.sendBulk(options) };
               return craftPromise(resolveThis);
           };

           emailCommon.sendCampaignEvent.promise = function (campaignEventId, recipientId)
           {
               var resolveThis = function() { return emailCommon.sendCampaignEvent(campaignEventId, recipientId); };
               return craftPromise(resolveThis);
           };

           return Object.freeze(emailCommon);
       });

/**
 * @private
 */
define('N/restricted/msgRouterBridge',[], function() {

	// container for all message queues ever created
	var allQueuesContainer = [];
	// queue stack with the active queue always on top of the stack (last index)
	var queueStack = [];

	function getMessageQueueImpl(queueId)
	{
		return allQueuesContainer.find(function (msgQueueImpl) {
			return (msgQueueImpl.id === queueId);
		}) || null;
	}

	function pushMsgQueue(messageQueueId)
	{
		var	activeQueue = getMessageQueueImpl(messageQueueId) || allQueuesContainer[0];
		queueStack.push(activeQueue);
		return queueStack.length;
	}

	function popMsgQueue(threshold) {
		var th = (threshold == null || threshold < 1) ? 1 : threshold;
		if (queueStack.length > th)
			queueStack.splice(-1);
		return queueStack.length;
	}

	function getActiveMsgQueue()
	{
		return queueStack[queueStack.length-1] || null;
	}

	function addToQueuesContainer(messageQueueImpl)
	{
		var queueId = allQueuesContainer.length;
		allQueuesContainer.push(messageQueueImpl);
		if (queueStack.length === 0)
			queueStack.push(messageQueueImpl);
		return queueId;
	}

	return Object.freeze({
		pushMsgQueue: pushMsgQueue,
		popMsgQueue: popMsgQueue,
		getActiveMsgQueue: getActiveMsgQueue,
		addToQueuesContainer : addToQueuesContainer
	});
});

/**
 * SuiteScript module for routing and storing messages/dialogs
 *
 * @private
 * @module N/msgRouter
 * @suiteScriptVersion 2.x
 */
define(
	'N/msgRouter',['N/nsobject', 'N/utilityFunctions', 'N/restricted/remoteApiBridge', 'N/restricted/invoker', 'N/restricted/msgRouterBridge'],
	function (nsobject, utilityFunctions, remoteApi, invoker, msgRouterBridge)
	{
		function isServerSide() { return typeof document === 'undefined'; }

		/**
		 * Simple object that contains information about the message stored on the record
		 * @param {Object} [options] all information to be stored about the message
		 * @returns {Message}
		 * @constructor
		 */
		function Message (options)
		{
			var TYPE = 'Message';
			var msgInfo = options;

			this.toString = function ()
			{
				return TYPE;
			};

			this.toJSON = function ()
			{
				return msgInfo;
			};
		}
		Object.freeze(Message);

		/**
		 * internal message queue implementation
		 * @returns {MessageQueueImpl}
		 * @constructor
		 */
		function MessageQueueImpl ()
		{
			var TYPE = 'msgRouter.MessageQueueImpl';

			/** the actual container where the messages (@see Message) are kept */
			var messageContainer = [];

			// create the public message service instance for this queue implementation
			var messageService = new MessageService(this);

			var queueId; // queue id to be returned from the invoker once this queue is added to the queue container
			Object.defineProperty(this, 'id', {get: function () {return queueId}});
			queueId = invoker(msgRouterBridge, 'addToQueuesContainer', [this]);

			this.getMessageService = function () { return messageService; };

			this.storeMessage = function (options)
			{
				var msgOptions = {};
				if (!options)
					utilityFunctions.throwSuiteScriptError('SSS_MISSING_REQD_ARGUMENT', 'options');
				if (!options.hasOwnProperty('source'))
					utilityFunctions.throwSuiteScriptError('SSS_MISSING_REQD_ARGUMENT', 'source');
				if (!options.hasOwnProperty('data'))
					utilityFunctions.throwSuiteScriptError('SSS_MISSING_REQD_ARGUMENT', 'data');
				msgOptions.source = options.source;
				msgOptions.data = options.data;
				msgOptions.reply = {value: options.reply || null};
				msgOptions.timestamp = (new Date()).getTime();

				if (isServerSide() && options.source === 'message.Message' && options.forClient === true)
				{
					msgOptions.forClient = options.forClient;
					sendMessageToClient(msgOptions.data);
				}
				messageContainer.push(new Message(msgOptions));
			};

			this.getMessages = function ()
			{
				return messageContainer.slice(0, messageContainer.length);
			};

			var DEFAULT_PROMPT_AUTO_RESPONSE = '';
			var DEFAULT_DIALOG_AUTO_RESPONSE = true;
			var DEFAULT_CONFIRM_AUTO_RESPONSE = true;

			/**
			 * provides an auto-reply for a dialog type specified by options parameter
			 * @param {Object} options
			 * @param {string} options.dialogType can be one of 'prompt', 'dialog', 'confirm'
			 * @param {string} options.dialogOptions this is for the dialog to pass in the buttons defined for the message
			 * @returns {?Object|boolean|string} auto response for the selected dialog type or null
			 */
			this.getAutoResponse = function getAutoResponse(options)
			{
				// TODO: allow to set auto response for a record via the MessageService object
				if (!options || !options.dialogType)
				{
					return null;
				}
				if (options.dialogType === 'prompt')
				{
					return DEFAULT_PROMPT_AUTO_RESPONSE;
				}
				else if (options.dialogType === 'confirm')
				{
					return DEFAULT_CONFIRM_AUTO_RESPONSE;
				}
				else if (options.dialogType === 'dialog')
				{
					if (options.dialogOptions &&
						options.dialogOptions.buttons &&
						options.dialogOptions.buttons.length > 0)
					{
						return options.dialogOptions.buttons[0].value;
					}
					else
						return DEFAULT_DIALOG_AUTO_RESPONSE;
				}
				return null;
			};

			this.toString = function ()
			{
				return TYPE;
			};

			this.toJSON = function ()
			{
				return {};
			};
		}
		Object.freeze(MessageQueueImpl);

		/**
		 * a public message queue to be available as a record's property to retrieve all messages stored on the record
		 * @param {MessageQueueImpl} messageQueueImpl a handle to internal implementation of the message queue
		 * @returns {MessageService}
		 * @constructor
		 */
		function MessageService (messageQueueImpl)
		{
			var TYPE = 'Record.MessageService';

			utilityFunctions.checkArgs([messageQueueImpl], ['messageQueueImpl'], TYPE);

			var messageQueue = messageQueueImpl;

			Object.defineProperty(this, 'id', {get: function () {return messageQueue.id;}});

			/**
			 * retrieves all messages from the message queue
			 * @returns {[Message]} a list of all messages in the queue
			 */
			this.getMessages = function ()
			{
				return messageQueue.getMessages();
			};

			//TODO: setAutoResponse() method that would allow user to define an auto-response for the record messages

			this.toString = function ()
			{
				return TYPE;
			};

			this.toJSON = function ()
			{
				return {};
			};
		}
		Object.freeze(MessageService);

		/**
		 * sets a MessageQueueImpl related to a MessageService provided on top of the queue stack, so all messages will be recorder to this queue from now on
		 * @param {Record} record inststance that has a messageQueue to be set as currently active queue
		 * @returns {Integer} the updated queue stack size (will be always greater than 0)
		 */
		var pushQueue = function pushQueue(record)
		{
			var queueId = null;
			if (record && record.hasOwnProperty('getMessageService') && typeof record['getMessageService'] === 'function')
			{
				var messageQueue = record.getMessageService();
				if (messageQueue instanceof Object && messageQueue.constructor.name === 'MessageService')
					queueId = messageQueue.id;
			}
			return invoker(msgRouterBridge, 'pushMsgQueue', [queueId || null]);
		};

		/**
		 * removes the currently active queue from the queue stack as long as the queue stack size is above value specified by paramter (or 1),
		 * all messages will be recorded to the previous MessageService from now on
		 * @param {Integer} [threshold] if stack size > threshold then pops queue from stack
		 * @returns {Integer} the updated queue stack size (will be always greater than 0)
		 */
		var popQueue = function popQueue(threshold)
		{
			return invoker(msgRouterBridge, 'popMsgQueue', [threshold || 1]);
		};

		/**
		 * provides the currently active MessageQueueImpl instance to store a message into it
		 * @returns {MessageQueueImpl} the active MessageQueueImpl instance, either related to a specific record, or a default one (i.e. id is 0)
		 */
		var getActiveQueue = function getActiveQueue()
		{
			var activeQueue = invoker(msgRouterBridge, 'getActiveMsgQueue', []);
			return activeQueue || new MessageQueueImpl(); // lazy initialization of a default message queue
		};

		/**
		 * provides a new instance of MessageService to be related to a Record instace
		 * @returns {MessageService}
		 */
		var getMessageServiceInstance = function getMessageQueue()
		{
			getActiveQueue(); // we want to make sure that the message queue is lazy initialized with a default queue before we start adding instances
			var msgQueueImpl = new MessageQueueImpl();
			return msgQueueImpl.getMessageService();
		};

		// this is here to overload all Javascript native messaging methods
		// so we can also relate them to a record
		(function overloadGlobalAlerts() {
			var global = this;

			function getArgs(args) {
				var _args = [];
				for (var i = 0; i < args.length; i++)
					_args.push(args[i]);
				return _args;
			}

			var gAlert = global.alert;
			global.alert = function () {
				var queue = getActiveQueue();
				var msg = {source: 'window.alert', data: {args: getArgs(arguments)}, reply: null};
				if (gAlert) gAlert.apply(null, arguments);
				queue.storeMessage(msg);
			};
			var gPrompt = global.prompt;
			global.prompt = function () {
				var queue = getActiveQueue();
				var msg = {source: 'window.prompt', data: {args: getArgs(arguments)}, reply: null};
				msg.reply = gPrompt ? gPrompt.apply(null, arguments) : queue.getAutoResponse({dialogType: 'prompt'});
				queue.storeMessage(msg);
				return msg.reply;
			};
			var gConfirm = global.confirm;
			global.confirm = function () {
				var queue = getActiveQueue();
				var msg = {source: 'window.confirm', data: {args: getArgs(arguments)}, reply: null};
				msg.reply = gConfirm ? gConfirm.apply(null, arguments) : queue.getAutoResponse({dialogType: 'confirm'});
				queue.storeMessage(msg);
				return msg.reply;
			};
		})();

		function sendMessageToClient(message)
		{
			if (util.isObject(message))
			{
				var msgJson = JSON.stringify(message);
				invoker(remoteApi, 'sendMessageToClient', [msgJson]);
			}
		}

		var MESSAGE_FIELD = 'custpage__ss_messages_for_client';
		/**
		 * Used to display messges sent from Before Load to the client
		 * @param {Object|string} options - either the JSON string of all messages to be shown or an option object
		 * @param {Object} options.currentRecord - the current record to read the messages from
		 */
		var messageModule;

		function showMessagesFromBeforeLoad(options)
		{
			if (!messageModule)
			{
				//lazy require to avoid circular dependency in define
				require(['N/ui/message'], function(mod) { messageModule = mod; showMessagesFromBeforeLoad(options); });
				return;
			}
			var currentRecord = options && options.currentRecord;
			var messages;
			try {
				if (currentRecord)
					messages = JSON.parse(currentRecord.getValue(MESSAGE_FIELD));
			} catch (e)	{
				return;
			}
			if (messages && Array.isArray(messages.messages))
			{
				messages.messages.forEach(function (msg) {
					if (!msg) return;
					var duration = msg.duration ? msg.duration : undefined;
					messageModule.create(msg).show(duration);
				})
			}
		}

		return Object.freeze(
		{
			getActiveQueue : getActiveQueue,
			pushQueue : pushQueue,
			popQueue : popQueue,
			getMessageServiceInstance : getMessageServiceInstance,
			showMessagesFromBeforeLoad : showMessagesFromBeforeLoad
		});
	}
);

/**
 * SuiteScript Message Module (Client Side)
 *
 * @module N/ui/message
 * @suiteScriptVersion 2.x
 *
 */
define('N/ui/message',['N/utilityFunctions', 'N/nsobject', 'N/error', 'N/msgRouter'], function (utilityFunctions, nsobject, error, msgRouter)
{
	var MESSAGE_TYPE = Object.freeze({
		CONFIRMATION: 0,
		INFORMATION: 1,
		WARNING: 2,
		ERROR: 3
	});

    /**
     * Return a new instance of Message, used to show/hide messages
     * @class
     * @classdesc Allows users to show/hide messages.
     * @return {message.Message}
     * @constructor
     *
     * @since 2015.2
     */
    function Message(initializedOptions)
    {
        var THIS_TYPE = 'message.Message';
        var msgOptions = initializedOptions;
        var msgObject = null;
        var messageQueue = msgRouter.getActiveQueue();

        /**
         * Shows the message.
         *
         * @restriction Client SuiteScript only
         * @param {Object} [options]
         * @param {int|string} [options.duration] The amount of time (in milliseconds) to show the message. Default is 0 (show forever)
         *
         * @return {void}
         *
         * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE if options.duration is specified with a non-numerical value.
         *
         * @since 2016.1
         */
        this.show = function(options)
        {
            var msecsToShow = 0;
            if (options === undefined)
                msecsToShow = 0;
            else if (options.hasOwnProperty("duration"))
                msecsToShow = parseInt(options.duration);
            else if (util.isNumber(options))
                msecsToShow = parseInt(options);

            if (isNaN(msecsToShow))
                utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE);

            msgOptions.duration = msecsToShow;

	        messageQueue.storeMessage({source: THIS_TYPE, data: msgOptions, reply: null, forClient: options && options.sendToClient});

	        // NS.UI.Messaging is available only in client
			if (typeof(NS) !== 'undefined' &&
				typeof(NS.UI) !== 'undefined' &&
				typeof(NS.UI.Messaging) !== 'undefined' &&
                typeof(NS.UI.Messaging.Message) === 'function')
			{
				msgObject = new NS.UI.Messaging.Message(msgOptions);
				msgObject.show();
			}
        };

        /**
         * Hides the message
         *
         * @restriction Client SuiteScript only
         *
         * @return {void}
         *
         * @since 2016.1
         */
        this.hide = function()
        {
            if (msgObject !== null)
                msgObject.hide();
        };

        /**
         * Returns the object type name (message.Message)
         *
         * @return {string}
         */
        this.toString = function()
        {
            return THIS_TYPE;
        };

        /**
         * JSON.stringify() implementation.
         *
         * @return {{type: string, title: string, message: string}}
         */
        this.toJSON = function()
        {
            return msgOptions;
        };
    }
    Message.prototype = nsobject.getNewInstance();
    Object.freeze(Message);

    function create(options)
    {
        var type, title, message;

        if (options !== null && options !== undefined)
        {
            type = options.type;
            title = options.title || "";
            message = options.message || "";
        }

        utilityFunctions.checkArgs([type], ['type'], 'Message.create');

        var messageOptions = {
            title: title,
            message: message,
            type: type
        };

        return new Message(messageOptions);
    }

    return Object.freeze({
                             /**
                              * Creates a message which can be shown/hidden near the top of the page.
                              *
                              * @restriction Client SuiteScript only
                              * @param {Object} options
                              * @param {string} options.type The type of message, see message.Type
                              * @param {string} [options.title] The title of the message. Defaults to empty string.
                              * @param {string} [options.message] The content of the message. Defaults to empty string.
                              *
                              * @return {Message} A message object which can be shown or hidden.
                              *
                              * @since 2016.1
                              */
                             create: create,

                             /**
                              * Enum for message types
                              * @enum {string}
                              */
							 Type: MESSAGE_TYPE
                             //Type: NS.UI.Messaging ? NS.UI.Messaging.Type : null
                         });
});

/**
 * SuiteScript Dialog Module (Client Side)
 *
 * @module N/ui/dialog
 * @suiteScriptVersion 2.x
 *
 */
define('N/ui/dialog',['N/utilityFunctions', 'N/error', 'N/msgRouter'], function (utilityFunctions, error, msgRouter)
{
    var DEFAULT_BUTTON_LABEL = "OK";
    var DEFAULT_BUTTON_VALUE = true;

    function prepareOptions(options)
    {
        var title = "", message = "";
        if (options !== undefined)
        {
            title = options.hasOwnProperty("title") ? options.title : "";
            message = options.hasOwnProperty("message") ? options.message : "";
        }

        return {title: title, message: message};
    }

	function prepareButtons(options)
	{
		var rawButtons;
		if ((options === undefined) || (options === null) || !options.hasOwnProperty("buttons"))
			rawButtons = [];
		else
			rawButtons = options.buttons;

		if (!util.isArray(rawButtons))
			utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE);

		if (rawButtons.length === 0)
			rawButtons = [{label: DEFAULT_BUTTON_LABEL, value: DEFAULT_BUTTON_VALUE}];

		return rawButtons;
	}

    function craftButtons(options)
    {
    	var buttons = prepareButtons(options);
        var buttonList = [];

        for (var i = 0; i < buttons.length; i++)
        {
            var thisButton = buttons[i];
            if (!thisButton.hasOwnProperty("label") || !thisButton.hasOwnProperty("value"))
                utilityFunctions.throwSuiteScriptError(error.Type.BUTTONS_MUST_INCLUDE_BOTH_A_LABEL_AND_VALUE);

            buttonList.push(new NS.UI.Messaging.Button({
                                                           label: thisButton.label,
                                                           value: thisButton.value,
                                                           onClick: function (event) { event.dialog.close(event); }
                                                       }));
        }
        return buttonList;
    }


    function doDialog(options, dialogType)
    {
	    var msg = {source: 'dialog.' + dialogType, data: options, reply: null};
    	var finalOptions = prepareOptions(options);

    	var messageQueue = msgRouter.getActiveQueue();

    	// server side
    	if (typeof document === 'undefined') {

		    if (dialogType === 'dialog') {
			    finalOptions.buttons = prepareButtons(options);
		    }
		    msg.reply = messageQueue.getAutoResponse({dialogType: dialogType, dialogOptions: finalOptions});
		    messageQueue.storeMessage(msg);
		    return msg.reply;
		    // TODO: change ret value to promise once its defined on the server so the return type is same as on client
	    }
	    // client side
    	else {
    		var creatorFunction;
		    if (dialogType === 'dialog') {
			    creatorFunction = NS.UI.Messaging.Dialog;
			    finalOptions.buttons = craftButtons(options);
		    }
		    else if (dialogType === 'confirm') {
			    creatorFunction = NS.UI.Messaging.Confirm;
		    }
		    else if (dialogType === 'alert') {
			    creatorFunction = NS.UI.Messaging.Alert;
		    }

		    return new Promise(function (resolve, reject) {
			    try {
				    finalOptions.onClose = function (event) {
					    var result = event.button.value;
					    msg.reply = result;
					    messageQueue.storeMessage(msg);
					    resolve(result);
				    };
				    var myDialog = new creatorFunction(finalOptions);
				    myDialog.open();
			    }
			    catch (e) {
				    reject(e);
			    }
		    });
	    }
    }

    function doAlert(options)
    {
        return doDialog(options, 'alert');
    }

    function doConfirm(options)
    {
        return doDialog(options, 'confirm');
    }

    function doCreate(options)
    {
        return doDialog(options, 'dialog');
    }

    return Object.freeze({
                             /**
                              * Creates an Alert Dialog with an OK Button.
                              *
                              * @restriction Client SuiteScript only
                              *
                              * @param {Object} options
                              * @param {string} [options.title] The title of the alert. Defaults to empty string.
                              * @param {string} [options.message] The content of the alert. Defaults to empty string.
                              *
                              * @return {Promise} A Promise object. Pass a function into the then portion to fire a callback when the button is pressed.
                              *                   The callback will be passed in a response object which contains the value of the button where:
                              *                   OK returns true.
                              * @since 2016.1
                              */
                             alert: doAlert,
                             /**
                              * Creates an Confirm Dialog with an OK and Cancel Button.
                              *
                              * @restriction Client SuiteScript only
                              *
                              * @param {Object} options
                              * @param {string} [options.title] The title of the confirmation box. Defaults to empty string.
                              * @param {string} [options.message] The content of the confirmation box. Defaults to empty string.
                              *
                              * @return {Promise} A Promise object. Pass a function into the then portion to fire a callback when the button is pressed.
                              *					 The callback will be passed in a response object which contains the value of the button where:
                              *					 OK returns true and Cancel returns false.
                              * @since 2016.1
                              */
                             confirm: doConfirm,
                             /**
                              * Creates an Dialog with the specified buttons.
                              *
                              * @restriction Client SuiteScript only
                              *
                              * @param {Object} options
                              * @param {string} [options.title]   The title of the dialog box. Defaults to empty string.
                              * @param {string} [options.message] The content of the dialog box. Defaults to empty string.
                              * @param {string} [options.buttons] The list of buttons to add. Each item in the list requires a label and value.
                              *                                            If empty, defaults to a button with label "OK" and value true.
                              *
                              * @return {Promise} A Promise object. Pass a function into the then portion to fire a callback when the button is pressed.
                              *					 The callback will be passed in a response object which contains the value of the button where:
                              *					 OK returns true and Cancel returns false.
                              * @since 2016.1
                              *
                              * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE if options.buttons is specified and is not an array.
                              * @throws {SuiteScriptError} BUTTONS_MUST_INCLUDE_BOTH_A_LABEL_AND_VALUE if options.buttons is specified and one or more items do not have a label and/or value.
                              */
                             create: doCreate
                         });
});

/**
 * SuiteScript UI Module (Client Side)
 *
 * @module N/ui
 * @suiteScriptVersion 2.x
 *
 */
define('N/ui',['N/ui/message', 'N/ui/dialog'], function (message, dialog)
{
    return Object.freeze({
        message: message,
        dialog: dialog
    })
});

/**
 * @private
 */
define('N/restricted/urlApi',['N/restricted/reflet'], function(reflet){ return reflet; });

/**
 * SuiteScript module
 *
 * @module N/url
 * @NApiVersion 2.x
 *
 */
define('N/url',['N/restricted/bridge', 'N/restricted/invoker', 'N/restricted/urlApi'],
        function (apiBridge, invoker, urlApi)
        {

	        var HOST_TYPES = Object.freeze({
		        APPLICATION: 'APPLICATION',
		        CUSTOMER_CENTER: 'CUSTOMERCENTER',
		        RESTLET: 'RESTLETS',
		        SUITETALK: 'SUITETALK',
		        FORM: 'FORMS'
	        });

            function traverseParams(prefix, obj, add)
            {

                var rbracket = /\[\]$/;
                if (util.isArray(obj))
                {
                    // Serialize array item.
                    util.each(obj, function (i, v)
                    {
                        if (rbracket.test(prefix))
                        {
                            // Treat each array item as a scalar.
                            add(prefix, v);

                        }
                        else
                        {
                            // Item is non-scalar (array or object), encode its numeric index.
                            traverseParams(prefix + "[" + (typeof v === "object" ? i : "") + "]", v, add);
                        }
                    });

                }
                else
                {
                    // Serialize scalar item.
                    add(prefix, obj);
                }
            }

            /*
             Inspired by jQuery.param()
             */
            function format(options, params)
            {
                var domain = options;
                if (util.isObject(options))
                {
                    domain = options.domain;
                    params = options.params;
                }
                var prefix;
                var s = [];
                var r20 = /%20/g;
                format = format || '';

                function add(key, value)
                {
                    // If value is a function, invoke it and return its value
                    value = util.isFunction(value) ? value() : (value == null ? "" : value);
                    s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
                };

                // If an array was passed in, assume that it is an array of form elements.
                if (util.isArray(params))
                {
                    for (var i = 0; i < params.length; i++)
                        add(i, params[i]);
                }
                else
                {
                    // encode params recursively.
                    for (prefix in params)
                    {
                        traverseParams(prefix, params[prefix], add);
                    }
                }

                // Return the resulting serialization
                var queryString = s.join("&").replace(r20, "+");
                var separator = (domain.indexOf('?') === -1) ? '?' : '&';

                return domain + separator + queryString;
            }


            /** @alias N/url */
            return Object.freeze({
                /**
                 * @param {Object} opts
                 * @param {string} opts.recordType
                 * @param {string} opts.recordId
                 * @param {boolean} opts.isEditMode
                 * @param {Object} opts.params Per url.format({query
                              *
                 * @return {String} url
                 *
                 * @since 2015.1
                 */
                resolveRecord: function resolveRecord(opts)
                {
                    var url = invoker(urlApi, 'nlapiResolveURL', ['RECORD', opts.recordType, opts.recordId || null, opts.isEditMode === true ? 'EDIT' : null]);
                    if (opts.params)
                        url = format(url, opts.params);
                    return url;
                },
                /**
                 *
                 * @param {Object} options
                 * @param {string} options.id
                 * @param {Map} options.params (optional) url parameters
                 *
                 * @return {String} url
                 *
                 * @since 2015.1
                 */
                resolveTaskLink: function resolveTaskLink(options, params)
                {
                    var taskId = options;
                    if (util.isObject(options))
                    {
                        taskId = options.id;
                        params = options.params;
                    }
                    var url = invoker(urlApi, 'nlapiResolveURL', ['TASKLINK', taskId, null, null]);
                    if (params)
                        url = format(url, params);
                    return url;
                },
                /**
                 * @param {Object} opts
                 * @param {string} opts.scriptId
                 * @param {string} opts.deploymentId
                 * @param {boolean} opts.returnExternalUrl
                 * @param {Object} opts.params Per url.format({query
                              *
                 * @return {String} url
                 *
                 * @since 2015.1
                 */
                resolveScript: function resolveScript(opts)
                {
                    var url = invoker(urlApi, 'nlapiResolveURL', ['WEB_SCRIPT', opts.scriptId, opts.deploymentId, opts.returnExternalUrl === true ? 'EXTERNAL' : null]);
                    if (opts.params)
                        url = format(url, opts.params);
                    return url;
                },
                /**
                 * @param {Object} opts
                 * @param {string} opts.hostType
                 * @param {string} opts.accountId
                 *
                 * @return {String} domain
                 *
                 * @since 2017.1
                 */
                resolveDomain: function resolveDomain(opts)
                {
                    return invoker(urlApi, 'nlapiResolveDomain', [opts.hostType, opts.accountId || null]);
                },
                /**
                 * @param {Object} options
                 * @param {string} options.domain
                 * @param {Object} options.params query string data parameters as an object
                 *
                 * @return {String} url
                 *
                 * @since 2015.1
                 */
                format: format,
                HostType: HOST_TYPES
            });
        });

/**
 * @private
 */
define('N/restricted/clientScriptHandler',['N/restricted/reflet'], function(reflet){ return reflet; });

/**
 * @private
 */
define('N/restricted/recordRemoteApiBridge',['N/restricted/reflet'], function(reflet){ return reflet; });

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/recordConstants
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/recordConstants',[],
	function ()
	{
		var RECORD_MODE = Object.freeze({
			DYNAMIC_RECORD: 'dynamic record',
			DEFERRED_DYNAMIC_RECORD: 'standard record',
			READ_ONLY_RECORD: 'read-only record'
		});

		var SUBRECORD_MODE = Object.freeze({
			DYNAMIC_SUBRECORD: 'dynamic subrecord',
			DEFERRED_DYNAMIC_SUBRECORD: 'standard subrecord',
			READ_ONLY_SUBRECORD: 'read-only subrecord'
		});

		var CURRENT_RECORD_MODE = Object.freeze({
			CURRENT_RECORD: 'current record',
			READ_ONLY_CURRENT_RECORD: 'read-only current record'
		});

		var CURRENT_SUBRECORD_MODE = Object.freeze({
			CURRENT_SUBRECORD: 'current subrecord',
			READ_ONLY_CURRENT_SUBRECORD: 'read-only current subrecord'
		});

		var ALL_RECORD_PROXY_NAMES = Object.freeze([
			RECORD_MODE.DYNAMIC_RECORD,
			RECORD_MODE.DEFERRED_DYNAMIC_RECORD,
			RECORD_MODE.READ_ONLY_RECORD,
			SUBRECORD_MODE.DYNAMIC_SUBRECORD,
			SUBRECORD_MODE.DEFERRED_DYNAMIC_SUBRECORD,
			SUBRECORD_MODE.READ_ONLY_SUBRECORD,
			CURRENT_RECORD_MODE.CURRENT_RECORD,
			CURRENT_RECORD_MODE.READ_ONLY_CURRENT_RECORD,
			CURRENT_SUBRECORD_MODE.CURRENT_SUBRECORD,
			CURRENT_SUBRECORD_MODE.READ_ONLY_CURRENT_SUBRECORD
		]);

		var LINE_MODE = Object.freeze({
			DYNAMIC_LINE: 'dynamic record sublist line',
			DEFERRED_DYNAMIC_LINE: 'standard record sublist line',
			READ_ONLY_LINE: 'read-only record sublist line'
		});

		var RECORD_UNDERLYING_IMPL_NAME = Object.freeze({
			CLIENT_DYNAMIC_RECORD:      'recordDefinition.Record',	        // recordDefinition.js (both record & subrecord)
			DOM_CURRENT_RECORD:         'DomCurrentRecord',			        // domCurrentRecord.js (V1 client record)
			DOM_CURRENT_SUBRECORD:      'DomCurrentSubrecord',		        // currentSubrecord.js (V1 client subrecord)
			SERVER_DYNAMIC_RECORD:      'RecordImpl',				        // serverRecordService.js (java RecordImpl object)
			SERVER_DYNAMIC_SUBRECORD:   'SubrecordImpl'				        // serverRecordService.js (java SubrecordImpl object)
		});

		var ALL_RECORD_UNDERLYING_IMPL_NAMES = Object.freeze([
			RECORD_UNDERLYING_IMPL_NAME.CLIENT_DYNAMIC_RECORD,
			RECORD_UNDERLYING_IMPL_NAME.DOM_CURRENT_RECORD,
			RECORD_UNDERLYING_IMPL_NAME.DOM_CURRENT_SUBRECORD,
			RECORD_UNDERLYING_IMPL_NAME.SERVER_DYNAMIC_RECORD,
			RECORD_UNDERLYING_IMPL_NAME.SERVER_DYNAMIC_SUBRECORD
		]);

		return Object.freeze({
			RECORD_MODE: RECORD_MODE,
			SUBRECORD_MODE: SUBRECORD_MODE,
			CURRENT_RECORD_MODE: CURRENT_RECORD_MODE,
			CURRENT_SUBRECORD_MODE: CURRENT_SUBRECORD_MODE,
			ALL_RECORD_PROXY_NAMES: ALL_RECORD_PROXY_NAMES,
			LINE_MODE: LINE_MODE,
			RECORD_UNDERLYING_IMPL_NAME: RECORD_UNDERLYING_IMPL_NAME,
			ALL_RECORD_UNDERLYING_IMPL_NAMES: ALL_RECORD_UNDERLYING_IMPL_NAMES
		});
	});

/**
 * SuiteScript field util module
 *
 * @private
 * @module N/fieldUtil
 * @suiteScriptVersion 2.x
 *
 */

define('N/fieldUtil',["N/utilityFunctions", "N/error"],
	function(utilityFunctions, error)
	{
		var SELECT_FIELD_TYPES = Object.freeze({
			SELECT: 'select',
			MULTI_SELECT: 'multiselect'
		});
		var RADIO_TYPE = 'radio';
		var CUSTPAGE_PREFIX = 'custpage';
		var SELECT_FIELD_TYPE_LIST = [SELECT_FIELD_TYPES.SELECT, SELECT_FIELD_TYPES.MULTI_SELECT];

		function verifyPrefixedWithCustPage(fieldName)
		{
			utilityFunctions.assertTrue( isPrefixedWithCustPage(fieldName), error.Type.SSS_INVALID_UI_OBJECT_TYPE );
		}

		function isPrefixedWithCustPage(fieldName)
		{
			return (!utilityFunctions.isValEmpty(fieldName)) && (fieldName.indexOf(CUSTPAGE_PREFIX) === 0)
		}

		function isMultiSelectType(type)
		{
			return type === SELECT_FIELD_TYPES.MULTI_SELECT;
		}

		function isSelectType(type)
		{
			return SELECT_FIELD_TYPE_LIST.indexOf(type) > -1;
		}

		function isSelectTypeOrRadio(type)
		{
			return isSelectType(type) || type === RADIO_TYPE;
		}

		return {
					verifyPrefixedWithCustPage: verifyPrefixedWithCustPage,
					isPrefixedWithCustPage: isPrefixedWithCustPage,
					isMultiSelectType : isMultiSelectType,
					isSelectType: isSelectType,
					isSelectTypeOrRadio: isSelectTypeOrRadio,
					SELECT_FIELD_TYPES: SELECT_FIELD_TYPES
			   };
	});

/**
 * SuiteScript metadata module
 *
 * @private
 * @module N/field
 * @NApiVersion 2.x
 *
 */
define('N/field',['N/restricted/bridge', 'N/error', 'N/nsobject', 'N/restricted/invoker', 'N/utilityFunctions', 'N/fieldUtil'],
        function (apiBridge, error, nsobject, invoker, utilityFunctions, fieldUtil)
{

    /**
     * @protected
     * @constructor
     */
    function Field(delegate)
    {
        /**
         * Return label of the field
         * @name Field#label
         * @type string
         * @readonly
         * @since 2015.2
         */
        Object.defineProperty(this, 'label', {
            get: function ()
            {
                return invoker(delegate, 'getLabel');
            },
            set: function (val)
            {
                return invoker(delegate, 'setLabel', [val]);
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return id of the field
         * @name Field#id
         * @type string
         * @readonly
         * @since 2015.2
         */
        Object.defineProperty(this, 'id', {
            get: function ()
            {
                        return invoker(delegate, 'getName');
            },
            set: function (val)
            {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'field.Field.id');
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Disabled state of the field
         * @name Field#isDisabled
         * @type boolean
         * @since 2015.2
         */
        Object.defineProperty(this, 'isDisabled', {
                    get: function ()
                    {
                        return invoker(delegate, 'isDisabled');
            },
                    set: function (val)
                    {
                        invoker(delegate, 'setDisabled', [val]);
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Display state of the field
         * @name Field#isDisplay
         * @type boolean
         * @since 2015.2
         */
        Object.defineProperty(this, 'isDisplay', {
                    get: function ()
                    {
                        return invoker(delegate, 'isDisplay');
            },
                    set: function (val)
                    {
                        invoker(delegate, 'setDisplay', [val]);
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Mandatory state of the field
         * @name Field#isMandatory
         * @type boolean
         * @since 2015.2
         */
        Object.defineProperty(this, 'isMandatory', {
                    get: function ()
                    {
                        return invoker(delegate, 'isMandatory');
            },
                    set: function (val)
                    {
                        invoker(delegate, 'setMandatory', [val]);
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Read Only state of the field
         * @name Field#isReadOnly
         * @type boolean
         * @since 2015.2
         */
        Object.defineProperty(this, 'isReadOnly', {
                    get: function ()
                    {
                        return invoker(delegate, 'isReadOnly');
            },
                    set: function (val)
                    {
                        invoker(delegate, 'setReadOnly', [val]);
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Visible state of the field
         * @name Field#isVisible
         * @type boolean
         * @since 2015.2
         */
        Object.defineProperty(this, 'isVisible', {
                    get: function ()
                    {
                        return invoker(delegate, 'isVisible');
            },
                    set: function (val)
                    {
                        invoker(delegate, 'setVisible', [val]);
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return type of the field
         * @name Field#type
         * @type string
         * @readonly
         * @since 2015.2
         */
        Object.defineProperty(this, 'type', {
            get: function ()
            {
                return invoker(delegate, 'getType');
            },
            set: function (val)
            {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'field.Field.type');
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return the sublistId of the field
         * @name Field#sublistId
         * @type string
         * @readonly
         * @since 2015.2
         */
        Object.defineProperty(this, 'sublistId', {
            get: function ()
            {
                return invoker(delegate, 'getSublistName');
            },
            set: function (val)
            {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'field.Field.sublistId');
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Returns if the field is a popup
         * @name Field#isPopup
         * @type boolean
         * @readonly
         * @since 2015.2
         */
        Object.defineProperty(this, 'isPopup', {
            get: function ()
            {
                return invoker(delegate, 'isPopup');
            },
            set: function (val)
            {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'field.Field.isPopup');
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Returns a list of available options on a select field. This API can be used on both standard and custom select fields. Only the first 1,000 available options will be returned by this API.
         *
         * @param {Object} options
         * @param {string} options.filter
         * @param {string} options.operator Supported operators are contains | is | startswith. If not specified, defaults to the contains operator.
         * @return {Array}
         *
         */

        function getSelectOptions(options,filteroperator)
        {
            var filter = options;
            if (utilityFunctions.isObject(options))
            {
                filter = options.filter;
                filteroperator = options.operator;
            }
            var sOptions = [];
                    var optionObjects = invoker(delegate, 'getSelectOptions', [filter || null, filteroperator || null]);
                    for (var i in optionObjects)
            {
                        if (!optionObjects.hasOwnProperty(i))
                    continue;
                        sOptions[sOptions.length] = {
                            'value': optionObjects[i].getId(),
                            'text': optionObjects[i].getText()
                        };
            }
            return sOptions;
        };

        if(fieldUtil.isSelectTypeOrRadio(this.type))
            this.getSelectOptions = getSelectOptions;

        function insertSelectOption(options, text)
        {
            var value,
                selected = false,
                that = this,
                undef = undefined;

            if (text !== undef)
            {
                value = options;
            }
            else if (options !== undef && options !== null)
            {
                value = options.value;
                text = options.text;
                selected = options.isSelected || false;
            }
            if (!invoker(delegate, 'isCurrentRecord', []))
                fieldUtil.verifyPrefixedWithCustPage(that.id);
            utilityFunctions.checkArgs([value, text], ['value', 'text'], 'Field.insertSelectOption');
            invoker(delegate, 'insertSelectOption', [String(value), text, selected]);
        }

        function removeSelectOption(options)
        {
            var undef = undefined,
                that = this,
                value = ((options !== undef) && (options !== null) && (options.value !== undef)) ? options.value : options;

            fieldUtil.verifyPrefixedWithCustPage(that.id);
            utilityFunctions.checkArgs([value], ['value'], 'Field.removeSelectOption');
            invoker(delegate, 'removeSelectOption', [String(value)]);
        }

        if(fieldUtil.isSelectType(this.type)) {
            this.insertSelectOption = insertSelectOption;
            this.removeSelectOption = removeSelectOption;
        }
        // Functions for debugger
        /**
         * get JSON format of the object
         * @return {{id: *, label: *, type: *}}
         *
         */
        this.toJSON = function toJSON()
        {
            return {
                        'id': this.id,
                        'label': this.label,
                        'type': this.type
            };
        };

        /**
         * @return {string}
         *
         */
        this.toString = function toString()
        {
            return "Field";
        };
    }

    Field.prototype = nsobject.getNewInstance();

    return Object.freeze({
        create: function create(f)
        {
            try
            {
                return Object.freeze(new Field(f));
            }
            catch (e)
            {
                throw error.create(e);
            }
        }
    });

});

/**
 * Field Definition module
 * Will create the appropriate Field Object given the desired attributes.
 *
 * @private
 * @module N/fieldDefinition
 * @NApiVersion 2.x
 *
 */
define('N/metadata/fieldDefinition',['N/restricted/invoker', 'N/utilityFunctions', 'N/nsobject', 'N/error'], function(invoker, utilityFunctions, nsobject, error) {



    var FIELD_CATEGORY = {
        CURRENT_BODY: 'currentBody',
        CURRENT_SUBLIST: 'currentSublist',
        DYNAMIC_BODY: 'dynamicBody',
        DYNAMIC_SUBLIST: 'dynamicSublist',
        DEFERRED_DYNAMIC_BODY: 'deferredDynamicBody',
        DEFERRED_DYNAMIC_SUBLIST: 'deferredDynamicSublist',
        DEFERRED_DYNAMIC_CURRENT_BODY: 'deferredDynamicCurrentBody',
        DEFERRED_DYNAMIC_CURRENT_SUBLIST: 'deferredDynamicCurrentSublist',
        READ_ONLY_BODY: 'readOnlyRecordBody',
        READ_ONLY_SUBLIST: 'readOnlyRecordSublist'
    };
    FIELD_CATEGORY.getInstance = function getFieldCategoryInstance(options){
        var category;
        if(!!options.isDynamic)
        {
            category = !!options.isSublistField ? FIELD_CATEGORY.DYNAMIC_SUBLIST : FIELD_CATEGORY.DYNAMIC_BODY;
        }
        else if(!!options.isReadOnly)
        {
            category = !!options.isSublistField ? FIELD_CATEGORY.READ_ONLY_SUBLIST : FIELD_CATEGORY.READ_ONLY_BODY;
        }
        else
        {
            category = !!options.isSublistField ? FIELD_CATEGORY.DEFERRED_DYNAMIC_SUBLIST : FIELD_CATEGORY.DEFERRED_DYNAMIC_BODY;
        }
        return category;
    };
    FIELD_CATEGORY = utilityFunctions.freezeObjectIfPossible(FIELD_CATEGORY);

    var FIELD_PROPERTIES = Object.freeze({
                                            ID: "id",
                                            LABEL: "label",
                                            TYPE: "type",
                                            SUBLIST_ID: "sublistId",
                                            SELECT_OPTION_PROP: "selectOptionProp",
                                            IS_MANDATORY: "isMandatory",
                                            IS_DISABLED: "isDisabled",
                                            IS_POPUP: "isPopup",
                                            IS_DISPLAY: "isDisplay",
                                            IS_VISIBLE: "isVisible",
                                            IS_READ_ONLY: "isReadOnly",
											TO_JSON: "toJSON",
											TO_STRING: "toString"
                                         });

    var ACCESS_LEVEL = Object.freeze({
                NONE: 0,
                READ_ONLY: 1,
                READ_WRITE: 2
                                     });

    function Field(delegate, permissions)
    {
        function authorizeThenWrite(accessLevel, setFunction, errorMsg)
        {
            if (accessLevel === ACCESS_LEVEL.READ_WRITE)
            {
                setFunction();
            }
            else
            {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, errorMsg );
            }
        }

        function noAction() { }

        if (permissions[FIELD_PROPERTIES.ID] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return the id of the field
             * @name Field#id
             * @type string
             * @readonly
             * @since 2015.2
             */
            Object.defineProperty(this, 'id', {
                get: function ()
                {
                    return delegate.id;
                },
                set: function (val)
                {
                    authorizeThenWrite(permissions[FIELD_PROPERTIES.ID], noAction, "Field.id");
                },
                enumerable: true,
                configurable: false
            });
        }
        if (permissions[FIELD_PROPERTIES.LABEL] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return the label of the field
             * @name Field#label
             * @type string
             * @readonly
             * @since 2015.2
             */
            Object.defineProperty(this, 'label', {
                get: function ()
                {
                    return delegate.label;
                },
                set: function (label)
                {
                            var setFunction = function ()
                            {
                                        delegate.label = label;
                                      };
                    authorizeThenWrite(permissions[FIELD_PROPERTIES.LABEL], setFunction, "Field.label");
                },
                enumerable: true,
                configurable: false
            });
        }
        if (permissions[FIELD_PROPERTIES.TYPE] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return the type of the field
             * @name Field#type
             * @type string
             * @readonly
             * @since 2015.2
             */
            Object.defineProperty(this, 'type', {
                get: function ()
                {
                    return delegate.type;
                },
                set: function (val)
                {
                    authorizeThenWrite(permissions[FIELD_PROPERTIES.TYPE], noAction, "Field.type");
                },
                enumerable: true,
                configurable: false
            });
        }
        if (permissions[FIELD_PROPERTIES.SUBLIST_ID] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return the sublist id of the field
             * @name Field#sublistId
             * @type string
             * @readonly
             * @since 2015.2
             */
            Object.defineProperty(this, 'sublistId', {
                get: function ()
                {
                    return delegate.sublistId;
                },
                set: function (val)
                {
                    authorizeThenWrite(permissions[FIELD_PROPERTIES.SUBLIST_ID], noAction, "Field.sublistId");
                },
                enumerable: true,
                configurable: false
            });
        }
        if (permissions[FIELD_PROPERTIES.SELECT_OPTION_PROP] > ACCESS_LEVEL.NONE)
        {
            this.getSelectOptions = delegate.getSelectOptions;
	        this.insertSelectOption = delegate.insertSelectOption;
	        this.removeSelectOption = delegate.removeSelectOption;
        }
        if (permissions[FIELD_PROPERTIES.IS_MANDATORY] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return whether the field is mandatory or not.
             * @name Field#isMandatory
             * @type boolean
             * @since 2015.2
             */
            Object.defineProperty(this, 'isMandatory', {
                get: function ()
                {
                    return delegate.isMandatory;
                },
                set: function (required)
                {
                            var setFunction = function ()
                            {
                                            if (!util.isBoolean(required))
                                                utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, "Field.isMandatory",'boolean' );

                                            delegate.isMandatory = required;
                                        };
                    authorizeThenWrite(permissions[FIELD_PROPERTIES.IS_MANDATORY], setFunction, "Field.isMandatory");
                },
                enumerable: true,
                configurable: false
            });
        }
        // ==== Current Record (UI) specific properties
        if (permissions[FIELD_PROPERTIES.IS_DISABLED] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return whether the field is disabled
             * @name Field#isDisabled
             * @type boolean
             * @since 2015.2
             */
            Object.defineProperty(this, 'isDisabled', {
                get: function ()
                {
                    return delegate.isDisabled;
                },
                set: function (val)
                {
                            var setFunction = function ()
                            {
                        if (!util.isBoolean(val))
                            utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, "Field.isDisabled",'boolean' );

                        delegate.isDisabled = val;
                    };
                    authorizeThenWrite(permissions[FIELD_PROPERTIES.IS_DISABLED], setFunction, "Field.isDisabled");
                },
                enumerable: true,
                configurable: false
            });
        }
        if (permissions[FIELD_PROPERTIES.IS_POPUP] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return whether the field is a popup
             * @name Field#isPopup
             * @type boolean
             * @readonly
             * @since 2015.2
             */
            Object.defineProperty(this, 'isPopup', {
                get: function ()
                {
                    return delegate.isPopup;
                },
                set: function (val)
                {
                    authorizeThenWrite(permissions[FIELD_PROPERTIES.IS_POPUP], noAction, "Field.isPopup");
                },
                enumerable: true,
                configurable: false
            });
        }
        if (permissions[FIELD_PROPERTIES.IS_DISPLAY] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return whether the field is displayed (when false, there is no space reserved on the UI for this field, unlike visible)
             * @name Field#isDisplay
             * @type boolean
             * @since 2015.2
             */
            Object.defineProperty(this, 'isDisplay', {
                get: function ()
                {
                    return delegate.isDisplay;
                },
                set: function (show)
                {
                            var setFunction = function ()
                            {
                                        if (!util.isBoolean(show))
                                            utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, "Field.isDisplay",'boolean' );
                                        delegate.isDisplay = show;
                                    };
                    authorizeThenWrite(permissions[FIELD_PROPERTIES.IS_DISPLAY], setFunction, "Field.isDisplay");
                },
                enumerable: true,
                configurable: false
            });
        }
        if (permissions[FIELD_PROPERTIES.IS_VISIBLE] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return whether the field is visible (when false, the space is still reserved on the UI for this field, unlike display)
             * @name Field#isVisible
             * @type boolean
             * @since 2015.2
             */
            Object.defineProperty(this, 'isVisible', {
                get: function ()
                {
                    return delegate.isVisible;
                },
                set: function (show)
                {
                            var setFunction = function ()
                            {
                                        if (!util.isBoolean(show))
                                            utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, "Field.isVisible",'boolean' );
                                        delegate.isVisible = show;
                                    };
                    authorizeThenWrite(permissions[FIELD_PROPERTIES.IS_VISIBLE], setFunction, "Field.isVisible");
                },
                enumerable: true,
                configurable: false
            });
        }
        if (permissions[FIELD_PROPERTIES.IS_READ_ONLY] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return whether the field is readOnly
             * @name Field#isVisible
             * @type boolean
             * @since 2015.2
             */
            Object.defineProperty(this, 'isReadOnly', {
                get: function ()
                {
                    return delegate.isReadOnly
                },
                set: function (val)
                {
                            var setFunction = function ()
                            {
                                        if (!util.isBoolean(val))
                                            utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, "Field.isReadOnly",'boolean' );
                                        delegate.isReadOnly = val;
                                    };

                    authorizeThenWrite(permissions[FIELD_PROPERTIES.IS_READ_ONLY], setFunction, "Field.isReadOnly");
                },
                enumerable: true,
                configurable: false
            });
        }

		if (permissions[FIELD_PROPERTIES.TO_JSON] > ACCESS_LEVEL.NONE)
		{
			this.toJSON = delegate.toJSON;
		}

		if (permissions[FIELD_PROPERTIES.TO_STRING] > ACCESS_LEVEL.NONE)
		{
			this.toString = delegate.toString;
		}
    }

    Field.prototype = nsobject.getNewInstance();
    Object.freeze(Field);

    return Object.freeze({
                             Category: FIELD_CATEGORY,
                Property: FIELD_PROPERTIES,
                             Access: ACCESS_LEVEL,
                create: function (delegate, permissions)
                             {
                                 return !delegate ? null : Object.freeze(new Field(delegate, permissions));
                             }
                         });
        });

/**
 *
 * @private
 * @module N/fieldPermissions
 * @NApiVersion 2.x
 *
 */
define('N/metadata/fieldPermissions',['N/metadata/fieldDefinition'], function(fieldDef) {

    var dynamicBody = {};
    dynamicBody[fieldDef.Property.ID]                 = fieldDef.Access.READ_ONLY;
    dynamicBody[fieldDef.Property.TYPE]               = fieldDef.Access.READ_ONLY;
    dynamicBody[fieldDef.Property.LABEL]              = fieldDef.Access.READ_WRITE;
    dynamicBody[fieldDef.Property.SUBLIST_ID]         = fieldDef.Access.NONE;
    dynamicBody[fieldDef.Property.SELECT_OPTION_PROP] = fieldDef.Access.READ_ONLY;
    dynamicBody[fieldDef.Property.IS_MANDATORY]       = fieldDef.Access.READ_WRITE;
    dynamicBody[fieldDef.Property.IS_DISABLED]        = fieldDef.Access.NONE;
    dynamicBody[fieldDef.Property.IS_POPUP]           = fieldDef.Access.NONE;
    dynamicBody[fieldDef.Property.IS_DISPLAY]         = fieldDef.Access.NONE;
    dynamicBody[fieldDef.Property.IS_VISIBLE]         = fieldDef.Access.NONE;
    dynamicBody[fieldDef.Property.IS_READ_ONLY]       = fieldDef.Access.NONE;
	dynamicBody[fieldDef.Property.TO_JSON]            = fieldDef.Access.READ_ONLY;
	dynamicBody[fieldDef.Property.TO_STRING]          = fieldDef.Access.READ_ONLY;

    var dynamicSublist = {};
    dynamicSublist[fieldDef.Property.ID]                 = fieldDef.Access.READ_ONLY;
    dynamicSublist[fieldDef.Property.TYPE]               = fieldDef.Access.READ_ONLY;
    dynamicSublist[fieldDef.Property.LABEL]              = fieldDef.Access.READ_WRITE;
    dynamicSublist[fieldDef.Property.SUBLIST_ID]         = fieldDef.Access.READ_ONLY;
    dynamicSublist[fieldDef.Property.SELECT_OPTION_PROP] = fieldDef.Access.READ_ONLY;
    dynamicSublist[fieldDef.Property.IS_MANDATORY]       = fieldDef.Access.READ_WRITE;
    dynamicSublist[fieldDef.Property.IS_DISABLED]        = fieldDef.Access.NONE;
    dynamicSublist[fieldDef.Property.IS_POPUP]           = fieldDef.Access.NONE;
    dynamicSublist[fieldDef.Property.IS_DISPLAY]         = fieldDef.Access.NONE;
    dynamicSublist[fieldDef.Property.IS_VISIBLE]         = fieldDef.Access.NONE;
    dynamicSublist[fieldDef.Property.IS_READ_ONLY]       = fieldDef.Access.NONE;
	dynamicSublist[fieldDef.Property.TO_JSON]            = fieldDef.Access.READ_ONLY;
	dynamicSublist[fieldDef.Property.TO_STRING]          = fieldDef.Access.READ_ONLY;

    var deferredDynamicBody = {};
    deferredDynamicBody[fieldDef.Property.ID]                 = fieldDef.Access.READ_ONLY;
    deferredDynamicBody[fieldDef.Property.TYPE]               = fieldDef.Access.READ_ONLY;
    deferredDynamicBody[fieldDef.Property.LABEL]              = fieldDef.Access.READ_WRITE;
    deferredDynamicBody[fieldDef.Property.SUBLIST_ID]         = fieldDef.Access.NONE;
    deferredDynamicBody[fieldDef.Property.SELECT_OPTION_PROP] = fieldDef.Access.NONE;
    deferredDynamicBody[fieldDef.Property.IS_MANDATORY]       = fieldDef.Access.READ_WRITE;
    deferredDynamicBody[fieldDef.Property.IS_DISABLED]        = fieldDef.Access.NONE;
    deferredDynamicBody[fieldDef.Property.IS_POPUP]           = fieldDef.Access.NONE;
    deferredDynamicBody[fieldDef.Property.IS_DISPLAY]         = fieldDef.Access.NONE;
    deferredDynamicBody[fieldDef.Property.IS_VISIBLE]         = fieldDef.Access.NONE;
    deferredDynamicBody[fieldDef.Property.IS_READ_ONLY]       = fieldDef.Access.NONE;
    deferredDynamicBody[fieldDef.Property.TO_JSON]            = fieldDef.Access.READ_ONLY;
    deferredDynamicBody[fieldDef.Property.TO_STRING]          = fieldDef.Access.READ_ONLY;

    var deferredDynamicSublist = {};
    deferredDynamicSublist[fieldDef.Property.ID]                 = fieldDef.Access.READ_ONLY;
    deferredDynamicSublist[fieldDef.Property.TYPE]               = fieldDef.Access.READ_ONLY;
    deferredDynamicSublist[fieldDef.Property.LABEL]              = fieldDef.Access.READ_WRITE;
    deferredDynamicSublist[fieldDef.Property.SUBLIST_ID]         = fieldDef.Access.READ_ONLY;
    deferredDynamicSublist[fieldDef.Property.SELECT_OPTION_PROP] = fieldDef.Access.NONE;
    deferredDynamicSublist[fieldDef.Property.IS_MANDATORY]       = fieldDef.Access.READ_WRITE;
    deferredDynamicSublist[fieldDef.Property.IS_DISABLED]        = fieldDef.Access.NONE;
    deferredDynamicSublist[fieldDef.Property.IS_POPUP]           = fieldDef.Access.NONE;
    deferredDynamicSublist[fieldDef.Property.IS_DISPLAY]         = fieldDef.Access.NONE;
    deferredDynamicSublist[fieldDef.Property.IS_VISIBLE]         = fieldDef.Access.NONE;
    deferredDynamicSublist[fieldDef.Property.IS_READ_ONLY]       = fieldDef.Access.NONE;
    deferredDynamicSublist[fieldDef.Property.TO_JSON]            = fieldDef.Access.READ_ONLY;
    deferredDynamicSublist[fieldDef.Property.TO_STRING]          = fieldDef.Access.READ_ONLY;

    var currentBody = {};
    currentBody[fieldDef.Property.ID]                 = fieldDef.Access.READ_ONLY;
    currentBody[fieldDef.Property.TYPE]               = fieldDef.Access.READ_ONLY;
    currentBody[fieldDef.Property.LABEL]              = fieldDef.Access.READ_WRITE;
    currentBody[fieldDef.Property.SUBLIST_ID]         = fieldDef.Access.NONE;
    currentBody[fieldDef.Property.SELECT_OPTION_PROP] = fieldDef.Access.READ_ONLY;
    currentBody[fieldDef.Property.IS_MANDATORY]       = fieldDef.Access.READ_WRITE;
    currentBody[fieldDef.Property.IS_DISABLED]        = fieldDef.Access.READ_WRITE;
    currentBody[fieldDef.Property.IS_POPUP]           = fieldDef.Access.READ_ONLY;
    currentBody[fieldDef.Property.IS_DISPLAY]         = fieldDef.Access.READ_WRITE;
    currentBody[fieldDef.Property.IS_VISIBLE]         = fieldDef.Access.READ_WRITE;
    currentBody[fieldDef.Property.IS_READ_ONLY]       = fieldDef.Access.READ_WRITE;
	currentBody[fieldDef.Property.TO_JSON]            = fieldDef.Access.READ_ONLY;
	currentBody[fieldDef.Property.TO_STRING]          = fieldDef.Access.READ_ONLY;

    var currentSublist = {};
    currentSublist[fieldDef.Property.ID]                 = fieldDef.Access.READ_ONLY;
    currentSublist[fieldDef.Property.TYPE]               = fieldDef.Access.READ_ONLY;
    currentSublist[fieldDef.Property.LABEL]              = fieldDef.Access.READ_WRITE;
    currentSublist[fieldDef.Property.SUBLIST_ID]         = fieldDef.Access.READ_ONLY;
    currentSublist[fieldDef.Property.SELECT_OPTION_PROP] = fieldDef.Access.READ_ONLY;
    currentSublist[fieldDef.Property.IS_MANDATORY]       = fieldDef.Access.READ_WRITE;
    currentSublist[fieldDef.Property.IS_DISABLED]        = fieldDef.Access.READ_WRITE;
    currentSublist[fieldDef.Property.IS_POPUP]           = fieldDef.Access.READ_ONLY;
    currentSublist[fieldDef.Property.IS_DISPLAY]         = fieldDef.Access.READ_ONLY;
    currentSublist[fieldDef.Property.IS_VISIBLE]         = fieldDef.Access.READ_ONLY;
    currentSublist[fieldDef.Property.IS_READ_ONLY]       = fieldDef.Access.READ_ONLY;
	currentSublist[fieldDef.Property.TO_JSON]            = fieldDef.Access.READ_ONLY;
	currentSublist[fieldDef.Property.TO_STRING]          = fieldDef.Access.READ_ONLY;

    var deferredDynamicCurrentBody = {};
    deferredDynamicCurrentBody[fieldDef.Property.ID]                 = fieldDef.Access.READ_ONLY;
    deferredDynamicCurrentBody[fieldDef.Property.TYPE]               = fieldDef.Access.READ_ONLY;
    deferredDynamicCurrentBody[fieldDef.Property.LABEL]              = fieldDef.Access.READ_WRITE;
    deferredDynamicCurrentBody[fieldDef.Property.SUBLIST_ID]         = fieldDef.Access.NONE;
    deferredDynamicCurrentBody[fieldDef.Property.SELECT_OPTION_PROP] = fieldDef.Access.NONE;
    deferredDynamicCurrentBody[fieldDef.Property.IS_MANDATORY]       = fieldDef.Access.READ_WRITE;
    deferredDynamicCurrentBody[fieldDef.Property.IS_DISABLED]        = fieldDef.Access.READ_WRITE;
    deferredDynamicCurrentBody[fieldDef.Property.IS_POPUP]           = fieldDef.Access.READ_ONLY;
    deferredDynamicCurrentBody[fieldDef.Property.IS_DISPLAY]         = fieldDef.Access.READ_WRITE;
    deferredDynamicCurrentBody[fieldDef.Property.IS_VISIBLE]         = fieldDef.Access.READ_WRITE;
    deferredDynamicCurrentBody[fieldDef.Property.IS_READ_ONLY]       = fieldDef.Access.READ_WRITE;
    deferredDynamicCurrentBody[fieldDef.Property.TO_JSON]            = fieldDef.Access.READ_ONLY;
    deferredDynamicCurrentBody[fieldDef.Property.TO_STRING]          = fieldDef.Access.READ_ONLY;

    var deferredDynamicCurrentSublist = {};
    deferredDynamicCurrentSublist[fieldDef.Property.ID]                 = fieldDef.Access.READ_ONLY;
    deferredDynamicCurrentSublist[fieldDef.Property.TYPE]               = fieldDef.Access.READ_ONLY;
    deferredDynamicCurrentSublist[fieldDef.Property.LABEL]              = fieldDef.Access.READ_WRITE;
    deferredDynamicCurrentSublist[fieldDef.Property.SUBLIST_ID]         = fieldDef.Access.READ_ONLY;
    deferredDynamicCurrentSublist[fieldDef.Property.SELECT_OPTION_PROP] = fieldDef.Access.NONE;
    deferredDynamicCurrentSublist[fieldDef.Property.IS_MANDATORY]       = fieldDef.Access.READ_WRITE;
    deferredDynamicCurrentSublist[fieldDef.Property.IS_DISABLED]        = fieldDef.Access.READ_WRITE;
    deferredDynamicCurrentSublist[fieldDef.Property.IS_POPUP]           = fieldDef.Access.READ_ONLY;
    deferredDynamicCurrentSublist[fieldDef.Property.IS_DISPLAY]         = fieldDef.Access.READ_ONLY;
    deferredDynamicCurrentSublist[fieldDef.Property.IS_VISIBLE]         = fieldDef.Access.READ_ONLY;
    deferredDynamicCurrentSublist[fieldDef.Property.IS_READ_ONLY]       = fieldDef.Access.READ_ONLY;
    deferredDynamicCurrentSublist[fieldDef.Property.TO_JSON]            = fieldDef.Access.READ_ONLY;
    deferredDynamicCurrentSublist[fieldDef.Property.TO_STRING]          = fieldDef.Access.READ_ONLY;

    var readOnlyRecordBody = {};
    readOnlyRecordBody[fieldDef.Property.ID]                 = fieldDef.Access.READ_ONLY;
    readOnlyRecordBody[fieldDef.Property.TYPE]               = fieldDef.Access.READ_ONLY;
    readOnlyRecordBody[fieldDef.Property.LABEL]              = fieldDef.Access.READ_ONLY;
    readOnlyRecordBody[fieldDef.Property.SUBLIST_ID]         = fieldDef.Access.NONE;
    readOnlyRecordBody[fieldDef.Property.SELECT_OPTION_PROP] = fieldDef.Access.NONE;
    readOnlyRecordBody[fieldDef.Property.IS_MANDATORY]       = fieldDef.Access.READ_ONLY;
    readOnlyRecordBody[fieldDef.Property.IS_DISABLED]        = fieldDef.Access.READ_ONLY;
    readOnlyRecordBody[fieldDef.Property.IS_POPUP]           = fieldDef.Access.READ_ONLY;
    readOnlyRecordBody[fieldDef.Property.IS_DISPLAY]         = fieldDef.Access.READ_ONLY;
    readOnlyRecordBody[fieldDef.Property.IS_VISIBLE]         = fieldDef.Access.READ_ONLY;
    readOnlyRecordBody[fieldDef.Property.IS_READ_ONLY]       = fieldDef.Access.READ_ONLY;
    readOnlyRecordBody[fieldDef.Property.TO_JSON]            = fieldDef.Access.READ_ONLY;
    readOnlyRecordBody[fieldDef.Property.TO_STRING]          = fieldDef.Access.READ_ONLY;

    var readOnlyRecordSublist = {};
    readOnlyRecordSublist[fieldDef.Property.ID]                 = fieldDef.Access.READ_ONLY;
    readOnlyRecordSublist[fieldDef.Property.TYPE]               = fieldDef.Access.READ_ONLY;
    readOnlyRecordSublist[fieldDef.Property.LABEL]              = fieldDef.Access.READ_ONLY;
    readOnlyRecordSublist[fieldDef.Property.SUBLIST_ID]         = fieldDef.Access.READ_ONLY;
    readOnlyRecordSublist[fieldDef.Property.SELECT_OPTION_PROP] = fieldDef.Access.NONE;
    readOnlyRecordSublist[fieldDef.Property.IS_MANDATORY]       = fieldDef.Access.READ_ONLY;
    readOnlyRecordSublist[fieldDef.Property.IS_DISABLED]        = fieldDef.Access.READ_ONLY;
    readOnlyRecordSublist[fieldDef.Property.IS_POPUP]           = fieldDef.Access.READ_ONLY;
    readOnlyRecordSublist[fieldDef.Property.IS_DISPLAY]         = fieldDef.Access.READ_ONLY;
    readOnlyRecordSublist[fieldDef.Property.IS_VISIBLE]         = fieldDef.Access.READ_ONLY;
    readOnlyRecordSublist[fieldDef.Property.IS_READ_ONLY]       = fieldDef.Access.READ_ONLY;
    readOnlyRecordSublist[fieldDef.Property.TO_JSON]            = fieldDef.Access.READ_ONLY;
    readOnlyRecordSublist[fieldDef.Property.TO_STRING]          = fieldDef.Access.READ_ONLY;

    var masterPermission = {};
    masterPermission[fieldDef.Category.CURRENT_BODY]                     = currentBody;
    masterPermission[fieldDef.Category.CURRENT_SUBLIST]                  = currentSublist;
    masterPermission[fieldDef.Category.DYNAMIC_BODY]                     = dynamicBody;
    masterPermission[fieldDef.Category.DYNAMIC_SUBLIST]                  = dynamicSublist;
    masterPermission[fieldDef.Category.DEFERRED_DYNAMIC_BODY]            = deferredDynamicBody;
    masterPermission[fieldDef.Category.DEFERRED_DYNAMIC_SUBLIST]         = deferredDynamicSublist;
    masterPermission[fieldDef.Category.DEFERRED_DYNAMIC_CURRENT_BODY]    = deferredDynamicCurrentBody;
    masterPermission[fieldDef.Category.DEFERRED_DYNAMIC_CURRENT_SUBLIST] = deferredDynamicCurrentSublist;
    masterPermission[fieldDef.Category.READ_ONLY_BODY] = readOnlyRecordBody;
    masterPermission[fieldDef.Category.READ_ONLY_SUBLIST] = readOnlyRecordSublist;

    var convertToCurrentVersion = {};
    convertToCurrentVersion[fieldDef.Category.CURRENT_BODY] = fieldDef.Category.CURRENT_BODY;
    convertToCurrentVersion[fieldDef.Category.CURRENT_SUBLIST] = fieldDef.Category.CURRENT_SUBLIST;
    convertToCurrentVersion[fieldDef.Category.DYNAMIC_BODY] = fieldDef.Category.CURRENT_BODY;
    convertToCurrentVersion[fieldDef.Category.DYNAMIC_SUBLIST] = fieldDef.Category.CURRENT_SUBLIST;
    convertToCurrentVersion[fieldDef.Category.DEFERRED_DYNAMIC_BODY] = fieldDef.Category.DEFERRED_DYNAMIC_CURRENT_BODY;
    convertToCurrentVersion[fieldDef.Category.DEFERRED_DYNAMIC_SUBLIST] = fieldDef.Category.DEFERRED_DYNAMIC_CURRENT_SUBLIST;
    convertToCurrentVersion[fieldDef.Category.READ_ONLY_BODY] = fieldDef.Category.READ_ONLY_BODY;
    convertToCurrentVersion[fieldDef.Category.READ_ONLY_SUBLIST] = fieldDef.Category.READ_ONLY_SUBLIST;

    function getPermission(type, isCurrent)
    {
        var trueType = isCurrent ? convertToCurrentVersion[type] : type;
        return masterPermission[trueType];
    }

    return Object.freeze({
                            getPermissions: getPermission
                         });
        });

/**
 * Field metadata module
 * Will provide the proper attributes based on the parameters sent in to identify its source.
 *
 * @private
 * @module N/fieldMetadata
 * @suiteScriptVersion 2.x
 */
define('N/metadata/fieldMetadata',['N/utilityFunctions', 'N/metadata/fieldDefinition', 'N/metadata/fieldPermissions'], function(utilityFunctions, fieldDef, fieldPermissions) {

    function wrap(options)
    {
        var fieldCategory = options.category || null,
                 delegate = options.delegate || null,
                isCurrent = options.current  || false;

        utilityFunctions.checkArgs([fieldCategory, delegate], ["fieldCategory", "delegate"], "fieldMetadata");

        return fieldDef.create(delegate, fieldPermissions.getPermissions(fieldCategory, isCurrent));
    }

    return Object.freeze({
                            Category: fieldDef.Category,
                            wrap : wrap
                         });
});

/**
 * SuiteScript module
 * This file is an alias for NLSqlInjectionFilter - NLSqlInjectionFilter.getFirstIllegalMatch(null)
 *
 * @private
 * @module N/util/sqlInjectionFilter
 * @suiteScriptVersion 2.x
 */
define('N/util/sqlInjectionFilter',["N/restricted/invoker", 'N/restricted/remoteApiBridge'],
	function(invoker, apiBridge){
		/* imports */
		/**
		 * @alias SELECT_STRING (NLSqlInjectionFilter.java)
		 */
		var SQL_SELECT_STRING_REGEX = /select[ ].+from[ ]?[^ ,]*[ ,]+((all)?(trandoc|tranline|trancard|entity|custjob|emaillogin|emailpassword|emailpasswordhistory|emailpasswordnewhistory)|([a-zA-Z_0-9]*)?@SIGNUPDB_0|([a-zA-Z_0-9]*)?@SANDBOX_SIGNUPDB_0|pwdresetanswers|v\$|source\$|dbms_|all_|dba_|user_|java\$|nl_)/i;

		/**
		 * utility function that values field value against SQL injection regex. Logs error if match is found
		 * @param fieldId - field name
		 * @param toValidate - value in field
		 */
		function validateSqlInjection(fieldId, toValidate)
		{
			if(isNonEmptyString(toValidate))
			{
				var matches = SQL_SELECT_STRING_REGEX.exec(toValidate.replace(/\s/g,' '));
				if(matches != null && matches.length > 1 && matches[1].trim().length > 0)
					logSQLInjectionError(fieldId, toValidate, matches[1]);
			}
		}

		function logSQLInjectionError(fieldId, toValidate, firstCaptureGroup)
		{
			invoker(apiBridge, 'logSQLInjectionError', [fieldId, toValidate, firstCaptureGroup]);
		}

		function isNonEmptyString(toValidate)
		{
			return (util.isString(toValidate) && toValidate.length > 0);
		}

		/* assign util.sqlInjectionFilter package */
		return Object.freeze({
			validateSqlInjection: validateSqlInjection
		});
	}
);

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/recordUtilityFunctions
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/recordUtilityFunctions',['N/restricted/invoker', 'N/utilityFunctions', 'N/error', 'N/restricted/remoteApiBridge', 'N/util/sqlInjectionFilter'],
	function(invoker, utilityFunctions, error, clientScriptHandler, sqlInjectionFilter)
	{
	    var undef = undefined;
	    var FIELD_TYPE = {
	            SUBRECORD_FIELD_TYPE : 'summary',
	            MULTISELECT : 'multiselect',
	            RADIO : 'radio',
		        SELECT : 'select',
		        CHECKBOX: 'checkbox',
		        TIME: "time",
		        TIMETRACK: "timetrack"
        };

	    var MACHINE_TYPE = {
	            INLINE_EDIT: 'inlineeditor'
        };

		var SELECT_FIELD_TYPE = [FIELD_TYPE.SELECT, FIELD_TYPE.MULTI_SELECT];
	    function isSelectType(type)
	    {
	        return SELECT_FIELD_TYPE.indexOf(type) > -1;
	    }

	    var EDIT_MACHINE_TYPE = [MACHINE_TYPE.INLINE_EDIT];
	    function isEditMachine(sublist)
	    {
	        return EDIT_MACHINE_TYPE.indexOf(sublist.type) > -1;
	    }

	    function handleOverloadingMethodsForSingleArgument(options, key, errorMessageFillerValue)
	    {
	        var argument = options !== undef && options !== null && !util.isString(options) ? options[key] : options;
	        utilityFunctions.checkArgs([argument], [key], errorMessageFillerValue);

	        return argument;
	    }

	    function emptyIfNullOrUndefined(value)
	    {
	        if(value === null || value === undefined)
	            return "";
	        else
	            return value;
	    }

	    function assertValidSublistOperation(isValid)
	    {
	        if(!isValid)
	            utilityFunctions.throwSuiteScriptError(error.Type.INVALID_SUBLIST_OPERATION);
	    }

	    function formatValueToArrayType(value)
	    {
	        if(!value && value !== 0 && value !== '')
	            return value;
	        else
	        {
	            if(typeof value === 'string' && value.indexOf(String.fromCharCode(5)) !== -1)
	                value = value.split(String.fromCharCode(5));

	            // Empty value represents the value is not set, hence return empty array
	            return util.isArray(value) ? value : (!utilityFunctions.isValEmpty(value)) ? [value] : [];
	        }
	    }
	    function formatArrayToStringType(value)
	    {
	        if(util.isArray(value))
	            return value.join(String.fromCharCode(5));
	        else
	            return String(value);
	    }

	    function validateAgainstSqlInjection(fieldId, value)
	    {
		    sqlInjectionFilter.validateSqlInjection(fieldId, value);
	    }

	    /**
	     * utility function to apply function to each property of the object, the function takes 2 argument one is the key and second one is the value
	     * @param obj
	     * @param {Function} function to process each property of the object, first argument will be property key and second argument will be the entry
	     */
	    function forEachProperty(obj, f)
	    {
	        for(var pKey in obj)
	        {
	            if(obj.hasOwnProperty(pKey))
	            {
	                f(pKey, obj[pKey]);
	            }
	        }
	    }

	    function executeRecordGetterFunctionsForInstance(sublistId, fieldId, lineInstanceId, useBuffer, bodyFieldFunction, sublistFieldFunction)
	    {
	        var toRet = null;
	        if (!!sublistId)
	        {
	            toRet = sublistFieldFunction(sublistId, fieldId, lineInstanceId, useBuffer);
	        }
	        else
	        {
	            toRet = bodyFieldFunction(fieldId);
	        }
	        return toRet;
	    }

	    function executeRecordGetterFunctions(sublistId, fieldId, line, bodyFieldFunction, sublistFieldFunction, currentSublistFieldFunctions)
	    {
	        var toRet = null;
	        if (sublistId)
	        {
	            if (line >= 0)
	                toRet = sublistFieldFunction(sublistId, fieldId, line);
	            else
	                toRet = currentSublistFieldFunctions(sublistId, fieldId);
	        }
	        else
	        {
	            toRet = bodyFieldFunction(fieldId);
	        }
	        return toRet;
	    }

	    function matchRecordFieldValueSchema(obj)
	    {
	        return util.isObject(obj) && obj.hasOwnProperty('value') && obj.hasOwnProperty('legacyStringValue');
	    }

	    function transformRawValueToFieldValueSchema(obj, cacher)
	    {
	    	if (typeof(obj) === 'string') {
	    		obj = obj.replace(/&gt;/g, ">").replace(/&lt;/g, "<").replace(/&amp;/g, "&").replace(/<br>/g, '\n');
		    }
	        var fieldValue = {}
	        if(/* select schema */ util.isObject(obj) && obj.hasOwnProperty('id') && obj.hasOwnProperty('text'))
	        {
	            fieldValue = {value: undefined, legacyStringValue: obj.id };
	            cacher(obj.id, obj.text);
	        }
	        else
	            fieldValue = {value: undefined, legacyStringValue: obj};
	        return fieldValue;
	    }

	    function validateRecordFieldValueSchema(val)
	    {
	        if (!matchRecordFieldValueSchema(val) && val !== null && val !== undefined)
	        {
	            utilityFunctions.throwSuiteScriptError(error.Type.FAILED_AN_UNEXPECTED_ERROR_OCCURRED);
	        }
	    }

	    function clone(receiver, contributor)
	    {
	        for (var key in contributor)
	            if (contributor.hasOwnProperty(key))
	            {
	                var value = contributor[key];
	                if(util.isDate(contributor[key]))
	                {
	                    value = new Date(value);
	                }
	                else if(util.isArray(value))
	                {
	                    value = value.map(function(v){
	                        return v;
	                    })
	                }

	                receiver[key] = value;
	            }
	        return receiver;
	    }

	    function getZeroBasedIndex(index)
	    {
	        if (isNaN(index))
	            return index;
	        else
	            index = parseInt(index, 10);

	        return index > 0 ? index - 1 : index;
	    }

	    function getOneBasedIndex(index)
	    {
	        if (isNaN(index))
	            return index;
	        else
	            index = parseInt(index, 10);

	        return index >= 0 ? index + 1 : index;
	    }

	    function validateAndGetOneBasedIndex(index, method, indexUpperLimit)
	    {
	        if (isNaN(index))
	            return index;
	        else
	            index = parseInt(index, 10);

	        if (index < 0 || (indexUpperLimit !== undefined && index >= indexUpperLimit))
	        {
	            throw error.create({name: error.Type.INVALID_SUBLIST_OPERATION, message: method});
	        }
	        else
	        {
	            return index + 1;
	        }
	    }

	    function getClientSlavingResultFromMetadata(clientSlavingMetadata, masterValue, getClientSlavingMetadata)
	    {
	        //TODO refactor into client slaving metadata
	        var slaveResults = {fields: []};

	        for(var slaveFieldId in clientSlavingMetadata)
	        {
	            var clientSlavingResult = clientSlavingMetadata[slaveFieldId];
	            var result = { isClientSlaving: true };
	            result.name = clientSlavingResult.name;
	            if(clientSlavingResult.machine)
	                result.machine = clientSlavingResult.machine;
	            if(clientSlavingResult.firechange || getClientSlavingMetadata(result.machine, result.name) !== null)
	                result.firechange = true;
	            if(clientSlavingResult.condition)
	                result.condition = clientSlavingResult.condition;
	            if(clientSlavingResult.nooverride)
	                result.nooverride = clientSlavingResult.nooverride;

	            if(clientSlavingResult.values)
	                result.value = clientSlavingResult.values["_"+masterValue] || "";

	            if(clientSlavingResult.options && util.isArray(clientSlavingResult.options))
	            {
	                result.options = [];
	                var selectOptions = clientSlavingResult.options;

	                for(var i = 0; i < selectOptions.length; i++)
	                {
	                    if(!!selectOptions[i].isSelected)
	                        result.value = selectOptions[i].value;
	                    result.options.push([selectOptions[i].value, selectOptions[i].text]);
	                }
	            }

	            slaveResults.fields.push(result);
	        }

	        return slaveResults;
	    }

	    return {
	        FIELD_TYPE: FIELD_TYPE,
	        clone: clone,
	        no_op_function: function(){},
	        isSelectType: isSelectType,
	        isEditMachine: isEditMachine,
	        executeRecordGetterFunctions: executeRecordGetterFunctions,
	        executeRecordGetterFunctionsForInstance: executeRecordGetterFunctionsForInstance,
	        forEachProperty: forEachProperty,
	        handleOverloadingMethodsForSingleArgument: handleOverloadingMethodsForSingleArgument,
	        emptyIfNullOrUndefined: emptyIfNullOrUndefined,
	        assertValidSublistOperation: assertValidSublistOperation,
	        formatValueToArrayType: formatValueToArrayType,
	        formatArrayToStringType: formatArrayToStringType,
	        validateAgainstSqlInjection: validateAgainstSqlInjection,
	        validateRecordFieldValueSchema: validateRecordFieldValueSchema,
	        matchRecordFieldValueSchema: matchRecordFieldValueSchema,
	        getZeroBasedIndex: getZeroBasedIndex,
	        getOneBasedIndex: getOneBasedIndex,
	        validateAndGetOneBasedIndex: validateAndGetOneBasedIndex,
	        getClientSlavingResultFromMetadata: getClientSlavingResultFromMetadata,
	        transformRawValueToFieldValueSchema: transformRawValueToFieldValueSchema
	    };
	});

/**
 * SuiteScript field level metadata event module
 *
 * @private
 * @module N/record/fieldLevelMetadataEvent
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/fieldLevelMetadataEvent',[], function()
{
	var EVENT_TYPE = Object.freeze({
			LABEL_CHANGE: 'LABEL_CHANGE'
		});

	function getEvent(type, fieldLevelMetadata)
	{
		return {
			type: type,
			fieldLevelMetadata: fieldLevelMetadata
		};
	}

	function addFieldValues(event, oldValue, newValue)
	{
		event.oldValue = oldValue;
		if(newValue !== undefined)
		{
			event.newValue = newValue;
		}

		return event;
	}

	function emit(emitter, fieldLevelMetadata, type, oldValue, newValue)
	{
		emitter.emit(addFieldValues(getEvent(type, fieldLevelMetadata), oldValue, newValue));
	}

	return Object.freeze({
		Type: EVENT_TYPE,
		emit: emit
	});
});

/**
 * SuiteScript record event enum module
 *
 * @private
 * @module N/eventEmitter
 * @suiteScriptVersion 2.x
 *
 */
define('N/eventEmitter',['N/utilityFunctions','N/error'],
	function (utilityFunctions, error)
	{

		function assertArray(types)
		{
			var isArray = Array.isArray(types);

			if(!isArray)
			{
				utilityFunctions.throwSuiteScriptError('error.Type.INVALID_ARRAY');
			}
		}

		function assertEventType(validEventTypes, checkEventTypes)
		{
			var invalidEventTypeFound = !!validEventTypes && checkEventTypes.some(function(v){
				return validEventTypes.indexOf(v) === -1;
			});

			if(invalidEventTypeFound)
			{
				utilityFunctions.throwSuiteScriptError('error.Type.INVALID_EVENT_TYPE');
			}
		}

		function assertListener(listener)
		{
			if(typeof listener !== 'function')
			{
				utilityFunctions.throwSuiteScriptError('error.Type.INVALID_EVENT_LISTENER');
			}
		}

		function assertAsyncAvailable()
		{
			if(typeof setTimeout !== 'function')
			{
				utilityFunctions.throwSuiteScriptError('error.Type.ASYNC_EVENTS_UNAVAILABLE');
			}
		}

		function asyncTransform(listener)
		{
			return function(event)
			{
				setTimeout(listener.bind(null, event), 0);
			};
		}

		function insulatedTransform(listener)
		{
			return function(event){
				try
				{
					listener(event);
				}
				catch(e)
				{
					if(!!console && !!console.error)
					{
						console.error(e);
					}
				}
			};
		}

		function assertFunction(func)
		{
			if(typeof func !== 'function')
			{
				utilityFunctions.throwSuiteScriptError('error.Type.NOT_A_FUNCTION');
			}
		}

		function createListenerCollection()
		{
			var eventsListeners = {};

			function getEventListeners(eventType)
			{
				var result = eventsListeners[eventType];

				if(!result)
				{
					result = [];
					eventsListeners[eventType] = result;
				}

				return result;
			}

			function add(type, listener)
			{
				var listeners = getEventListeners(type);
				listeners.push(listener);
			}

			function get(type)
			{
				return getEventListeners(type).slice(0);
			}

			function remove(type, listener)
			{
				var listeners = getEventListeners(type);
				var index = 0;
				var count = listeners.length;

				if(!!listener)
				{
					index = listeners.indexOf(listener);
					count = 1;
				}

				if (index != -1) {
					listeners.splice(index, count);
				}
			}

			return Object.freeze({
				add: add,
				get: get,
				remove: remove
			});
		}

		function createEmitter(options)
		{
			var async = !!options && !!options.async;
			var isBlocking = async;
			var insulated = !!options && !!options.insulated;
			var eventTypes = !!options && options.eventTypes || null;
			var preProcessor = !!options && options.preProcessor || null;
			var heldEvents = [];
			var heldEventsEmittingFunction = null;
			var eventsListeners = createListenerCollection();

			if(async)
			{
				assertAsyncAvailable();
			}

			function on(options){
				var types = !!options && options.types || null;
				var listener = !!options && options.listener || null;

				utilityFunctions.checkArgs([types, listener], ['types', 'listener'], 'emitter.on');
				assertArray(types);
				assertEventType(eventTypes, types);
				assertListener(listener);

				types.forEach(function(type){
					eventsListeners.add(type, listener);
				});
			}

			function off(options)
			{
				var types = !!options && options.types || null;
				var listener = !!options && options.listener || null;

				utilityFunctions.checkArgs([types], ['types'], 'emitter.off');
				assertArray(types);
				assertEventType(eventTypes, types);

				types.forEach(function(type){
					eventsListeners.remove(type, listener);
				});
			}

			function emitHeldEvents(){
				function emitHeldEventsInternal(){
					if(!!preProcessor)
					{
						heldEvents = preProcessor(heldEvents);
					}

					var errorEvents = [];
					heldEvents.forEach(function (event) {
						if (event.type === "ERROR" && errorEvents.indexOf(event.error) != -1)
							return;
						if (!!event.error)
							errorEvents.push(event.error);
						if (!event.suppressEmit)
							internalEmit(event);
					});
					heldEvents = [];
					heldEventsEmittingFunction = null;
				}

				if (!heldEventsEmittingFunction)
				{
					heldEventsEmittingFunction = emitHeldEventsInternal;
					setTimeout(heldEventsEmittingFunction, 0);
				}
			}

			function internalEmit(event)
			{
				var type = !!event && event.type || null;
				
				eventsListeners.get(type).forEach(function (listener){
					var func = listener;

					func = insulated ? insulatedTransform(func) : func;
					func = async ? asyncTransform(func) : func;

					func(event);
				});
			}

			function emit(event)
			{
				var type = !!event && event.type || null;

				utilityFunctions.checkArgs([event, type], ['event', 'type'], 'emitter.emit');
				assertEventType(eventTypes, [type]);

				if(isBlocking)
				{
					heldEvents.push(event);
					emitHeldEvents();
				}
				else
				{
					if(!!preProcessor)
					{
						event = preProcessor([event])[0];
					}

					internalEmit(event);
				}
			}

			return Object.freeze({
				on: on,
				off: off,
				emit: emit
			});
		}

		return Object.freeze({
			create: createEmitter
		});
	});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/fieldLevelMetadata
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/fieldLevelMetadata',['N/record/recordUtilityFunctions', 'N/utilityFunctions', 'N/record/fieldLevelMetadataEvent', 'N/eventEmitter'],
       function(recordUtil, utilityFunctions, fieldLevelMetadataEvent, eventEmitter){

           /**
            * object hold the field metadata of record
            *
            * @param {{name: string,
               label: string,
               type: string,
               isMachineHeaderField: boolean,
               acceptEmptyValueForSelectField: boolean,
               isPopup: boolean,
               maxLength: number,
               isNumeric: boolean,
               isCurrency: boolean,
               hasBlankString: boolean,
               blankString: string,
               minValue: number,
               maxValue: number,
               validationTypeField: string,
               fieldState: *,
               fieldScript: object,
               radioSet: *,
               slavingMetadata: *,
               clientSlavingMetadata: *,
               optionMastersAndAuxFields: *,
               hasStaticOptions: boolean,
               supplementedOptions: array}} metadata
            * @returns {FieldLevelMetadata}
            * @constructor
            */
           function FieldLevelMetadata(metadata)
           {
               var that = this;
               var label = metadata.label;
               var defaultFieldStates = metadata.hasOwnProperty('fieldState') ? metadata.fieldState : {};
               var emitter = eventEmitter.create();

               Object.defineProperty(this, 'label', {
                   get: function ()
                   {
                       return label;
                   },
                   set: function (val)
                   {
                       var oldValue = label;
                       label = val;
                       var newValue = label;
                       fieldLevelMetadataEvent.emit(emitter, that, fieldLevelMetadataEvent.Type.LABEL_CHANGE, oldValue, newValue);
                   },
                   enumerable: true,
                   configurable: false
               });

               function getName() { return metadata.name; }
               utilityFunctions.addReadOnlyProperty(that, 'name', getName);

               function getType() { return metadata.type; }
	           utilityFunctions.addReadOnlyProperty(that, 'type', getType);

	           function isFieldMultiSelect() { return metadata.type === recordUtil.FIELD_TYPE.MULTISELECT; }
	           /**
	            * Return true if the field is a multi-select field type
	            * @name FieldLevelMetadata#isTypeMultiSelect
	            * @type boolean
	            * @readonly
	            * @throws READ_ONLY when setting the property is attempted
	            */
	           utilityFunctions.addReadOnlyProperty(that, 'isTypeMultiSelect', isFieldMultiSelect);

	           function isFieldSelectType(){ return recordUtil.isSelectType(metadata.type); }
	           /**
	            * Return true if the field is a select type
	            * @name FieldLevelMetadata#isTypeSelect
	            * @type boolean
	            * @readonly
	            * @throws READ_ONLY when setting the property is attempted
	            */
	           utilityFunctions.addReadOnlyProperty(that, 'isTypeSelect', isFieldSelectType);


	           function isFieldRadioType(){ return metadata.type === recordUtil.FIELD_TYPE.RADIO; }
	           /**
	            * Return true if the field is a radio type
	            * @name FieldLevelMetadata#isTypeRadio
	            * @type boolean
	            * @readonly
	            * @throws READ_ONLY when setting the property is attempted
	            */
	           utilityFunctions.addReadOnlyProperty(that, 'isTypeRadio', isFieldRadioType);

	           function getRadioSet() { return metadata.radioSet || null; }
	           utilityFunctions.addReadOnlyProperty(that, 'radioSet', getRadioSet);

               function isPopup() { return metadata.isPopup || false; }
	           utilityFunctions.addReadOnlyProperty(that, 'isPopup', isPopup);

               function hasStaticOptions() { return metadata.hasStaticOptions || false; }
	           utilityFunctions.addReadOnlyProperty(that, 'hasStaticOptions', hasStaticOptions);

	           function getSupplementedOptions() { return metadata.supplementedOptions || null; }
	           utilityFunctions.addReadOnlyProperty(that, 'supplementedOptions', getSupplementedOptions);

               function isMachineHeaderField() { return metadata.isMachineHeaderField || false; }
	           utilityFunctions.addReadOnlyProperty(that, 'isMachineHeaderField', isMachineHeaderField);


               function acceptEmptyValueForSelectField() {return (metadata.acceptEmptyValueForSelectField) ? metadata.acceptEmptyValueForSelectField : true; };
	           utilityFunctions.addReadOnlyProperty(that, 'acceptEmptyValueForSelectField', acceptEmptyValueForSelectField);


               function getMaxLength() { return metadata.maxLength; }
	           utilityFunctions.addReadOnlyProperty(that, 'maxLength', getMaxLength);

               function isNumeric() { return metadata.isNumeric; }
	           utilityFunctions.addReadOnlyProperty(that, 'isNumeric', isNumeric);

               function isCurrency() { return metadata.isCurrency; }
	           utilityFunctions.addReadOnlyProperty(that, 'isCurrency', isCurrency);

               function hasBlankString() { return metadata.hasBlankString; }
	           utilityFunctions.addReadOnlyProperty(that, 'hasBlankString', hasBlankString);

               function getBlankString() {
                   return metadata.blankString
               }
	           utilityFunctions.addReadOnlyProperty(that, 'blankString', getBlankString);


               function hasMinValue() { return metadata.hasOwnProperty("minValue"); }
	           utilityFunctions.addReadOnlyProperty(that, 'hasMinValue', hasMinValue);

               function getMinValue() { return metadata.minValue; }
	           utilityFunctions.addReadOnlyProperty(that, 'minValue', getMinValue);

               function hasMaxValue() { return metadata.hasOwnProperty("maxValue"); }
	           utilityFunctions.addReadOnlyProperty(that, 'hasMaxValue', hasMaxValue);

               function getMaxValue() { return metadata.maxValue; }
	           utilityFunctions.addReadOnlyProperty(that, 'maxValue', getMaxValue);


               function getValidationFieldType() { return metadata.validationTypeField; }
	           /**
	            * field type for validation logic
	            * @name FieldLevelMetadata#fieldTypeForValidation
	            * @type string
	            * @readonly
	            * @throws READ_ONLY when setting the property is attempted
	            */
	           utilityFunctions.addReadOnlyProperty(that, 'fieldTypeForValidation', getValidationFieldType);

               function getDefaultFieldState() { return util.extend({}, defaultFieldStates); }
	           utilityFunctions.addReadOnlyProperty(that, 'defaultFieldState', getDefaultFieldState);

               function getSlavingMetadata() { return metadata.hasOwnProperty('slavingMetadata') ? metadata.slavingMetadata : null; }

	           utilityFunctions.addReadOnlyProperty(that, 'slavingMetadata', getSlavingMetadata);

               function getClientSlavingMetadata() { return metadata.clientSlavingMetadata; }
	           utilityFunctions.addReadOnlyProperty(that, 'clientSlavingMetadata', getClientSlavingMetadata);

               function getFieldScripts(){ return metadata.fieldScript; }
	           utilityFunctions.addReadOnlyProperty(that, 'fieldScripts', getFieldScripts);

               function getFieldScript(scriptType)
               {
                   if(metadata.hasOwnProperty('fieldScript') && metadata['fieldScript'].hasOwnProperty(scriptType))
                       return metadata['fieldScript'][scriptType];
                   else
                       return null;
               }
               this.getFieldScript = getFieldScript;

               function getOptionMastersAndAuxFields() { return metadata.optionMastersAndAuxFields; /* array */ }
	           utilityFunctions.addReadOnlyProperty(that, 'optionMastersAndAuxFields', getOptionMastersAndAuxFields);

               function getSubrecordType()
               {
                   return (metadata.type === 'summary' && metadata.hasOwnProperty('subrecordType')) ? metadata.subrecordType : null;
               }
	           utilityFunctions.addReadOnlyProperty(that, 'subrecordType', getSubrecordType);


               function getSubrecordIdField()
               {
                   return (metadata.type === 'summary' && metadata.hasOwnProperty('subrecordIdField')) ? metadata.subrecordIdField : null;
               }
	           utilityFunctions.addReadOnlyProperty(that, 'subrecordIdField', getSubrecordIdField);


               function getSubrecordCompatibilityMap()
               {
                   return (metadata.type === 'summary' && metadata.hasOwnProperty('subrecordCompatibilityMap')) ? metadata.subrecordCompatibilityMap : null;
               }
	           utilityFunctions.addReadOnlyProperty(that, 'subrecordCompatibilityMap', getSubrecordCompatibilityMap);


               function getSubrecordInitialParameters()
               {
                   return (metadata.type === 'summary' && metadata.hasOwnProperty('subrecordInitialParameters')) ? metadata.subrecordInitialParameters: null;
               }
	           utilityFunctions.addReadOnlyProperty(that, 'subrecordInitialParameters', getSubrecordInitialParameters);

               this.on = emitter.on;
               this.off = emitter.off;

               function toJSON()
               {
                   var copy = util.extend({}, metadata);
                   return copy;
               }

               return this;
           }
           Object.freeze(FieldLevelMetadata);


           return {
               /**
                * return a new instance of field level metadata object
                * @param {Object} options
                * @returns {FieldLevelMetadata}
                */
               create: function create(options) {
                   return new FieldLevelMetadata(options);
               }
           };
       });

/**
 * SuiteScript sublist metadata event module
 *
 * @private
 * @module N/record/sublistLevelMetadataEvent
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/sublistLevelMetadataEvent',['N/record/fieldLevelMetadataEvent'], function(fieldLevelMetadataEvent)
{
	var EVENT_TYPE = Object.freeze({
		FIELD_METADATA_LABEL_CHANGE: 'FIELD_METADATA_LABEL_CHANGE'
	});

	var translateFieldLevelMetadataEventTypeToSublistLevelMetadataEventType = (function(){
		var eventTranslations = {};

		eventTranslations[fieldLevelMetadataEvent.Type.LABEL_CHANGE] = EVENT_TYPE.FIELD_METADATA_LABEL_CHANGE;

		return function(fieldStateEventType){
			return eventTranslations[fieldStateEventType];
		}
	}());

	function translateFieldLevelMetadataEventToSublistLevelMetadataEvent(sublistLevelMetadata, fieldLevelMetadataEvent)
	{
		return addFieldLevelMetadataEventDetails(getEvent(sublistLevelMetadata, translateFieldLevelMetadataEventTypeToSublistLevelMetadataEventType(fieldLevelMetadataEvent.type)), fieldLevelMetadataEvent);
	}

	function addFieldLevelMetadataEventDetails(event, fieldLevelMetadataEvent)
	{
		event.fieldId = fieldLevelMetadataEvent.fieldLevelMetadata.name;
		if(fieldLevelMetadataEvent.oldValue !== undefined){ event.oldValue = fieldLevelMetadataEvent.oldValue; }
		if(fieldLevelMetadataEvent.newValue !== undefined){ event.newValue = fieldLevelMetadataEvent.newValue; }

		return event;
	}

	function getEvent(sublistLevelMetadata, type)
	{
		return {
			type: type,
			sublistLevelMetadata: sublistLevelMetadata
		};
	}

	function emit(emitter, sublistState, type)
	{
		emitter.emit(getEvent(sublistState, type));
	}

	function forwardFieldLevelMetadataEvent(emitter, sublistLevelMetadata, fieldLevelMetadataEvent)
	{
		emitter.emit(translateFieldLevelMetadataEventToSublistLevelMetadataEvent(sublistLevelMetadata, fieldLevelMetadataEvent));
	}

	function forwardFieldLevelMetadataEvents(emitter, sublistLevelMetadata, fieldLevelMetadata)
	{
		var forward = forwardFieldLevelMetadataEvent.bind(null, emitter, sublistLevelMetadata);

		fieldLevelMetadata.on({
			types: [
				fieldLevelMetadataEvent.Type.LABEL_CHANGE
			],
			listener: forward
		});
	}

	return Object.freeze({
		Type: EVENT_TYPE,
		emit: emit,
		forwardFieldLevelMetadataEvents: forwardFieldLevelMetadataEvents
	});
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/sublistLevelMetadata
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/sublistLevelMetadata',['N/utilityFunctions', 'N/record/sublistLevelMetadataEvent', 'N/eventEmitter'],
       function(utilityFunctions, sublistLevelMetadataEvent, eventEmitter){

           /**
            * object hold the sublist metadata of record
            *
            * @param {Object} options
            * @param {{name: string,
               type: string,
               nlobjSublistType: string,
               sortedFields: *,
               backwardCompatibleFields: *,
               sublistScript: string,
               defaultValues: *,
               displayOnly: boolean,
               isTotallingSublist: boolean,
               isScriptableMachine: boolean}} options.sublistMetadataObj
            * @param {Object} options.fieldMetadatas fieldLevelMetadata collection
            * @returns {SublistLevelMetadata}
            * @constructor
            */
           function SublistLevelMetadata(options)
           {
               var that = this;
               var sublistMetadataObj = options.sublistMetadataObj;
               var fieldMetadata = options.fieldMetadatas;

               var name = sublistMetadataObj.name;
               var type = sublistMetadataObj.type; /* machine type: edit|list|search|subtab */
               var nlobjSublistType = sublistMetadataObj.nlobjSublistType; /* sublist type: inlineeditor|editor|staticlist|list */
               var isScriptableMachine = sublistMetadataObj.isScriptableMachine;
               var isSublistEditable = sublistMetadataObj.isEditable;
               var sortedFields = sublistMetadataObj.sortedFields || [];
               var backwardCompatibleFields = sublistMetadataObj.backwardCompatibleFields;
               var scripts = sublistMetadataObj.sublistScript || {};
               var defaultValues = sublistMetadataObj.defaultValues || {};
               var isSublistDisplayOnly = sublistMetadataObj.displayOnly || false;

               var emitter = eventEmitter.create();
               Object.keys(fieldMetadata).forEach(function(fieldId){
                   var metadata = fieldMetadata[fieldId];
                   sublistLevelMetadataEvent.forwardFieldLevelMetadataEvents(emitter, that, metadata);
               });

               function getName() { return name }
	           utilityFunctions.addReadOnlyProperty(this, 'name', getName);

               function getType() { return type }
	           utilityFunctions.addReadOnlyProperty(this, 'type', getType);

               function getSortedFields() { return sortedFields; }
	           utilityFunctions.addReadOnlyProperty(this, 'sortedFields', getSortedFields);

               function getBackwardCompatibilityFieldNamesForSubrecord() { return backwardCompatibleFields; }
	           utilityFunctions.addReadOnlyProperty(this, 'backwardCompatibilityFieldNamesForSubrecord', getBackwardCompatibilityFieldNamesForSubrecord);

               function getNlobjSublistConstructorType() { return nlobjSublistType; }
	           utilityFunctions.addReadOnlyProperty(this, 'nlobjSublistConstructorType', getNlobjSublistConstructorType);

               function getIsScriptableMachine(){
                   return isScriptableMachine;
               }
	           utilityFunctions.addReadOnlyProperty(this, 'isScriptableMachine', getIsScriptableMachine);

               function getIsSublistEditable(){
                   return isSublistEditable;
               }
	           utilityFunctions.addReadOnlyProperty(this, 'isEditable', getIsSublistEditable);

               function getSublistScripts(scriptingTrigger)
               {
                   /*
                    * list of scriptingTrigger:
                    * validatelines
                    * validateinsert
                    * validatedelete
                    * lineinit
                    * linecommit
                    * postdeleteline
                    * recalc
                    */
                   var result = null;

                   if(scriptingTrigger === undefined)
                   {
                       result = scripts;
                   }
                   else if(scripts.hasOwnProperty(scriptingTrigger))
                   {
                       result = scripts[scriptingTrigger];
                   }

                   return result;
               }
               this.getSublistScripts = getSublistScripts;

               function getSublistDefaultValue()
               {
                   return util.extend({}, defaultValues);
               }
	           utilityFunctions.addReadOnlyProperty(this, 'defaultValue', getSublistDefaultValue);

               function getDefaultSublistState()
               {
                   return util.extend({}, sublistMetadataObj.sublistState);
               }
	           utilityFunctions.addReadOnlyProperty(this, 'defaultState', getDefaultSublistState);

               function getFieldMetadatas()
               {
                   return fieldMetadata
               }
	           utilityFunctions.addReadOnlyProperty(this, 'fieldMetadata', getFieldMetadatas);


               function getFieldMetadata(fieldId)
               {
                   return fieldMetadata.hasOwnProperty(fieldId) ? fieldMetadata[fieldId] : null;
               }
               this.getFieldMetadata = getFieldMetadata;

               function isTotallingSublist()
               {
                   return sublistMetadataObj.isTotallingSublist;
               }
	           utilityFunctions.addReadOnlyProperty(this, 'isTotallingSublist', isTotallingSublist);

               function isDisplayOnly()
               {
                   return isSublistDisplayOnly;
               }
	           utilityFunctions.addReadOnlyProperty(this, 'displayOnly', isDisplayOnly);

               this.on = emitter.on;
               this.off = emitter.off;

               return this;
           }
           Object.freeze(SublistLevelMetadata);

           return {
               /**
                * return a new instance of sublist level metadata object
                * @param {Object} options
                * @returns {SublistLevelMetadata}
                */
               create: function create(options) {
                   return new SublistLevelMetadata(options);
               }
           };
       });

/**
 * SuiteScript metadata event module
 *
 * @private
 * @module N/record/metadataEvent
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/metadataEvent',['N/record/fieldLevelMetadataEvent', 'N/record/sublistLevelMetadataEvent'], function(fieldLevelMetadataEvent, sublistLevelMetadataEvent)
{
	var EVENT_TYPE = Object.freeze({
		FIELD_METADATA_LABEL_CHANGE: 'FIELD_METADATA_LABEL_CHANGE'
	});

	function getEvent(metadata, type)
	{
		return {
			type: type,
			metadata: metadata
		};
	}

	var translateFieldLevelMetadataEventTypeToMetadataEventType = (function(){
		var eventTranslations = {};

		eventTranslations[fieldLevelMetadataEvent.Type.LABEL_CHANGE] = EVENT_TYPE.FIELD_METADATA_LABEL_CHANGE;

		return function(fieldStateEventType){
			return eventTranslations[fieldStateEventType];
		}
	}());

	function translateFieldLevelMetadataEventToMetadataEvent(metadata, fieldLevelMetadataEvent)
	{
		return addFieldLevelMetadataEventDetails(getEvent(metadata, translateFieldLevelMetadataEventTypeToMetadataEventType(fieldLevelMetadataEvent.type)), fieldLevelMetadataEvent);
	}

	function addFieldLevelMetadataEventDetails(event, fieldLevelMetadataEvent)
	{
		event.fieldId = fieldLevelMetadataEvent.fieldLevelMetadata.name;

		return event;
	}

	function forwardFieldLevelMetadataEvent(emitter, metadata, fieldLevelMetadataEvent)
	{
		emitter.emit(translateFieldLevelMetadataEventToMetadataEvent(metadata, fieldLevelMetadataEvent));
	}

	function forwardFieldLevelMetadataEvents(emitter, metadata, fieldLevelMetadata)
	{
		var forward = forwardFieldLevelMetadataEvent.bind(null, emitter, metadata);

		fieldLevelMetadata.on({
			types: [
				fieldLevelMetadataEvent.Type.LABEL_CHANGE
			],
			listener: forward
		});
	}

	var translateSublistLevelMetadataEventTypeToMetadataEventType = (function(){
		var eventTranslations = {};

		eventTranslations[sublistLevelMetadataEvent.Type.FIELD_METADATA_LABEL_CHANGE] = EVENT_TYPE.FIELD_METADATA_LABEL_CHANGE;

		return function(sublistLevelMetadataEventType){
			return eventTranslations[sublistLevelMetadataEventType];
		}
	}());

	function translateSublistLevelMetadataEventToMetadataEvent(metadata, sublistLevelMetadataEvent)
	{
		return addSublistLevelMetadataEventDetails(getEvent(metadata, translateSublistLevelMetadataEventTypeToMetadataEventType(sublistLevelMetadataEvent.type)), sublistLevelMetadataEvent);
	}

	function addSublistLevelMetadataEventDetails(event, sublistLevelMetadataEvent)
	{
		event.sublistId = sublistLevelMetadataEvent.sublistLevelMetadata.name;
		event.fieldId = sublistLevelMetadataEvent.fieldId;
		if(sublistLevelMetadataEvent.oldValue !== undefined){ event.oldValue = sublistLevelMetadataEvent.oldValue; }
		if(sublistLevelMetadataEvent.newValue !== undefined){ event.newValue = sublistLevelMetadataEvent.newValue; }

		return event;
	}

	function forwardSublistLevelMetadataEvent(emitter, metadata, sublistLevelMetadataEvent)
	{
		emitter.emit(translateSublistLevelMetadataEventToMetadataEvent(metadata, sublistLevelMetadataEvent));
	}

	function forwardSublistLevelMetadataEvents(emitter, metadata, sublistLevelMetadata)
	{
		var forward = forwardSublistLevelMetadataEvent.bind(null, emitter, metadata);

		sublistLevelMetadata.on({
			types: [
				sublistLevelMetadataEvent.Type.FIELD_METADATA_LABEL_CHANGE
			],
			listener: forward
		});
	}

	function emit(emitter, metadata, type)
	{
		emitter.emit(getEvent(metadata, type));
	}

	return Object.freeze({
		Type: EVENT_TYPE,
		emit: emit,
		forwardFieldLevelMetadataEvents: forwardFieldLevelMetadataEvents,
		forwardSublistLevelMetadataEvents: forwardSublistLevelMetadataEvents
	});
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/metadata
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/metadata',['N/utilityFunctions', 'N/record/recordUtilityFunctions', 'N/record/fieldLevelMetadata','N/record/sublistLevelMetadata', 'N/record/metadataEvent', 'N/eventEmitter'],
       function(utilityFunctions, recordUtil, fieldLevelMetadata, sublistLevelMetadata, metadataEvent, eventEmitter){


           function Metadata(metadataObj)
           {
               var that = this;
               var type, queryUrl, sortedFields, sortedSublists, libraryScript, staticScript, uiFormScript;
               var fieldIds, sublistIds, sublistFieldIds, fieldMetadata, sublistMetadata;

               var emitter = eventEmitter.create();

               (function constructor(metadataObj){
                   type = metadataObj.type;
                   queryUrl = metadataObj.queryUrl;
                   sortedFields = metadataObj.sortedFields;
                   sortedSublists = metadataObj.sortedSublist;
                   /* Record Scripting Variables */
                   libraryScript = metadataObj.libraryScript;
                   staticScript = metadataObj.staticScript;
                   uiFormScript = metadataObj.uiFormScript;

                   fieldIds = [];
                   sublistIds = [];
                   sublistFieldIds = {};
                   fieldMetadata = {};
                   sublistMetadata = {};
                   (function setFieldMetadata(fieldLevelMetadataObjs){
                       recordUtil.forEachProperty(fieldLevelMetadataObjs, function(fieldId, metadataJSON)
                       {
                           fieldIds[fieldIds.length] = fieldId;
                       });

                       utilityFunctions.freezeObjectIfPossible(fieldIds);
                   })(metadataObj.bodyField);

                   (function setSublistFieldMetadata(sublistLevelMetadataObjs){

                       recordUtil.forEachProperty(sublistLevelMetadataObjs, function(sublistId, sublistLevelMetadataObj){
                           sublistIds[sublistIds.length] = sublistId;

                           var fieldmetadataJSON = sublistLevelMetadataObj.fieldMetadata;
                           var fieldLevelMetadatas = {};
                           sublistFieldIds[sublistId] = [];

                           recordUtil.forEachProperty(fieldmetadataJSON, function(fieldId, metadataJSON)
                           {
                               sublistFieldIds[sublistId].push(fieldId);
                               fieldLevelMetadatas[fieldId] = fieldLevelMetadata.create(metadataJSON);
                           });

                           var metadata = sublistLevelMetadata.create({sublistMetadataObj: sublistLevelMetadataObj, fieldMetadatas: fieldLevelMetadatas});
                           metadataEvent.forwardSublistLevelMetadataEvents(emitter, that, metadata);
                           sublistMetadata[sublistId] = metadata;
                       });

                       utilityFunctions.freezeObjectIfPossible(sublistIds);
                   }) (metadataObj.sublist);


               })(metadataObj);

               function getType() { return type; }
	           utilityFunctions.addReadOnlyProperty(this, 'type', getType);

               function getQueryUrl() { return queryUrl; }
	           utilityFunctions.addReadOnlyProperty(this, 'queryUrl', getQueryUrl);

               function getLibraryScript() { return libraryScript; }
	           utilityFunctions.addReadOnlyProperty(this, 'libraryScript', getLibraryScript);

               function getStaticScript() { return staticScript; }
	           utilityFunctions.addReadOnlyProperty(this, 'staticScript', getStaticScript);

               function getUIFormScript() { return uiFormScript; }
	           utilityFunctions.addReadOnlyProperty(this, 'uiFormScript', getUIFormScript);

               function getSortedFields() { return sortedFields; }
	           utilityFunctions.addReadOnlyProperty(this, 'sortedFields', getSortedFields);

               function getSortedSublists() { return sortedSublists; }
	           utilityFunctions.addReadOnlyProperty(this, 'sortedSublists', getSortedSublists);

               function getAllFieldNames() { return fieldIds; }
	           utilityFunctions.addReadOnlyProperty(this, 'fieldIds', getAllFieldNames);

               function isValidField(fieldId)
               {
                   return getAllFieldNames().indexOf(fieldId) > -1;
               }
               this.isValidField = isValidField;

               function getAllSubrecordFields()
               {
                   return getAllFieldNames().filter(function(v, i, a){
                       var fieldId = v;
                       return getFieldMetadata(null, fieldId) && getFieldMetadata(null, fieldId).type === recordUtil.FIELD_TYPE.SUBRECORD_FIELD_TYPE;
                   });
               }
	           utilityFunctions.addReadOnlyProperty(this, 'subrecordFieldIds', getAllSubrecordFields);

               function getSublistFieldMetadata(sublistId, fieldId)
               {
                   return sublistMetadata.hasOwnProperty(sublistId) ? sublistMetadata[sublistId].getFieldMetadata(fieldId) : null;
               }

               function getFieldMetadata(sublistId, fieldId)
               {
                   if(sublistId)
                       return getSublistFieldMetadata(sublistId, fieldId);

                   var metadata = null;
                   if(fieldMetadata.hasOwnProperty(fieldId))
                       metadata = fieldMetadata[fieldId];
                   else if(metadataObj.bodyField.hasOwnProperty(fieldId))
                   {
                       metadata = fieldLevelMetadata.create(metadataObj.bodyField[fieldId]);
                       metadataEvent.forwardSublistLevelMetadataEvents(emitter, that, metadata);
                       fieldMetadata[fieldId] = metadata;
                   }

                   return metadata;
               }

	           /**
	            *
	            * @param {string} sublistId
	            * @param {string} fieldId
	            * @returns {FieldLevelMetadata}
	            */
               this.getFieldMetadata = getFieldMetadata;

               function isValidSublist(sublistId)
               {
                   return sublistMetadata.hasOwnProperty(sublistId);
               }
               this.isValidSublist = isValidSublist;

               function getSublistMetadata(sublistId)
               {
                   return sublistMetadata.hasOwnProperty(sublistId) ? sublistMetadata[sublistId] : null;
               }
               this.getSublistMetadata = getSublistMetadata;

               function getSublistType(sublistId)
               {
                   var metadata = getSublistMetadata(sublistId);
                   return (metadata) ? metadata.type : null;
               }
               this.getSublistType = getSublistType;

               function getSublists() { return sublistIds; }
	           utilityFunctions.addReadOnlyProperty(this, 'sublistIds', getSublists);

               function isValidSublistField(sublistId, fieldId)
               {
                   var sublistfields = getAllSublistFields(sublistId);
                   return (sublistfields != null && sublistfields.indexOf(fieldId) > -1);
               }
               this.isValidSublistField = isValidSublistField;

               function getAllSublistFields(sublistId)
               {
                   return sublistFieldIds[sublistId] || [];
               }
               this.getAllSublistFields = getAllSublistFields;

               function getAllSublistSubrecordFields(sublistId)
               {
                   var sublistFields = sublistFieldIds[sublistId] || [];

                   sublistFields = sublistFields.filter(function(v, i, a){
                       var fieldId = v;

                       return getSublistFieldMetadata(sublistId, fieldId) &&
                              getSublistFieldMetadata(sublistId, fieldId).type === recordUtil.FIELD_TYPE.SUBRECORD_FIELD_TYPE;
                   });

                   return sublistFields;
               }
               this.getAllSublistSubrecordFields = getAllSublistSubrecordFields;

               function getSublistScripts(sublistName, scriptingTrigger)
               {
                   var metadata = getSublistMetadata(sublistName);
                   return (metadata) ? metadata.getSublistScripts(scriptingTrigger) : null;
               }
               this.getSublistScripts = getSublistScripts;

               function getSublistDefaultValue(sublistId)
               {
                   var metadata = getSublistMetadata(sublistId);
                   return (metadata) ? metadata.defaultValue : {};
               }
               this.getSublistDefaultValue = getSublistDefaultValue;

               function toJSON()
               {
                   return metadataObj;
               }

               function clone()
               {
                   return new Metadata(toJSON());
               }
               this.clone = clone;

               this.on = emitter.on;
               this.off = emitter.off;

               return this;
           }

           return {
               /**
                * return a new instance of Metadata
                * @param {Object} metadataObj
                * @returns {Metadata}
                */
               create: function(metadataObj) { return new Metadata(metadataObj); },
               /**
                * return true if object is an instance of Metadata
                * @param {Object} obj
                * @returns {boolean}
                */
               isInstance: function(obj) { return obj instanceof Metadata; }
           };
       });

/**
 * SuiteScript field state event module
 *
 * @private
 * @module N/record/fieldStateEvent
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/fieldStateEvent',[], function()
{
	var EVENT_TYPE = Object.freeze({
			PARENT_STATE_CHANGE: 'PARENT_STATE_CHANGE',
			USE_TEXT_API_CHANGE: 'USE_TEXT_API_CHANGE',
			IS_PARSED_CHANGE: 'IS_PARSED_CHANGE',
			IS_MANDATORY_CHANGE: 'IS_MANDATORY_CHANGE',
			IS_HIDDEN_CHANGE: 'IS_HIDDEN_CHANGE',
			IS_DISABLED_CHANGE: 'IS_DISABLED_CHANGE',
			IS_VISIBLE_CHANGE: 'IS_VISIBLE_CHANGE',
			IS_DISPLAY_CHANGE: 'IS_DISPLAY_CHANGE',
			IS_READ_ONLY_CHANGE: 'IS_READ_ONLY_CHANGE',
			IGNORE_SLAVING_CHANGE: 'IGNORE_SLAVING_CHANGE',
			IS_CHANGED_CHANGE: 'IS_CHANGED_CHANGE',
			LABEL_CHANGE: 'LABEL_CHANGE'
		});

	function getEvent(fieldState, type)
	{
		return {
			type: type,
			fieldState: fieldState
		};
	}

	function addValues(event, oldValue, newValue)
	{
		if(oldValue !== undefined){ event.oldValue = oldValue; }
		if(newValue !== undefined){ event.newValue = newValue; }

		return event;
	}

	function emit(emitter, fieldState, type, oldValue, newValue)
	{
		emitter.emit(addValues(getEvent(fieldState, type), oldValue, newValue));
	}

	return Object.freeze({
		Type: EVENT_TYPE,
		emit: emit
	});
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/fieldState
 * @suiteScriptVersion 2.x
 */
define('N/record/fieldState',['N/record/fieldStateEvent', 'N/eventEmitter'], function (fieldStateEvent, eventEmitter){
    /**
     * field state for record
     *
     * @param {Object} options
     * @param {RecordStateController} options.parentState parent state
     * @param {Object} options.fieldState field state object
     * @param {string} options.fieldState.name name
     * @param {string} options.fieldState.label label
     * @param {boolean} options.fieldState.isMandatory isMandatory
     * @param {boolean} options.fieldState.isDefaultMandatory isDefaultMandatory
     * @param {boolean} options.fieldState.isHidden isHidden
     * @param {boolean} options.fieldState.isDisabled isDisabled
     * @param {boolean} options.fieldState.isReadOnly isReadOnly
     * @param {boolean} options.fieldState.noSlaving noSlaving
     * @param {boolean} options.fieldState.isChanged isChanged
     * @param {boolean} options.fieldState.isVisible isVisible
     * @param {boolean} options.fieldState.isDisplay isDisplay
     * @param {boolean} options.fieldState.isParsed isParsed
     *
     * @return {FieldState}
     * @constructor
     * @private
     *
     */
    function FieldState(options)
    {
        var that = this;
        var parentState = options.parentState;
        var fs = options.fieldState;
        var id = fs.name || '';
        var label = fs.label || '';
        var shouldUseTextApi = false;
        var isParsed = fs && !!(fs.isParsed);

        var isFieldMandatory = fs.isMandatory || false;             // is this field mandatory (required)
        var defaultMandatory = fs.isDefaultMandatory || false;      // is this field mandatory by default (required)
        var isFieldHidden = fs.isHidden || false;                   // is this field hidden (i.e. not visible or editable to user in the UI)
        var isFieldDisabled = fs.isDisabled || false;               // is this field disabled (i.e. uneditable by user in UI).
        var isFieldReadOnly = fs.isReadOnly || false;               // is a fundamentally read-only field
        var ignoreSlaving = fs.noSlaving || false;                  // if true then slaving is disabled when during fieldChange execution
        var isFieldChanged = fs.isChanged || false;                 // if true then this field was set/changed by the user
        var isFieldVisible = fs.isVisible || true;                  // if true then this field should be made visible in the user interface
        var isFieldDisplay = fs.isDisplay || true;                  // if false then this field should be removed from the user interface

        var emitter = eventEmitter.create();

        /**
         * parentState
         * @name FieldState#parentState
         * @type {SublistState|RecordStateController}
         */
        Object.defineProperty(this, 'parentState', {
            get: function ()
            {
                return parentState;
            },
            set: function (state)
            {
                if(parentState !== state)
                {
                    parentState = state;
                    fieldStateEvent.emit(emitter, that, fieldStateEvent.Type.PARENT_STATE_CHANGE);
                }
            },
            enumerable: true,
            configurable: false
        });

        /**
         * useTextApi
         *
         * @name FieldState#useTextApi
         * @type boolean
         */
        Object.defineProperty(this, 'useTextApi', {
            get: function ()
            {
                return shouldUseTextApi;
            },
            set: function (val)
            {
                if (util.isBoolean(val) && (shouldUseTextApi !== val))
                {
                    var oldValue = shouldUseTextApi;
                    shouldUseTextApi = val;
                    var newValue = shouldUseTextApi;
                    fieldStateEvent.emit(emitter, that, fieldStateEvent.Type.USE_TEXT_API_CHANGE, oldValue, newValue);
                }
            },
            enumerable: true,
            configurable: false
        });
        /**
         * isParsed
         *
         * @name FieldState#isParsed
         * @type boolean
         */
        Object.defineProperty(this, 'isParsed', {
            get: function ()
            {
                return isParsed;
            },
            set: function (val)
            {
                if (util.isBoolean(val) && (isParsed !== val))
                {
                    var oldValue = isParsed;
                    isParsed = val;
                    var newValue = isParsed;
                    fieldStateEvent.emit(emitter, that, fieldStateEvent.Type.IS_PARSED_CHANGE, oldValue, newValue);
                }
            },
            enumerable: true,
            configurable: false
        });

        /**
         * isMandatory
         *
         * @name FieldState#isMandatory
         * @type boolean
         */
        Object.defineProperty(this, 'isMandatory', {
            get: function ()
            {
                return isFieldMandatory;
            },
            set: function (val) {
                if (util.isBoolean(val) && (isFieldMandatory !== val))
                {
                    var oldValue = isFieldMandatory;
                    isFieldMandatory = val;
                    var newValue = isFieldMandatory;
                    fieldStateEvent.emit(emitter, that, fieldStateEvent.Type.IS_MANDATORY_CHANGE, oldValue, newValue);
                }
            },
            enumerable: true,
            configurable: false
        });

        /**
         * isDefaultMandatory
         *
         * @name FieldState#isDefaultMandatory
         * @type boolean
         * @readonly
         */
        Object.defineProperty(this, 'isDefaultMandatory', {
            get: function ()
            {
                return defaultMandatory;
            },
            enumerable: true,
            configurable: false
        });
        /**
         * isHidden
         *
         * @name FieldState#isHidden
         * @type boolean
         */
        Object.defineProperty(this, 'isHidden', {
            get: function ()
            {
                return isFieldHidden;
            },
            set: function (val)
            {
                if (util.isBoolean(val) && (isFieldHidden !== val))
                {
                    var oldValue = isFieldHidden;
                    isFieldHidden = val;
                    var newValue = isFieldHidden;
                    fieldStateEvent.emit(emitter, that, fieldStateEvent.Type.IS_HIDDEN_CHANGE, oldValue, newValue);
                }
            },
            enumerable: true,
            configurable: false
        });
        /**
         * isDisabled
         *
         * @name FieldState#isDisabled
         * @type boolean
         */
        Object.defineProperty(this, 'isDisabled', {
            get: function ()
            {
                return isFieldDisabled;
            },
            set: function (val)
            {
                if (util.isBoolean(val) && (isFieldDisabled !== val))
                {
                    var oldValue = isFieldDisabled;
                    isFieldDisabled = val;
                    var newValue = isFieldDisabled;
                    fieldStateEvent.emit(emitter, that, fieldStateEvent.Type.IS_DISABLED_CHANGE, oldValue, newValue);
                }
            },
            enumerable: true,
            configurable: false
        });
        /**
         * isVisible
         *
         * @name FieldState#isVisible
         * @type boolean
         */
        Object.defineProperty(this, 'isVisible', {
            get: function ()
            {
                return isFieldVisible;
            },
            set: function (val)
            {
                if (util.isBoolean(val) && (isFieldVisible !== val))
                {
                    var oldValue = isFieldVisible;
                    isFieldVisible = val;
                    var newValue = isFieldVisible;
                    fieldStateEvent.emit(emitter, that, fieldStateEvent.Type.IS_VISIBLE_CHANGE, oldValue, newValue);
                }
            },
            enumerable: true,
            configurable: false
        });
        /**
         * isDisplay
         *
         * @name FieldState#isDisplay
         * @type boolean
         */
        Object.defineProperty(this, 'isDisplay', {
            get: function ()
            {
                return isFieldDisplay;
            },
            set: function (val)
            {
                if (util.isBoolean(val) && (isFieldDisplay !== val))
                {
                    var oldValue = isFieldDisplay;
                    isFieldDisplay = val;
                    var newValue = isFieldDisplay;
                    fieldStateEvent.emit(emitter, that, fieldStateEvent.Type.IS_DISPLAY_CHANGE, oldValue, newValue);
                }
            },
            enumerable: true,
            configurable: false
        });
        /**
         * isReadOnly
         *
         * @name FieldState#isReadOnly
         * @type boolean
         */
        Object.defineProperty(this, 'isReadOnly', {
            get: function ()
            {
                return isFieldReadOnly;
            },
            set: function (val)
            {
                if (util.isBoolean(val) && (isFieldReadOnly !== val))
                {
                    var oldValue = isFieldReadOnly;
                    isFieldReadOnly = val;
                    var newValue = isFieldReadOnly;
                    fieldStateEvent.emit(emitter, that, fieldStateEvent.Type.IS_READ_ONLY_CHANGE, oldValue, newValue);
                }
            },
            enumerable: true,
            configurable: false
        });
        /**
         * ignoreSlaving
         *
         * @name FieldState#ignoreSlaving
         * @type boolean
         */
        Object.defineProperty(this, 'ignoreSlaving', {
            get: function ()
            {
                return ignoreSlaving;
            },
            set: function (val)
            {
                if (util.isBoolean(val) && (ignoreSlaving !== val))
                {
                    var oldValue = ignoreSlaving;
                    ignoreSlaving = val;
                    var newValue = ignoreSlaving;
                    fieldStateEvent.emit(emitter, that, fieldStateEvent.Type.IGNORE_SLAVING_CHANGE, oldValue, newValue);
                }
            },
            enumerable: true,
            configurable: false
        });
        /**
         * isChanged
         *
         * @name FieldState#isChanged
         * @type boolean
         */
        Object.defineProperty(this, 'isChanged', {
            get: function ()
            {
                return isFieldChanged;
            },
            set: function (val)
            {
                if (util.isBoolean(val) && (isFieldChanged !== val))
                {
                    var oldValue = isFieldChanged;
                    isFieldChanged = val;
                    var newValue = isFieldChanged;
                    if(val === true && parentState)
                    {
                        parentState.isChanged = val;
                    }
                    fieldStateEvent.emit(emitter, that, fieldStateEvent.Type.IS_CHANGED_CHANGE, oldValue, newValue);
                }
            },
            enumerable: true,
            configurable: false
        });
        /**
         * label
         *
         * @name FieldState#label
         * @type string
         */
        Object.defineProperty(this, 'label', {
            get: function ()
            {
                return label;
            },
            set: function (val)
            {
                if(label !== val)
                {
                    var oldValue = label;
                    label = val;
                    var newValue = label;
                    fieldStateEvent.emit(emitter, that, fieldStateEvent.Type.LABEL_CHANGE, oldValue, newValue);
                }
            },
            enumerable: true,
            configurable: false
        });
        /**
         * name
         * @name FieldState#name
         * @type string
         */
        Object.defineProperty(this, 'id', {
            get: function ()
            {
                return id;
            },
            set: function (val)
            {
                // TODO: remove ???
                id = val;
            },
            enumerable: true,
            configurable: false
        });
        
        this.on = emitter.on;
        this.off = emitter.off;
        
        return this;
    }
    Object.freeze(FieldState);


    return Object.freeze({
                             /**
                              * create a new instance of fieldState
                              *
                              * @param {Object} options
                              * @param {RecordStateController} [options.parentState]
                              * @param {Object} options.fieldState
                              *
                              * @returns {FieldState}
                              */
                             create: function (options) {
                                 return new FieldState(options);
                             },
                             /**
                              * clone the fieldState object
                              *
                              * @param {FieldState} fieldState
                              * @returns {FieldState}
                              */
                             clone: function (fieldState)
                             {
                                 return new FieldState({
                                     parentState: fieldState.parentState,
                                     fieldState: {
                                             name: fieldState.id,
                                             label: fieldState.label,
                                             isMandatory: fieldState.isMandatory,
                                             isDefaultMandatory: fieldState.isDefaultMandatory,
                                             isHidden: fieldState.isHidden,
                                             isDisabled: fieldState.isDisabled,
                                             isReadOnly: fieldState.isReadOnly,
                                             noSlaving: fieldState.ignoreSlaving,
                                             isChanged: fieldState.isChanged,
                                             isVisible: fieldState.isVisible,
                                             isDisplay: fieldState.isDisplay,
                                             isParsed: fieldState.isParsed
                                         }
                                 });
                             },
                             /**
                              * create a new instance of fieldState
                              *
                              * @param {Object} options
                              * @param {RecordStateController} [options.parentState]
                              * @param {FieldLevelMetadata} options.metadata
                              *
                              * @returns {FieldState}
                              */
                             createBasedOnFieldLevelMetadata: function(options){
                                 var parentState = options.parentState;
                                 var metadata = options.metadata;
                                 return new FieldState({
                                     parentState: parentState,
                                     fieldState: metadata.defaultFieldState
                                 });
                             }
                         })
});

/**
 * SuiteScript sublist line state event module
 *
 * @private
 * @module N/record/sublistLineStateEvent
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/sublistLineStateEvent',[], function()
{
	var EVENT_TYPE = Object.freeze({
			LINE_NUM_CHANGE: 'LINE_NUM_CHANGE',
			IS_INSERTED_CHANGE: 'IS_INSERTED_CHANGE',
			FIELD_STATE_ADDED: 'FIELD_STATE_ADDED',
			FIELD_STATE_REMOVED: 'FIELD_STATE_REMOVED'
		});

	function getEvent(sublistLineState, type)
	{
		return {
			type: type,
			sublistLineState: sublistLineState
		};
	}

	function emit(emitter, sublistLineState, type)
	{
		emitter.emit(getEvent(sublistLineState, type));
	}

	return Object.freeze({
		Type: EVENT_TYPE,
		emit: emit
	});
});

/**
 * SuiteScript recordstate module
 *
 * @private
 * @module N/record/sublistLineState
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/sublistLineState',['N/utilityFunctions', 'N/record/fieldState', 'N/record/sublistLineStateEvent', 'N/eventEmitter'], function(utilityFunctions, fieldState, sublistLineStateEvent, eventEmitter)
{
    function addFieldId(obj, fieldId)
    {
        obj.fieldId = fieldId;
        return obj;
    }

    /**
     * line state for record sublist
     *
     * @param {Object} options
     * @param {Object} options.fieldStates field states for the line
     * @param {Number} [options.line=-1]
     *
     * @return {SublistLineState}
     * @constructor
     */
    function SublistLineState(options)
    {
        var that = this;
        var fieldStates = options.fieldStates;
        var originalLine = options.line || options.line === 0 ? options.line : -1;
        var isInsertedLine = false;
        var emitter = eventEmitter.create();

        /**
         * lineNum line number from db
         *
         * @name SublistLineState#lineNum
         * @type number
         */
        Object.defineProperty(this, 'lineNum', {
            get: function ()
            {
                return originalLine;
            },
            set: function (line)
            {
                if(originalLine !== line)
                {
                    originalLine = line;
                    sublistLineStateEvent.emit(emitter, that, sublistLineStateEvent.Type.LINE_NUM_CHANGE);
                }
            },
            enumerable: true,
            configurable: false
        });
        /**
         * isInserted
         *
         * @name SublistLineState#isInserted
         * @type boolean
         */
        Object.defineProperty(this, 'isInserted', {
            get: function ()
            {
                return isInsertedLine;
            },
            set: function (val)
            {
                if(isInsertedLine !== val)
                {
                    isInsertedLine = val;
                    sublistLineStateEvent.emit(emitter, that, sublistLineStateEvent.Type.IS_INSERTED_CHANGE);
                }
            },
            enumerable: true,
            configurable: false
        });
        /**
         * isChanged
         *
         * @name SublistLineState#isChanged
         * @type boolean
         * @readonly
         */
        Object.defineProperty(this, 'isChanged', {
            get: function ()
            {
                for(var fieldId in fieldStates)
                {
                    if(fieldStates.hasOwnProperty(fieldId) && fieldStates[fieldId].isChanged)
                        return true;
                }
                return false;
            },
            enumerable: true,
            configurable: false
        });
        //
        ///**
        // * return all the field names based on field states
        // * @returns {Array}
        // */
        //this.getAllFields = getAllFields;
        //function getAllFields()
        //{
        //    var arr = [];
        //    for(var f in fieldStates)
        //        if(fieldStates.hasOwnProperty(f))
        //            arr.push(f);
        //    return arr;
        //}

        /**
         * has the fieldState for field
         *
         * @param {string} fieldId
         * @returns {boolean}
         */
        function hasFieldState(fieldId)
        {
            return fieldStates.hasOwnProperty(fieldId);
        }
        this.hasFieldState = hasFieldState;

        /**
         * remove field state
         * @param {string} fieldId
         */
        function removeFieldState(fieldId)
        {
            if(fieldStates.hasOwnProperty(fieldId))
            {
                delete fieldStates[fieldId];
                sublistLineStateEvent.emit(emitter, that, sublistLineStateEvent.Type.FIELD_STATE_REMOVED);
            }
        }
        this.removeFieldState = removeFieldState;

        /**
         * return the fieldState object for fieldId in the current line
         *
         * @param {string} fieldId
         * @returns {FieldState}
         */
        function getFieldState(fieldId)
        {
            return fieldStates[fieldId];
        }
        this.getFieldState = getFieldState;

        /**
         * add new fieldState object for fieldId in the current line
         *
         * @param {string} fieldId
         * @param {FieldState} state
         * @returns {FieldState}
         */
        function addFieldState(fieldId, state)
        {
            fieldStates[fieldId] = state;
            sublistLineStateEvent.emit(emitter, that, sublistLineStateEvent.Type.FIELD_STATE_ADDED);
        }
        this.addFieldState = addFieldState;

        /**
         * clone the fieldState object in the current line
         *
         * @returns {object} collection of cloned fieldState from current line
         */
        function getClonedFieldStates()
        {
            var returnFieldStates = {};
            for(var fieldId in fieldStates)
            {
                if(fieldStates.hasOwnProperty(fieldId))
	                returnFieldStates[fieldId] = fieldState.clone(fieldStates[fieldId]);
            }
            return returnFieldStates;
        }
        this.getClonedFieldStates = getClonedFieldStates;

        this.on = emitter.on;
        this.off = emitter.off;

        return this;
    }
    utilityFunctions.freezeObjectIfPossible(SublistLineState);

    return Object.freeze({
                             /**
                              * create a new instance of sublist line state
                              *
                              * @param {Object} options
                              * @param {Object} options.fieldStates
                              * @param {Number} options.line
                              *
                              * @return {SublistLineState}
                              */
                             create: function (options)
                             {
                                 return new SublistLineState(options);
                             }
                         });
});

/**
 * SuiteScript sublist state event module
 *
 * @private
 * @module N/record/sublistStateEvent
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/sublistStateEvent',['N/record/fieldStateEvent'], function(fieldStateEvent)
{
	var EVENT_TYPE = Object.freeze({
			IS_DISPLAY_CHANGE: 'IS_DISPLAY_CHANGE',
			IS_CHANGED_CHANGE: 'IS_CHANGED_CHANGE',
			IS_HIDDEN_CHANGE: 'IS_HIDDEN_CHANGE',
			FIELD_IS_MANDATORY_CHANGE: 'FIELD_IS_MANDATORY_CHANGE',
			FIELD_IS_HIDDEN_CHANGE: 'FIELD_IS_HIDDEN_CHANGE',
			FIELD_IS_DISABLED_CHANGE: 'FIELD_IS_DISABLED_CHANGE',
			FIELD_IS_VISIBLE_CHANGE: 'FIELD_IS_VISIBLE_CHANGE',
			FIELD_IS_DISPLAY_CHANGE: 'FIELD_IS_DISPLAY_CHANGE',
			FIELD_IS_READ_ONLY_CHANGE: 'FIELD_IS_READ_ONLY_CHANGE',
			FIELD_LABEL_CHANGE: 'FIELD_LABEL_CHANGE'
		});

	var translateFieldStateEventTypeToSublistStateEventType = (function(){
		var eventTranslations = {};

		eventTranslations[fieldStateEvent.Type.IS_MANDATORY_CHANGE] = EVENT_TYPE.FIELD_IS_MANDATORY_CHANGE;
		eventTranslations[fieldStateEvent.Type.IS_HIDDEN_CHANGE] = EVENT_TYPE.FIELD_IS_HIDDEN_CHANGE;
		eventTranslations[fieldStateEvent.Type.IS_DISABLED_CHANGE] = EVENT_TYPE.FIELD_IS_DISABLED_CHANGE;
		eventTranslations[fieldStateEvent.Type.IS_VISIBLE_CHANGE] = EVENT_TYPE.FIELD_IS_VISIBLE_CHANGE;
		eventTranslations[fieldStateEvent.Type.IS_DISPLAY_CHANGE] = EVENT_TYPE.FIELD_IS_DISPLAY_CHANGE;
		eventTranslations[fieldStateEvent.Type.IS_READ_ONLY_CHANGE] = EVENT_TYPE.FIELD_IS_READ_ONLY_CHANGE;
		eventTranslations[fieldStateEvent.Type.LABEL_CHANGE] = EVENT_TYPE.FIELD_LABEL_CHANGE;

		return function(fieldStateEventType){
			return eventTranslations[fieldStateEventType];
		}
	}());

	function translateFieldStateEventToSublistStateEvent(sublistState, fieldStateEvent)
	{
		return addFieldStateEventDetails(getEvent(sublistState, translateFieldStateEventTypeToSublistStateEventType(fieldStateEvent.type)), fieldStateEvent);
	}

	function addFieldStateEventDetails(event, fieldStateEvent)
	{
		var lineFieldStateLocation = event.sublistState.findLineForFieldState(fieldStateEvent.fieldState);
		event.fieldId = fieldStateEvent.fieldState.id;
		if(fieldStateEvent.oldValue !== undefined){ event.oldValue = fieldStateEvent.oldValue; }
		if(fieldStateEvent.newValue !== undefined){ event.newValue = fieldStateEvent.newValue; }
		event.line = lineFieldStateLocation.line;
		event.currentLine = lineFieldStateLocation.current;

		return event;
	}

	function getEvent(sublistState, type)
	{
		return {
			type: type,
			sublistState: sublistState
		};
	}

	function addValues(event, oldValue, newValue)
	{
		if(oldValue !== undefined){ event.oldValue = oldValue; }
		if(newValue !== undefined){ event.newValue = newValue; }

		return event;
	}

	function emit(emitter, sublistState, type, oldValue, newValue)
	{
		emitter.emit(addValues(getEvent(sublistState, type), oldValue, newValue));
	}

	function forwardFieldStateEvent(emitter, sublistState, fieldStateEvent)
	{
		emitter.emit(translateFieldStateEventToSublistStateEvent(sublistState, fieldStateEvent));
	}

	function forwardFieldStateEvents(emitter, sublistState, fieldState)
	{
		var forward = forwardFieldStateEvent.bind(null, emitter, sublistState);

		fieldState.on({
			types: [
				fieldStateEvent.Type.IS_MANDATORY_CHANGE,
				fieldStateEvent.Type.IS_HIDDEN_CHANGE,
				fieldStateEvent.Type.IS_DISABLED_CHANGE,
				fieldStateEvent.Type.IS_VISIBLE_CHANGE,
				fieldStateEvent.Type.IS_DISPLAY_CHANGE,
				fieldStateEvent.Type.IS_READ_ONLY_CHANGE,
				fieldStateEvent.Type.LABEL_CHANGE
			],
			listener: forward
		});
	}

	return Object.freeze({
		Type: EVENT_TYPE,
		emit: emit,
		forwardFieldStateEvents: forwardFieldStateEvents
	});
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/sublistState
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/sublistState',['N/utilityFunctions', 'N/error', 'N/record/fieldState', 'N/record/sublistLineState', 'N/record/sublistStateEvent', 'N/eventEmitter'],
       function(utilityFunctions, error, fieldState, sublistLineState, sublistStateEvent, eventEmitter){

           function SublistController()
           {
               var that = this;
               var sublist = {};

               function lineInstanceIdExists(lineInstanceId)
               {
                   return sublist.hasOwnProperty(lineInstanceId);
               }

               function getLineInstanceIds()
               {
                   return Object.keys(sublist);
               }
               this.getLineInstanceIds = getLineInstanceIds;

               function has(lineInstanceId)
               {
                   var result = false;
                   var hasLineInstanceId = lineInstanceIdExists(lineInstanceId);

                   if(hasLineInstanceId)
                   {
                       result = !!sublist[lineInstanceId];
                   }

                   return result;
               }
               this.has = has;

               function get(lineInstanceId)
               {
                   var result = null;
                   var hasLineInstanceId = lineInstanceIdExists(lineInstanceId);

                   if(hasLineInstanceId)
                   {
                       result = sublist[lineInstanceId];
                   }

                   return result;
               }
               this.get = get;

               function put(lineInstanceId, value)
               {
                   var previousValue = get(lineInstanceId);
                   sublist[lineInstanceId] = value;
                   return previousValue;
               }
               this.put = put;

               function remove(lineInstanceId)
               {
                   var removedValue = get(lineInstanceId);
                   delete sublist[lineInstanceId];
                   return removedValue;
               }
               this.remove = remove;
           }

        /**
         * sublist state for record sublist
         *
         * @param {Object} options
         * @param {string} options.id sublist name
         * @param {RecordStateController} options.parentState
         * @param {Object} options.sublistStateObj
         * @param {boolean} options.sublistStateObj.allowAddlines
         * @param {boolean} options.sublistStateObj.isDisplay
         * @param {Object} options.fieldMetadata group of field metadata with field id as key
         *
         * @return {SublistState}
         * @constructor
         */
        function SublistState(options)
        {
            var that = this;
            var id = options.id;
            var parentState = options.parentState;
            var sublistStateObj = options.sublistStateObj;
            var fieldMetadata = options.fieldMetadata;
            var getModelController = options.getModelController;
            var lineStatePrototype = {};

            var lines = new SublistController();
            var lineBuffers = new SublistController();

            var allowsNewLine = sublistStateObj.allowAddlines || false;
            var isSublistChanged = false;
            var isSublistDisplay = sublistStateObj.isDisplay || true;
            var isSublistHidden = false;

            var emitter = eventEmitter.create();

            function checkIfMachineDoesNotAllowsChangeForInstance(lineInstanceId)
            {
            	var useBuffer = false;
            	return !allowsNewLine && !getModelController().isSublistLineInstanceIdValid(id, lineInstanceId, useBuffer);
            }

            function getSublistlines(useBuffer)
            {
                return !useBuffer ? lines : lineBuffers;
            }

            function findLineForFieldState(fieldstate)
            {
                var result = {
                        current: false,
                        line: null
                    };
                var fieldId = fieldstate.id;
                var modelController = getModelController();

                var lineInstanceId = null;
                var lineInstanceIds = null;
                var sublistLineState = null;
                var found = false;

                if(!found)
                {
                    lineInstanceIds = lineBuffers.getLineInstanceIds();
                    for (var i = 0; i < lineInstanceIds.length; i++)
                    {
                        lineInstanceId = lineInstanceIds[i];
                        sublistLineState = lineBuffers.get(lineInstanceId);
                        if (!!sublistLineState && sublistLineState.hasFieldState(fieldId) && sublistLineState.getFieldState(fieldId) === fieldstate)
                        {
                            found = true;
                            result.current = true;
                            result.line = modelController.getSublistLineValueForInstance(id, '_sequence', lineInstanceId, result.current);
                            break;
                        }
                    }
                }

                if(!found)
                {
                    lineInstanceIds = lines.getLineInstanceIds();
                    for (var i = 0; i < lineInstanceIds.length; i++)
                    {
                        lineInstanceId = lineInstanceIds[i];
                        sublistLineState = lines.get(lineInstanceId);
                        if (sublistLineState.hasFieldState(fieldId) && sublistLineState.getFieldState(fieldId) === fieldstate)
                        {
                            found = true;
                            result.current = false;
                            result.line = modelController.getSublistLineValueForInstance(id, '_sequence', lineInstanceId, result.current);
                            break;
                        }
                    }
                }

                return result;
            }
            this.findLineForFieldState = findLineForFieldState;

            (function constructor(fieldMetadata){
                lineStatePrototype = {};
                for(var fieldId in fieldMetadata)
                {
                    if(fieldMetadata.hasOwnProperty(fieldId))
                        lineStatePrototype[fieldId] = fieldMetadata[fieldId].defaultFieldState;
                }
            }(fieldMetadata));


            /**
             * name of sublist
             * @name SublistState#name
             * @type string
             */
            Object.defineProperty(this, 'id', {
                get: function ()
                {
                    return id;
                },
                enumerable: true,
                configurable: false
            });
            /**
             * return true if sublist is allowed to add line
             * @name SublistState#allowsNewLine
             * @type boolean
             * @readonly
             */
            Object.defineProperty(this, 'allowsNewLine', {
                get: function ()
                {
                    return allowsNewLine;
                },
                enumerable: true,
                configurable: false
            });
            /**
             * return true if sublist is on display
             * @name SublistState#isDisplay
             * @type boolean
             */
            Object.defineProperty(this, 'isDisplay', {
                get: function ()
                {
                    return isSublistDisplay;
                },
                set: function (val)
                {
                    if(util.isBoolean(val) && (isSublistDisplay !== val))
                    {
                        var oldValue = isSublistDisplay;
                        isSublistDisplay = val;
                        var newValue = isSublistDisplay;
                        sublistStateEvent.emit(emitter, that, sublistStateEvent.Type.IS_DISPLAY_CHANGE, oldValue, newValue);
                    }
                },
                enumerable: true,
                configurable: false
            });
            /**
             * return true if sublist is changed
             * @name SublistState#isChanged
             * @type boolean
             */
            Object.defineProperty(this, 'isChanged', {
                get: function ()
                {
                    return isSublistChanged;
                },
                set: function (val)
                {
                    if(util.isBoolean(val) && (isSublistChanged !== val))
                    {
                        var oldValue = isSublistChanged;
                        isSublistChanged = val;
                        var newValue = isSublistChanged;
                        if(val === true && parentState)
                            parentState.isChanged = true;
                        sublistStateEvent.emit(emitter, that, sublistStateEvent.Type.IS_CHANGED_CHANGE, oldValue, newValue);
                    }
                },
                enumerable: true,
                configurable: false
            });
            /**
             * return true if sublist is hidden
             * @name SublistState#isHidden
             * @type boolean
             */
            Object.defineProperty(this, 'isHidden', {
                get: function ()
                {
                    return isSublistHidden;
                },
                set: function (val)
                {
                    if(util.isBoolean(val) && (isSublistHidden !== val))
                    {
                        var oldValue = isSublistHidden;
                        isSublistHidden = val;
                        var newValue = isSublistHidden;
                        sublistStateEvent.emit(emitter, that, sublistStateEvent.Type.IS_HIDDEN_CHANGE, oldValue, newValue);
                    }
                },
                enumerable: true,
                configurable: false
            });

            function getFieldLevelMetadata(fieldId)
            {
                return fieldMetadata.hasOwnProperty(fieldId) ? fieldMetadata[fieldId] : null;
            }

            function createNewFieldState(lineState, fieldId)
            {
                var fieldstate;
                var fieldLevelMetadata = getFieldLevelMetadata(fieldId);
                if(fieldLevelMetadata)
                {
                    fieldstate = fieldState.createBasedOnFieldLevelMetadata({metadata: fieldLevelMetadata});
                }
                else
                {
                    var fsObj = {name: fieldId, label: fieldId};
                    addField(fieldId, fsObj);
                    fieldstate = fieldState.create({fieldState: fsObj});
                }
                sublistStateEvent.forwardFieldStateEvents(emitter, that, fieldstate);

                return fieldstate;
            }


            /**
             * add field state for virtual field and apply to all rows
             * @param {String} fieldId
             * @param {Object} state
             */
            function addField(fieldId, state)
            {
                var fieldstate;

                lineBuffers.getLineInstanceIds().forEach(function(lineInstanceId){
                    var fieldstate = fieldState.create({fieldState: {name: fieldId, label: fieldId}});
                    sublistStateEvent.forwardFieldStateEvents(emitter, that, fieldstate);
                    var thisLine = lineBuffers.get(lineInstanceId);
                    if (thisLine != null)
                        thisLine.addFieldState[fieldId] = fieldstate;
                });

                lines.getLineInstanceIds().forEach(function(lineInstanceId){
                    var fieldstate = fieldState.create({fieldState: {name: fieldId, label: fieldId}});
                    sublistStateEvent.forwardFieldStateEvents(emitter, that, fieldstate);
                    lines.get(lineInstanceId).addFieldState[fieldId] = fieldstate;
                });

                lineStatePrototype[fieldId] = state;
            }


            /**
             * remove field state from sublist line state
             * @param fieldId
             *
             */
            function removeFieldState(fieldId, line_0)
            {
                var useBuffer = false;
                var lineInstanceId = getModelController().getSublistLineInstanceIdForLine(id, line_0, useBuffer);
                removeFieldStateForInstance(fieldId, lineInstanceId, useBuffer);
            }
            this.removeFieldState = removeFieldState;

            function removeFieldStateForInstance(fieldId, lineInstanceId, useBuffer)
            {
                var sublistlineState = getSublistlines(useBuffer).get(lineInstanceId);
                if(!!sublistlineState)
                {
                    sublistlineState.removeFieldState(fieldId);
                }
            }
            this.removeFieldStateForInstance = removeFieldStateForInstance;

            /**
             * return the field state in a line
             * @param {string} fieldId field of the return field state
             * @param {number} line_0 the line number of the field (0 index based)
             * @returns {FieldState}
             */
            function getFieldState(fieldId, line_0)
            {
                var modelController = getModelController();
                var useBuffer = true;
                var lineInstanceId = modelController.getSublistLineInstanceIdForLine(id, line_0, useBuffer);

                if(lineInstanceId === null)
                {
                    useBuffer = false;
                    lineInstanceId = modelController.getSublistLineInstanceIdForLine(id, line_0, useBuffer);
                }

                return getFieldStateForInstance(fieldId, lineInstanceId, useBuffer);
            }
            this.getFieldState = getFieldState;

            function getFieldStateForInstance(fieldId, lineInstanceId, useBuffer)
            {
                var fieldState = null;
                var modelController = getModelController();

	            var isLineInstanceValid = modelController.isSublistLineInstanceIdValid(id, lineInstanceId, useBuffer);
	            if (!isLineInstanceValid && useBuffer)
	            {
		            useBuffer = false;
		            isLineInstanceValid = modelController.isSublistLineInstanceIdValid(id, lineInstanceId, useBuffer);
	            }

                if(isLineInstanceValid)
                {
                    var sublistLines = getSublistlines(useBuffer);
                    if(!sublistLines.has(lineInstanceId))
                    {
                        insertLineForInstance(lineInstanceId, useBuffer, true);
                    }

                    var sublistlineState = sublistLines.get(lineInstanceId);
                    if(!sublistlineState.hasFieldState(fieldId))
                    {
                        sublistlineState.addFieldState(fieldId, createNewFieldState(sublistlineState, fieldId));
                    }

                    fieldState = sublistlineState.getFieldState(fieldId);
                }
                else
                {
                    utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_SUBLIST_OPERATION);
                }

                return fieldState;
            }
            this.getFieldStateForInstance = getFieldStateForInstance;

            function getLineStatePropotype(overwrittenDefaults)
            {
                var prototype = {};
                for(var fieldId in lineStatePrototype)
                {
                    if(lineStatePrototype.hasOwnProperty(fieldId))
                        prototype[fieldId] = util.extend({}, lineStatePrototype[fieldId]);

                    if(overwrittenDefaults)
                    {
                        var fs = overwrittenDefaults[fieldId];
                        for (var key in fs)
                        {
                            if (fs.hasOwnProperty(key))
                                prototype[fieldId][key] = fs[key];
                        }
                    }
                }

                return prototype;
            }

            function createClonedLineState(line_0)
            {
                var modelController = getModelController();
                var useBuffer = false;
                var lineInstanceId = modelController.getSublistLineInstanceIdForLine(id, line_0, useBuffer);

                return createClonedLineStateForInstance(lineInstanceId, useBuffer);
            }

            function createClonedLineStateForInstance(lineInstanceId, useBuffer)
            {
                var sublistlineStateClone = null;
                var modelController = getModelController();

                if(modelController.isSublistLineInstanceIdValid(id, lineInstanceId, useBuffer))
                {
                    var sublistlines = getSublistlines(useBuffer);

                    if(sublistlines.has(lineInstanceId))
                    {
                        var sublistlineState = getSublistlines(useBuffer).get(lineInstanceId);

                        sublistlineStateClone = sublistLineState.create({
                            fieldStates: forwardFieldStateEventsOnClonedFieldStates(sublistlineState.getClonedFieldStates()),
                            line: sublistlineState.lineNum
                        });

                        sublistlineStateClone.isInserted = sublistlineState.isInserted;
                        sublistlineStateClone.isChanged = sublistlineState.isChanged;
                    }
                    else
                    {
                        sublistlineStateClone = sublistLineState.create({
                            fieldStates: transformFieldPrototypesToFieldStates(getLineStatePropotype()),
                            line: -1
                        });
                    }
                }

                return sublistlineStateClone;
            }

            function doForwardFieldStateEvents(fieldStates, needToCreateFirst)
            {
	            return Object.keys(fieldStates).reduce(function(p, c){
		            var fieldstate = needToCreateFirst ? fieldState.create({fieldState: fieldStates[c]}) : fieldStates[c];
		            sublistStateEvent.forwardFieldStateEvents(emitter, that, fieldstate);
		            p[c] = fieldstate;
		            return p;
	            }, {});
            }

            function forwardFieldStateEventsOnClonedFieldStates(fieldStates)
            {
	            return doForwardFieldStateEvents(fieldStates, false)
            }

            function transformFieldPrototypesToFieldStates(fieldPrototypes)
            {
	            return doForwardFieldStateEvents(fieldPrototypes, true)
            }

            /**
             * initiate the line states by record data
             */
            function init()
            {
                var modelController = getModelController();
                lines.getLineInstanceIds().forEach(function(lineInstanceId){
                    lines.remove(lineInstanceId);
                });
                lineBuffers.getLineInstanceIds().forEach(function(lineInstanceId){
                    lineBuffers.remove(lineInstanceId);
                });

                for(var i = 0; i < modelController.getSublistLineCount(id); i++)
                {
                    var sublistFieldStates = modelController.getSublistFieldStates(id, i);
                    var overwrittenDefaults = !!sublistFieldStates ? sublistFieldStates : {};
                    var fieldStates = transformFieldPrototypesToFieldStates(getLineStatePropotype(overwrittenDefaults));
                    var linestate = sublistLineState.create({fieldStates: fieldStates, line: i});

                    var useBuffer = false;
                    var lineInstanceId = modelController.getSublistLineInstanceIdForLine(id, i, useBuffer);
                    lines.put(lineInstanceId, linestate);
                }
            }
            this.init = init;

            /**
             * return all the field names
             * @returns {String[]} fieldnames
             */
            function getAllFields()
            {
                var fields = [];
                for(var fieldId in lineStatePrototype)
                    if(lineStatePrototype.hasOwnProperty(fieldId))
                        fields.push(fieldId);

                return fields;
            }
            this.getAllFields = getAllFields;
            /**
             * return all the field names
             * @param {number} line_0 the sublist line index
             * @returns {String[]} fieldnames
             */
            function getAllLineFields(line_0)
            {
                var modelController = getModelController();
                var useBuffer = false;
                var lineInstanceId = modelController.getSublistLineInstanceIdForLine(id, line_0, useBuffer);

                return getAllLineFieldsForInstance(lineInstanceId, useBuffer);
            }
            this.getAllLineFields = getAllLineFields;

            function getAllLineFieldsForInstance(lineInstanceId, useBuffer)
            {
                var result = null,
                    sublistlineState = getSublistlines(useBuffer).get(lineInstanceId);

                if(!!sublistlineState && !!sublistlineState.getAllFields)
                {
                    result = sublistlineState.getAllFields();
                }

                return result;
            }
            this.getAllLineFieldsForInstance = getAllLineFieldsForInstance;

            /**
             * return the field state from the current line state
             * @param {string} fieldId
             * @returns {FieldState}
             */
            function getCurrentLineFieldState(fieldId)
            {
                var currentLineFieldState = null;
                var useBuffer = true;
                var modelController = getModelController();
                var lineInstanceId = modelController.getSublistSelectedLineInstanceId(id);

                if(lineInstanceId !== null)
                {
                    currentLineFieldState = getBufferLineFieldStateForInstance(fieldId, lineInstanceId, useBuffer);
                }
                return currentLineFieldState;
            }
            this.getCurrentLineFieldState = getCurrentLineFieldState;

            function getBufferLineFieldStateForInstance(fieldId, lineInstanceId, useBuffer)
            {
                var fieldState = null;
                var modelController = getModelController();
                var isLineInstanceSelected = modelController.isSublistLineInstanceIdSelected(id, lineInstanceId);
                var isLineInstanceValid = modelController.isSublistLineInstanceIdSelected(id, lineInstanceId, useBuffer);

                if(isLineInstanceSelected || isLineInstanceValid)
                {
                    var sublistLines = getSublistlines(useBuffer);
                    if(!sublistLines.has(lineInstanceId))
                    {
                        resetBufferLineStateForInstance(lineInstanceId, useBuffer);
                    }

                    var sublistlineState = sublistLines.get(lineInstanceId);
                    if(!sublistlineState.hasFieldState(fieldId))
                    {
                        sublistlineState.addFieldState(fieldId, createNewFieldState(sublistlineState, fieldId));
                    }

                    fieldState = sublistlineState.getFieldState(fieldId);
                }
                else
                {
                    utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_SUBLIST_OPERATION);
                }

                return fieldState;
            }
            this.getBufferLineFieldStateForInstance = getBufferLineFieldStateForInstance;

            /**
             * remove the current line buffer
             */
            function removeCurrentLineState()
            {
                var modelController = getModelController();
                var useBuffer = true;
                var lineInstanceId = modelController.getSublistSelectedLineInstanceId(id);

                removeSublistLineState(lineInstanceId, useBuffer);
            }
            this.removeCurrentLineState = removeCurrentLineState;

            function removeSublistLineState(lineInstanceId, useBuffer)
            {
                getSublistlines(useBuffer).remove(lineInstanceId);
            }
            this.removeSublistLineState = removeSublistLineState;

            /**
             * reload the current line state buffer by current line index
             * @param {number} currentLineIndex
             */
            function resetCurrentLineState(currentLineIndex)
            {
                var modelController = getModelController();
                var useBuffer = true;
                var lineInstanceId = modelController.getSublistLineInstanceIdForLine(id, currentLineIndex, useBuffer);

                resetBufferLineStateForInstance(lineInstanceId, useBuffer)
            }
            this.resetCurrentLineState = resetCurrentLineState;

            function resetBufferLineStateForInstance(lineInstanceId, useBuffer)
            {
                var sublistlineState = null;

                removeBufferLineForInstance(lineInstanceId);
                if(useBuffer)
                {
                    sublistlineState = createClonedLineStateForInstance(lineInstanceId, false);
                }
                if(!sublistlineState)
                {
                    sublistlineState = createClonedLineStateForInstance(lineInstanceId, useBuffer);
                }

                getSublistlines(useBuffer).put(lineInstanceId, sublistlineState);
            }
            this.resetBufferLineStateForInstance = resetBufferLineStateForInstance;

            /**
             * commit the current line state buffer to actual line state
             * @param {number} currentLineIndex
             */
            function commitCurrentLine(currentLineIndex)
            {
                var modelController = getModelController();
                var useBuffer = true;
                var lineInstanceId = modelController.getSublistLineInstanceIdForLine(id, currentLineIndex, useBuffer);

                commitLineForInstance(lineInstanceId);
            }
            this.commitCurrentLine = commitCurrentLine;

            function commitLineForInstance(lineInstanceId)
            {
                var useBuffer = true;
                var modelController = getModelController();

                if(modelController.isSublistLineInstanceIdValid(id, lineInstanceId, useBuffer))
                {
                    var sublistlineState = lineBuffers.remove(lineInstanceId);
                    sublistlineState.isInserted = false;
                    lines.put(lineInstanceId, sublistlineState);
                    that.isChanged = true;
                }
            }
            this.commitLineForInstance = commitLineForInstance;

            /**
             * insert a new LineState
             * @param {number} line_0 line number of inserted line
             * @param {boolean} isInsert if the line is inserted
             */
            function insertLine(line_0, isInsert)
            {
                var modelController = getModelController();
                var useBuffer = false;
                var lineInstanceId = modelController.getSublistLineInstanceIdForLine(id, line_0, useBuffer);

                insertLineForInstance(lineInstanceId, useBuffer, isInsert);
            }
            this.insertLine = insertLine;

            function insertLineForInstance(lineInstanceId, useBuffer, isInsert)
            {
                if (checkIfMachineDoesNotAllowsChangeForInstance(lineInstanceId))
                    utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_SUBLIST_OPERATION);

                var modelController = getModelController();
                if(modelController.isSublistLineInstanceIdValid(id, lineInstanceId, useBuffer))
                {
                    var sublistlineState = sublistLineState.create({fieldStates: transformFieldPrototypesToFieldStates(getLineStatePropotype())});
                    sublistlineState.isInserted = !!isInsert;
                    getSublistlines(useBuffer).put(lineInstanceId, sublistlineState);
                }
            }
            this.insertLineForInstance = insertLineForInstance;


            /**
             * return true if line is inserted
             * @param line_0
             * @returns {boolean}
             */
            function isLineInserted(line_0)
            {
                var modelController = getModelController();
                var useBuffer = false;
                var lineInstanceId = modelController.getSublistLineInstanceIdForLine(id, line_0, useBuffer);

                return isLineInsertedForInstance(lineInstanceId, useBuffer);
            }
            this.isLineInserted = isLineInserted;

            function isLineInsertedForInstance(lineInstanceId, useBuffer)
            {
                var result = false;
                var sublistlines = getSublistlines(useBuffer);

                if(sublistlines.has(lineInstanceId))
                {
                    var sublistlineState = sublistlines.get(lineInstanceId);
                    result = sublistlineState.isInserted;
                }

                return result;
            }
            this.isLineInsertedForInstance = isLineInsertedForInstance;

            /**
             * remove line state
             * @param {number} line_0
             */
            function removeLine(line_0)
            {
                var modelController = getModelController();
                var useBuffer = false;
                var lineInstanceId = modelController.getSublistLineInstanceIdForLine(id, line_0, useBuffer);

                removeLineForInstance(lineInstanceId);
            }
            this.removeLine = removeLine;

	        function removeBufferLineForInstance(lineInstanceId)
	        {
		        if (checkIfMachineDoesNotAllowsChangeForInstance(lineInstanceId))
			        utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_SUBLIST_OPERATION);

		        getSublistlines(true).remove(lineInstanceId);
	        }

            function removeLineForInstance(lineInstanceId)
            {
                if (checkIfMachineDoesNotAllowsChangeForInstance(lineInstanceId))
                    utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_SUBLIST_OPERATION);

                getSublistlines(true).remove(lineInstanceId);
	            getSublistlines(false).remove(lineInstanceId);
            }
            this.removeLineForInstance = removeLineForInstance;

            /**
             * return true if line is removed
             * @param line_0
             * @returns {boolean}
             */
            function isLineRemoved(line_0)
            {
                var isNotRemoved = false;
                var lineInstanceIds = lines.getLineInstanceIds();
                var lineNum = parseInt(line_0, 10);

                if(!isNaN(lineNum))
                {
                    var index = 0;
                    while(!isNotRemoved && index < lineInstanceIds.length)
                    {
                        var lineInstanceId = lineInstanceIds[index];
                        isNotRemoved = lines.get(lineInstanceId).lineNum === lineNum;
                        index += 1;
                    }
                }

                return !isNotRemoved;
            }
            this.isLineRemoved = isLineRemoved;

            /**
             * return true if line is changed
             * @param {number} line_0
             * @return {boolean}
             */
            function isLineChanged(line_0)
            {
                var modelController = getModelController();
                var useBuffer = false;
                var lineInstanceId = modelController.getSublistLineInstanceIdForLine(id, line_0, useBuffer);

                return isLineChangedForInstance(lineInstanceId, useBuffer);
            }
            this.isLineChanged = isLineChanged;

            function isLineChangedForInstance(lineInstanceId, useBuffer)
            {
                var result = false;
                var sublistlines = getSublistlines(useBuffer);

                if(sublistlines.has(lineInstanceId))
                {
                    var sublistlineState = sublistlines.get(lineInstanceId);
                    result = sublistlineState.isChanged;
                }

                return result;
            }
            this.isLineChangedForInstance = isLineChangedForInstance;

            /**
             * return the number of lines
             * @return {number}
             */
            function getLineCount()
            {
                return Object.keys(lines).length;
            }
            this.getLineCount = getLineCount;

            this.on = emitter.on;
            this.off = emitter.off;

            return this;
        }
        Object.freeze(SublistState);

        return Object.freeze({
                                /**
                                 * create a new instance of sublist state
                                 *
                                 * @param {Object} options
                                 * @param {String} options.id
                                 * @param {Object} options.sublistStateObj
                                 * @param {RecordStateController} options.parentState
                                 * @param {Object} options.fieldMetadata
                                 *
                                 * @return {SublistState}
                                 */
                                create: function (options) { return new SublistState(options); }
                            });
});

/**
 * SuiteScript record state controller event module
 *
 * @private
 * @module N/record/recordStateControllerEvent
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/recordStateControllerEvent',['N/record/fieldStateEvent', 'N/record/sublistStateEvent'], function(fieldStateEvent, sublistStateEvent) {
	var EVENT_TYPE = Object.freeze({
			FIELD_IS_MANDATORY_CHANGE: 'FIELD_IS_MANDATORY_CHANGE',
			FIELD_IS_HIDDEN_CHANGE: 'FIELD_IS_HIDDEN_CHANGE',
			FIELD_IS_DISABLED_CHANGE: 'FIELD_IS_DISABLED_CHANGE',
			FIELD_IS_VISIBLE_CHANGE: 'FIELD_IS_VISIBLE_CHANGE',
			FIELD_IS_DISPLAY_CHANGE: 'FIELD_IS_DISPLAY_CHANGE',
			FIELD_IS_READ_ONLY_CHANGE: 'FIELD_IS_READ_ONLY_CHANGE',
			FIELD_LABEL_CHANGE: 'FIELD_LABEL_CHANGE',
			SUBLIST_IS_DISPLAY_CHANGE: 'SUBLIST_IS_DISPLAY_CHANGE',
			SUBLIST_IS_HIDDEN_CHANGE: 'SUBLIST_IS_HIDDEN_CHANGE'
		});

	function getEvent(type)
	{
		return {
			type: type
		}
	}

	var translateFieldStateEventTypeToRecordControllerEventType = (function () {
		var eventTranslations = {};

		eventTranslations[fieldStateEvent.Type.IS_MANDATORY_CHANGE] = EVENT_TYPE.FIELD_IS_MANDATORY_CHANGE;
		eventTranslations[fieldStateEvent.Type.IS_HIDDEN_CHANGE] = EVENT_TYPE.FIELD_IS_HIDDEN_CHANGE;
		eventTranslations[fieldStateEvent.Type.IS_DISABLED_CHANGE] = EVENT_TYPE.FIELD_IS_DISABLED_CHANGE;
		eventTranslations[fieldStateEvent.Type.IS_VISIBLE_CHANGE] = EVENT_TYPE.FIELD_IS_VISIBLE_CHANGE;
		eventTranslations[fieldStateEvent.Type.IS_DISPLAY_CHANGE] = EVENT_TYPE.FIELD_IS_DISPLAY_CHANGE;
		eventTranslations[fieldStateEvent.Type.IS_READ_ONLY_CHANGE] = EVENT_TYPE.FIELD_IS_READ_ONLY_CHANGE;
		eventTranslations[fieldStateEvent.Type.LABEL_CHANGE] = EVENT_TYPE.FIELD_LABEL_CHANGE;

		return function (fieldStateEventType) {
			return eventTranslations[fieldStateEventType];
		}
	}());

	function addFieldStateEventDetails(event, fieldStateEvent)
	{
		event.fieldId = fieldStateEvent.fieldState.id;
		if(fieldStateEvent.oldValue !== undefined){ event.oldValue = fieldStateEvent.oldValue; }
		if(fieldStateEvent.newValue !== undefined){ event.newValue = fieldStateEvent.newValue; }
		return event;
	}

	function translateFieldStateEventToRecordControllerStateEvent(fieldStateEvent)
	{
		return addFieldStateEventDetails(getEvent(translateFieldStateEventTypeToRecordControllerEventType(fieldStateEvent.type)), fieldStateEvent);
	}

	function forwardFieldStateEvent(emitter, fieldStateEvent)
	{
		emitter.emit(translateFieldStateEventToRecordControllerStateEvent(fieldStateEvent));
	}

	function forwardFieldStateEvents(emitter, fieldState)
	{
		var forward = forwardFieldStateEvent.bind(null, emitter);

		fieldState.on({
			types: [
				fieldStateEvent.Type.IS_MANDATORY_CHANGE,
				fieldStateEvent.Type.IS_HIDDEN_CHANGE,
				fieldStateEvent.Type.IS_DISABLED_CHANGE,
				fieldStateEvent.Type.IS_VISIBLE_CHANGE,
				fieldStateEvent.Type.IS_DISPLAY_CHANGE,
				fieldStateEvent.Type.IS_READ_ONLY_CHANGE,
				fieldStateEvent.Type.LABEL_CHANGE
			],
			listener: forward
		});
	}

	var translateSublistStateEventTypeToRecordControllerEventType = (function () {
		var eventTranslations = {};

		eventTranslations[sublistStateEvent.Type.IS_DISPLAY_CHANGE] = EVENT_TYPE.SUBLIST_IS_DISPLAY_CHANGE;
		eventTranslations[sublistStateEvent.Type.IS_HIDDEN_CHANGE] = EVENT_TYPE.SUBLIST_IS_HIDDEN_CHANGE;
		eventTranslations[sublistStateEvent.Type.FIELD_IS_MANDATORY_CHANGE] = EVENT_TYPE.FIELD_IS_MANDATORY_CHANGE;
		eventTranslations[sublistStateEvent.Type.FIELD_IS_HIDDEN_CHANGE] = EVENT_TYPE.FIELD_IS_HIDDEN_CHANGE;
		eventTranslations[sublistStateEvent.Type.FIELD_IS_DISABLED_CHANGE] = EVENT_TYPE.FIELD_IS_DISABLED_CHANGE;
		eventTranslations[sublistStateEvent.Type.FIELD_IS_VISIBLE_CHANGE] = EVENT_TYPE.FIELD_IS_VISIBLE_CHANGE;
		eventTranslations[sublistStateEvent.Type.FIELD_IS_DISPLAY_CHANGE] = EVENT_TYPE.FIELD_IS_DISPLAY_CHANGE;
		eventTranslations[sublistStateEvent.Type.FIELD_IS_READ_ONLY_CHANGE] = EVENT_TYPE.FIELD_IS_READ_ONLY_CHANGE;
		eventTranslations[sublistStateEvent.Type.FIELD_LABEL_CHANGE] = EVENT_TYPE.FIELD_LABEL_CHANGE;

		return function (sublistStateEventType) {
			return eventTranslations[sublistStateEventType];
		}
	}());

	function addSublistStateEventDetails(event, sublistStateEvent)
	{
		event.sublistId = sublistStateEvent.sublistState.id;
		if(sublistStateEvent.hasOwnProperty('fieldId'))
		{
			event.line = sublistStateEvent.line;
			event.currentLine = sublistStateEvent.currentLine;
			event.fieldId = sublistStateEvent.fieldId;
		}
		if(sublistStateEvent.oldValue !== undefined){ event.oldValue = sublistStateEvent.oldValue; }
		if(sublistStateEvent.newValue !== undefined){ event.newValue = sublistStateEvent.newValue; }

		return event;
	}

	function translateSublistStateEventToRecordControllerStateEvent(sublistStateEvent)
	{
		return addSublistStateEventDetails(getEvent(translateSublistStateEventTypeToRecordControllerEventType(sublistStateEvent.type)), sublistStateEvent);
	}

	function forwardSublistStateEvent(emitter, sublistStateEvent)
	{
		emitter.emit(translateSublistStateEventToRecordControllerStateEvent(sublistStateEvent));
	}

	function forwardSublistStateEvents(emitter, sublistState)
	{
		var forward = forwardSublistStateEvent.bind(null, emitter);

		sublistState.on({
			types: [
				sublistStateEvent.Type.IS_DISPLAY_CHANGE,
				sublistStateEvent.Type.IS_HIDDEN_CHANGE,
				sublistStateEvent.Type.FIELD_IS_MANDATORY_CHANGE,
				sublistStateEvent.Type.FIELD_IS_HIDDEN_CHANGE,
				sublistStateEvent.Type.FIELD_IS_DISABLED_CHANGE,
				sublistStateEvent.Type.FIELD_IS_VISIBLE_CHANGE,
				sublistStateEvent.Type.FIELD_IS_DISPLAY_CHANGE,
				sublistStateEvent.Type.FIELD_IS_READ_ONLY_CHANGE,
				sublistStateEvent.Type.FIELD_LABEL_CHANGE
			],
			listener: forward
		});
	}

	function unforwardSublistStateEvents(sublistState)
	{
		sublistState.off({
			types: [
				sublistStateEvent.Type.IS_DISPLAY_CHANGE,
				sublistStateEvent.Type.IS_HIDDEN_CHANGE,
				sublistStateEvent.Type.FIELD_IS_MANDATORY_CHANGE,
				sublistStateEvent.Type.FIELD_IS_HIDDEN_CHANGE,
				sublistStateEvent.Type.FIELD_IS_DISABLED_CHANGE,
				sublistStateEvent.Type.FIELD_IS_VISIBLE_CHANGE,
				sublistStateEvent.Type.FIELD_IS_DISPLAY_CHANGE,
				sublistStateEvent.Type.FIELD_IS_READ_ONLY_CHANGE,
				sublistStateEvent.Type.FIELD_LABEL_CHANGE
			]
		})
	}

	return Object.freeze({
		Type: EVENT_TYPE,
		forwardFieldStateEvents: forwardFieldStateEvents,
		forwardSublistStateEvents: forwardSublistStateEvents,
		unforwardSublistStateEvents: unforwardSublistStateEvents
	});
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/recordStateController
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/recordStateController',['N/record/fieldState', 'N/record/sublistState', 'N/record/recordStateControllerEvent', 'N/eventEmitter'], function(fieldState, sublistState, recordStateControllerEvent, eventEmitter){

   function createSublistState(sublistId, parentState, sublistMetadata, getModelController)
   {
      var state = sublistState.create({
            id: sublistId,
            parentState: parentState,
            sublistStateObj: sublistMetadata.defaultState,
            fieldMetadata: sublistMetadata.fieldMetadata,
            getModelController: getModelController
         });
      state.init();

      return state;
   }

    /**
     * record state controller
     * @param {Object} options
     * @param {Metadata} options.metadata
     * @param {ModelController} options.data
     * @constructor
     */
    function RecordStateController(options)
    {
        var that = this;
        var metadata = options.metadata;
        var modelController = options.data;
      var getModelController = options.getModelController;
        var isChanged = false;
       var emitter = eventEmitter.create();

        var fieldStates = {};
        var sublistStates = {};

        (function constructor(metadata, getModelController){
            var sublists = metadata.sublistIds;
            sublists.forEach(function(sublistId){
                var sublistMetadata = metadata.getSublistMetadata(sublistId);
                if(sublistMetadata)
                {
                   var sublist = createSublistState(sublistId, that, sublistMetadata, getModelController);
                   recordStateControllerEvent.forwardSublistStateEvents(emitter, sublist);
                    sublistStates[sublistId] = sublist;
                }
            });
        })(metadata, getModelController);


        /**
         * is record changed by any operations
         * @name RecordStateController#isChanged
         * @type {boolean}
         */
        Object.defineProperty(this, 'isChanged', {
            get: function ()
            {
                return isChanged;
            },
            set: function (val)
            {
                if(util.isBoolean(val))
                    isChanged = val;
            },
            enumerable: true,
            configurable: false
        });

        function createNewFieldState(fieldId)
        {
            var state;
            var fieldLevelMetadata = metadata.getFieldMetadata(undefined, fieldId);
            if(fieldLevelMetadata)
            {
                state = fieldState.createBasedOnFieldLevelMetadata({metadata: fieldLevelMetadata, parentState: that});
            }
            else
            {
               state = fieldState.create({parentState: that, fieldState: {name: fieldId, label: fieldId}});
            }
           recordStateControllerEvent.forwardFieldStateEvents(emitter, state);

            return state;
        }

        /**
         * remove field state
         * @param {string} fieldId
         */
        function removeFieldState(fieldId)
        {
            if(fieldStates.hasOwnProperty(fieldId))
                delete fieldStates[fieldId];
        }
        this.removeFieldState = removeFieldState;

        /**
         * return field state for record field
         * @param {string} fieldId
         * @return {FieldState}
         */
        function getFieldState(fieldId)
        {
            var state;
            if(fieldStates.hasOwnProperty(fieldId))
                state = fieldStates[fieldId];
            else
            {
                state = createNewFieldState(fieldId);
                fieldStates[fieldId] = state;
            }

            return state;
        }
        this.getFieldState = getFieldState;

        /**
         * return the sublist state of record sublist
         * @param {string} sublistId
         * @returns {SublistState}
         */
        function getSublistState(sublistId)
        {
            var state = null;
            if(sublistStates.hasOwnProperty(sublistId))
                state = sublistStates[sublistId];

            return state;
        }
        this.getSublistState = getSublistState;

        function addSublist(sublistId, getModelController)
        {
            removeSublist(sublistId);
            var sublistMetadata = metadata.getSublistMetadata(sublistId);
           var sublist = createSublistState(sublistId, that, sublistMetadata, getModelController);
           recordStateControllerEvent.forwardSublistStateEvents(emitter, sublist);
            sublistStates[sublistId] = sublist;
        }
        this.addSublist = addSublist;

        function removeSublist(sublistId)
        {
            var sublist = sublistStates[sublistId];
            if(!!sublist)
            {
                delete sublistStates[sublistId];
                recordStateControllerEvent.unforwardSublistStateEvents(emitter, sublist);
            }
        }

        function removeSublistFieldState(sublistId, fieldId, line)
        {
            getSublistState(sublistId).removeFieldState(fieldId, line);
            getSublistState(sublistId).isChanged = true;
        }
        this.removeSublistFieldState = removeSublistFieldState;


        function getAllFields()
        {
            var arr = [];
            for(var f in fieldStates)
                if(fieldStates.hasOwnProperty(f))
                    arr.push(f);
            return arr;
        }
        this.getAllFields = getAllFields;
        function getAllSublists()
        {
            var arr = [];
            for(var sublistId in sublistStates)
                if(sublistStates.hasOwnProperty(sublistId))
                    arr.push(sublistId);
            return arr;
        }
        this.getAllSublists = getAllSublists;

      this.on = emitter.on;
      this.off = emitter.off;
    }

    return {
        /**
         * return a new instance of RecordStateController
         * @param {Object} options
         * @returns {RecordStateController}
         */
        create: function(options) { return new RecordStateController(options); },
        /**
         * return true if object is an instance of FieldStates
         * @param {Object} obj
         * @returns {boolean}
         */
        isInstance: function(obj) { return obj instanceof RecordStateController; }
    };
});

/**
 * @private
 */
define('N/restricted/fieldClientScriptHandler',['N/restricted/reflet'], function(reflet){ return reflet; });

/**
 * SuiteScript module
 *
 * @private
 * @module N/util/validator
 * @suiteScriptVersion 2.x
 */
define(
	'N/util/validator',['N/util/date','N/error','N/format','N/fieldTypeConstants','N/utilityFunctions'],
	function (DateUtil, error, format, fieldTypeConstants, utilityFunctions){

		// For Email Validation  
		var TLD_PATTERN = "zw|zuerich|zone|zm|zippo|zip|zero|zara|zappos|za|yun|yt|youtube|you|yokohama|yoga|yodobashi|ye|yandex|yamaxun|yahoo|yachts|xyz|xxx|xperia|xn--zfr164b|xn--ygbi2ammx|xn--yfro4i67o|xn--y9a3aq|xn--xkc2dl3a5ee0h|xn--xkc2al3hye2a|xn--xhq521b|xn--wgbl6a|xn--wgbh1c|xn--w4rs40l|xn--w4r85el8fhu5dnra|xn--vuq861b|xn--vhquv|xn--vermgensberatung-pwb|xn--vermgensberater-ctb|xn--unup4y|xn--tiq49xqyj|xn--tckwe|xn--t60b56a|xn--ses554g|xn--s9brj9c|xn--rovu88b|xn--rhqv96g|xn--qxam|xn--qcka1pmc|xn--q9jyb4c|xn--pssy2u|xn--pgbs0dh|xn--pbt977c|xn--p1ai|xn--p1acf|xn--ogbpf8fl|xn--o3cw4h|xn--nyqy26a|xn--nqv7fs00ema|xn--nqv7f|xn--node|xn--ngbe9e0a|xn--ngbc5azd|xn--mxtq1m|xn--mk1bu44c|xn--mix891f|xn--mgbx4cd0ab|xn--mgbtx2b|xn--mgbt3dhd|xn--mgbpl2fh|xn--mgbi4ecexp|xn--mgberp4a5d4ar|xn--mgbca7dzdo|xn--mgbc0a9azcg|xn--mgbbh1a71e|xn--mgbb9fbpob|xn--mgbayh7gpa|xn--mgbab2bd|xn--mgbaam7a8h|xn--mgba7c0bbn0a|xn--mgba3a4f16a|xn--mgba3a3ejt|xn--mgb9awbf|xn--lgbbat1ad8j|xn--l1acc|xn--kput3i|xn--kpu716f|xn--kpry57d|xn--kprw13d|xn--kcrx77d1x4a|xn--jvr189m|xn--jlq61u9w7b|xn--j6w193g|xn--j1amh|xn--j1aef|xn--io0a7i|xn--imr513n|xn--i1b6b1a6a2e|xn--hxt814e|xn--h2brj9c|xn--gk3at1e|xn--gecrj9c|xn--gckr3f0f|xn--g2xx48c|xn--fzys8d69uvgm|xn--fzc2c9e2c|xn--fpcrj9c3d|xn--flw351e|xn--fjq720a|xn--fiqz9s|xn--fiqs8s|xn--fiq64b|xn--fiq228c5hs|xn--fhbei|xn--fct429k|xn--estv75g|xn--efvy88h|xn--eckvdtc9d|xn--e1a4c|xn--d1alf|xn--d1acj3b|xn--czru2d|xn--czrs0t|xn--czr694b|xn--co-pka|xn--clchc0ea0b2g2a9gcd|xn--cg4bki|xn--cck2b3b|xn--c2br7g|xn--c1avg|xn--bck1b9a5dre4c|xn--b4w605ferd|xn--9krt00a|xn--9et52u|xn--9dbq2a|xn--90ais|xn--90ae|xn--90a3ac|xn--8y0a063a|xn--80aswg|xn--80asehdb|xn--80aqecdr1a|xn--80ao21a|xn--80adxhks|xn--6qq986b3xl|xn--6frz82g|xn--5tzm5g|xn--5su34j936bgsg|xn--55qx5d|xn--55qw42g|xn--54b7fta0cc|xn--4gbrim|xn--45q11c|xn--45brj9c|xn--42c2d9a|xn--3pxu8k|xn--3oq18vl8pn36a|xn--3e0b707e|xn--3ds443g|xn--3bst00m|xn--30rr7y|xn--1qqw23a|xn--1ck2e1b|xn--11b4c3d|xin|xihuan|xfinity|xerox|xbox|wtf|wtc|ws|wow|world|works|work|woodside|wolterskluwer|wme|winners|wine|windows|win|williamhill|wiki|wien|whoswho|wf|weir|weibo|wedding|wed|website|weber|webcam|weatherchannel|weather|watches|watch|warman|wanggou|wang|walter|walmart|wales|vuelos|vu|voyage|voto|voting|vote|volvo|volkswagen|vodka|vn|vlaanderen|vivo|viva|vistaprint|vista|vision|visa|virgin|vip|vin|villas|viking|vig|video|viajes|vi|vg|vet|versicherung|verisign|ventures|vegas|ve|vc|vanguard|vana|vacations|va|uz|uy|us|ups|uol|uno|university|unicom|uk|ug|uconnect|ubs|ubank|ua|tz|tw|tvs|tv|tushu|tunes|tui|tube|tt|trv|trust|travelersinsurance|travelers|travelchannel|travel|training|trading|trade|tr|toys|toyota|town|tours|total|toshiba|toray|top|tools|tokyo|today|to|tn|tmall|tm|tl|tkmaxx|tk|tjx|tjmaxx|tj|tirol|tires|tips|tiffany|tienda|tickets|tiaa|theatre|theater|thd|th|tg|tf|teva|tennis|temasek|telefonica|telecity|tel|technology|tech|team|tdk|td|tci|tc|taxi|tax|tattoo|tatar|tatamotors|target|taobao|talk|taipei|tab|sz|systems|symantec|sydney|sy|sx|swiss|swiftcover|swatch|sv|suzuki|surgery|surf|support|supply|supplies|sucks|su|style|study|studio|stream|store|storage|stockholm|stcgroup|stc|statoil|statefarm|statebank|starhub|star|staples|stada|st|srt|srl|sr|spreadbetting|spot|spiegel|space|soy|sony|song|solutions|solar|sohu|software|softbank|social|soccer|so|sncf|sn|smile|smart|sm|sling|sl|skype|sky|skin|ski|sk|sj|site|singles|sina|silk|si|shriram|showtime|show|shouji|shopping|shop|shoes|shiksha|shia|shell|shaw|sharp|shangrila|sh|sg|sfr|sexy|sex|sew|seven|ses|services|sener|select|seek|security|secure|seat|se|sd|scot|scor|scjohnson|science|schwarz|schule|school|scholarships|schmidt|schaeffler|scb|sca|sc|sbs|sbi|sb|saxo|save|sas|sarl|sapo|sap|sanofi|sandvikcoromant|sandvik|samsung|samsclub|salon|sale|sakura|safety|safe|saarland|sa|ryukyu|rwe|rw|run|ruhr|ru|rsvp|rs|room|rogers|rodeo|rocks|rocher|ro|rmit|rip|rio|ril|rightathome|ricoh|richardli|rich|rexroth|reviews|review|restaurant|rest|republican|report|repair|rentals|rent|ren|reliance|reit|reisen|reise|rehab|redumbrella|redstone|red|recipes|realty|realtor|realestate|read|re|raid|radio|racing|qvc|quest|quebec|qpon|qa|py|pwc|pw|pub|pt|ps|prudential|pru|protection|property|properties|promo|progressive|prof|productions|prod|pro|prime|press|praxi|pramerica|pr|post|porn|politie|poker|pohl|pnc|pn|pm|plus|plumbing|playstation|play|place|pl|pk|pizza|pioneer|pink|ping|pin|pid|pictures|pictet|pics|piaget|physio|photos|photography|photo|philips|pharmacy|ph|pg|pfizer|pf|pet|pe|pccw|pay|passagens|party|parts|partners|pars|paris|panerai|panasonic|pamperedchef|page|pa|ovh|ott|otsuka|osaka|origins|orientexpress|organic|org|orange|oracle|open|ooo|onyourside|online|onl|ong|one|omega|om|ollo|oldnavy|olayangroup|olayan|okinawa|office|off|observer|obi|nz|nyc|nu|ntt|nrw|nra|nr|np|nowtv|nowruz|now|norton|northwesternmutual|nokia|no|nl|nissay|nissan|ninja|nikon|nike|nico|ni|nhk|ngo|ng|nfl|nf|nexus|nextdirect|next|news|newholland|new|neustar|network|netflix|netbank|net|nec|ne|nc|nba|navy|natura|nationwide|name|nagoya|nadex|nab|na|mz|my|mx|mw|mv|mutuelle|mutual|museum|mu|mtr|mtpc|mtn|mt|msd|ms|mr|mq|mp|movistar|movie|mov|motorcycles|moto|moscow|mortgage|mormon|mopar|montblanc|monster|money|monash|mom|moi|moe|moda|mobily|mobi|mo|mn|mma|mm|mls|mlb|ml|mk|mitsubishi|mit|mint|mini|mil|microsoft|miami|mh|mg|metlife|meo|menu|men|memorial|meme|melbourne|meet|media|med|me|md|mckinsey|mcdonalds|mcd|mc|mba|mattel|maserati|marshalls|marriott|markets|marketing|market|mango|management|man|makeup|maison|maif|madrid|macys|ma|ly|lv|luxury|luxe|lupin|lundbeck|lu|ltda|ltd|lt|ls|lr|lplfinancial|lpl|love|lotto|lotte|london|lol|loft|locus|locker|loans|loan|lk|lixil|living|live|lipsy|link|linde|lincoln|limo|limited|lilly|like|lighting|lifestyle|lifeinsurance|life|lidl|liaison|li|lgbt|lexus|lego|legal|lefrak|leclerc|lease|lds|lc|lb|lawyer|law|latrobe|latino|lat|lasalle|lanxess|landrover|land|lancome|lancia|lancaster|lamer|lamborghini|ladbrokes|lacaixa|la|kz|kyoto|ky|kw|kuokgroup|kred|krd|kr|kpn|kpmg|kp|kosher|komatsu|koeln|kn|km|kiwi|kitchen|kindle|kinder|kim|kia|ki|kh|kg|kfh|kerryproperties|kerrylogistics|kerryhotels|ke|kddi|kaufen|juniper|juegos|jprs|jpmorgan|jp|joy|jot|joburg|jobs|jo|jnj|jmp|jm|jll|jlc|jio|jewelry|jetzt|jeep|je|jcp|jcb|java|jaguar|iwc|iveco|itv|itau|it|istanbul|ist|ismaili|iselect|is|irish|ir|iq|ipiranga|io|investments|intuit|international|intel|int|insure|insurance|institute|ink|ing|info|infiniti|industries|in|immobilien|immo|imdb|imamat|im|il|ikano|iinet|ifm|ieee|ie|id|icu|ice|icbc|ibm|hyundai|hyatt|hughes|hu|htc|ht|hsbc|hr|how|house|hotmail|hoteles|hot|hosting|host|hospital|horse|honeywell|honda|homesense|homes|homegoods|homedepot|holiday|holdings|hockey|hn|hm|hkt|hk|hiv|hitachi|hisamitsu|hiphop|hgtv|hermes|here|helsinki|help|healthcare|health|hdfcbank|hdfc|hbo|haus|hangout|hamburg|hair|gy|gw|guru|guitars|guide|guge|gucci|guardian|gu|gt|gs|group|gripe|green|gratis|graphics|grainger|gr|gq|gp|gov|got|gop|google|goog|goodyear|goodhands|goo|golf|goldpoint|gold|godaddy|gn|gmx|gmo|gmbh|gmail|gm|globo|global|gle|glass|glade|gl|giving|gives|gifts|gift|gi|gh|ggee|gg|gf|george|genting|gent|gea|ge|gdn|gd|gbiz|gb|garden|gap|games|game|gallup|gallo|gallery|gal|ga|fyi|futbol|furniture|fund|fujixerox|fujitsu|ftr|frontier|frontdoor|frogans|frl|fresenius|free|fr|fox|foundation|forum|forsale|forex|ford|football|foodnetwork|food|foo|fo|fm|fly|flowers|florist|flir|flights|flickr|fk|fj|fitness|fit|fishing|fish|firmdale|firestone|fire|financial|finance|final|film|fido|fidelity|fiat|fi|ferrero|ferrari|feedback|fedex|fast|fashion|farmers|farm|fans|fan|family|faith|fairwinds|fail|fage|extraspace|express|exposed|expert|exchange|everbank|events|eus|eurovision|eu|et|esurance|estate|esq|es|erni|ericsson|er|equipment|epson|epost|enterprises|engineering|engineer|energy|emerck|email|eg|ee|education|edu|edeka|eco|ec|eat|earth|dz|dvr|dvag|durban|dupont|duns|dunlop|duck|dubai|dtv|drive|download|dot|domains|doha|dog|dodge|doctor|docs|do|dnp|dm|dk|dj|diy|dish|discover|discount|directory|direct|digital|diet|diamonds|dhl|dev|design|desi|dentist|dental|democrat|delta|deloitte|dell|delivery|degree|deals|dealer|deal|de|dds|dclk|day|datsun|dating|date|dance|dad|dabur|cz|cyou|cymru|cy|cx|cw|cv|cuisinella|cu|csc|cruises|cruise|crs|crown|cricket|creditunion|creditcard|credit|cr|courses|coupons|coupon|country|corsica|corp|coop|cool|cookingchannel|cooking|contractors|contact|consulting|construction|condos|comsec|computer|compare|company|community|commbank|comcast|com|cologne|college|coffee|codes|coach|co|cn|cm|clubmed|club|cloud|clothing|clinique|clinic|click|cleaning|claims|cl|ck|cityeats|city|citic|citi|citadel|cisco|circle|cipriani|ci|church|chrysler|chrome|christmas|chloe|chintai|cheap|chat|chase|channel|chanel|ch|cg|cfd|cfa|cf|cern|ceo|center|ceb|cd|cc|cbs|cbre|cbn|cba|catholic|catering|cat|casino|cash|caseih|case|casa|cartier|cars|careers|career|care|cards|caravan|car|capitalone|capital|capetown|canon|cancerresearch|camp|camera|cam|calvinklein|call|cal|cafe|cab|ca|bzh|bz|by|bw|bv|buzz|buy|business|builders|build|bugatti|budapest|bt|bs|brussels|brother|broker|broadway|bridgestone|bradesco|br|box|boutique|bot|boston|bostik|bosch|boots|booking|book|boo|bond|bom|bofa|boehringer|boats|bo|bnpparibas|bnl|bn|bmw|bms|bm|blue|bloomberg|blog|blockbuster|blanco|blackfriday|black|bj|biz|bio|bingo|bing|bike|bid|bible|bi|bharti|bh|bg|bf|bet|bestbuy|best|berlin|bentley|beer|beauty|beats|be|bd|bcn|bcg|bbva|bbt|bbc|bb|bayern|bauhaus|basketball|baseball|bargains|barefoot|barclays|barclaycard|barcelona|bar|bank|band|bananarepublic|banamex|baidu|baby|ba|azure|az|axa|ax|aws|aw|avianca|autos|auto|author|auspost|audio|audible|audi|au|attorney|athleta|at|associates|asia|asda|as|arte|art|arpa|army|archi|aramco|ar|aquarelle|aq|apple|app|apartments|aol|ao|anz|anquan|android|analytics|amsterdam|amica|amfam|amex|americanfamily|americanexpress|am|alstom|alsace|ally|allstate|allfinanz|alipay|alibaba|alfaromeo|al|akdn|airtel|airforce|airbus|aigo|aig|ai|agency|agakhan|ag|afl|afamilycompany|af|aetna|aero|aeg|ae|adult|ads|adac|ad|actor|active|aco|accountants|accountant|accenture|academy|ac|abudhabi|abogado|able|abc|abbvie|abbott|abb|abarth|aarp|aaa";
		var DOMAIN_PART_PATTERN = "(?:[a-z0-9]+(?:-+[a-z0-9]+)*\\.)+(?:" + TLD_PATTERN + ")";
		var SIMPLE_EMAIL_PATTERN_LOCAL_PART = "[-a-z0-9!#$%&'*+/=?^_`{|}~]+(?:\\.[-a-z0-9!#$%&'*+/=?^_`{|}~]+)*";
		var SIMPLE_EMAIL_PATTERN = "^" + SIMPLE_EMAIL_PATTERN_LOCAL_PART + '@' + DOMAIN_PART_PATTERN + "$";
		var DISPLAY_NAME_PATTERN = "(?:\\\\[^\\x00-\\x1f]|[^\"\\x00-\\x1f])*";
		var COMPOUND_EMAIL_PATTERN = "\""+ DISPLAY_NAME_PATTERN +"\"[ \\t]*<" + SIMPLE_EMAIL_PATTERN + ">";
	
		var DIGIT_ONLY_REGEX = /^[0-9]+$/;
		var LOWERALPHANUMERIC_UNDERSCORE_REGEX = /^[0-9a-z_]+$/;
		var ALPHANUMERIC_UNDERSCORE_REGEX = /^[0-9A-Za-z_]+$/;
		var T_OR_F_REGEX = /(T|F)/;
		var COLOR_HEX_REGEX = /^#[0-9a-fA-F]{6}$/;
		var ASCII_CHARS_REGEX = /^[\x20-\x7E]+$/;
		var PACKAGE_REGEX = /^[a-z0-9]+(\.[a-z0-9]+){2}$/;
		var FURIGANA_REGEX = /^[\u0020\u3000\u30A0-\u30FF\uFF61-\uFF9F]+$/;
		var FUNCTION_REGEX = /^[0-9A-Za-z_$]+(\.[0-9A-Za-z_$]+)*$/;
	
		var NON_EMAIL_DELIMITER_REGEX_G = /("[^"\u0000-\u001f]*"|[^,;\n\r])+/g;
		var NON_ALPHANUMERIC_REGEX_G = /[^a-zA-Z0-9]/g;
	
		/**
		 *  validate[type] or validateAndFormat[type] summary
		 *  [type] is determined based on the fieldType
		 *
		 *  @param toValidate - the value to validate
		 *
		 *  @returns object with the following:
		 *  isValid				 - whether the inputted value was valid or not
		 *  formattedValue		  - the value reformatted appropriately (if just a validateXXXX function, it will equal toValidate)
		 *							if isValid = F, should return an empty string.
		 *
		 *  You can optionally return a code and message (key) from error module ERROR_TYPES to throw specific errors
		 *  errorCode (optional)	- the error code to send back, default: INVALID_FLD_VALUE
		 *  errorMsgKey (optional)  - *just* the message key which will retrieve the desired message later, default: INVALID_FIELD_VALUE
		 *							Will fill in {1} as fieldValue and {2} as fieldName.
		 *  errorFullMsg (optional) - the *entire* message in which to use when throwing error. Use if errorMsgKey does not satisfy your reqs
		 *							You will need to call util.getErrorMessage(yourMessageKey, param1, param2, ...) on your own
		 *							If present, will ignore errorMsgKey.
		 */
	
		// General case where only a test on a specific regex is necessary, and no specific error message is required
		function validateByRegexTest(toValidate, regexPattern, msgKeyOnFail)
		{
			if (!regexPattern.test(toValidate))
			{
				if (!!msgKeyOnFail)
					return {isValid: false, formattedValue: toValidate, errorMsgKey: msgKeyOnFail};
				else
					return {isValid: false, formattedValue: ""};
			}
			else
			{
				return {isValid: true, formattedValue: toValidate};
			}
		}
	
		function validateDateObject(toValidate)
		{
			if ( !(toValidate instanceof Date || Object.prototype.toString.call(toValidate) === '[object Date]') )
			{
				return {isValid: false, formattedValue: ""};
			}
			else if(Object.prototype.toString.call(toValidate) === '[object Date]' && isNaN(toValidate.getDay()))
			{
				return {isValid: false, formattedValue: ""};
			}
			else if (DateUtil.isDateTooOld(toValidate))
			{
				var errorMsg = utilityFunctions.getErrorMessage(error.Type.INVALID_DATE_VALUE_MUST_BE_ON_OR_AFTER_1CUTOFF_DATE, DateUtil.getOldestDateString());
				return {isValid: false, formattedValue: toValidate, errorFullMsg: errorMsg}
			}
			else
			{
				return {isValid: true, formattedValue: toValidate};
			}
		}
	
		function validateMMYYDateObject(toValidate)
		{
			if ( !(toValidate instanceof Date || Object.prototype.toString.call(toValidate) === '[object Date]') || toValidate.getFullYear() < 1900 || toValidate.getFullYear() > 2100 )
			{
				return {isValid: false, formattedValue: ""};
			}
			else
			{
				return {isValid: true, formattedValue: toValidate};
			}
		}
	
		function isWithinMinMax(toValidate, minVal, maxVal)
		{
			var numVal = parseFloat(toValidate);
			var minimum = isNaN(parseFloat(minVal)) ?  -Number.MAX_VALUE : minVal;
			var maximum = isNaN(parseFloat(maxVal)) ?  Number.MAX_VALUE : maxVal;
	
			if (numVal < minimum || numVal > maximum)
			{
				var fullErrorMsg = utilityFunctions.getErrorMessage(error.Type.INVALID_NUMBER_MUST_BE_BETWEEN_1_AND_2, String(minVal), String(maxVal));
				return {isValid: false, formattedValue: "", errorFullMsg: fullErrorMsg};
			}
			else
			{
				return {isValid: true, formattedValue: toValidate};
			}
		}

		function validateBoolean(toValidate)
		{
			if(toValidate === true || toValidate === false || toString.call(toValidate) === '[object Boolean]')
				return {isValid: true, formattedValue: toValidate} ;
			else
				return {isValid: false, formattedValue: ""};
		}
	
		function validateInteger(toValidate, posOnly, minVal, maxVal)
		{
			var numVal = parseInt(toValidate, 10);
			if (isNaN(toValidate) || (parseFloat(toValidate) !== numVal) || (posOnly && (numVal <= 0) ) )
			{
				return {isValid: false, formattedValue: ""} ;
			}
			else
			{
				return isWithinMinMax(toValidate, minVal, maxVal);
			}
		}
	
		function validateNumericValue(toValidate, minVal, maxVal, fieldType)
		{
			if ( isNaN(toValidate) || isNaN(parseFloat(toValidate)))
			{
				return { isValid: false, formattedValue: "", errorMsgKey: error.Type.INVALID_NUMBER_OR_PERCENTAGE} ;
			}
	
			var numVal = parseFloat(toValidate);
			var minimum = isNaN(parseFloat(minVal)) ?  -Number.MAX_VALUE : minVal;
			var maximum = isNaN(parseFloat(maxVal)) ?  Number.MAX_VALUE : maxVal;

			if(fieldType !== null && fieldType !== undefined)
			{
				if ((fieldType === fieldTypeConstants.Type.POSFLOAT) || (fieldType === fieldTypeConstants.Type.POSCURRENCY))
				{
					minimum = Number.MIN_VALUE;
				}
				else if ((fieldType === fieldTypeConstants.Type.NONNEGFLOAT) || (fieldType === fieldTypeConstants.Type.NONNEGCURRENCY))
				{
					minimum = 0;
				}
			}

			return isWithinMinMax(numVal, minimum, maximum);
		}
	
		function validateEmail(toValidate)
		{
			var simpleEmailRegex = new RegExp(SIMPLE_EMAIL_PATTERN, "i");
			var compoundEmailRegex = new RegExp(COMPOUND_EMAIL_PATTERN, "i");
	
			var testResult = simpleEmailRegex.test(toValidate) || compoundEmailRegex.test(toValidate);
	
			return {isValid: testResult, formattedValue: toValidate};
		}
	
		function validateEmails(toValidate)
		{
			var emailList = toValidate.split(/[,;\n\r]/);
			var bademails = [];
	
			for (var i = 0; i < emailList.length; i++)
			{
				var anEmail = util.trim(emailList[i]);
				if (anEmail === "")
					continue;
				if (!validateEmail(anEmail).isValid)
					bademails.push(anEmail);
			}
			if (bademails.length > 0)
			{
				var badEmailString = bademails.join(" ");
				var fullErrorMsg = utilityFunctions.getErrorMessage(error.Type.INVALID_EMAILS_FOUND) + badEmailString;
				return {isValid: false, formattedValue: "", errorFullMsg: fullErrorMsg};
			}
			return {isValid: true, formattedValue: toValidate};
		}
	
		function validateUrl(toValidate)
		{
			var val = toValidate.toLowerCase();
	
			if ( !(val.indexOf('/') === 0 || val.indexOf('http://') === 0 || val.indexOf('https://') === 0 || val.indexOf('ftp://') === 0 || val.indexOf('file://') === 0) )
			{
				return {isValid: false, formattedValue: "", errorMsgKey: error.Type.INVALID_URL_URL_MUST_START_WITH_HTTP_HTTPS_FTP_OR_FILE};
			}
	
			if (val.indexOf(' ') > 0 || val.indexOf('\t') > 0)
			{
				return {isValid: false, formattedValue: "", errorMsgKey: error.Type.INVALID_URL_SPACES_ARE_NOT_ALLOWED_IN_THE_URL};
			}
	
			return {isValid: true, formattedValue: toValidate};
		}
	
		function validateCCNumber(toValidate)
		{
			var cardnum = toValidate;
			// This is for credit card numbers. Do not validate if it is masked (i.e. all but last 4 numbers are masked)
			if ((cardnum.length > 4) &&
				(cardnum.slice(0, -4).replace(new RegExp( "\\*", "g" ), '').length === 0) &&
				(cardnum.slice(-4).replace(new RegExp( "\\*", "g" ), '').length === 4))
			{
				isValid = true;
				return cardnum;
			}
			else //adapted from checkccnumber (NLRecordUtil.js)
			{
				if (cardnum.length < 13 || cardnum.length > 20)
				{
					return {isValid: false, formattedValue: "", errorMsgKey: error.Type.CREDIT_CARD_NUMBERS_MUST_CONTAIN_BETWEEN_13_AND_20_DIGITS};
				}
				if (!DIGIT_ONLY_REGEX.test(cardnum))
				{
					return {isValid: false, formattedValue: "", errorMsgKey: error.Type.CREDIT_CARD_NUMBER_MUST_CONTAIN_ONLY_DIGITS};
				}
	
				// Perform Luhn check
				// http://www.ling.nwu.edu/~sburke/pub/luhn_lib.pl
				var no_digit = cardnum.length;
				var oddoeven = no_digit & 1;
				var sum = 0;
	
				for (var count = 0; count < no_digit; count++)
				{
					var digit = parseInt(cardnum.charAt(count),10);
					if (!((count & 1) ^ oddoeven))
					{
						digit *= 2;
						if (digit > 9)
							digit -= 9;
					}
					sum += digit;
				}
				if (sum % 10 !== 0)
				{
					return {isValid: false, formattedValue: "", errorMsgKey: error.Type.CREDIT_CARD_NUMBER_IS_NOT_VALID__PLEASE_CHECK_THAT_ALL_DIGITS_WERE_ENTERED_CORRECTLY};
				}
	
				return {isValid: true, formattedValue: toValidate};
			}
		}
	
		function validatePhoneNumber(toValidate, isFullPhoneType)
		{
			// Fail immediately if any non-ascii characters are found [0x20 (space) - 0x7E (~)]
			if ( !(ASCII_CHARS_REGEX.test(toValidate)) )
			{
				return {isValid: false, formattedValue: ""};
			}
			// Remove all non-alphanumeric characters to check if valid.
			var validPhoneDigits = toValidate.replace(NON_ALPHANUMERIC_REGEX_G, '');
			if (validPhoneDigits.length < 7)
			{
				return {isValid: false, formattedValue: "",  errorMsgKey: error.Type.PHONE_NUMBER_SHOULD_HAVE_SEVEN_DIGITS_OR_MORE};
			}
	
			if (isFullPhoneType && (validPhoneDigits.length < 10) )
			{
				return {isValid: false, formattedValue: "",  errorMsgKey: error.Type.PLEASE_INCLUDE_THE_AREA_CODE_FOR_PHONE_NUMBER};
			}
	
			return {isValid: true, formattedValue: toValidate}
		}
	
		function validateIdentifier(toValidate, lowercaseOnly)
		{
			var re = lowercaseOnly ? LOWERALPHANUMERIC_UNDERSCORE_REGEX : ALPHANUMERIC_UNDERSCORE_REGEX;
			if (!re.test(toValidate))
			{
				return {isValid: false, formattedValue: "", errorMsgKey: error.Type.IDENTIFIERS_CAN_CONTAIN_ONLY_DIGITS_ALPHABETIC_CHARACTERS_OR__WITH_NO_SPACES};
			}
			else
				return {isValid: true, formattedValue: toValidate};
		}
	
		function validateCCDate(toValidate, checkNotBeforeToday)
		{
			var toValidateDate = toValidate.split("/");
			// must be in MM/YYYY form
			if (toValidate.length !== 7 || toValidateDate.length !== 2 || toValidateDate[0].length !== 2 || toValidateDate[1].length !== 4)
			{
				errorKey = checkNotBeforeToday ? error.Type.PLEASE_ENTER_AN_EXPIRATION_DATE_IN_MMYYYY_FORMAT
											   : error.Type.PLEASE_ENTER_A_VALID_FROM_START_DATE_IN_MMYYYY_FORMAT;
				return {isValid: false, formattedValue: "", errorMsgKey: errorKey};
			}
			else
			{
				var toValidateMonth = DIGIT_ONLY_REGEX.test(toValidateDate[0]) ? parseInt(toValidateDate[0], 10) : NaN;
				var toValidateYear = DIGIT_ONLY_REGEX.test(toValidateDate[1]) ? parseInt(toValidateDate[1], 10) : NaN;
				if (isNaN(toValidateMonth) || toValidateMonth < 1 || toValidateMonth > 12 ||
					isNaN(toValidateYear) || toValidateYear < 1000)
				{
					return {isValid: false, formattedValue: "", errorMsgKey:  error.Type.NOTICE_THE_CREDIT_CARD_APPEARS_TO_BE_INCORRECT};
				}
				else
				{
					var today = new Date();
					if (	checkNotBeforeToday && (toValidateYear < today.getFullYear() || ( (toValidateYear === today.getFullYear()) && toValidateMonth < (today.getMonth() + 1) ))
						|| !checkNotBeforeToday && (toValidateYear > today.getFullYear() || ( (toValidateYear === today.getFullYear()) && toValidateMonth > (today.getMonth() + 1) )) )
					{
						return {isValid: false, formattedValue: "", errorMsgKey:  error.Type.NOTICE_THE_CREDIT_CARD_APPEARS_TO_BE_INCORRECT};
					}
					else
					{
						return {isValid: true, formattedValue: toValidate};
					}
				}
			}
		}
	
		/**
		 * validateValueLength
		 * Checks whether fieldValue is no greater than maxLen (given it is a positive value).
		 * Throws error if fieldValue is longer than maxLen.
		 * If strictValidation is true, then ensures its value is checked even if fieldValue is numeric.
		 * @param fieldName - name of given field
		 * @param fieldValue - value of given field
		 * @param maxLen - cross reference getFieldLength() in NLRecordFieldUtil.java for the value used
		 * @param useStrict - strictly apply to all value types
		 */
		function validateValueLength(fieldName, fieldValue, maxLen, useStrict)
		{
			var validateMe = (useStrict && !isNaN(parseFloat(fieldValue)) && isFinite(fieldValue)) ? ("" + fieldValue) : fieldValue;
			if ( !isNaN(maxLen) && (maxLen > 0) && (validateMe.length > maxLen) )
			{
				throwError({name: error.Type.INVALID_FLD_VALUE,
					           message: utilityFunctions.getErrorMessage(error.Type.THE_FIELD_1_CONTAINED_MORE_THAN_THE_MAXIMUM_NUMBER__2__OF_CHARACTERS_ALLOWED, fieldName, maxLen)});
			}
		}

		/**
		 * validateField
		 * validates the fieldValue from fieldName based on its fieldType, and possibly formats appropriately.
		 * Does nothing if fieldValue is empty UNLESS it is a checkbox
		 *
		 * @param fieldName, fieldType, fieldValue - self explanatory
		 * @param fieldType
		 * @param fieldValue
		 * @param isNum
		 * @param isCurr
		 * @param validationType - gives a specific type for validation ('function' uses this)
		 * @param minVal - minimum valid value
		 * @param maxVal - maximum valid value
		 * @param maxLength - maximum valid length for fieldValue (cross-check NLRecordFieldType.java:getFieldLength )
		 * @param useStrict - record is in a mode that requires stricter validation
		 *
		 * Throws error if fieldValue is invalid or null/undefined
		 * @returns {object} fieldValue
		 * @param mandatory
		 */
		function validateField(fieldName, fieldType, fieldValue, isNum, isCurr, validationType, minVal, maxVal, maxLength, mandatory, useStrict)
		{
			if ((fieldValue === undefined) || (fieldValue === null) || (fieldValue.length === 0))
			{
				if (mandatory)
				{
					throwError({name: error.Type.INVALID_FLD_VALUE,
							message: utilityFunctions.getErrorMessage(error.Type.FIELD_MUST_CONTAIN_A_VALUE)});
				}
				else if(fieldType !== fieldTypeConstants.Type.CHECKBOX)
				{
					return fieldValue;
				}
			}
	
	
			var isNumeric =   isNum || (fieldType === fieldTypeConstants.Type.INTEGER) || (fieldType === fieldTypeConstants.Type.POSINTEGER)
									|| (fieldType === fieldTypeConstants.Type.FLOAT)   || (fieldType === fieldTypeConstants.Type.POSFLOAT)
									|| (fieldType === fieldTypeConstants.Type.NONNEGFLOAT) || (fieldType === fieldTypeConstants.Type.PERCENT)
									|| (fieldType === fieldTypeConstants.Type.RATE) || (fieldType === fieldTypeConstants.Type.RATEHIGHPRECISION);
			var isCurrency = isCurr || (fieldType === fieldTypeConstants.Type.POSCURRENCY) || (fieldType === fieldTypeConstants.Type.CURRENCY)
									|| (fieldType === fieldTypeConstants.Type.CURRENCY2) || (fieldType === fieldTypeConstants.Type.NONNEGCURRENCY);

			// TIME internally converts string time to numeric which can cause unnecessary length error.
			useStrict = useStrict && (fieldType !== fieldTypeConstants.Type.TIME);
			validateValueLength(fieldName, fieldValue, maxLength, useStrict);
	
			switch(true)
			{
				case (fieldType === fieldTypeConstants.Type.DATE) ||
					 (fieldType === fieldTypeConstants.Type.TIMEOFDAY) ||
                     (fieldType === fieldTypeConstants.Type.DATETIME) ||
					 (fieldType === fieldTypeConstants.Type.DATETIMETZ):
					validationPackage = validateDateObject(fieldValue);
					break;
	
				case (fieldType === fieldTypeConstants.Type.MMYYDATE):
					validationPackage = validateMMYYDateObject(fieldValue);
					break;
	
				case (fieldType === fieldTypeConstants.Type.INTEGER):
					validationPackage = validateInteger(fieldValue, false, minVal, maxVal);
					break;
	
				case (fieldType === fieldTypeConstants.Type.POSINTEGER):
					validationPackage = validateInteger(fieldValue, true, minVal, maxVal);
					break;
	
				case (fieldType === fieldTypeConstants.Type.TIMETRACK) ||
					 (fieldType === fieldTypeConstants.Type.RATE) ||
					 (fieldType === fieldTypeConstants.Type.RATEHIGHPRECISION):
					validationPackage = validateNumericValue(fieldValue, minVal, maxVal);
					break;
	
				case (fieldType === fieldTypeConstants.Type.TIME):
					minVal = (!minVal || (minVal < 0)) ? 0 : minVal;
					validationPackage = validateNumericValue(fieldValue, minVal, maxVal);
					break;
	
				case (fieldType === fieldTypeConstants.Type.PERCENT):
					validationPackage = validateNumericValue(fieldValue, minVal, maxVal);
					break;
	
				case ( !!isNumeric || !!isCurrency ):
					validationPackage = validateNumericValue(fieldValue, minVal, maxVal, fieldType);
					break;
	
				case (fieldType === fieldTypeConstants.Type.EMAIL):
					validationPackage = validateEmail(fieldValue);
					break;
	
				case (fieldType === fieldTypeConstants.Type.EMAILS):
					validationPackage = validateEmails(fieldValue);
					break;
	
				case (fieldType === fieldTypeConstants.Type.URL):
					validationPackage = validateUrl(fieldValue);
					break;
	
				case (fieldType === fieldTypeConstants.Type.CHECKBOX):
					validationPackage = validateBoolean(fieldValue);
					break;
	
				case (fieldType === fieldTypeConstants.Type.CCNUMBER):
					validationPackage = validateCCNumber(fieldValue);
					break;
	
				case (fieldType === fieldTypeConstants.Type.PHONE):
					validationPackage = validatePhoneNumber(fieldValue, false);
					break;
	
				case (fieldType === fieldTypeConstants.Type.FULLPHONE):
					validationPackage = validatePhoneNumber(fieldValue, true);
					break;
	
				case (fieldType === fieldTypeConstants.Type.IDENTIFIER):
					validationPackage = validateIdentifier(fieldValue, true);
					break;
	
				case (fieldType === fieldTypeConstants.Type.IDENTIFIERANYCASE):
					validationPackage = validateIdentifier(fieldValue, false);
					break;
	
				case (fieldType === fieldTypeConstants.Type.CCEXPDATE):
					validationPackage = validateCCDate(fieldValue, true);
					break;
	
				case (fieldType === fieldTypeConstants.Type.CCVALIDFROM):
					validationPackage = validateCCDate(fieldValue, false);
					break;
	
				case (fieldType === fieldTypeConstants.Type.COLOR):
					validationPackage = validateByRegexTest(fieldValue, COLOR_HEX_REGEX, error.Type.COLOR_VALUE_MUST_BE_6_HEXADECIMAL_DIGITS_OF_THE_FORM_RRGGBB__EXAMPLE_FF0000_FOR_RED);
					break;
	
				case (fieldType === fieldTypeConstants.Type.PACKAGE):
					validationPackage = validateByRegexTest(fieldValue, PACKAGE_REGEX, error.Type.INVALID_SUITEAPP_APPLICATION_ID);
					break;
	
				case (fieldType === fieldTypeConstants.Type.FURIGANA):
					validationPackage = validateByRegexTest(fieldValue, FURIGANA_REGEX, error.Type.NON_KATAKANA_DATA_FOUND);
					break;

                case (fieldType === fieldTypeConstants.Type.FUNCTION):
				case (validationType !== null) && (typeof validationType !== "undefined") &&
					 (validationType.toLowerCase() === fieldTypeConstants.Type.QUOTEDFUNCTION):
					validationPackage = validateByRegexTest(fieldValue, FUNCTION_REGEX);
					break;
	
				default:
					return fieldValue;
			}
	
			if (!validationPackage.isValid || validationPackage.formattedValue.length === 0)
			{
				// If there is a specific error message, use it. Else use the cookie-cutter version.
				var errorCode = validationPackage.errorCode ? validationPackage.errorCode : error.Type.INVALID_FLD_VALUE;
	
				if (!!validationPackage.errorFullMsg)
				{
					throwError({name: errorCode, message: validationPackage.errorFullMsg});
				}
				else
				{
					if ( !!isNumeric || !!isCurrency )
					{
						fieldName = fieldName.replace("_formattedValue", "");
					}
					var errorMsgKey = validationPackage.errorMsgKey ? validationPackage.errorMsgKey : error.Type.INVALID_FIELD_VALUE;
					var errorMessage = utilityFunctions.getErrorMessage(errorMsgKey, String(fieldValue), fieldName);

					throwError({name: errorCode, message: errorMessage.replace(/\\\"/g, "\"")});
				}
			}
	
			return validationPackage.formattedValue;
		}

		function throwError(e)
		{
			throw error.create(e);
		}
	
		/**
		 * validateRadioField
		 * specific method to validate radio fields.
		 * Unlike most other fields, a radio field will NOT accept an empty string (unless it is a radio value)
		 *
		 * @param fieldName, fieldValue - self explanatory
		 * @param radioSet - a set of possible values for the radio buttons with the given fieldname
		 *
		 * Throws error if fieldValue is not found in radioSet
		 * @returns fieldValue
		 */
		function validateRadioField(fieldName, fieldValue, radioSet)
		{
			if ( (radioSet === null) || (typeof radioSet === "undefined") || !radioSet.hasOwnProperty(fieldValue) )
			{
				throw error.create({name: error.Type.INVALID_FLD_VALUE,
									message: utilityFunctions.getErrorMessage(error.Type.INVALID_FIELD_VALUE, String(fieldValue), fieldName)});
			}
			return fieldValue;
		}

		/**
		 * validateRadioField
		 * specific method to validate radio fields.
		 * Unlike most other fields, a radio field will NOT accept an empty string (unless it is a radio value)
		 *
		 * @param {string} fieldId
		 * @param {string} text
		 * @param {Object} radioSet
		 *
		 * Throws error if fieldValue is not found in radioSet
		 * @returns key
		 */
		function validateRadioFieldByText(fieldId, text, radioSet)
		{
			if(radioSet !== null && radioSet !== undefined)
			{
				for (var key in radioSet)
				{
					if (radioSet.hasOwnProperty(key) && radioSet[key] === text)
						return key;
				}
			}

			throw error.create({name: error.Type.INVALID_FLD_VALUE,
								   message: utilityFunctions.getErrorMessage(error.Type.INVALID_FIELD_VALUE, String(text), fieldId)});
		}

		/**
		 * validateCheckBoxField
		 * specific method to validate check box fields.
		 * Unlike most other fields, a check box field will NOT accept an empty string
		 *
		 * @param {string} fieldId
		 * @param {string} text
		 * Throws error if fieldValue is empty
		 * @returns text
		 */
		function validateCheckBoxField(fieldId, text)
		{
			if (utilityFunctions.isValEmpty(text))
			{
				throw error.create({
					name: error.Type.INVALID_FLD_VALUE,
					message: utilityFunctions.getErrorMessage(error.Type.INVALID_FIELD_VALUE, String(text), fieldId)
				});
			}
		}

		/* assign util.validator package */
		return Object.freeze({
				validateField: validateField,
				validateRadioField: validateRadioField,
				validateRadioFieldByText: validateRadioFieldByText,
				validateCheckBoxField: validateCheckBoxField
			});
	}
);

/**
 * SuiteScript record field event module
 *
 * @private
 * @module N/record/recordFieldEvent
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/recordFieldEvent',[], function()
{
	var EVENT_TYPE = Object.freeze({
			FIELD_VALUE_CHANGE: 'FIELD_VALUE_CHANGE'
		});

	function getEvent(type, recordField)
	{
		return {
			type: type,
			recordField: recordField
		};
	}

	function addErrorDetails(event, error)
	{
		event.error = error;

		return event;
	}

	function wrapValueValidation(options)
	{
		var func = options.func;
		var emitter = options.emitter;
		var recordField = options.recordField;

		return function(){
			var result = undefined;

			try
			{
				result = func.apply(null, arguments);
			}
			catch(error)
			{
				emitter.emit(addErrorDetails(getEvent(EVENT_TYPE.FIELD_VALUE_CHANGE, recordField), error));
				throw error;
			}
			return result;
		}
	}

	return Object.freeze({
		Type: EVENT_TYPE,
		wrapValueValidation: wrapValueValidation
	});
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/recordField
 * @suiteScriptVersion 2.x
 */
define(
	'N/record/recordField',['N/restricted/fieldClientScriptHandler', 'N/restricted/invoker', 'N/fieldUtil', 'N/utilityFunctions', 'N/error','N/nsobject', 'N/util/formatter', 'N/util/validator', 'N/record/recordFieldEvent', 'N/eventEmitter'],
	function (remoteApi, invoker, fieldUtil, utilityFunctions, error, nsobject, formatter, validator, recordFieldEvent, eventEmitter){

		var INVALID_KEY_OR_REF = 'INVALID_KEY_OR_REF';

		var UPDATE_FIELD_ATTRIBUTE = "updateFieldAttribute",
			UPDATE_FIELD_ATTRIBUTE_EXCEPTION = "updateFieldAttributeException",
			UPDATE_LINEITEM_FIELD_ATTRIBUTE = "updateLineItemFieldAttribute",
			UPDATE_LINEITEM_FIELD_ATTRIBUTE_EXCEPTION = "updateLineItemFieldAttributeException";

		/* private object constructor */
		function SelectOption(text, id)
		{
			function getText() { return text; }
			function getId() { return id; }
			function toJSON() { return {id:id, text:text}; }
			function toString() { return "SelectOption"; }

			this.getText = getText;
			this.getId = getId;
			this.toJSON = toJSON;
			this.toString = toString()
		}
		SelectOption.prototype = nsobject.getNewInstance();
		Object.freeze(SelectOption);

		//TODO JSDoc these methods, this is exported by Record
		/*
		* Field - Primary object used to encapsulate a record field object.
		*
		* @protected
		* @constructor
		*/
		function Field(params)
		{
			/* private vars */

			var that = this;
			var field = params;
			var recordFunctions = params.recordFunctions;
			var metadata = params.metadata;
			var fieldState = params.fieldState;
			var label = fieldState.label;
			var emitter = eventEmitter.create();

			/* private method */
			function getFieldInfo()
			{
				return {sublistId: getSublistName(), fieldId: String(metadata.name), lineNum: parseInt(getLine(),10) };
			}
			function isRecordDynamic()
			{
				return field.isRecordDynamic;
			}
			function isCurrentRecord()
			{
				return field.isCurrentRecord;
			}
			function getRecordForm() {
				return field.form;
			}
			function getFieldOptions() {
				return recordFunctions.getFieldOptions();
			}
			function setRecordInternalEventFlag(isInternal)
			{
				recordFunctions.setInternalEvent(isInternal);
			}
			function getRecordInternalEventFlag()
			{
				return recordFunctions.isInternal();
			}
			function constructSelectOptions( options )
			{
				var selectOptions = [];
				for(var i = 0; i < options.length; i++)
				{
					if(options[i] instanceof SelectOption)
					{
						selectOptions.push(options[i]);
						continue;
					}
					/* remove empty option */
					if(!utilityFunctions.isValEmpty(options[i].id))
						selectOptions.push(new SelectOption(options[i].text, options[i].id));
				}
				return selectOptions;
			}
			function getValidFilterOperation(op)
			{
				if(typeof op === 'undefined')
					return 'contains';

				var validOperations = ['contains', 'is', 'startswith'];
				if( validOperations.indexOf(op.toLowerCase()) > -1)
					return op.toLowerCase();
				else
					utilityFunctions.throwSuiteScriptError(error.Type.INVALID_GETSELECTOPTION_FILTER_OPERATOR, op, validOperations.join(','));
			}
			function filterOptions(options, filter, filterOperation)
			{
				var toRet = [];
				for(var i = 0; i < options.length; i++)
				{
					var isValid = isOptionValid(options[i], filter, filterOperation);
					if(isValid)
						toRet.push(options[i]);
				}
				return toRet;
			}
			function isOptionValid(option, filter, filterOperation)
			{
				var isValid = false;
				if((filterOperation === 'contains') || (filterOperation === 'startswith'))
				{
					var pos = option.getText().toLowerCase().search(filter.toLowerCase());
					if(filterOperation === 'startswith')
						isValid = (pos === 0);
					else
						isValid = (pos > -1);
				}
				else if(filterOperation === 'is')
				{
					isValid = option.getText().toLowerCase() === filter.toLowerCase();
				}

				return isValid;
			}
			function cacheFieldOption(options, action, data)
			{
				if (options !== null && getRecord().isDynamic)
				{
					getFieldOptions().put(getSublistName(), getName(), getLine(), options, action, data);
					cacheSelectOptionTexts(getSublistName(), getName(), options);
				}
			}
			function cacheFieldColumnOption(options, action, data)
			{
				if (options !== null && getRecord().isDynamic && getSublistName())
				{
					getFieldOptions().put(getSublistName(), getName(), -1, options, action, data);
					cacheSelectOptionTexts(getSublistName(), getName(), options);
				}
			}
			function cacheSelectOptionTexts(sublistName, fieldName, options)
			{
				var modelController = getRecord().getModelController();
				(options || []).forEach(function(option) {
					modelController.cacheSelectOptionText(sublistName, fieldName, option.getId(), option.getText());
				});
			}

			function getOptionsFromRecordFieldCache()
			{
				if(getRecord().isDynamic)
					return getFieldOptions().get(getSublistName(), getName(), getLine());
				else
					return null;
			}
			function getOptionsFromRecordFieldColumnCache()
			{
				if(getRecord().isDynamic && getSublistName())
					return getFieldOptions().get(getSublistName(), getName(), -1);
				else
					return null;
			}

			function getRecord() { return field.record; }
			function getSubrecordType() { return metadata.subrecordType; }
			function getSubrecordIdField() { return metadata.subrecordIdField; }
			function isSublistField() { return (field.sublistId) ? true : false; }
			function isMachineHeaderField() { return metadata.isMachineHeaderField; }
			function acceptEmptyValueForSelectField() { return metadata.acceptEmptyValueForSelectField; }
			function isRadioField() { return getType() === 'radio'; }
			function isPopup() { return metadata.isPopup; }
			function getType() { return  metadata.type; }
			function getName() { return metadata.name; }
			function getFieldState() { return fieldState; }
			function getSublistName() { return field.sublistId ? String(field.sublistId) : null; }
			function getLine() { return field.lineNum || field.lineNum === 0 ? field.lineNum : -1; }
			function setLine(ln)
			{
				field.lineNum = ln;
				// TODO: does this need an event? what data object is responsible for this value?
			}
			function getMaxLength() { return metadata.maxLength; }
			function isNumeric() { return metadata.isNumeric; }
			function isCurrency() { return metadata.isCurrency; }
			function getMinValue() { return (metadata.hasMinValue) ? metadata.minValue : undefined; }
			function getMaxValue() { return (metadata.hasMaxValue) ? metadata.maxValue : undefined; }
			function getValidationFieldType() { return metadata.fieldTypeForValidation; }
			function noSlaving() { return getFieldState().ignoreSlaving; }
			function setNoSlaving(noSlaving) { 
				getFieldState().ignoreSlaving = noSlaving;
				return that;
			}
			function isDisabled() { return getFieldState().isDisabled; }
			function setDisabled(disable)
			{
				disable = !!disable;
				var oldDisabled = getFieldState().isDisabled;

				if(disable !== oldDisabled){
					getFieldState().isDisabled = disable;
				}

				return that;
			}
			function isDefaultMandatory() { return getFieldState().isDefaultMandatory; }
			function isMandatory() { return getFieldState().isMandatory; }
			function setMandatory(mandatory)
			{
				mandatory = !!mandatory;
				var oldMandatory = getFieldState().isMandatory;

				if(mandatory !== oldMandatory){
					getFieldState().isMandatory = mandatory;
				}

				return that;
			}
			function isDisplay() { return getFieldState().isDisplay; }
			function setDisplay(display)
			{
				display = !!display;
				var oldDisplay = getFieldState().isDisplay;

				if(display !== oldDisplay){
					getFieldState().isDisplay = display;
				}

				return that;
			}
			function isVisible() { return getFieldState().isVisible; }
			function setVisible(visible)
			{
				visible = !!visible;
				var oldVisible = getFieldState().isVisible;

				if(visible !== oldVisible){
					getFieldState().isVisible = visible;
				}

				return that;
			}
			function isReadOnly() { return getFieldState().isReadOnly; }
			function setReadOnly(readonly)
			{
				readonly = !!readonly;
				var oldReadonly = getFieldState().isReadOnly;

				if(readonly !== oldReadonly){
					getFieldState().isReadOnly = readonly;
				}

				return that;
			}
			function getLabel()
			{
				if(getFieldState().label !== label)
					label = getFieldState().label;
				return label;
			}
			function setLabel(newLabel)
			{
				newLabel = '' + newLabel;
				var oldLabel = label;

				if(newLabel !== oldLabel){
					label = newLabel;
					getFieldState().label = newLabel;
				}

				return that;
			}

			function getRecordFieldValue(sublistId, fieldId, lineNum)
			{
				try{
					var wasInternal = getRecordInternalEventFlag();
					setRecordInternalEventFlag(true);

					if(sublistId)
					{
						if(isRecordDynamic() && (lineNum === -1 || lineNum === getRecord().doGetCurrentSublistIndex(sublistId)))
							return getRecord().getCurrentSublistLineValueAsLegacyString(sublistId, fieldId);
						else
							return getRecord().getSublistLineValueAsLegacyString(sublistId, fieldId, lineNum);
					}
					else
						return getRecord().getValueAsLegacyString(fieldId);
				}
				finally
				{
					setRecordInternalEventFlag(wasInternal);
				}
			}
			function getRecordQueryRequest()
			{
				return recordFunctions.getQueryRequest.call();
			}
			function getRequestParam()
			{
				var queryRequest = getRecordQueryRequest();
				markQueryRequest(queryRequest.payload,getName());
				return [getRecord().type, queryRequest.url, queryRequest.payload , getFieldInfo()];
			}
			function getSelectOptionForPopup(idsOrTexts, byIds)
			{
				idsOrTexts = utilityFunctions.normalizeArrayOrSingularObjectArg(idsOrTexts);

				var lookupBind = [];
				for(var i = 0; i < idsOrTexts.length; i++)
					lookupBind.push((util.isString(idsOrTexts[i]) && !metadata.hasStaticOptions) ? "'" + idsOrTexts[i] + "'" : idsOrTexts[i]);

				var requestParam = getRequestParam();
				requestParam.push(getOptionMastersAndAuxFieldsValue(), lookupBind, byIds);
				return invoker(remoteApi, 'getSelectOptionForPopup', requestParam);
			}
			function getSelectOptionsWithSupplementedOptions()
			{
				var optionList = null;
				var cachedOptions = getOptionsFromRecordFieldCache();
				if (!Array.isArray(cachedOptions))
				{
					var supplementalOptions = metadata.supplementedOptions;
					if (Array.isArray(supplementalOptions))
					{
						optionList = supplementalOptions;
					}
				}
				else
				{
					optionList = cachedOptions;
				}
				return optionList;
			}

			/**
			 * Retrieve select options, supporting client-side caching.
			 * Returns an empty array if there are too many options to be cached on the client (for safe operation).
			 * This *CANNOT* be used with tooManyOptions().
			 * @param filter
			 * @param filterOperator
			 * @param lookupBind
			 * @returns {Array}
			 */
			function getSelectOptions(filter, filterOperator, lookupBind)
			{
				return getSelectOptions_internal(filter, filterOperator, lookupBind, false/*denoteVeryLargeListAsNull*/);
			}

			/**
			 * Smarter version of getSelectOptions() that is able to distinguish between an empty options list, and one that is too
			 * large to be cached on the client. Returns null if there are too many options to be cached.
			 * This can be used with tooManyOptions().
			 */
			function getSelectOptions_nullMeansTooMany(filter, filterOperator, lookupBind)
			{
				return getSelectOptions_internal(filter, filterOperator, lookupBind, true/*denoteVeryLargeListAsNull*/);
			}

			/**
			 * This method is valid to deterine of the options list is "too large to send to the client", but only if called
			 * after getSelectOptions_nullMeansTooMany().
			 */
			function tooManyOptions(options)
			{
				return options === null;
			}

			/**
			 * Internal implementation to call the server to retrieve select options, supporting client-side caching.
			 */
			function getSelectOptions_internal(filter, filterOperator, lookupBind, denoteVeryLargeListAsNull)
			{
				var selectOptions = [];
				if(fieldUtil.isSelectType(getType()))
				{
					var options = getOptionsFromRecordFieldCache();
					if(isPopup())
					{
						options = (lookupBind) ? getSelectOptionForPopup(lookupBind, true) : getSelectOptionFromServer(denoteVeryLargeListAsNull);
						if (options === null)
							return null;
					}
					// Server Side Option is required
					else if (options === null || options === undefined)
					{
						var supplementalOptions = getSelectOptionsWithSupplementedOptions();
						options = (Array.isArray(supplementalOptions)) ? supplementalOptions : getSelectOptionFromServer(denoteVeryLargeListAsNull);
						if (options === null)
							return null;
						options = constructSelectOptions(options);
						cacheFieldOption(options);
					}

					selectOptions = extendWithColumnOptions(constructSelectOptions(options));
				}
				else if(isRadioField())
				{
					selectOptions = getRadioSelectOption();
				}

				if(filter)
					selectOptions = filterOptions(selectOptions, filter, getValidFilterOperation(filterOperator));

				return selectOptions;
			}

			function getColumnSelectOptions(filter, filterOperator, lookupBind)
			{
				var columnSelectOptions = [];
				if(getSublistName() && fieldUtil.isSelectType(getType()) && !isPopup())
				{
					var options = getOptionsFromRecordFieldColumnCache() || [];
					columnSelectOptions = constructSelectOptions(options);
				}

				if(filter)
					columnSelectOptions = filterOptions(columnSelectOptions, filter, getValidFilterOperation(filterOperator));

				return columnSelectOptions;
			}
			function extendWithColumnOptions(lineOptions)
			{
				lineOptions = lineOptions || [];
				var columnOptions = getColumnSelectOptions();
				columnOptions.forEach(function(columnOption) { if (!lineOptions.some(function(lineOption) {return lineOption.getId() === columnOption.getId();})) lineOptions.push(columnOption); });
				return lineOptions;
			}

			/**
			 * Insert select option, supporting client-side caching.
			 * @param value
			 * @param text
			 * @param selected
			 * @param isColumnOption
			 */
			function insertSelectOption(value, text, selected, isColumnOption)
			{
				if (!isCurrentRecord())
					fieldUtil.verifyPrefixedWithCustPage(getName());

				var addedOpt = new SelectOption(text, value);

				if (isColumnOption)
				{
					var columnOptions = getColumnSelectOptions();
					if (columnOptions.some(function(v) { return v.getId() === value; }))
						utilityFunctions.throwSuiteScriptError(error.Type.SELECT_OPTION_ALREADY_PRESENT, value);
					columnOptions.push(addedOpt);
					cacheFieldColumnOption(columnOptions, 'add', addedOpt);
				}

				var myOptions = getSelectOptions();

				if (!isColumnOption)
				{
					if (myOptions.some(function(v) { return v.getId() === value; }))
						utilityFunctions.throwSuiteScriptError(error.Type.SELECT_OPTION_ALREADY_PRESENT, value);

					myOptions.push(addedOpt);
					cacheFieldOption(myOptions, 'add', addedOpt);
				}

				recordFunctions.updateSelectOptions(getSublistName(), getName(), getLine(), myOptions, value, text, selected);
			}

			/**
			 * Remove select option, supporting client-side caching.
			 * @param value
			 * @param isColumnOption
			 */
			function removeSelectOption(value, isColumnOption)
			{
				fieldUtil.verifyPrefixedWithCustPage(getName());

				if (isColumnOption)
				{
					var columnOptions = getColumnSelectOptions();

					var removedColumnOpt = null;
					var postRemovalColumnOptionList = columnOptions.filter(function(v) {
						if (v.getId() === value) {
							removedColumnOpt = v;
							return false;
						}
						return true;
					});
					if (removedColumnOpt === null)
						utilityFunctions.throwSuiteScriptError(error.Type.SELECT_OPTION_NOT_FOUND, value);
					cacheFieldColumnOption(postRemovalColumnOptionList, 'remove', removedColumnOpt);
				}

				var myOptions = getSelectOptions();

				if (!isColumnOption)
				{
					var removedOpt = null;
					var postRemovalOptionList = myOptions.filter(function(v) {
						if (v.getId() === value) {
							removedOpt = v;
							return false;
						}
						return true;
					});
					if (removedOpt === null)
						utilityFunctions.throwSuiteScriptError(error.Type.SELECT_OPTION_NOT_FOUND, value);
					cacheFieldOption(postRemovalOptionList, 'remove', removedOpt);
				}
			}

			function getOptionMastersAndAuxFieldsValue()
			{
				var fields = metadata.optionMastersAndAuxFields;
				var toRet = [];
				fields.forEach(function(field) {
					toRet.push({
						           fieldId: field.fieldName,
						           sublistId: field.sublistName,
						           value: getRecordFieldValue(field.sublistName, field.fieldName, getLine())
					           });
				});
				return toRet;
			}
			function getRadioSet(fieldId)
			{
				return recordFunctions.getRadioSet.call(getRecord(), fieldId);
			}
			function getRadioSelectOption()
			{
				var selectOptions = [];
				if(isSublistField() && !isMachineHeaderField())
				{
					for (var i = 1; i <= getRecord().getLineItemCount(getSublistName()); i++)
						selectOptions.push(new SelectOption(getLabel(), String(i)));
				}
				else
				{
					var radioValues = getRadioSet(getName());
					for(var radioValue in radioValues)
					{
						selectOptions.push(new SelectOption(radioValues[radioValue], radioValue));
					}
				}
				return selectOptions;
			}

			/**
			 * This will return the list of select options, if it's a small list. If more than 1050 options, this will return
			 * an empty Array by default, or null if pased-in parameter denoteVeryLargeListAsNull is true.
			 * @param denoteVeryLargeListAsNull
			 * @returns {Array}
			 */
			function getSelectOptionFromServer(denoteVeryLargeListAsNull)
			{
				var queryRequest = getRecordQueryRequest();
				markQueryRequest(queryRequest.payload, getName());
				var requestParam = [ getRecord().type, queryRequest.url, queryRequest.payload , getFieldInfo(), getOptionMastersAndAuxFieldsValue() ];
				var result = invoker(remoteApi, 'getFieldSelectOptions', requestParam);

				/* If the dropdown is a very large list (>1050 values), return null as distinct from [] to denote that it cannot be retrieved, only if the caller can process the null. */
				if (result === null && !denoteVeryLargeListAsNull)
					result = [];
				return result;
			}

			function removeEmptyValueForPopUpSelect(value)
			{
				var newArray = [];
				for(var idx = 0; idx < value.length; idx++)
				{
					if(!utilityFunctions.isValEmpty(value[idx]) && !considerAsEmptyForPopup(value[idx]))
						newArray.push(value[idx]);
				}

				return newArray;
			}
			function validateEmptyValue(value)
			{
				var valArray = util.isArray(value) ? value : [value];
				validateEmptyValueInArray(valArray);
			}
			function validateSelectFieldByText(text)
			{
				var result = text;

				validateEmptyValue(text);

				if(!utilityFunctions.isValEmpty(text) && !considerAsEmptyForPopup(text))
				{
					var options;
					if(isPopup())
					{
						if(util.isArray(text))
							text = removeEmptyValueForPopUpSelect(text);
						options = getSelectOptionForPopup(text, false);
						options = constructSelectOptions(options);
						result = findIdInFieldOptions(options, text);
					}
					else if(isRadioField())
					{
						var thisRadioSet = getRadioSet(getName());
						result = validator.validateRadioFieldByText(getName(), text, thisRadioSet);
					}
					else
					{
						options = getSelectOptions();
						result = findIdInFieldOptions(options, text);
					}
				}

				return result;
			}
			function considerAsEmptyForPopup(value)
			{
				if(isPopup())
				{
					//TODO translation
					return ["<Type then tab>", "<Type & tab for single value>"].indexOf(value) > -1;
				}
				else
					return false;
			}
			function validateSelectField(value, option)
			{
				validateEmptyValue(value);

				if(!utilityFunctions.isValEmpty(value) && !considerAsEmptyForPopup(value))
				{
					if (util.isArray(value) && !areIdsInFieldOptions(option, value))
					{
						throw error.create({name:INVALID_KEY_OR_REF, message: utilityFunctions.getErrorMessage(error.Type.INVALID_KEY_OR_REF, getName(), JSON.stringify(value))});
					}
					else if (!util.isArray(value) && !isIdInFieldOptions(option, value))
					{
						throw error.create({name:INVALID_KEY_OR_REF,message:utilityFunctions.getErrorMessage(error.Type.INVALID_KEY_OR_REF, getName(), value)});
					}
				}
			}
			function validateEmptyValueInArray(valueArray)
			{
				// validate if there are empty value in values
				if (!acceptEmptyValueForSelectField() &&
					(utilityFunctions.arrayContains(valueArray, '') || utilityFunctions.arrayContains(valueArray, null) || utilityFunctions.arrayContains(valueArray, undefined) ))
				{
					utilityFunctions.throwSuiteScriptError(error.Type.EMPTY_KEY_NOT_ALLOWED, getName());
				}
			}
			function areIdsInFieldOptions(options, ids)
			{
				var keyList = [];
				for(var i = 0; i < options.length; i++)
					keyList.push(options[i].getId());

				for(var j = 0; i < ids.length; j++)
				{
					if(keyList.indexOf(ids[j]) === -1)
						return false;
				}

				return true;
			}
			function isIdInFieldOptions(options, id)
			{
				for (var i = 0; i < options.length; i++)
				{
					if (options[i].getId() == id)
						return true;
				}
				return false;
			}
			function findIdInFieldOptions(options, text)
			{
				if(util.isArray(text))
					return findIdsInFieldOptions(options, text);

				for(var i = 0; i < options.length; i++)
				{
					if(options[i].getText() === text)
						return options[i].getId();
				}

				throw error.create({name:INVALID_KEY_OR_REF,
									message:utilityFunctions.getErrorMessage(error.Type.INVALID_KEY_OR_REF, getName(), String(text))});
			}
			function findIdsInFieldOptions(options, texts)
			{
				var internalIds = [];
				var validTexts = [];
				for(var i = 0; i < options.length; i++)
				{
					if(texts.indexOf(options[i].getText()) > -1)
					{
						internalIds.push(options[i].getId());
						validTexts.push(options[i].getText());
					}
				}

				if(validTexts.length !== texts.length)
				{
					var invalidTexts = [];
					for(var j=0; j < texts.length; j++)
						if(validTexts.indexOf(texts[j]) == -1)
							invalidTexts.push(texts[j]);

					throw error.create({name:INVALID_KEY_OR_REF,
										message:utilityFunctions.getErrorMessage(error.Type.INVALID_KEY_OR_REF, getName(), JSON.stringify(invalidTexts))});
				}

				return internalIds;
			}
			function validateAndFormatFieldValue(value, useStrict)
			{
				var returnedValue = value;
				if(fieldUtil.isSelectType(getType()) && isRecordDynamic())
				{
					/* Examine the select options using the client-side cache. This will go to the server the first time. */
					var options = getSelectOptions_nullMeansTooMany(null, null, value);
					// Validate record selects with a small number of options using the client-side options cache.
					if (!tooManyOptions(options))
					{
						validateSelectField(value, options);
					}
					/* Validate record selects with very large numbers of options on the server, without using client-side cache. */
					else
					{
						validateSelectFieldData(value);
					}

					if(util.isArray(value))
						returnedValue = value.map(function(val){ return String(val);});
					else
						returnedValue = String(value);
				}
				else if (isRadioField())
				{
					var thisRadioSet = getRadioSet(getName());
					returnedValue = validator.validateRadioField(getName(), value, thisRadioSet);
				}
				else
				{
					var validateMe = value;
					returnedValue = validator.validateField(getName(), getType(), validateMe, isNumeric(), isCurrency(),
					                                        getValidationFieldType(), getMinValue(), getMaxValue(), getMaxLength(), isMandatory(), !!useStrict);
				}

				return returnedValue;
			}

			/**
			 * Validate select option, supporting client-side caching.
			 * @param idsOrTexts
			 * @returns {boolean}
			 */
			function validateSelectFieldData(idsOrTexts)
			{
				var idsOrTexts = utilityFunctions.normalizeArrayOrSingularObjectArg(idsOrTexts);

				var fieldValue = String(idsOrTexts);
				if (fieldUtil.isMultiSelectType(getType()) && idsOrTexts.length > 1)
				{
					fieldValue = idsOrTexts.join(String.fromCharCode(5));
				}

				var myOptions = getSelectOptions_nullMeansTooMany();
				cacheFieldOption(myOptions);

				var isValid = false;
				if (fieldUtil.isSelectType(getType()) && fieldUtil.isPrefixedWithCustPage(getName()) && (idsOrTexts !== null) && !tooManyOptions(myOptions))
				{
					var matchedOptions = myOptions.filter(function(v) { return idsOrTexts.indexOf(v.getId()) > -1; });
					isValid = matchedOptions.length > 0;
				}
				else
				{
					var requestParam = getRequestParam();
					requestParam.push(getOptionMastersAndAuxFieldsValue(), fieldValue);
					isValid = invoker(remoteApi, 'validateSelectField', requestParam);
				}
				return isValid;
			}

			function markQueryRequest(request, fieldId)
			{
				request.q = String(fieldId);
			}

			function toString() { return "Field" }
			function toJSON()
			{
				return {
					name: getName(),
					type: getType(),
					label: getLabel()
				};
			}

			/* public undocumented methods */
			this.validateAndFormatFieldValue = recordFieldEvent.wrapValueValidation({
				emitter: emitter,
				recordField: that,
				func: validateAndFormatFieldValue
			});
			this.validateSelectFieldByText = recordFieldEvent.wrapValueValidation({
				emitter: emitter,
				recordField: that,
				func: validateSelectFieldByText
			});
			this.setLine = setLine;
			this.getLine = getLine;
			this.on = emitter.on;
			this.off = emitter.off;

			/* public methods */
			this.getType = getType;
			this.getSubrecordType = getSubrecordType;
			this.getSubrecordIdField = getSubrecordIdField;
			this.getName = getName;
			this.getSublistName = getSublistName;
			this.isPopup = isPopup;
			this.getMaxLength = getMaxLength;
			this.isNumeric = isNumeric;
			this.isCurrency = isCurrency;
			this.getMinValue = getMinValue;
			this.getMaxValue = getMaxValue;
			this.getValidationFieldType = getValidationFieldType;
			this.noSlaving = noSlaving;
			this.setNoSlaving = setNoSlaving;
			this.isDisabled = isDisabled;
			this.setDisabled = setDisabled;
			this.isDefaultMandatory = isDefaultMandatory;
			this.isMandatory = isMandatory;
			this.setMandatory = setMandatory;
			this.isDisplay = isDisplay;
			this.setDisplay = setDisplay;
			this.isVisible = isVisible;
			this.setVisible = setVisible;
			this.isReadOnly = isReadOnly;
			this.setReadOnly = setReadOnly;
			this.getLabel = getLabel;
			this.setLabel = setLabel;
			this.getSelectOptions = getSelectOptions;
			this.insertSelectOption = insertSelectOption;
			this.removeSelectOption = removeSelectOption;
			this.getRequestParam = getRequestParam;
			this.isCurrentRecord = isCurrentRecord;

			/* Debugger support */
			this.toJSON = toJSON;
			this.toString = toString;
		}
		Field.prototype = nsobject.getNewInstance();
		Object.freeze(Field);

		return Object.freeze({
				create: function(params) { return new Field(params); },
				isSelectType: fieldUtil.isSelectType,
				Type: fieldUtil.SELECT_FIELD_TYPES
			})
	}
);

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/matrix
 * @suiteScriptVersion 2.x
 */
define(
	'N/record/matrix',['N/utilityFunctions','N/error', 'N/record/recordUtilityFunctions'],
	function(utilityFunctions, error, recordUtil){

		function doGetMatrixHeaderCount(record, sublistId)
		{
			return parseInt(record.getValue(sublistId + 'headercount'), 10) || 0;
		}

		function getMatrixHeaderFieldName(record, sublistId, column)
		{
			var prefix = record.getValue(sublistId + 'header');

			return prefix + column;
		}

		function getMatrixFields(record, sublistId)
		{
			var matrixfieldsvalue = record.getValue(sublistId + 'matrixfields');

			return !!matrixfieldsvalue && matrixfieldsvalue.split(',') || [];
		}

		function isMatrixField(record, options, fieldId)
		{
			var sublistId,
				undef = undefined;
			if (fieldId !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
			}

			return utilityFunctions.arrayIndexOf(getMatrixFields(record, sublistId), fieldId) !== -1;
		}

		function getMatrixLineFieldName(record, options, fieldId, column)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef && column !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
		    {
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				column = options.column;
			}

			return isMatrixField(record, sublistId, fieldId) ? fieldId + "_" + column + "_" : null;
		}

		function getMatrixHeaderCount(record, options, fieldId)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
                fieldId = options.fieldId;
			}

            utilityFunctions.checkArgs( [sublistId, fieldId], ['sublistId', 'fieldId'], record.getMissingArgumentErrorMessageFillerValue('getMatrixHeaderCount'));
			return isMatrixField(record, sublistId, fieldId) ? doGetMatrixHeaderCount(record, sublistId) : null;
		}

		function getMatrixHeaderValue(record, options, fieldId, column)
		{
            var matrixHeaderFieldName,
				sublistId,
				undef = undefined;

			if (fieldId !== undef && column !== undef)
			{
				sublistId = options;
				column = recordUtil.validateAndGetOneBasedIndex(column, "getMatrixHeaderValue");
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
                column = recordUtil.validateAndGetOneBasedIndex(options.column, "getMatrixHeaderValue");
			}

            utilityFunctions.checkArgs( [sublistId, fieldId, column], ['sublistId', 'fieldId', 'column'], record.getMissingArgumentErrorMessageFillerValue('getMatrixHeaderValue'));
			validateMatrixField(record, sublistId, fieldId);
			matrixHeaderFieldName = getMatrixHeaderFieldName(record, sublistId, column);
			return record.getValue(matrixHeaderFieldName);
		}

		function setMatrixHeaderValue(record, options, fieldId, column, value, ignoreFieldChange)
		{
			var sublistId,
				noSlaving = false,
				fireFieldChanged= true,
				matrixHeaderFieldName,
				undef = undefined;

			if (fieldId !== undef && column !== undef)
			{
				sublistId = options;
                column = recordUtil.validateAndGetOneBasedIndex(column, "setMatrixHeaderValue");
				fireFieldChanged = util.isBoolean(ignoreFieldChange) ? !ignoreFieldChange : fireFieldChanged;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				column = recordUtil.validateAndGetOneBasedIndex(options.column, "setMatrixHeaderValue");
				value = options.value;
				fireFieldChanged = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChanged;
			}

            utilityFunctions.checkArgs( [sublistId, fieldId, column], ['sublistId', 'fieldId', 'column'], record.getMissingArgumentErrorMessageFillerValue('setMatrixHeaderValue'));

			validateMatrixField(record, sublistId, fieldId);
			matrixHeaderFieldName = getMatrixHeaderFieldName(record, sublistId, column);
			record.setValue(matrixHeaderFieldName, value, fireFieldChanged, noSlaving);

			return this;
		}

		function getCurrentMatrixSublistValue(record, options, fieldId, column)
		{
            var matrixLineFieldName,
				sublistId,
				undef = undefined;

			if (fieldId !== undef && column !== undef)
			{
				sublistId = options;
				column = recordUtil.validateAndGetOneBasedIndex(column, "getCurrentMatrixSublistValue");
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
                column = recordUtil.validateAndGetOneBasedIndex(options.column, "getCurrentMatrixSublistValue");
			}

            utilityFunctions.checkArgs( [sublistId, fieldId, column], ['sublistId', 'fieldId', 'column'], record.getMissingArgumentErrorMessageFillerValue('getCurrentMatrixSublistValue'));
            validateMatrixField(record, sublistId, fieldId);
            matrixLineFieldName = getMatrixLineFieldName(record, sublistId, fieldId, column);
			return record.getCurrentSublistValue(sublistId, matrixLineFieldName, column);
		}

		function setCurrentMatrixSublistValue(record, options, fieldId, column, value, ignoreFieldChange)
		{
            var matrixLineFieldName,
                noSlaving = false,
				sublistId,
				fireFieldChanged = true,
				undef = undefined;

			if (fieldId !== undef && column !== undef)
			{
				sublistId = options;
				column = recordUtil.validateAndGetOneBasedIndex(column, "setCurrentMatrixSublistValue");
				fireFieldChanged = util.isBoolean(ignoreFieldChange) ? !ignoreFieldChange : fireFieldChanged;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				column = recordUtil.validateAndGetOneBasedIndex(options.column, "setCurrentMatrixSublistValue");
				value = options.value;
				fireFieldChanged = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChanged;
			}

            utilityFunctions.checkArgs( [sublistId, fieldId, column], ['sublistId', 'fieldId', 'column'], record.getMissingArgumentErrorMessageFillerValue('setCurrentMatrixSublistValue'));
            validateMatrixField(record, sublistId, fieldId);
            matrixLineFieldName = getMatrixLineFieldName(record, sublistId, fieldId, column);
			record.setCurrentSublistValue(sublistId, matrixLineFieldName, value, fireFieldChanged, noSlaving);

            return this;
		}

		function getMatrixSublistValue(record, options, fieldId, linenum, column)
		{

            var matrixLineFieldName,
				sublistId,
				undef = undefined;

			if (fieldId !== undef && linenum !== undef && column !== undef)
			{
				sublistId = options;
				column = recordUtil.validateAndGetOneBasedIndex(column, "getMatrixSublistValue");
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				linenum = options.line;
                column = recordUtil.validateAndGetOneBasedIndex(options.column, "getMatrixSublistValue");
			}

            utilityFunctions.checkArgs( [sublistId, fieldId, linenum, column], ['sublistId', 'fieldId', 'line', 'column'], record.getMissingArgumentErrorMessageFillerValue('getMatrixSublistValue'));
			matrixLineFieldName = getMatrixLineFieldName(record, sublistId, fieldId, column);
            validateMatrixFieldAndLine(record, sublistId, fieldId, linenum);
			return record.getSublistValue(sublistId, matrixLineFieldName, linenum);
		}

		function setMatrixSublistValue(record, options, fieldId, linenum, column, value)
		{
            var matrixLineFieldName,
				sublistId,
				undef = undefined;

			if (fieldId !== undef && linenum !== undef && column !== undef)
			{
				sublistId = options;
				column = recordUtil.validateAndGetOneBasedIndex(column, "setMatrixSublistValue");
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				linenum = options.line;
				column = recordUtil.validateAndGetOneBasedIndex(options.column, "setMatrixSublistValue");
                value = options.value;
			}

            utilityFunctions.checkArgs( [sublistId, fieldId, linenum, column], ['sublistId', 'fieldId', 'line', 'column'], record.getMissingArgumentErrorMessageFillerValue('setMatrixSublistValue'));
            validateMatrixFieldAndLine(record, sublistId, fieldId, linenum);
            matrixLineFieldName = getMatrixLineFieldName(record, sublistId, fieldId, column);
			record.setSublistValue(sublistId, matrixLineFieldName, linenum, value);

            return this;
		}

		function findMatrixSublistLineWithValue(record, options, fieldId, column, value)
		{
            var matrixLineFieldName,
				sublistId,
				undef = undefined;

			if (fieldId !== undef && column !== undef && value !== undef)
			{
				sublistId = options;
				column = recordUtil.validateAndGetOneBasedIndex(column, "findMatrixSublistLineWithValue");
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				column = recordUtil.validateAndGetOneBasedIndex(options.column, "findMatrixSublistLineWithValue");
                value = options.value;
			}

            utilityFunctions.checkArgs( [sublistId, fieldId, column], ['sublistId', 'fieldId', 'column'], record.getMissingArgumentErrorMessageFillerValue('findMatrixSublistLineWithValue'));
			validateMatrixField(record, sublistId, fieldId);
			matrixLineFieldName = getMatrixLineFieldName(record, sublistId, fieldId, column);
			return record.doFindSublistLineWithValue(sublistId, matrixLineFieldName, value);
		}

		function getMatrixHeaderField(record, options, fieldId, column)
		{
            var matrixHeaderFieldName,
				sublistId,
				undef = undefined;

			if (fieldId !== undef && column !== undef)
			{
				sublistId = options;
				column = recordUtil.validateAndGetOneBasedIndex(column, "getMatrixHeaderField");
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
                column = recordUtil.validateAndGetOneBasedIndex(options.column, "getMatrixHeaderField");
			}

            utilityFunctions.checkArgs( [sublistId, fieldId, column], ['sublistId', 'fieldId', 'column'], record.getMissingArgumentErrorMessageFillerValue('getMatrixHeaderField'));
			validateMatrixField(record, sublistId, fieldId);
			matrixHeaderFieldName = getMatrixHeaderFieldName(record, sublistId, column);
			return record.getField(matrixHeaderFieldName);
		}

		function getMatrixSublistField(record, options, fieldId, linenum, column)
		{
            var matrixLineFieldName,
				sublistId,
				undef = undefined;

			if (fieldId !== undef && linenum !== undef && column !== undef)
			{
				sublistId = options;
				column = recordUtil.validateAndGetOneBasedIndex(column, "getMatrixSublistField");
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				linenum = options.line;
                column = recordUtil.validateAndGetOneBasedIndex(options.column, "getMatrixSublistField");
			}

            utilityFunctions.checkArgs( [sublistId, fieldId, linenum, column], ['sublistId', 'fieldId', 'line', 'column'], record.getMissingArgumentErrorMessageFillerValue('getMatrixSublistField'));
			matrixLineFieldName = getMatrixLineFieldName(record, sublistId, fieldId, column);

			return record.getSublistField(sublistId, matrixLineFieldName, linenum);
		}

		function parseMatrixLineField(record, fieldId, sublistId)
		{
			var result = null,
				fields, field, count, matrixLineFieldName,
				i;

			fields = getMatrixFields(record, sublistId);
			count = doGetMatrixHeaderCount(record, sublistId);
			for(i = 0; i < fields.length; i++)
			{
				field = fields[i];
				while(count-- > 0)
				{
					matrixLineFieldName = getMatrixLineFieldName(record, sublistId, field, count);
					if(fieldId === matrixLineFieldName)
					{
						result = {
							sublistname: sublistId,
							fieldname: field,
							column: count
						};
						break;
					}
				}
				if(!!result){break;}
			}

			return result;
		}

		function validateMatrixField(record, sublistId, fieldName)
		{
			if(!isMatrixField(record, sublistId, fieldName))
				utilityFunctions.throwSuiteScriptError(error.Type.METHOD_IS_ONLY_ALLOWED_FOR_MATRIX_FIELD);
		}

		function validateMatrixFieldAndLine(record, sublistId, fieldName, lineNum)
		{
			validateMatrixField(record, sublistId, fieldName);
			if (isNaN(lineNum) || (parseInt(lineNum, 10) >= record.doGetLineCount(sublistId)) )
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_SUBLIST_OPERATION);
		}

		return Object.freeze({
			getMatrixHeaderFieldName : getMatrixHeaderFieldName,
			getMatrixFields : getMatrixFields,
			isMatrixField : isMatrixField,
			getMatrixLineFieldName : getMatrixLineFieldName,
            getMatrixHeaderCount : getMatrixHeaderCount,
			getMatrixHeaderValue : getMatrixHeaderValue,
			setMatrixHeaderValue : setMatrixHeaderValue,
            getCurrentMatrixSublistValue : getCurrentMatrixSublistValue,
            setCurrentMatrixSublistValue : setCurrentMatrixSublistValue,
            getMatrixSublistValue : getMatrixSublistValue,
            setMatrixSublistValue : setMatrixSublistValue,
            findMatrixSublistLineWithValue : findMatrixSublistLineWithValue,
            getMatrixHeaderField : getMatrixHeaderField,
            getMatrixSublistField : getMatrixSublistField,
			parseMatrixLineField : parseMatrixLineField
		})
	}
);

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/sublist
 * @suiteScriptVersion 2.x
 *
 */
define(
	'N/record/sublist',['N/nsobject'],
	function (nsobject){

		var SUBLIST_TYPE = Object.freeze({
											INLINE_EDITOR : 'inlineeditor',
											EDITOR : 'editor',
											STATIC_LIST : 'staticlist',
											LIST: 'list'
										});

		/**
		 * Return a new instance of sublist object
		 *
		 * @param {Object} sublist
		 * @param {string} sublist.type type of sublist
		 * @param {SublistState} sublist.sublistState SublistState

		 * @return {Sublist}
		 * @constructor
		 *
		 * @since 2015.2
		 */
		function Sublist(sublist)
		{
			var that = this;
			var sublistType = sublist.type;
			var sublistState = sublist.sublistState;
			var sublistFieldsMetadata = sublist.sublistFields;

			/* private method */
			/**
			 * The name of the sublist.
			 * @name Sublist#name
			 * @type string
			 * @readonly
			 */
            this.getName = function() {
                return sublistState.id;
            };

			/**
			 * The type of the sublist.
			 * @name Sublist#type
			 * @type string
			 * @readonly
			 */
            this.getType = function() {
                return sublistType;
            };
			/**
			 * The sublist is changed
			 * @name Sublist#isChanged
			 * @type boolean
			 * @readonly
			 */
            this.isChanged = function() {
                return sublistState.isChanged;
            };

			/**
			 * The sublist is hidden
			 * @name Sublist#isHidden
			 * @type boolean
			 * @readonly
			 */
			this.isHidden = function() {
                return sublistState.isHidden
			};

			/**
			 * The sublist is display
			 * @name Sublist#isDisplay
			 * @type boolean
			 * @readonly
			 */
            this.isDisplay = function() {
                return sublistState.isDisplay;
            };


            this.getColumn = function(fieldId)
            {
                var columnMetadata = null;
                if (sublistFieldsMetadata.hasOwnProperty(fieldId))
                {
                    var fieldLevelMetadata = sublistFieldsMetadata[fieldId];
                    columnMetadata = {
                                        getName: function() { return fieldLevelMetadata.name },
                                        getType: function() { return fieldLevelMetadata.type },
                                        getLabel: function() { return fieldLevelMetadata.label },
                                        setLabel: function(newLabel) {
											fieldLevelMetadata.label = newLabel;
										},
                                        getSublistId: function() { return sublistState.id }
                                     };
                }
                return columnMetadata;
            };

			/**
			 * Returns the object type name (sublist.Sublist)
			 * @returns {string}
			 */
			this.toString = function() {
				return "record.Sublist"
			};

			/**
			 * JSON.stringify() implementation.
             * @returns {{id: string, type: string, isChanged: boolean, isDisplay: boolean}}
			 */
			this.toJSON  = function () {
				return {
					id: this.id,
					type: this.type,
					isChanged: this.isChanged,
                    isDisplay: this.isDisplay
				}
			};

			return this;
		}
		Sublist.prototype = nsobject.getNewInstance();
		Object.freeze(Sublist);

		/*
		 * Return a new instance of sublist v1 object
		 *
		 * @param {Sublist} sublist
		 * @return {SublistV1}
		 * @constructor
		 *
		 * @since 2015.2
		 */
		function SublistV1(sublist)
		{
            this.getName = function() { return sublist.getName(); };
			this.isChanged = function() { return sublist.isChanged(); };
			this.getSublistType = function() { return sublist.getType(); };
			this.getType = function() { return sublist.getType(); };
			this.isDisplay = function() { return sublist.isDisplay(); };
			this.setDisplay = function(val) {
				// TODO: figure out what it this mess about, but this is not supported in 1.0
				//sublist.isDisplay = val;
			};
			this.isHidden = function() { return sublist.isHidden(); };
			this.setHidden = function(val) {
				//sublist.isHidden = val;
			};
			return this;
		}
		SublistV1.prototype = nsobject.getNewInstance();
		Object.freeze(SublistV1);

		return Object.freeze({
			/**
			 * return a new instance of sublist object
			 * @param {Object} sublist
			 * @returns {Sublist}
			 */
			create: function(sublist) { return new Sublist(sublist); },
			/**
			 * return a new instance of sublist object
			 * @param {Object} sublistJson
			 * @returns {SublistV1}
			 */
			newInstanceOfV1Sublist: function(sublistJson) {
                var sublist = new Sublist(sublistJson);
                return new SublistV1(sublist);
            },
			/**
			 * @enum
			 */
			Type: SUBLIST_TYPE
		})
	}
);

/**
 * Sublist Definition module
 * Will create the appropriate Sublist Object given the desired attributes.
 *
 * @private
 * @module N/sublistDefinition
 * @NApiVersion 2.x
 *
 */
define('N/metadata/sublistDefinition',['N/restricted/invoker', 'N/utilityFunctions', 'N/nsobject', 'N/error'],
	function(invoker, utilityFunctions, nsobject, error) {

    var SUBLIST_CATEGORY = Object.freeze({
                                             REMOTE: "remoteRecord",
                                             CURRENT: "currentRecord",
                                             READ_ONLY: "readOnlyRecord"
                                       });

    var SUBLIST_PROPERTIES = Object.freeze({
                                            ID: "id",
                                            TYPE: "type",
                                            IS_CHANGED: "isChanged",
                                            IS_DISPLAY: "isDisplay",
                                            GET_COLUMN: "getColumn",
                                            GET_COLUMNS: "getColumns"
                                         });

    var COLUMN_PROPERTIES = Object.freeze({
                                               COLUMN_METADATA: "columnMetadata",
                                               ID: "id",
                                               TYPE: "type",
                                               LABEL: "label",
                                               SUBLIST_ID: "sublistId"
                                           });

    var ACCESS_LEVEL = Object.freeze({
                NONE: 0,
                READ_ONLY: 1,
                READ_WRITE: 2
                                     });

    function Sublist(sublistDelegate, permissions)
    {
        function authorizeThenWrite(accessLevel, setFunction, propertyName)
        {
            if (accessLevel === ACCESS_LEVEL.READ_WRITE)
            {
                setFunction();
            }
            else
            {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, propertyName );
            }
        }

        function noAction() { }

        if (permissions[SUBLIST_PROPERTIES.ID] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return the ID of the Sublist
             * @name Sublist#id
             * @type string
             * @readonly
             * @since 2015.2
             */
            Object.defineProperty(this, SUBLIST_PROPERTIES.ID, {
                get: function ()
                {
                    return sublistDelegate.getName();
                },
                set: function (val)
                {
                    authorizeThenWrite(permissions[SUBLIST_PROPERTIES.ID], noAction, "Sublist." + SUBLIST_PROPERTIES.ID);
                },
                enumerable: true,
                configurable: false
            });
        }
        if (permissions[SUBLIST_PROPERTIES.TYPE] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return the type of the Sublist
             * @name Sublist#type
             * @type string
             * @readonly
             * @since 2015.2
             */
            Object.defineProperty(this, SUBLIST_PROPERTIES.TYPE, {
                get: function ()
                {
                    return sublistDelegate.getType();
                },
                set: function (val)
                {
                    authorizeThenWrite(permissions[SUBLIST_PROPERTIES.TYPE], noAction, "Sublist." + SUBLIST_PROPERTIES.TYPE);
                },
                enumerable: true,
                configurable: false
            });
        }
        if (permissions[SUBLIST_PROPERTIES.IS_CHANGED] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return whether this sublist has changed
             * @name Sublist#isChanged
             * @type boolean
             * @readonly
             * @since 2015.2
             */
            Object.defineProperty(this, SUBLIST_PROPERTIES.IS_CHANGED, {
                get: function ()
                {
                    return sublistDelegate.isChanged();
                },
                set: function (val)
                {
                    authorizeThenWrite(permissions[SUBLIST_PROPERTIES.IS_CHANGED], noAction, "Sublist." + SUBLIST_PROPERTIES.IS_CHANGED);
                },
                enumerable: true,
                configurable: false
            });
        }
        if (permissions[SUBLIST_PROPERTIES.IS_DISPLAY] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return whether this sublist is displayed
             * @name Sublist#isDisplay
             * @type boolean
             * @readonly
             * @since 2015.2
             */
            Object.defineProperty(this, SUBLIST_PROPERTIES.IS_DISPLAY, {
                get: function ()
                {
                    return sublistDelegate.isDisplay();
                },
                set: function (val)
                {
                    authorizeThenWrite(permissions[SUBLIST_PROPERTIES.IS_DISPLAY], noAction, "Sublist." + SUBLIST_PROPERTIES.IS_DISPLAY);
                },
                enumerable: true,
                configurable: false
            });
        }
        if (permissions[SUBLIST_PROPERTIES.GET_COLUMN] > ACCESS_LEVEL.NONE)
        {
            /**
             * Returns a Column object given the specified fieldId
             * @name Sublist#getColumn
             * @param fieldId
             * @return {Column}
             * @since 2015.2
             */
                    this.getColumn = function (options)
            {
                var undef = undefined,
                                fieldId = options !== undef && options !== null && options.fieldId !== undef ? options.fieldId : options;
                utilityFunctions.checkArgs([fieldId], ['fieldId'], 'sublist.getColumn');
                var columnInfo = sublistDelegate.getColumn(fieldId);
                return !columnInfo ? null : Object.freeze(new Column(columnInfo));
            }
        }
        if (permissions[SUBLIST_PROPERTIES.GET_COLUMNS] > ACCESS_LEVEL.NONE)
        {
            /**
             * Returns an array containing the fieldIds of all columns in the sublist
             * @name Sublist#getColumns
             * @param sublistId
             * @return {Array}
             * @since 2015.2
             */
            this.getColumns = sublistDelegate.getColumns;
        }

        /**
         * Returns the object type name (sublist.Sublist)
         * @returns {string}
         */
                this.toString = function ()
                {
            return "sublist.Sublist"
        };

        /**
         * JSON.stringify() implementation.
         * @returns {{id: string, type: string, isChanged: boolean, isDisplay: boolean}}
         */
                this.toJSON = function ()
                {
            return {
                id: this.id,
                type: this.type,
                isChanged: this.isChanged,
                isDisplay: this.isDisplay
            }
        };

        function Column(columnDelegate)
        {
            var columnPermissions = permissions[COLUMN_PROPERTIES.COLUMN_METADATA];
            /**
             * Return the ID of the Column
             * @name Column#id
             * @type string
             * @readonly
             * @since 2015.2
             */
            Object.defineProperty(this, COLUMN_PROPERTIES.ID, {
                get: function ()
                {
                    return columnDelegate.getName();
                },
                set: function (val)
                {
                    authorizeThenWrite(columnPermissions[COLUMN_PROPERTIES.ID], noAction, "Column." + COLUMN_PROPERTIES.ID);
                },
                enumerable: true,
                configurable: false
            });

            /**
             * Return the type of the Column
             * @name Sublist#type
             * @type string
             * @readonly
             * @since 2015.2
             */
            Object.defineProperty(this, COLUMN_PROPERTIES.TYPE, {
                get: function ()
                {
                    return columnDelegate.getType();
                },
                set: function (val)
                {
                    authorizeThenWrite(columnPermissions[COLUMN_PROPERTIES.TYPE], noAction, "Column." + COLUMN_PROPERTIES.TYPE);
                },
                enumerable: true,
                configurable: false
            });

            /**
             * Return the label of the Column
             * @name Sublist#label
             * @type string
             * @readonly
             * @since 2015.2
             */
            Object.defineProperty(this, COLUMN_PROPERTIES.LABEL, {
                get: function ()
                {
                    return columnDelegate.getLabel();
                },
                set: function (val)
                {
                            var setFunction = function ()
                            {
                        columnDelegate.setLabel(val);
                    };
                    authorizeThenWrite(columnPermissions[COLUMN_PROPERTIES.LABEL], setFunction, "Column." + COLUMN_PROPERTIES.LABEL);
                },
                enumerable: true,
                configurable: false
            });

            /**
             * Return the sublistId of the Column
             * @name Sublist#type
             * @type string
             * @readonly
             * @since 2015.2
             */
            Object.defineProperty(this, COLUMN_PROPERTIES.SUBLIST_ID, {
                get: function ()
                {
                    return columnDelegate.getSublistId();
                },
                set: function (val)
                {
                    authorizeThenWrite(columnPermissions[COLUMN_PROPERTIES.SUBLIST_ID], noAction, "Column." + COLUMN_PROPERTIES.SUBLIST_ID);
                },
                enumerable: true,
                configurable: false
            });

            /**
             * Returns the object type name (sublist.Column)
             * @returns {string}
             */
                    this.toString = function ()
                    {
                return "sublist.Column"
            };

            /**
             * JSON.stringify() implementation.
             * @returns {{id: string, type: string, label: string, sublistId: string}}
             */
                    this.toJSON = function ()
                    {
                return {
                    id: this.id,
                    type: this.type,
                    label: this.label,
                    sublistId: this.sublistId
                }
            };


        }

        Column.prototype = nsobject.getNewInstance();
        Object.freeze(Column);
    }

    Sublist.prototype = nsobject.getNewInstance();
    Object.freeze(Sublist);


    return Object.freeze({
                             Category: SUBLIST_CATEGORY,
                Property: SUBLIST_PROPERTIES,
                             Column: COLUMN_PROPERTIES,
                             Access: ACCESS_LEVEL,
                create: function (delegate, permissions)
                             {
                                 return !delegate ? null : Object.freeze(new Sublist(delegate, permissions));
                             }
                         });
        });

/**
 *
 * @private
 * @module N/sublistPermissions
 * @NApiVersion 2.x
 *
 */
define('N/metadata/sublistPermissions',['N/metadata/sublistDefinition'], 
	function(sublistDef) {

    var sublistRemoteRecord = {};
    sublistRemoteRecord[sublistDef.Property.ID]                                         = sublistDef.Access.READ_ONLY;
    sublistRemoteRecord[sublistDef.Property.TYPE]                                       = sublistDef.Access.READ_ONLY;
    sublistRemoteRecord[sublistDef.Property.IS_CHANGED]                                 = sublistDef.Access.READ_ONLY;
    sublistRemoteRecord[sublistDef.Property.IS_DISPLAY]                                 = sublistDef.Access.READ_ONLY;
    sublistRemoteRecord[sublistDef.Property.GET_COLUMN]                                 = sublistDef.Access.READ_ONLY;
    sublistRemoteRecord[sublistDef.Property.GET_COLUMNS]                                = sublistDef.Access.NONE;
    sublistRemoteRecord[sublistDef.Column.COLUMN_METADATA]                              = {};
    sublistRemoteRecord[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.ID]        = sublistDef.Access.READ_ONLY;
    sublistRemoteRecord[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.TYPE]      = sublistDef.Access.READ_ONLY;
    sublistRemoteRecord[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.LABEL]     = sublistDef.Access.READ_WRITE;
    sublistRemoteRecord[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.SUBLIST_ID] = sublistDef.Access.READ_ONLY;

    var readOnlySublist = {};
    readOnlySublist[sublistDef.Property.ID]                                         = sublistDef.Access.READ_ONLY;
    readOnlySublist[sublistDef.Property.TYPE]                                       = sublistDef.Access.READ_ONLY;
    readOnlySublist[sublistDef.Property.IS_CHANGED]                                 = sublistDef.Access.READ_ONLY;
    readOnlySublist[sublistDef.Property.IS_DISPLAY]                                 = sublistDef.Access.READ_ONLY;
    readOnlySublist[sublistDef.Property.GET_COLUMN]                                 = sublistDef.Access.READ_ONLY;
    readOnlySublist[sublistDef.Property.GET_COLUMNS]                                = sublistDef.Access.NONE;
    readOnlySublist[sublistDef.Column.COLUMN_METADATA]                              = {};
    readOnlySublist[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.ID]        = sublistDef.Access.READ_ONLY;
    readOnlySublist[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.TYPE]      = sublistDef.Access.READ_ONLY;
    readOnlySublist[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.LABEL]     = sublistDef.Access.READ_ONLY;
    readOnlySublist[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.SUBLIST_ID] = sublistDef.Access.READ_ONLY;

    var sublistCurrentRecord = {};
    sublistCurrentRecord[sublistDef.Property.ID]                                         = sublistDef.Access.READ_ONLY;
    sublistCurrentRecord[sublistDef.Property.TYPE]                                       = sublistDef.Access.READ_ONLY;
    sublistCurrentRecord[sublistDef.Property.IS_CHANGED]                                 = sublistDef.Access.READ_ONLY;
    sublistCurrentRecord[sublistDef.Property.IS_DISPLAY]                                 = sublistDef.Access.READ_ONLY;
    sublistCurrentRecord[sublistDef.Property.GET_COLUMN]                                 = sublistDef.Access.NONE;
    sublistCurrentRecord[sublistDef.Property.GET_COLUMNS]                                = sublistDef.Access.NONE;

    var masterPermission = {};
    masterPermission[sublistDef.Category.REMOTE] = sublistRemoteRecord;
    masterPermission[sublistDef.Category.CURRENT] = sublistCurrentRecord;
    masterPermission[sublistDef.Category.READ_ONLY] = readOnlySublist;

    return Object.freeze(masterPermission);
        });

/**
 * Sublist metadata module
 * Will provide the proper attributes based on the parameters sent in to identify its source.
 *
 * @private
 * @module N/sublistMetadata
 * @NApiVersion 2.x
 *
 */
define('N/metadata/sublistMetadata',['N/utilityFunctions', 'N/metadata/sublistDefinition', 'N/metadata/sublistPermissions'],
	function(utilityFunctions, sublistDef, sublistPermissions) {

    function wrap(options)
    {
        var sublistCategory = options.category || null,
                   delegate = options.delegate || null;

        utilityFunctions.checkArgs([sublistCategory, delegate], ["sublistCategory", "delegate"], "sublistMetadata");

        return sublistDef.create(delegate, sublistPermissions[sublistCategory]);
    }

    return Object.freeze({
                             Category: sublistDef.Category,
                wrap: wrap
                         });
        });

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/line/dynamicLine
 * @suiteScriptVersion 2.x
 */
define('N/record/line/dynamicLine',['N/nsobject', 'N/record/recordConstants', 'N/utilityFunctions', 'N/error', 'N/environment'],
	function (nsobject, constants, utilityFunctions, error, environment)
	{
		var proxyOptions = Object.freeze({isInteractive: true});

		/**
		 * 
		 * Interface to subrecord line of dynamic record
		 * @param {Line} line
		 * @return {Line}
		 * @constructor
		 * @since 2017.1
		 */
		function DynamicLine(line)
		{
			/**
			 * The instance id of the line
			 * @property {string} instanceId
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'instanceId', line.getLineInstanceId);
			utilityFunctions.addReadOnlyProperty(this, 'sublistId', line.getSublistId);
			utilityFunctions.addReadOnlyProperty(this, 'sequence', line.getSequence);
			utilityFunctions.addReadOnlyProperty(this, 'record', getRecord);
			
			function getRecord()
			{
				return line.getRecord().proxy(proxyOptions);
			}

			this.cancel = line.cancel;
			this.commit = line.commit;
			this.getFields = line.getFields;
			this.getField = line.getField;
			this.getValue = line.getValue;
			this.setValue = line.setValue;
			this.getText = line.getText;
			this.setText = line.setText;
			this.hasSubrecord = line.hasSubrecord;
			this.getSubrecord = function getSubrecord()
			{
				var subrecord = line.getSubrecord.apply(line, arguments);
				return !subrecord ? null : subrecord.proxy(proxyOptions);
			};
			this.removeSubrecord = line.removeSubrecord;
			this.makeCopy = line.makeCopy;
			this.on = line.on;
			this.off = line.off;
			this.toJSON = line.toJSON;
			this.toString = function () {return constants.LINE_MODE.DYNAMIC_LINE;};

			return this;
		}

		DynamicLine.prototype = nsobject.getNewInstance();

		Object.freeze(DynamicLine);

		return DynamicLine;
	});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/line/deferredDynamicLine
 * @suiteScriptVersion 2.x
 */
define('N/record/line/deferredDynamicLine',['N/nsobject', 'N/record/recordConstants', 'N/utilityFunctions', 'N/error', 'N/environment'],
	function (nsobject, constants, utilityFunctions, error, environment)
	{
		var proxyOptions = Object.freeze({isInteractive: true});

		/**
		 * Interface to sublist line of deferred dynamic record
		 * @param {Line} line
		 * @return {Line}
		 * @constructor
		 * @since 2017.1
		 */
		function DeferredDynamicLine(line)
		{
			/**
			 * The instance id of the line
			 * @property {string} instanceId
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'instanceId', line.getLineInstanceId);
			utilityFunctions.addReadOnlyProperty(this, 'sublistId', line.getSublistId);
			utilityFunctions.addReadOnlyProperty(this, 'sequence', line.getSequence);
			utilityFunctions.addReadOnlyProperty(this, 'record', getRecord);

			function getRecord()
			{
				return line.getRecord().proxy(proxyOptions);
			}

			this.getFields = line.getFields;
			this.getField = line.getField;
			this.getValue = line.getValue;
			this.setValue = line.setValue;
			this.getText = line.getText;
			this.setText = line.setText;
			this.hasSubrecord = line.hasSubrecord;
			this.getSubrecord = function getSubrecord()
			{
				var subrecord = line.getSubrecord.apply(line, arguments);
				return !subrecord ? null : subrecord.proxy(proxyOptions);
			};
			this.removeSubrecord = line.removeSubrecord;
			this.makeCopy = line.makeCopy;
			this.toJSON = line.toJSON;
			this.toString = function () {return constants.LINE_MODE.DEFERRED_DYNAMIC_LINE;};

			return this;
		}

		DeferredDynamicLine.prototype = nsobject.getNewInstance();

		Object.freeze(DeferredDynamicLine);

		return DeferredDynamicLine;
	});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/line/readOnlyLine
 * @suiteScriptVersion 2.x
 */
define('N/record/line/readOnlyLine',['N/nsobject', 'N/record/recordConstants', 'N/utilityFunctions', 'N/error', 'N/environment'],
	function (nsobject, constants, utilityFunctions, error, environment)
	{
		var proxyOptions = Object.freeze({isInteractive: true});

		/**
		 * ReadOnly Line interface
		 * @param {Line} line
		 * @return {Line}
		 * @constructor
		 * @since 2016.2
		 */
		function ReadOnlyLine(line)
		{
			/**
			 * The instance id of the line
			 * @property {string} instanceId
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'instanceId', line.getLineInstanceId);
			utilityFunctions.addReadOnlyProperty(this, 'sublistId', line.getSublistId);
			utilityFunctions.addReadOnlyProperty(this, 'sequence', line.getSequence);
			utilityFunctions.addReadOnlyProperty(this, 'record', getRecord);

			function getRecord()
			{
				return line.getRecord().proxy(proxyOptions);
			}

			this.getFields = line.getFields;
			this.getField = line.getField;
			this.getValue = line.getValue;
			this.getText = line.getText;
			this.hasSubrecord = line.hasSubrecord;
			this.getSubrecord = function getSubrecord()
			{
				var subrecord = line.getSubrecord.apply(line, arguments);
				return !subrecord ? null : subrecord.proxy(proxyOptions);
			};
			this.makeCopy = line.makeCopy;
			this.toJSON = line.toJSON;
			this.toString = function () {return constants.LINE_MODE.READ_ONLY_LINE;};

			return this;
		}

		ReadOnlyLine.prototype = nsobject.getNewInstance();

		Object.freeze(ReadOnlyLine);

		return ReadOnlyLine;
	});

/**
 * SuiteScript record sublist line proxy module
 *
 * Creates a wrapper around the record sublist line that selectively exposes the line interface.
 *
 * @private
 * @module N/record/line/lineProxy
 * @NApiVersion 2.x
 */
define('N/record/line/lineProxy',['N/record/recordConstants',
		'N/record/line/dynamicLine', 'N/record/line/deferredDynamicLine', 'N/record/line/readOnlyLine'],
	function(constants,
	         DynamicLine, DeferredDynamicLine, ReadOnlyLine)
	{
		/**
		 * returns a record sublist line proxy based on the input configuration
		 *
		 * @param options
		 * @param {Line} options.delegate the actual underlying line instance (from lineDefinition).
		 * @param {boolean} options.isDynamic true if the line's record instance is a dynamic record
		 * @param {boolean} options.isReadOnly true if the line is read only instance
		 */
		function wrap(options)
		{
			var wrappedLine;
			var line = options.delegate;
			var isReadOnly = !!options.isReadOnly;
			var isDynamic = !!options.isDynamic;

			if(isReadOnly)
			{
				wrappedLine = new ReadOnlyLine(line);
			}
			else if (!isDynamic)
			{
				wrappedLine = new DeferredDynamicLine(line);
			}
			else if (isDynamic)
			{
				wrappedLine = new DynamicLine(line);
			}

			return wrappedLine;
		}

		return {
			wrap : wrap
		};
	}
);

// RecordBehaviorDelegate

/**
 * Performs the actions desired by the record or line objects with respect to the record.
 *
 * @private
 * @module N/common/record/recordActualWork
 * @NApiVersion 2.x
 *
 */
define('N/common/record/recordActualWork',['N/record/recordUtilityFunctions', 'N/utilityFunctions', 'N/util/formatter', 'N/util/validator'],
	function(recordUtil, utilityFunctions, formatter, validator)
{
	var undef = undefined;
	var IS_CHANGED = true;
	var FIELD_ID = "fieldId";
	var SUBLIST_ID = "sublistId";
	var METHOD_GET_FIELD = "getField";
	var METHOD_GET_FIELDS = "getFields";
	var METHOD_GET_VALUE = "getValue";
	var METHOD_SET_VALUE = "setValue";
	var METHOD_GET_TEXT = "getText";
	var METHOD_SET_TEXT = "setText";
	var METHOD_HAS_SUBRECORD = "hasSubrecord";
	var METHOD_GET_SUBRECORD = "getSubrecord";
	var METHOD_REMOVE_SUBRECORD = "removeSubrecord";


	/**
	 * Delegation Service for record-like object
	 * @param {Object} options
	 * @param {Record|Line} options.delegate
	 * @constructor
	 */
	function RecordBehaviorDelegate(options)
	{
		var delegate = options.delegate;


		function getFieldState(fieldId)
		{
			return delegate.getFieldState(fieldId);
		}

		function getFieldLevelMetadata(fieldId)
		{
			return delegate.getFieldLevelMetadataForBodyField(fieldId);
		}

		function isValidField(fieldId)
		{
			return delegate.isValidBodyField(fieldId);
		}

		function getField(options)
		{
			var fieldId = recordUtil.handleOverloadingMethodsForSingleArgument(options, FIELD_ID, delegate.getMissingArgumentErrorMessageFillerValue(METHOD_GET_FIELD));
			return delegate.doGetField(fieldId, this);
		}
		this.getField = getField;

		function getFields()
		{
			return delegate.doGetFields();
		}
		this.getFields = getFields;

		function getValue(options)
		{
			var isTextApi = false;
			var fieldId = recordUtil.handleOverloadingMethodsForSingleArgument(options, FIELD_ID, delegate.getMissingArgumentErrorMessageFillerValue(METHOD_GET_VALUE));
			delegate.validateTextApi(isTextApi, getFieldState(fieldId), METHOD_SET_TEXT, METHOD_GET_TEXT);
			return delegate.getParsedValueForBodyField(fieldId, this);
		}
		this.getValue = getValue;

		function setValue(options, value)
		{
			var fieldId, fireFieldChange = true;
			if (value !== undef || (options !== undef && options.fieldId === undef && typeof options === 'string'))
			{
				fieldId = options;
			}
			else if (options !== undef && options !== null)
			{
				fieldId = options.fieldId;
				value = options.value;
				fireFieldChange = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChange;
			}

			utilityFunctions.checkArgs([fieldId], [FIELD_ID], delegate.getMissingArgumentErrorMessageFillerValue(METHOD_SET_VALUE));
			recordUtil.validateAgainstSqlInjection(fieldId, value);
			delegate.doSetValue(fieldId, value, fireFieldChange, this);
		}
		this.setValue = setValue;

		function getText(options)
		{
			var isTextApi = true;
			var fieldId = recordUtil.handleOverloadingMethodsForSingleArgument(options, FIELD_ID, delegate.getMissingArgumentErrorMessageFillerValue(METHOD_GET_TEXT));
			delegate.validateTextApi(isTextApi, getFieldState(fieldId), METHOD_SET_VALUE, METHOD_GET_VALUE);
			return delegate.doGetText(fieldId, this);
		}
		this.getText = getText;

		function setText(options, text)
		{
			var fieldId, fireFieldChange = true;
			if (text !== undef || (options !== undef && options.fieldId === undef && typeof options === 'string'))
			{
				fieldId = options;
			}
			else if (options !== undef && options !== null)
			{
				fieldId = options.fieldId;
				text = options.text;
				fireFieldChange = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChange;
			}
			delegate.getMissingArgumentErrorMessageFillerValue(METHOD_GET_TEXT);
			utilityFunctions.checkArgs([fieldId], [FIELD_ID], delegate.getMissingArgumentErrorMessageFillerValue(METHOD_SET_TEXT));

			text = recordUtil.emptyIfNullOrUndefined(text);
			recordUtil.validateAgainstSqlInjection(fieldId, text);
			delegate.doSetText(fieldId, text, fireFieldChange, this);
		}
		this.setText = setText;

		function getParsedValue(fieldId)
		{
			var returnValue = delegate.doGetValue(fieldId);
			var fs = getFieldState(fieldId);
			var fieldLevelMetadata = getFieldLevelMetadata(fieldId);
			var isCheckbox = fieldLevelMetadata && fieldLevelMetadata.type === recordUtil.FIELD_TYPE.CHECKBOX;

			if ((fs && !fs.isParsed) || (isCheckbox && returnValue === ""))
			{
				var isFieldValid = isValidField(fieldId);
				var parsedValue = delegate.parseValue(isFieldValid, fieldLevelMetadata, returnValue);
				if (isFieldValid || parsedValue !== undefined)
					delegate.setParsedValueAndUpdateFieldState(fieldId, parsedValue, fs);
				returnValue = parsedValue;
			}
			return returnValue;
		}
		this.getParsedValue = getParsedValue;

		function getTextValue(fieldId)
		{
			var useBuffer = false;
			var lineInstanceId = null;
			return getTextValueForInstance(undef, fieldId, lineInstanceId, useBuffer)
		}
		this.getTextValue = getTextValue;

		function getTextValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer)
		{
			var setFieldMetadata = delegate.getSetFieldMetadata(sublistId, fieldId);
			var fieldLevelMetadata = delegate.extractInforFromFieldLevelMetadata(sublistId, fieldId);
			var value = getParsedValue(fieldId);
			return doGetTextValueForInstance(delegate.getHack(), value, lineInstanceId, useBuffer, setFieldMetadata, fieldLevelMetadata);
		}
		this.getTextValueForInstance = getTextValueForInstance;

		function commit()
		{
			return delegate.doCommit();
		}
		this.commit = commit;

		function cancel()
		{
			return delegate.doCancel();
		}
		this.cancel = cancel;

		function hasSubrecord(options)
		{
			var fieldId = recordUtil.handleOverloadingMethodsForSingleArgument(options, FIELD_ID, delegate.getMissingArgumentErrorMessageFillerValue(METHOD_HAS_SUBRECORD));
			return delegate.doHasSubrecord(fieldId);
		}
		this.hasSubrecord = hasSubrecord;

		function getSubrecord(options)
		{
			var fieldId = recordUtil.handleOverloadingMethodsForSingleArgument(options, FIELD_ID, delegate.getMissingArgumentErrorMessageFillerValue(METHOD_GET_SUBRECORD));
			return delegate.doGetSubrecord(fieldId);
		}
		this.getSubrecord = getSubrecord;

		function removeSubrecord(options)
		{
			var fieldId = recordUtil.handleOverloadingMethodsForSingleArgument(options, FIELD_ID, delegate.getMissingArgumentErrorMessageFillerValue(METHOD_REMOVE_SUBRECORD));
			return delegate.doRemoveSubrecord(fieldId);
		}
		this.removeSubrecord = removeSubrecord;

		function makeCopy()
		{
			return delegate.doMakeCopy();
		}
		this.makeCopy = makeCopy;
	}

	function create(options)
	{
		return new RecordBehaviorDelegate(options);
	}


	function updateSubrecordStates(record)
	{
		var subrecordSublistState = record.getSubrecordSublistState();
		var subrecordFieldState = record.getSubrecordFieldState();
		if (subrecordSublistState != null)
			subrecordSublistState.isChanged = IS_CHANGED;
		if (subrecordFieldState != null)
			subrecordFieldState.isChanged = IS_CHANGED;
	}

	function formatValueAsText(value, metadata)
	{
		var returnMe;
		if (util.isArray(value))
		{
			returnMe = value.map(function (val)
			{
				return recordUtil.formatArrayToStringType(val);
			});
		}
		else
		{
			returnMe = formatFieldWithEmptyValueOrSelectTypeOrVirtualField(value, metadata);
			if (returnMe === null)
			{
				returnMe = doFormatValue(value, metadata);
			}
		}
		return returnMe;
	}

	function formatFieldWithEmptyValueOrSelectTypeOrVirtualField(value, metadata)
	{
		var fieldType = metadata.type || null;
		var formattedValue = null;

		if (!value && value !== "" && value !== 0 && !util.isBoolean(value))
			formattedValue = "";
		else if (metadata.isMultiSelect && util.isArray(value))
			formattedValue = value.join(String.fromCharCode(5));
		else if (metadata.isSelect || fieldType === null)
			formattedValue = String(value);

		return formattedValue;
	}

	function needsToBeFormattedForLegacySave(metadata, value)
	{
		return util.isDate(value) || util.isBoolean(value) ||
			   metadata.type === recordUtil.FIELD_TYPE.TIME || metadata.type === recordUtil.FIELD_TYPE.TIMETRACK;
	}

	function doFormatValue(value, metadata)
	{
		var fieldType = metadata.type || null;
		var isNumeric = metadata.isNumeric || false;
		var isCurrency = metadata.isCurrency || false;
		var formattedValue = formatter.format(value, fieldType, isNumeric, isCurrency);
		return formattedValue ? String(formattedValue) : formattedValue;
	}

	function formatValueForLegacySyntheticRequest(value, metadata)
	{
		var formattedValue = formatFieldWithEmptyValueOrSelectTypeOrVirtualField(value, metadata);
		if (formattedValue === null || formattedValue === undef)
		{
			if (needsToBeFormattedForLegacySave(metadata, value))
				formattedValue = doFormatValue(value, metadata);
			else
				formattedValue = String(value)
		}

		return formattedValue;
	}

	function postDoSetSublistValueForInstance(record, sublistId, fieldId, lineInstanceId, useBuffer)
	{
		record.invalidateSubrecordClones();
		record.getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, useBuffer).isChanged = IS_CHANGED;
		updateSubrecordStates(record);
	}

	function postDoSetValueForInstance(record, postSetObject, lineInstanceId, useBuffer)
	{
		record.invalidateSubrecordClones();
		record.postSetFieldValueForInstance(postSetObject.sublistId, postSetObject.fieldId,
			lineInstanceId, useBuffer, postSetObject.dbValue,
			postSetObject.fireFieldChange, postSetObject.noSlaving, postSetObject.isUpdatingSlavingField);
		updateSubrecordStates(record);
	}

	function createObjectToDoSetSublistValue(val, metadata)
	{
		var value = recordUtil.emptyIfNullOrUndefined(val);
		var dbValue = formatValueForLegacySyntheticRequest(value, metadata);
		return {value: value, legacyStringValue: dbValue};
	}

	function createObjectToDoSetValue(val, metadata)
	{
		var dbValue;
		if (metadata.valueIsFormattedAsString)
			dbValue = (val !== null) ? String(val) : null;
		else
			dbValue = formatValueForLegacySyntheticRequest(val, metadata);
		return {value: val, legacyStringValue: dbValue};
	}

	function preDoSetSublistBufferValue(record, lineInstanceId, value, metadata)
	{
		var useBuffer = true;

		value = recordUtil.emptyIfNullOrUndefined(value);
		if (!!metadata.isMultiSelect)
			value = recordUtil.formatValueToArrayType(value);
		else if (!!metadata.isRadio)
			value = String(value);
		return record.validateAndFormatFieldValueForInstance(metadata.sublistId, metadata.fieldId, lineInstanceId, useBuffer, value, metadata.isInteractive);
	}

	function getTextValueForRadioField(value, fieldLevelMetadata)
	{
		var returnText = "";
		if (fieldLevelMetadata.radioSet)
			returnText = fieldLevelMetadata.radioSet[value];
		else if (fieldLevelMetadata.hasBlankString)
			returnText = fieldLevelMetadata.blankString;
		return returnText;
	}

	function getTextValueForSelectField(record, value, lineInstanceId, useBuffer, fieldLevelMetadata)
	{
		var returnText = "";
		var isMulti = false;
		if (util.trim(value) || value === 0 || value === false)
		{
			if (Array.isArray(fieldLevelMetadata.supplementedOptions))
				returnText = record.doGetTextValueForSupplementedSelectFieldForInstance(fieldLevelMetadata.sublistId, fieldLevelMetadata.fieldId, value, lineInstanceId, useBuffer, isMulti);
			else
				returnText = record.doGetTextValueForSelectFieldForInstance(fieldLevelMetadata.sublistId, fieldLevelMetadata.fieldId, value, lineInstanceId, useBuffer, isMulti);
		}
		else if (fieldLevelMetadata.hasBlankString)
			returnText = fieldLevelMetadata.blankString;

		return returnText;
	}

	function getTextValueForMultiSelectFieldForInstance(record, value, lineInstanceId, useBuffer, fieldLevelMetadata)
	{
		var returnText = "";
		var isMulti = true;
		if (value || value === 0 || value === false)
			returnText = record.doGetTextValueForSelectFieldForInstance(fieldLevelMetadata.sublistId, fieldLevelMetadata.fieldId, value, lineInstanceId, useBuffer, isMulti);
		else if (fieldLevelMetadata.hasBlankString)
			returnText = fieldLevelMetadata.blankString;

		return returnText ? String(returnText).split(String.fromCharCode(5)) : [];
	}

	function doGetTextValueForInstance(record, value, lineInstanceId, useBuffer, metadata, fieldLevelMetadata)
	{
		var formattedValue;
		if (!metadata.isValidField || value === undef || value === null)
			formattedValue = value;
		else if (metadata.isMultiSelect)
			formattedValue = getTextValueForMultiSelectFieldForInstance(record, value, lineInstanceId, useBuffer, fieldLevelMetadata);
		else if (metadata.isSelect)
			formattedValue = getTextValueForSelectField(record, value, lineInstanceId, useBuffer, fieldLevelMetadata);
		else if (metadata.isRadio)
			formattedValue = getTextValueForRadioField(value, fieldLevelMetadata);
		else
			formattedValue = formatValueAsText(value, metadata);
		return formattedValue;
	}


	function handleMultiSelectAndVirtualFieldForReturnValue(value, metadata)
	{
		var returnMe;
		if (metadata.hasFieldExisted)
			returnMe = (metadata.isMultiSelect && !value && value !== 0) ? [] : value;
		else
			returnMe = undef;
		return returnMe;
	}

	function getValueOrValuesForSelect(record, sublistId, fieldId, text, lineInstanceId, isMultiSelect, useBuffer)
	{
		var returnMe = "";
		var rf;
		record.validateIfSublistIdEditableCurrentSublist(sublistId);
		if (isMultiSelect)
		{
			returnMe = recordUtil.formatValueToArrayType(text);
			rf = record.getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
			returnMe = rf.validateSelectFieldByText(returnMe);
		}
		else
		{
			var unwrappedText = recordUtil.formatArrayToStringType(text);
			if (unwrappedText || unwrappedText === "")
			{
				rf = record.getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
				returnMe = rf.validateSelectFieldByText(unwrappedText);
			}
		}
		return returnMe;
	}

	function convertTextToValueForSetText(record, sublistId, fieldId, lineInstanceId, text, metadata, useBuffer)
	{
		var value;
		if (metadata.isMultiSelect || metadata.isSelect)
			value = getValueOrValuesForSelect(record, sublistId, fieldId, text, lineInstanceId, metadata.isMultiSelect, useBuffer);
		else if (metadata.isRadio)
			value = validator.validateRadioFieldByText(fieldId, text, metadata.radioSet);
		else
		{
			var fieldLevelMetadata = record.getMetadata().getFieldMetadata(sublistId, fieldId);
			if (fieldLevelMetadata && fieldLevelMetadata.type === recordUtil.FIELD_TYPE.TIME)
				validator.validateField(fieldId, "text", text, false, false, undefined, undefined, undefined, fieldLevelMetadata.maxLength, false, true);
			value = record.parseValue(metadata.isValidField, fieldLevelMetadata, text);
		}
		return value;
	}

	return {
		create: create,
		createObjectToDoSetSublistValue : createObjectToDoSetSublistValue,
		createObjectToDoSetValue: createObjectToDoSetValue,
		postDoSetSublistValueForInstance: postDoSetSublistValueForInstance,
		postDoSetValueForInstance: postDoSetValueForInstance,
		handleMultiSelectAndVirtualFieldForReturnValue: handleMultiSelectAndVirtualFieldForReturnValue,
		preDoSetSublistBufferValue: preDoSetSublistBufferValue,
		convertTextToValueForSetText: convertTextToValueForSetText
	}
});

/**
 * SuiteScript persisted sublist line impl
 *
 * @private
 * @module N/record/line/sublistLineImpl
 * @NApiVersion 2.x
 *
 */
define('N/record/line/sublistLineImpl',[],
	function() {

	/**
	 * Line implementation for sublist line instance
	 * @param {Line} line
	 * @constructor
	 */
	function SublistLineImpl(line) {
		var useBuffer = false;

		function getSublistId()
		{
			return line.getSublistId();
		}

		function getLineInstanceId()
		{
			return line.getLineInstanceId();
		}

		function getParentRecord(){
			return line.getUnproxiedRecord();
		}

		function getFieldState(fieldId)
		{
			return getParentRecord().getSublistFieldStateForInstance(getSublistId(), fieldId, getLineInstanceId(), useBuffer);
		}
		this.getFieldState = getFieldState;

		function getParsedValueForBodyField(fieldId, delegator)
		{
			return getParentRecord().doGetParsedSublistValueForInstance(getSublistId(), fieldId, getLineInstanceId(), useBuffer, delegator);
		}
		this.getParsedValueForBodyField = getParsedValueForBodyField;

		function setParsedValueForBodyField(fieldId, value)
		{
			getParentRecord().setParsedValueForSublistFieldForInstance(getSublistId(), getLineInstanceId(), fieldId, value, useBuffer);
		}
		this.setParsedValueForBodyField = setParsedValueForBodyField;

		function doGetValue(fieldId)
		{
			return getParentRecord().doGetSublistValueForInstance(getSublistId(), fieldId, getLineInstanceId(), useBuffer);
		}
		this.doGetValue = doGetValue;

		function doGetText(fieldId, delegator)
		{
			return getParentRecord().doGetSublistTextForInstance(getSublistId(), fieldId, getLineInstanceId(), useBuffer, delegator);
		}
		this.doGetText = doGetText;

		function doSetValue(fieldId, value, fireFieldChange)
		{
			return getParentRecord().doSetSublistValueForInstance(getSublistId(), fieldId, getLineInstanceId(), value, fireFieldChange, useBuffer);
		}
		this.doSetValue = doSetValue;

		function doSetText(fieldId, text, fireFieldChange)
		{
			var noSlaving = false;
			var isUpdatingSlavingField = false;
			return getParentRecord().doSetSublistTextForInstance(getSublistId(), fieldId, getLineInstanceId(), text, fireFieldChange, noSlaving, isUpdatingSlavingField, useBuffer);
		}
		this.doSetText = doSetText;

		function doGetField(fieldId, delegator)
		{
			return getParentRecord().doGetFieldForInstance(getSublistId(), fieldId, getLineInstanceId(), useBuffer, delegator);
		}
		this.doGetField = doGetField;

		function doGetFields()
		{
			return getParentRecord().getSublistFields(getSublistId());
		}
		this.doGetFields = doGetFields;

		function doCommit()
		{
			return getParentRecord().commitLineForInstance(getSublistId(), getLineInstanceId());
		}
		this.doCommit = doCommit;

		function doCancel()
		{
			return getParentRecord().cancelLineForInstance(getSublistId(), getLineInstanceId());
		}
		this.doCancel = doCancel;

		function hasSubrecord(fieldId)
		{
			return getParentRecord().doHasSubrecordForInstance(getSublistId(), fieldId, getLineInstanceId(), useBuffer);
		}
		this.hasSubrecord = hasSubrecord;

		function getSubrecord(fieldId)
		{
			return getParentRecord().doGetSublistSubrecordForInstance(getSublistId(), fieldId, getLineInstanceId(), useBuffer);
		}
		this.getSubrecord = getSubrecord;

		function removeSubrecord(fieldId)
		{
			return getParentRecord().doRemoveSublistSubrecordForInstance(getSublistId(), fieldId, getLineInstanceId(), useBuffer);
		}
		this.removeSubrecord = removeSubrecord;

		function makeCopy()
		{
			return getParentRecord().makeCopyForInstance(getSublistId(), getLineInstanceId(), useBuffer);
		}
		this.makeCopy = makeCopy;
	}

	function create(line)
	{
		return new SublistLineImpl(line);
	}

	return {
		/**
		 * create a regular sublistline implementation that will supplement line behavior
		 * @param {Line} line
		 */
		create : create
	};
});

/**
 * SuiteScript sublist buffer line impl
 *
 * @private
 * @module N/record/line/sublistLineBufferImpl
 * @NApiVersion 2.x
 *
 */
define('N/record/line/sublistLineBufferImpl',[], function() {

	/**
	 * Line implementation for sublist buffer line instance
	 * @param {Line} line
	 * @constructor
	 */
	function SublistLineBufferImpl(line) {
		var useBuffer = true;

		function getSublistId()
		{
			return line.getSublistId();
		}

		function getLineInstanceId()
		{
			return line.getLineInstanceId();
		}

		function getParentRecord(){
			return line.getUnproxiedRecord();
		}

		function getFieldState(fieldId)
		{
			return getParentRecord().getSublistFieldStateForInstance(getSublistId(), fieldId, getLineInstanceId(), useBuffer);
		}
		this.getFieldState = getFieldState;
		
		function getParsedValueForBodyField(fieldId, delegator)
		{
			return getParentRecord().doGetParsedSublistValueForInstance(getSublistId(), fieldId, getLineInstanceId(), useBuffer, delegator);
		}
		this.getParsedValueForBodyField = getParsedValueForBodyField;

		function setParsedValueForBodyField(fieldId, value)
		{
			getParentRecord().setParsedValueForSublistFieldForInstance(getSublistId(), getLineInstanceId(), fieldId, value, useBuffer);
		}
		this.setParsedValueForBodyField = setParsedValueForBodyField;

		function doGetValue(fieldId)
		{
			return getParentRecord().doGetSublistValueForInstance(getSublistId(), fieldId, getLineInstanceId(), useBuffer);
		}
		this.doGetValue = doGetValue;

		function doGetText(fieldId, delegator)
		{
			return getParentRecord().doGetSublistTextForInstance(getSublistId(), fieldId, getLineInstanceId(), useBuffer, delegator);
		}
		this.doGetText = doGetText;

		function doSetValue(fieldId, value, fireFieldChange)
		{
			return getParentRecord().doSetSublistValueForInstance(getSublistId(), fieldId, getLineInstanceId(), value, fireFieldChange, useBuffer);
		}
		this.doSetValue = doSetValue;

		function doSetText(fieldId, text, fireFieldChange)
		{
			var noSlaving = false;
			var isUpdatingSlavingField = false;
			return getParentRecord().doSetSublistTextForInstance(getSublistId(), fieldId, getLineInstanceId(), text, fireFieldChange, noSlaving, isUpdatingSlavingField, useBuffer);
		}
		this.doSetText = doSetText;

		function doGetField(fieldId, delegator)
		{
			return getParentRecord().doGetFieldForInstance(getSublistId(), fieldId, getLineInstanceId(), useBuffer, delegator);
		}
		this.doGetField = doGetField;

		function doGetFields()
		{
			return getParentRecord().getSublistFields(getSublistId());
		}
		this.doGetFields = doGetFields;

		function doCommit()
		{
			return getParentRecord().commitLineForInstance(getSublistId(), getLineInstanceId());
		}
		this.doCommit = doCommit;

		function doCancel()
		{
			return getParentRecord().cancelLineForInstance(getSublistId(), getLineInstanceId());
		}
		this.doCancel = doCancel;

		function hasSubrecord(fieldId)
		{
			return getParentRecord().doHasSubrecordForInstance(getSublistId(), fieldId, getLineInstanceId(), useBuffer);
		}
		this.hasSubrecord = hasSubrecord;

		function getSubrecord(fieldId)
		{
			return getParentRecord().doGetSublistSubrecordForInstance(getSublistId(), fieldId, getLineInstanceId(), useBuffer);
		}
		this.getSubrecord = getSubrecord;
		
		function removeSubrecord(fieldId)
		{
			return getParentRecord().doRemoveSublistSubrecordForInstance(getSublistId(), fieldId, getLineInstanceId(), useBuffer);
		}
		this.removeSubrecord = removeSubrecord;

		function makeCopy()
		{
			return getParentRecord().makeCopyForInstance(getSublistId(), getLineInstanceId(), useBuffer);
		}
		this.makeCopy = makeCopy;
	}

	function create(line)
	{
		return new SublistLineBufferImpl(line);
	}

	return {
		/**
		 * create a buffered sublistline implementation that will supplement line behavior
		 * @param {Line} line
		 */
		create : create
	};
});

/**
 * SuiteScript record impl factory
 *
 * @private
 * @module N/record/line/sublistLineImplementation
 * @NApiVersion 2.x
 *
 */
define('N/record/line/sublistLineImplementation',['N/record/line/sublistLineImpl', 'N/record/line/sublistLineBufferImpl'], function(sublistLineImpl, sublistLineBufferImpl){

	function create(options)
	{
		var useBuffer = options.useBuffer;
		var line = options.line;
		return !useBuffer ? sublistLineImpl.create(line) : sublistLineBufferImpl.create(line);
	}

	return {
		/**
		 * create the corresponding implementation for line object based on the useBuffer mode
		 * @param {Object} options
		 * @param {boolean} options.useBuffer is buffer instance
		 * @param {Line} options.line line definition object
		 */
		create : create
	};
});

/**
 * SuiteScript record event enum module
 *
 * @private
 * @module N/record/recordEvent
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/recordEvent',[],function () {
    var EVENT_TYPE = Object.freeze({
            ERROR: 'ERROR',

            UPDATE_ALL: 'UPDATE_ALL',
            RECORD_INITIALIZED: 'RECORD_INITIALIZED',

            UPDATE_FIELD_VALUE: 'UPDATE_FIELD_VALUE',
            UPDATE_FIELD_OPTIONS: 'UPDATE_FIELD_OPTIONS',
            UPDATE_SUBLIST: 'UPDATE_SUBLIST',
            CREATE_LINE: 'CREATE_LINE',
            UPDATE_LINE: 'UPDATE_LINE',
            INSERT_LINE: 'INSERT_LINE',
            REMOVE_LINE: 'REMOVE_LINE',
            SELECT_LINE: 'SELECT_LINE',
            UPDATE_RELATED_RECORD_VIEW: 'UPDATE_RELATED_RECORD_VIEW',

            FIELD_IS_MANDATORY_CHANGE: 'FIELD_IS_MANDATORY_CHANGE',
            FIELD_IS_HIDDEN_CHANGE: 'FIELD_IS_HIDDEN_CHANGE',
            FIELD_IS_DISABLED_CHANGE: 'FIELD_IS_DISABLED_CHANGE',
            FIELD_IS_VISIBLE_CHANGE: 'FIELD_IS_VISIBLE_CHANGE',
            FIELD_IS_DISPLAY_CHANGE: 'FIELD_IS_DISPLAY_CHANGE',
            FIELD_IS_READ_ONLY_CHANGE: 'FIELD_IS_READ_ONLY_CHANGE',
            FIELD_LABEL_CHANGE: 'FIELD_LABEL_CHANGE',

            SUBLIST_IS_DISPLAY_CHANGE: 'SUBLIST_IS_DISPLAY_CHANGE',
            SUBLIST_IS_HIDDEN_CHANGE: 'SUBLIST_IS_HIDDEN_CHANGE',
            SUBLIST_COLUMN_LABEL_CHANGE: 'SUBLIST_COLUMN_LABEL_CHANGE',

		    LINE_VALIDATION_FAILED: 'LINE_VALIDATION_FAILED'
        });

    return Object.freeze({
        Type : EVENT_TYPE
    });
});

/**
 * SuiteScript sublist line event module
 *
 * @private
 * @module N/record/sublistLineEvent
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/sublistLineEvent',[], function()
{
	var EVENT_TYPE = Object.freeze({
			FIELD_VALUE_CHANGE: 'FIELD_VALUE_CHANGE'
		});

	function getEvent(sublistLine, fieldId, type)
	{
		return {
			type: type,
			sublistLine: sublistLine,
			fieldId: fieldId
		};
	}

	function addFieldValues(event, oldValue, newValue)
	{
		event.oldValue = oldValue;
		if(newValue !== undefined)
		{
			event.newValue = newValue;
		}

		return event;
	}

	function addInternalFlag(event, isInternalChange)
	{
		if (isInternalChange === true)
			event.internal = true;

		return event;
	}

	function emit(emitter, sublistLine, fieldId, type)
	{
		emitter.emit(getEvent(sublistLine, fieldId, type));
	}

	function updateField(emitter, sublistLine, fieldId, oldValue, newValue, isInternalChange)
	{
		emitter.emit(addInternalFlag(addFieldValues(getEvent(sublistLine, fieldId, EVENT_TYPE.FIELD_VALUE_CHANGE), oldValue, newValue), isInternalChange));
	}

	return Object.freeze({
		Type: EVENT_TYPE,
		emit: emit,
		updateField: updateField
	});
});

/**
 * SuiteScript model event module
 *
 * @private
 * @module N/record/modelEvent
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/modelEvent',['N/record/sublistLineEvent'], function(sublistLineEvent)
{
	var EVENT_TYPE = Object.freeze({
			FIELD_VALUE_CHANGE: 'FIELD_VALUE_CHANGE',
			LINE_SELECT: 'LINE_SELECT',
			LINE_CREATE: 'LINE_CREATE',
			LINE_INSERT: 'LINE_INSERT',
			LINE_UPDATE: 'LINE_UPDATE',
			LINE_DELETE: 'LINE_DELETE'
		});

	function getEvent(type)
	{
		return {
			type: type
		};
	}

	function addFieldId(event, fieldId)
	{
		event.fieldId = fieldId;

		return event;
	}

	function addFieldValues(event, oldValue, newValue)
	{
		event.oldValue = oldValue;
		if(newValue !== undefined)
		{
			event.newValue = newValue;
		}

		return event;
	}

	function addSublistInfo(event, sublistLine, isBuffer, suppressEmit)
	{
		event.sublistId = sublistLine.id;
		event.lineId = sublistLine.getFieldValue('_id');
		event.line = sublistLine.index;
		event.useLineBuffer = !!isBuffer;
		if (!!suppressEmit)
			event.suppressEmit = true;

		return event;
	}

	function addInternalFlag(event, isInternalChange)
	{
		if (isInternalChange === true)
			event.internal = true;

		return event;
	}

	function emit(emitter, fieldId, type)
	{
		emitter.emit(addFieldId(getEvent(type), fieldId));
	}

	function updateField(emitter, fieldId, oldValue, newValue, isInternalChange)
	{
		emitter.emit(addInternalFlag(addFieldValues(addFieldId(getEvent(EVENT_TYPE.FIELD_VALUE_CHANGE), fieldId), oldValue, newValue), isInternalChange));
	}

	function selectLine(emitter, sublistLine, isBuffer)
	{
		emitter.emit(addSublistInfo(getEvent(EVENT_TYPE.LINE_SELECT), sublistLine, isBuffer));
	}

	function createLine(emitter, sublistLine, isBuffer)
	{
		emitter.emit(addSublistInfo(getEvent(EVENT_TYPE.LINE_CREATE), sublistLine, isBuffer));
	}

	function insertLine(emitter, sublistLine, isBuffer)
	{
		emitter.emit(addSublistInfo(getEvent(EVENT_TYPE.LINE_INSERT), sublistLine, isBuffer));
	}

	function updateLine(emitter, sublistLine, isBuffer)
	{
		emitter.emit(addSublistInfo(getEvent(EVENT_TYPE.LINE_UPDATE), sublistLine, isBuffer));
	}

	function deleteLine(emitter, sublistLine, isBuffer, suppressEmit)
	{
		emitter.emit(addSublistInfo(getEvent(EVENT_TYPE.LINE_DELETE), sublistLine, isBuffer, suppressEmit));
	}

	var translateSublistLineEventTypeToModelEventType = (function () {
		var eventTranslations = {};

		eventTranslations[sublistLineEvent.Type.FIELD_VALUE_CHANGE] = EVENT_TYPE.FIELD_VALUE_CHANGE;

		return function (sublistStateEventType) {
			return eventTranslations[sublistStateEventType];
		}
	}());

	function addSublistLineEventDetails(event, sublistLineEvent, isBuffer)
	{
		event.sublistId = sublistLineEvent.sublistLine.id;
		event.lineId = sublistLineEvent.sublistLine.getFieldValue('_id');
		event.line = sublistLineEvent.sublistLine.index;
		event.fieldId = sublistLineEvent.fieldId;
		if(sublistLineEvent.oldValue !== undefined){ event.oldValue = sublistLineEvent.oldValue; }
		if(sublistLineEvent.newValue !== undefined){ event.newValue = sublistLineEvent.newValue; }
		event.useLineBuffer = isBuffer;
		if (sublistLineEvent.internal) { event.internal = true; }
		return event;
	}

	function translateSublistLineEventToModelEvent(sublistLineEvent, isBuffer)
	{
		return addSublistLineEventDetails(getEvent(translateSublistLineEventTypeToModelEventType(sublistLineEvent.type)), sublistLineEvent, isBuffer);
	}

	function forwardSublistLineEvent(emitter, isBuffer, sublistStateEvent)
	{
		emitter.emit(translateSublistLineEventToModelEvent(sublistStateEvent, isBuffer));
	}

	function forwardSublistLineEvents(emitter, sublistLine, isBuffer)
	{
		var forward = forwardSublistLineEvent.bind(null, emitter, isBuffer);

		sublistLine.on({
			types: [
				sublistLineEvent.Type.FIELD_VALUE_CHANGE
			],
			listener: forward
		});
	}

	function unforwardSublistLineEvents(sublistLine)
	{
		sublistLine.off({
			types: [
				sublistLineEvent.Type.FIELD_VALUE_CHANGE
			]
		});
	}

	return Object.freeze({
		Type: EVENT_TYPE,
		emit: emit,
		updateField: updateField,
		selectLine: selectLine,
		createLine: createLine,
		insertLine: insertLine,
		updateLine: updateLine,
		deleteLine: deleteLine,
		forwardSublistLineEvents: forwardSublistLineEvents,
		unforwardSublistLineEvents: unforwardSublistLineEvents
	});
});

/**
 * SuiteScript record definition event filter module
 *
 * @private
 * @module N/common/record/recordDefinitionEventCompressor
 * @suiteScriptVersion 2.x
 *
 */
define('N/common/record/recordDefinitionEventCompressor',['N/record/recordEvent'], function (recordEvent) {
	/*
	 UPDATE_FIELD_VALUE: 'UPDATE_FIELD_VALUE',
	 UPDATE_FIELD_OPTIONS: 'UPDATE_FIELD_OPTIONS',
	 UPDATE_SUBLIST: 'UPDATE_SUBLIST',
	 CREATE_LINE: 'CREATE_LINE',
	 UPDATE_LINE: 'UPDATE_LINE',
	 INSERT_LINE: 'INSERT_LINE',
	 REMOVE_LINE: 'REMOVE_LINE',
	 SELECT_LINE: 'SELECT_LINE',
	 UPDATE_RELATED_RECORD_VIEW: 'UPDATE_RELATED_RECORD_VIEW',

	 FIELD_IS_MANDATORY_CHANGE: 'FIELD_IS_MANDATORY_CHANGE',
	 FIELD_IS_HIDDEN_CHANGE: 'FIELD_IS_HIDDEN_CHANGE',
	 FIELD_IS_DISABLED_CHANGE: 'FIELD_IS_DISABLED_CHANGE',
	 FIELD_IS_VISIBLE_CHANGE: 'FIELD_IS_VISIBLE_CHANGE',
	 FIELD_IS_DISPLAY_CHANGE: 'FIELD_IS_DISPLAY_CHANGE',
	 FIELD_IS_READ_ONLY_CHANGE: 'FIELD_IS_READ_ONLY_CHANGE',
	 FIELD_LABEL_CHANGE: 'FIELD_LABEL_CHANGE',

	 SUBLIST_IS_DISPLAY_CHANGE: 'SUBLIST_IS_DISPLAY_CHANGE',
	 SUBLIST_IS_HIDDEN_CHANGE: 'SUBLIST_IS_HIDDEN_CHANGE',
	 SUBLIST_COLUMN_LABEL_CHANGE: 'SUBLIST_COLUMN_LABEL_CHANGE'
	 */

	function isErrorEvent(event)
	{
		return event.error !== undefined;
	}

	function getSingletonEvent(eventType, eventData)
	{
		var event = eventData.singleton[eventType];
		event = !!event && event.last;

		return event || null;
	}

	function getBodyFieldEvent(fieldId, eventData, eventType)
	{
		var event = eventData.body[eventType];
		event = !!event && event[fieldId];
		event = !!event && event.last;

		return event || null;
	}

	function getBodyFieldErrorEvent(fieldId, eventData, eventType)
	{
		var event = eventData.body[eventType];
		event = !!event && event[fieldId];
		event = !!event && event.error;

		return event || null;
	}

	function getSublistFieldEvent(sublistId, fieldId, lineId, buffer, eventData, eventType)
	{
		var bufferOrActual = buffer ? 'buffer' : 'actual';
		var event = eventData.sublist[bufferOrActual][sublistId];
		event = !!event && event[lineId];
		event = !!event && event[eventType];
		event = !!event && event[fieldId];
		event = !!event && event.last;

		return event || null;
	}

	function getSublistFieldErrorEvent(sublistId, fieldId, lineId, buffer, eventData, eventType)
	{
		var bufferOrActual = buffer ? 'buffer' : 'actual';
		var event = eventData.sublist[bufferOrActual][sublistId];
		event = !!event && event[lineId];
		event = !!event && event[eventType];
		event = !!event && event[fieldId];
		event = !!event && event.error;

		return event || null;
	}

	function getSublistEvent(eventType, sublistId, buffer, eventData)
	{
		var bufferOrActual = buffer ? 'buffer' : 'actual';

		var event = eventData.sublist[bufferOrActual][sublistId];
		event = !!event && event[eventType];
		event = !!event && event.last;

		return event || null;
	}

	function getSublistErrorEvent(eventType, sublistId, buffer, eventData)
	{
		var bufferOrActual = buffer ? 'buffer' : 'actual';

		var event = eventData.sublist[bufferOrActual][sublistId];
		event = !!event && event[eventType];
		event = !!event && event.error;

		return event || null;
	}

	function getSublistLineEvent(eventType, sublistId, lineId, buffer, eventData)
	{
		var bufferOrActual = buffer ? 'buffer' : 'actual';

		var event = eventData.sublist[bufferOrActual][sublistId];
		event = !!event && event[lineId];
		event = !!event && event[eventType];
		event = !!event && event.last;

		return event || null;
	}

	function getSublistLineErrorEvent(eventType, sublistId, lineId, buffer, eventData)
	{
		var bufferOrActual = buffer ? 'buffer' : 'actual';

		var event = eventData.sublist[bufferOrActual][sublistId];
		event = !!event && event[lineId];
		event = !!event && event[eventType];
		event = !!event && event.error;

		return event || null;
	}

	function getUpdateAllEvent(eventData)
	{
		return getSingletonEvent(recordEvent.Type.UPDATE_ALL, eventData);
	}

	function getCreateLineEvent(sublistId, lineId, buffer, eventData)
	{
		return getSublistLineEvent(recordEvent.Type.CREATE_LINE, sublistId, lineId, buffer, eventData);
	}

	function getUpdateLineEvent(sublistId, lineId, buffer, eventData)
	{
		return getSublistLineEvent(recordEvent.Type.UPDATE_LINE, sublistId, lineId, buffer, eventData);
	}

	function getInsertLineEvent(sublistId, lineId, buffer, eventData)
	{
		return getSublistLineEvent(recordEvent.Type.INSERT_LINE, sublistId, lineId, buffer, eventData);
	}

	function getRemoveLineEvent(sublistId, lineId, buffer, eventData)
	{
		return getSublistLineEvent(recordEvent.Type.REMOVE_LINE, sublistId, lineId, buffer, eventData);
	}

	function hasErrorEvent(event, eventData)
	{
		var hasEvent = false;

		for(var i = 0; i < eventData.errors.length; i+= 1)
		{
			if(event.error !== undefined && event.error === eventData.errors[i].error)
			{
				hasEvent = true;
				break;
			}
		}

		return hasEvent;
	}

	function hasSingletonEvent(event, eventData)
	{
		return event === getSingletonEvent(event.type, eventData);
	}

	function hasFieldEvent(event, eventData)
	{
		var result = false;

		if(!!event.sublistId)
		{
			var func = isErrorEvent(event) ? getSublistFieldErrorEvent : getSublistFieldEvent;
			result = event === func(event.sublistId, event.fieldId, event.lineId, event.useLineBuffer, eventData, event.type);
		}
		else
		{
			var func = isErrorEvent(event) ? getBodyFieldErrorEvent : getBodyFieldEvent;
			result = event === func(event.fieldId, eventData, event.type);
		}

		return result;
	}

	function hasSublistEvent(event, eventData)
	{
		var func = isErrorEvent(event) ? getSublistErrorEvent : getSublistEvent;
		return event === func(event.type, event.sublistId, event.useLineBuffer, eventData);
	}

	function hasSublistLineEvent(event, eventData)
	{
		var func = isErrorEvent(event) ? getSublistLineErrorEvent : getSublistLineEvent;
		return event === func(event.type, event.sublistId, event.lineId, event.useLineBuffer, eventData);
	}

	function getSublistEventDataSafe(sublistId, buffer, eventData)
	{
		var bufferOrActual = buffer ? 'buffer' : 'actual';

		var data = eventData.sublist[bufferOrActual];
		data[sublistId] = data[sublistId] || {};

		return data[sublistId];
	}

	function getSublistLineEventDataSafe(sublistId, lineId, buffer, eventData)
	{
		var bufferOrActual = buffer ? 'buffer' : 'actual';

		var data = eventData.sublist[bufferOrActual];
		data[sublistId] = data[sublistId] || {};

		data = data[sublistId];
		data[lineId] = data[lineId] || {};

		return data[lineId];
	}

	function processErrorEvent(event, eventData)
	{
		if(!hasErrorEvent(event, eventData))
		{
			eventData.errors.push(event);
		}
	}

	function processSingletonEvent(event, eventData)
	{
		var data = eventData.singleton;
		data[event.type] = data[event.type] || {first: null, last: null, error: null};
		data = data[event.type];

		updateFirstLastEvent(event, data);
	}

	function processUpdateAllEvent(event, eventData)
	{
		eventData.body = {};
		eventData.sublist = {actual:{}, buffer:{}};
		eventData.singleton = {};
		eventData.errors = [];

		processSingletonEvent(event, eventData);
	}

	function updateSublistEvent(event, data)
	{
		data[event.type] = data[event.type] || {first: null, last: null, error: null};
		data = data[event.type];

		updateFirstLastEvent(event, data);
	}

	function processSublistEvent(event, eventData)
	{
		if(isErrorEvent(event))
		{
			processErrorEvent(event, eventData);
		}

		var data = getSublistEventDataSafe(event.sublistId, event.useLineBuffer, eventData);
		var updateAll = !!getUpdateAllEvent(eventData);

		if (!updateAll)
		{
			updateSublistEvent(event, data);
		}
	}

	function updateSublistLineEvent(event, data)
	{
		data[event.type] = data[event.type] || {first: null, last: null, error: null};
		data = data[event.type];

		updateFirstLastEvent(event, data);
	}

	function processSublistLineEvent(event, eventData)
	{
		if(isErrorEvent(event))
		{
			processErrorEvent(event, eventData);
		}

		var data = getSublistLineEventDataSafe(event.sublistId, event.lineId, event.useLineBuffer, eventData);
		var updateAll = !!getUpdateAllEvent(eventData);

		if (!updateAll && !getRemoveLineEvent(event.sublistId, event.lineId, event.useLineBuffer, eventData) || isErrorEvent(event))
		{
			updateSublistLineEvent(event, data);
		}
	}

	function processSublistRemoveLineEvent(event, eventData)
	{
		var isError = isErrorEvent(event);
		if(isError)
		{
			processErrorEvent(event, eventData);
		}

		var data = getSublistLineEventDataSafe(event.sublistId, event.lineId, event.useLineBuffer, eventData);
		var updateAll = !!getUpdateAllEvent(eventData);
		var lineCreatedOrInserted = (getCreateLineEvent(event.sublistId, event.lineId, event.useLineBuffer, eventData) ||
				getInsertLineEvent(event.sublistId, event.lineId, event.useLineBuffer, eventData));

		if(!isError)
		{
			Object.keys(data).forEach(function (v) {
				delete data[v];
			});
		}

		if(!updateAll && !lineCreatedOrInserted || isError)
		{
			updateSublistLineEvent(event, data);
		}
	}

	function updateFirstLastEvent(event, data)
	{
		var isError = isErrorEvent(event);
		var firstEvent = data.first == null;
		var eventGoesToOriginalState = !firstEvent &&
				data.first.oldValue !== undefined &&
				event.newValue !== undefined &&
				data.first.oldValue === event.newValue;

		if(isError)
		{
			data.error = event;
		}
		else if(firstEvent)
		{
			data.first = event;
			data.last = event;
		}
		else if(eventGoesToOriginalState)
		{
			data.first = null;
			data.last = null;
		}
		else
		{
			data.last = event;
			if(data.first.hasOwnProperty('oldValue'))
			{
				data.last.oldValue = data.first.oldValue;
			}
		}
	}

	function updateFieldEvent(event, data)
	{
		data[event.type] = data[event.type] || {};
		data = data[event.type];
		data[event.fieldId] = data[event.fieldId] || {first: null, last: null, error:null};
		data = data[event.fieldId];

		updateFirstLastEvent(event, data);
	}

	function processFieldBodyEvent(event, eventData)
	{
		var data = eventData.body;
		var updateAll = !!getUpdateAllEvent(eventData);

		if (!updateAll)
		{
			updateFieldEvent(event, data);
		}
	}

	function processFieldSublistEvent(event, eventData)
	{
		var updateAll = !!getUpdateAllEvent(eventData);
		var ignore = !isErrorEvent(event) && (
				getCreateLineEvent(event.sublistId, event.lineId, event.useLineBuffer, eventData) ||
				getUpdateLineEvent(event.sublistId, event.lineId, event.useLineBuffer, eventData) ||
				getInsertLineEvent(event.sublistId, event.lineId, event.useLineBuffer, eventData) ||
				getRemoveLineEvent(event.sublistId, event.lineId, event.useLineBuffer, eventData) );

		if(!updateAll && !ignore || isErrorEvent(event))
		{
			var data = getSublistLineEventDataSafe(event.sublistId, event.lineId, event.useLineBuffer, eventData);
			updateFieldEvent(event, data);
		}
	}

	function processFieldEvent(event, eventData)
	{
		if(isErrorEvent(event))
		{
			processErrorEvent(event, eventData);
		}

		if(!!event.sublistId)
		{
			processFieldSublistEvent(event, eventData)
		}
		else
		{
			processFieldBodyEvent(event, eventData);
		}
	}

	var processEvent = (function(){
		var process = {};

		process[recordEvent.Type.ERROR] = processErrorEvent;

		process[recordEvent.Type.UPDATE_ALL] = processUpdateAllEvent;
		process[recordEvent.Type.RECORD_INITIALIZED] = processSingletonEvent;

		process[recordEvent.Type.UPDATE_FIELD_OPTIONS] = processFieldEvent;
		process[recordEvent.Type.UPDATE_FIELD_VALUE] = processFieldEvent;
		process[recordEvent.Type.CREATE_LINE] = processSublistLineEvent;
		process[recordEvent.Type.UPDATE_LINE] = processSublistLineEvent;
		process[recordEvent.Type.INSERT_LINE] = processSublistLineEvent;
		process[recordEvent.Type.REMOVE_LINE] = processSublistRemoveLineEvent;
		process[recordEvent.Type.SELECT_LINE] = processSublistEvent;

		process[recordEvent.Type.FIELD_IS_MANDATORY_CHANGE] = processFieldEvent;
		process[recordEvent.Type.FIELD_IS_HIDDEN_CHANGE] = processFieldEvent;
		process[recordEvent.Type.FIELD_IS_DISABLED_CHANGE] = processFieldEvent;
		process[recordEvent.Type.FIELD_IS_VISIBLE_CHANGE] = processFieldEvent;
		process[recordEvent.Type.FIELD_IS_DISPLAY_CHANGE] = processFieldEvent;
		process[recordEvent.Type.FIELD_IS_READ_ONLY_CHANGE] = processFieldEvent;
		process[recordEvent.Type.FIELD_LABEL_CHANGE] = processFieldEvent;

		process[recordEvent.Type.SUBLIST_IS_DISPLAY_CHANGE] = processSublistEvent;
		process[recordEvent.Type.SUBLIST_IS_HIDDEN_CHANGE] = processSublistEvent;
		process[recordEvent.Type.SUBLIST_COLUMN_LABEL_CHANGE] = processSublistEvent;

		process[recordEvent.Type.LINE_VALIDATION_FAILED] = processSublistLineEvent;

		return function processEvent(event, eventData){
			var func = process[event.type] || function(){};
			func(event, eventData);
		};
	}());

	var hasEvent = (function(){
		var has = {};
		has[recordEvent.Type.ERROR] = hasErrorEvent;

		has[recordEvent.Type.UPDATE_ALL] = hasSingletonEvent;
		has[recordEvent.Type.RECORD_INITIALIZED] = hasSingletonEvent;

		has[recordEvent.Type.UPDATE_FIELD_OPTIONS] = hasFieldEvent;
		has[recordEvent.Type.UPDATE_FIELD_VALUE] = hasFieldEvent;
		has[recordEvent.Type.CREATE_LINE] = hasSublistLineEvent;
		has[recordEvent.Type.UPDATE_LINE] = hasSublistLineEvent;
		has[recordEvent.Type.INSERT_LINE] = hasSublistLineEvent;
		has[recordEvent.Type.REMOVE_LINE] = hasSublistLineEvent;
		has[recordEvent.Type.SELECT_LINE] = hasSublistEvent;

		has[recordEvent.Type.FIELD_IS_MANDATORY_CHANGE] = hasFieldEvent;
		has[recordEvent.Type.FIELD_IS_HIDDEN_CHANGE] = hasFieldEvent;
		has[recordEvent.Type.FIELD_IS_DISABLED_CHANGE] = hasFieldEvent;
		has[recordEvent.Type.FIELD_IS_VISIBLE_CHANGE] = hasFieldEvent;
		has[recordEvent.Type.FIELD_IS_DISPLAY_CHANGE] = hasFieldEvent;
		has[recordEvent.Type.FIELD_IS_READ_ONLY_CHANGE] = hasFieldEvent;
		has[recordEvent.Type.FIELD_LABEL_CHANGE] = hasFieldEvent;

		has[recordEvent.Type.SUBLIST_IS_DISPLAY_CHANGE] = hasSublistEvent;
		has[recordEvent.Type.SUBLIST_IS_HIDDEN_CHANGE] = hasSublistEvent;
		has[recordEvent.Type.SUBLIST_COLUMN_LABEL_CHANGE] = hasSublistEvent;

		has[recordEvent.Type.LINE_VALIDATION_FAILED] = hasSublistLineEvent;

		return function hasEvent(event, eventData){
			var func = has[event.type] || function(){return false;};
			return func(event, eventData);
		};
	}());

	function createEventData(events)
	{
		var eventData = {body:{}, sublist:{actual:{}, buffer:{}}, singleton: {}, errors:[]};

		events.forEach(function(event){
			processEvent(event, eventData);
		});

		return {
			hasEvent: function (event){ return hasEvent(event, eventData); }
		}
	}

	function cleanEvent(event)
	{
		delete event.oldValue;
		delete event.newValue;

		return event;
	}

	// Fixes Issue 467543: If while filtering the eventData, we encounter multiple inserts in a row, we must ensure
	// all intermediate "creates" are suppressed from being emitted, such that the UI does not accidentally wipe out
	// the previously "inserted" line's values. The only surviving "create" should be the last one which indicates
	// the new line buffer being created. 
	function BatchInsertModeHandler()
	{
		var isBatchInserting = false;

		function isEventThisType(thisEvent, thisType)
		{
			return !!thisEvent && (thisEvent.type === thisType);
		}

		function getLastFilteredEvent(filteredList)
		{
			return filteredList.slice(filteredList.length - 1)[0];
		}

		function updateBatchInsertionStatus(thisEvent, eventList)
		{
			var lastEvent = getLastFilteredEvent(eventList);
			var isLastInsert = isEventThisType(lastEvent, recordEvent.Type.INSERT_LINE);
			var isThisInsert = isEventThisType(thisEvent, recordEvent.Type.INSERT_LINE);

			isBatchInserting = isLastInsert && isThisInsert;
		}
		this.update = updateBatchInsertionStatus;

		function shouldIgnoreEvent(thisEvent, eventList)
		{
			if (!isBatchInserting || eventList.length === 0)
				return false;

			var lastEvent = getLastFilteredEvent(eventList);
			var isCreateEvent = isEventThisType(thisEvent, recordEvent.Type.CREATE_LINE);
			var doLineIdsMatch = thisEvent.lineId === lastEvent.lineId;

			return isBatchInserting && isCreateEvent && doLineIdsMatch;
		}
		this.shouldIgnore = shouldIgnoreEvent;
	}

	function compress(events)
	{
		var eventData = createEventData(events);
		var batchInsertModeChecker = new BatchInsertModeHandler();

		var filteredEvents = events.reduce(function(p, c, i, a){
				if(eventData.hasEvent(c) && !batchInsertModeChecker.shouldIgnore(c, p))
				{
					batchInsertModeChecker.update(c, p);
					p.push(cleanEvent(c));
				}
				return p;
			}, []);

		return filteredEvents;
	}

	function noCompress(events)
	{
		return events.map(function(v, i, a){
			return cleanEvent(v);
		});
	}

	return Object.freeze({
		compress: compress,
		noCompress: noCompress
	});
});

/**
 * SuiteScript record definition event module
 *
 * @private
 * @module N/common/record/recordDefinitionEvent
 * @suiteScriptVersion 2.x
 *
 */
define('N/common/record/recordDefinitionEvent',['N/record/recordEvent', 'N/record/modelEvent', 'N/record/recordStateControllerEvent', 'N/record/metadataEvent', 'N/record/recordFieldEvent',
		'N/common/record/recordDefinitionEventCompressor'],
function (recordEvent, modelEvent, recordStateControllerEvent, metadataEvent, recordFieldEvent,
		recordDefinitionEventCompressor
){
	var EVENT_TYPE = recordEvent.Type;

	function getEvent(type, record)
	{
		return {
			type: type,
			record: record.proxy({isInteractive: false}) // since we don't have the actual proxy record, we obtain it assuming it was not interactive
		}
	}

	function addErrorAttribute(obj, error)
	{
		obj.error = error;

		return obj;
	}

	function wrapEmitError(options)
	{
		var record = options.record;    /* This will always be an unproxied recordDefinition instance */
		var func = options.func;
		var emitter = options.emitter;

		return function(){
			var result = undefined;

			try
			{
				result = func.apply(record, arguments);
			}
			catch(error)
			{
				emitError(emitter, record, error);
				throw error;
			}
			return result;
		}
	}

	function addSublistLineAttributes(event, sublistId, line)
	{
		if (!sublistId)
			return event;

		var onCurrentLine = line === -1 || line === event.record.getCurrentSublistIndex(sublistId);

		event.sublistId = sublistId;
		event.line = line;

		if(onCurrentLine)
		{
			event.lineId = event.record.getCurrentSublistValue({
				sublistId: sublistId,
				fieldId: '_id'
			});
		}
		else
		{
			if (event.record.getCurrentSublistIndex(sublistId) === -1)
				return event;
			event.lineId = event.record.getSublistValue({
				sublistId: sublistId,
				fieldId: '_id',
				line: line
			});
		}
		event.useLineBuffer = onCurrentLine;

		return event;
	}

	function getLineValidationEvent(record, sublistId, line, fieldId)
	{
		var event = addFieldAttributes(getEvent(EVENT_TYPE.LINE_VALIDATION_FAILED, record), fieldId, sublistId, line);
		return event;
	}


	function wrapEmitLineValidationError(options)
	{
		var record = options.record;    /* This will always be an unproxied recordDefinition instance */
		var func = options.func;
		var emitter = options.emitter;
		var sublistId = options.sublistId;
		var line = record.getCurrentSublistIndex(sublistId);
		var fieldId = options.fieldId || 'linechanged'; // in case we do not know the fieldId, pass in the 'linechanged' field

		return function(){
			var result = undefined;

			try
			{
				result = func.apply(record, arguments);
			}
			catch(error)
			{
				emitter.emit(addErrorAttribute(getLineValidationEvent(record, sublistId, line, fieldId), error));
				// this onject copy is on purpose, so the event compressor does not throw away the alert message
				// with the actual error text.
				throw util.extend({}, error);
			}
			return result;
		}
	}

	function emitError(emitter, record, error)
	{
		emitter.emit(addErrorAttribute(getEvent(EVENT_TYPE.ERROR, record), error));
	}

	function emitUpdateAll(emitter, record)
	{
		emitter.emit(getEvent(EVENT_TYPE.UPDATE_ALL, record));
	}

	function addFieldAttributes(event, fieldId, sublistId, line)
	{
		var onSublist = !!sublistId;
		var onCurrentLine = onSublist && (line === -1 || line === event.record.getCurrentSublistIndex(sublistId));

		event.fieldId = fieldId;

		if(onSublist)
		{
			event = addSublistLineAttributes(event, sublistId, line);
			if(onCurrentLine)
			{
				event.field = event.record.getCurrentSublistField({
					sublistId: sublistId,
					fieldId: fieldId
				});
			}
			else
			{
				if (event.record.getCurrentSublistIndex(sublistId) === -1)
					return event;
				event.field = event.record.getSublistField({
					sublistId: sublistId,
					fieldId: fieldId,
					line: line
				});
			}
		}
		else
		{
			event.field = event.record.getField({
				fieldId: fieldId
			});
		}
		return event;
	}

	function addActionAttributes(event, action, data)
	{
		if (action)
		{
			event.action = action;
			event.data = data;
		}
		return event;
	}

	function emitUpdateFieldOptions(emitter, record, sublistId, fieldId, line, action, data)
	{
		var event = addActionAttributes(addFieldAttributes(getEvent(EVENT_TYPE.UPDATE_FIELD_OPTIONS, record), fieldId, sublistId, line), action, data);
		emitter.emit(event);
	}


	var translateModelEventTypeToRecordEventType = (function () {
		var eventTranslations = {};

		eventTranslations[modelEvent.Type.FIELD_VALUE_CHANGE] = EVENT_TYPE.UPDATE_FIELD_VALUE;
		eventTranslations[modelEvent.Type.LINE_SELECT] = EVENT_TYPE.SELECT_LINE;
		eventTranslations[modelEvent.Type.LINE_CREATE] = EVENT_TYPE.CREATE_LINE;
		eventTranslations[modelEvent.Type.LINE_INSERT] = EVENT_TYPE.INSERT_LINE;
		eventTranslations[modelEvent.Type.LINE_UPDATE] = EVENT_TYPE.UPDATE_LINE;
		eventTranslations[modelEvent.Type.LINE_DELETE] = EVENT_TYPE.REMOVE_LINE;

		return function (fieldStateEventType) {
			return eventTranslations[fieldStateEventType];
		}
	}());

	function addModelEventDetails(event, modelEvent)
	{
		var onSublist = modelEvent.hasOwnProperty('sublistId');
		var onField = modelEvent.hasOwnProperty('fieldId');

		if(onSublist)
		{
			event.sublistId = modelEvent.sublistId;
			event.lineId = modelEvent.lineId;
			event.line = modelEvent.line;
			event.useLineBuffer = modelEvent.useLineBuffer;
			if (modelEvent.hasOwnProperty("suppressEmit"))
				event.suppressEmit = modelEvent.suppressEmit;
		}

		if(onField) {
			event.fieldId = modelEvent.fieldId;
			if(modelEvent.oldValue !== undefined){ event.oldValue = modelEvent.oldValue; }
			if(modelEvent.newValue !== undefined){ event.newValue = modelEvent.newValue; }
		}

		if (modelEvent.internal)
			event.internal = true;

		return event;
	}

	function translateModelEventToRecordEvent(modelEvent, record)
	{
		return addModelEventDetails(getEvent(translateModelEventTypeToRecordEventType(modelEvent.type), record), modelEvent);
	}

	function forwardModelControllerEvent(record, emitter, modelEvent)
	{
		emitter.emit(translateModelEventToRecordEvent(modelEvent, record));
	}

	function forwardModelControllerEvents(options)
	{
		var record = options.record;
		var emitter = options.emitter;
		var forward = forwardModelControllerEvent.bind(null, record, emitter);

		record.getModelController().on({
			types: [
				modelEvent.Type.FIELD_VALUE_CHANGE,
				modelEvent.Type.LINE_SELECT,
				modelEvent.Type.LINE_CREATE,
				modelEvent.Type.LINE_INSERT,
				modelEvent.Type.LINE_UPDATE,
				modelEvent.Type.LINE_DELETE
			],
			listener: forward
		});
	}

	var translateRecordStateEventTypeToRecordEventType = (function () {
		var eventTranslations = {};

		eventTranslations[recordStateControllerEvent.Type.FIELD_IS_MANDATORY_CHANGE] = EVENT_TYPE.FIELD_IS_MANDATORY_CHANGE;
		eventTranslations[recordStateControllerEvent.Type.FIELD_IS_HIDDEN_CHANGE] = EVENT_TYPE.FIELD_IS_HIDDEN_CHANGE;
		eventTranslations[recordStateControllerEvent.Type.FIELD_IS_DISABLED_CHANGE] = EVENT_TYPE.FIELD_IS_DISABLED_CHANGE;
		eventTranslations[recordStateControllerEvent.Type.FIELD_IS_VISIBLE_CHANGE] = EVENT_TYPE.FIELD_IS_VISIBLE_CHANGE;
		eventTranslations[recordStateControllerEvent.Type.FIELD_IS_DISPLAY_CHANGE] = EVENT_TYPE.FIELD_IS_DISPLAY_CHANGE;
		eventTranslations[recordStateControllerEvent.Type.FIELD_IS_READ_ONLY_CHANGE] = EVENT_TYPE.FIELD_IS_READ_ONLY_CHANGE;
		eventTranslations[recordStateControllerEvent.Type.FIELD_LABEL_CHANGE] = EVENT_TYPE.FIELD_LABEL_CHANGE;
		eventTranslations[recordStateControllerEvent.Type.SUBLIST_IS_DISPLAY_CHANGE] = EVENT_TYPE.SUBLIST_IS_DISPLAY_CHANGE;
		eventTranslations[recordStateControllerEvent.Type.SUBLIST_IS_HIDDEN_CHANGE] = EVENT_TYPE.SUBLIST_IS_HIDDEN_CHANGE;

		return function (fieldStateEventType) {
			return eventTranslations[fieldStateEventType];
		}
	}());


	function addRecordStateEventFieldDetails(event, recordStateEvent)
	{
		var onSublist = recordStateEvent.hasOwnProperty('sublistId');
		var onCurrentLine = onSublist && !!recordStateEvent.currentLine;

		if(onSublist)
		{
			event.sublistId = recordStateEvent.sublistId;
			if(onCurrentLine)
			{
				event.lineId = event.record.getCurrentSublistValue({
					sublistId: recordStateEvent.sublistId,
					fieldId: '_id'
				});
				event.line = recordStateEvent.line;
				event.field = event.record.getCurrentSublistField({
					sublistId: recordStateEvent.sublistId,
					fieldId: recordStateEvent.fieldId
				});
			}
			else
			{
				event.lineId = event.record.getSublistValue({
					sublistId: recordStateEvent.sublistId,
					fieldId: '_id',
					line: recordStateEvent.line
				});
				event.line = recordStateEvent.line;
				event.field = event.record.getSublistField({
					sublistId: recordStateEvent.sublistId,
					fieldId: recordStateEvent.fieldId,
					line: recordStateEvent.line
				});
			}
			event.useLineBuffer = onCurrentLine;
		}
		else
		{
			event.field = event.record.getField({
				fieldId: recordStateEvent.fieldId
			});
		}

		event.fieldId = recordStateEvent.fieldId;
		if(recordStateEvent.oldValue !== undefined){ event.oldValue = recordStateEvent.oldValue; }
		if(recordStateEvent.newValue !== undefined){ event.newValue = recordStateEvent.newValue; }

		return event;
	}

	function addRecordStateEventSublistDetails(event, recordStateEvent)
	{
		event.sublistId = recordStateEvent.sublistId;
		event.sublist = event.record.getSublist({
			sublistId: recordStateEvent.sublistId
		});
		if(recordStateEvent.oldValue !== undefined){ event.oldValue = recordStateEvent.oldValue; }
		if(recordStateEvent.newValue !== undefined){ event.newValue = recordStateEvent.newValue; }

		return event;
	}

	function addRecordStateEventDetails(event, recordStateEvent)
	{
		function isRecordStateFieldEvent(type)
		{
			return [recordStateControllerEvent.Type.FIELD_IS_MANDATORY_CHANGE,
					recordStateControllerEvent.Type.FIELD_IS_HIDDEN_CHANGE,
					recordStateControllerEvent.Type.FIELD_IS_DISABLED_CHANGE,
					recordStateControllerEvent.Type.FIELD_IS_VISIBLE_CHANGE,
					recordStateControllerEvent.Type.FIELD_IS_DISPLAY_CHANGE,
					recordStateControllerEvent.Type.FIELD_IS_READ_ONLY_CHANGE,
					recordStateControllerEvent.Type.FIELD_LABEL_CHANGE].indexOf(type) !== -1;
		}

		function isRecordStateSublistEvent(type)
		{
			return [recordStateControllerEvent.Type.SUBLIST_IS_DISPLAY_CHANGE,
					recordStateControllerEvent.Type.SUBLIST_IS_HIDDEN_CHANGE].indexOf(type) !== -1;
		}

		if(isRecordStateFieldEvent(recordStateEvent.type))
		{
			addRecordStateEventFieldDetails(event, recordStateEvent);
		}
		else if(isRecordStateSublistEvent(recordStateEvent.type))
		{
			addRecordStateEventSublistDetails(event, recordStateEvent);
		}

		return event;
	}

	function translateRecordStateEventToRecordEvent(recordStateEvent, record)
	{
		record.flushBufferCacheForFieldStateUpdate(recordStateEvent.sublistId, recordStateEvent.fieldId, recordStateEvent.line, recordStateEvent.currentLine);
		return addRecordStateEventDetails(getEvent(translateRecordStateEventTypeToRecordEventType(recordStateEvent.type), record), recordStateEvent);
	}

	function forwardRecordStateEvent(emitter, record, recordStateEvent)
	{
		emitter.emit(translateRecordStateEventToRecordEvent(recordStateEvent, record));
	}

	function forwardRecordStateEvents(emitter, record)
	{
		var recordStateController = record.getRecordStateController();
		var forward = forwardRecordStateEvent.bind(null, emitter, record);

		recordStateController.on({
			types: [
				recordStateControllerEvent.Type.FIELD_IS_MANDATORY_CHANGE,
				recordStateControllerEvent.Type.FIELD_IS_HIDDEN_CHANGE,
				recordStateControllerEvent.Type.FIELD_IS_DISABLED_CHANGE,
				recordStateControllerEvent.Type.FIELD_IS_VISIBLE_CHANGE,
				recordStateControllerEvent.Type.FIELD_IS_DISPLAY_CHANGE,
				recordStateControllerEvent.Type.FIELD_IS_READ_ONLY_CHANGE,
				recordStateControllerEvent.Type.FIELD_LABEL_CHANGE,
				recordStateControllerEvent.Type.SUBLIST_IS_DISPLAY_CHANGE,
				recordStateControllerEvent.Type.SUBLIST_IS_HIDDEN_CHANGE
			],
			listener: forward
		});
	}

	var translateMetadataEventTypeToRecordEventType = (function () {
		var eventTranslations = {};

		eventTranslations[metadataEvent.Type.FIELD_METADATA_LABEL_CHANGE] = EVENT_TYPE.SUBLIST_COLUMN_LABEL_CHANGE;

		return function (fieldStateEventType) {
			return eventTranslations[fieldStateEventType];
		}
	}());

	function addMetadataEventDetails(event, metadataEvent)
	{
		event.sublistId = metadataEvent.sublistId;
		event.fieldId = metadataEvent.fieldId;
		if(metadataEvent.oldValue !== undefined){ event.oldValue = metadataEvent.oldValue; }
		if(metadataEvent.newValue !== undefined){ event.newValue = metadataEvent.newValue; }

		return event;
	}

	function translateMetadataEventToRecordEvent(metadataEvent, record)
	{
		return addMetadataEventDetails(getEvent(translateMetadataEventTypeToRecordEventType(metadataEvent.type), record), metadataEvent);
	}

	function forwardMetadataEvent(emitter, record, metadataEvent)
	{
		emitter.emit(translateMetadataEventToRecordEvent(metadataEvent, record));
	}

	function forwardMetadataEvents(emitter, record)
	{
		var metadata = record.getMetadata();
		var forward = forwardMetadataEvent.bind(null, emitter, record);

		metadata.on({
			types: [
				metadataEvent.Type.FIELD_METADATA_LABEL_CHANGE
			],
			listener: forward
		});
	}

	var translateRecordFieldEventTypeToRecordEventType = (function () {
		var eventTranslations = {};

		eventTranslations[recordFieldEvent.Type.FIELD_VALUE_CHANGE] = EVENT_TYPE.UPDATE_FIELD_VALUE;

		return function (fieldStateEventType) {
			return eventTranslations[fieldStateEventType];
		}
	}());

	function addRecordFieldEventDetails(event, recordFieldEvent, onCurrentLine)
	{
		var onSublist = recordFieldEvent.recordField.getSublistName() !== null;

		if(onSublist)
		{
			var sublistId = recordFieldEvent.recordField.getSublistName();
			var lineNum = recordFieldEvent.recordField.getLine();

			event.sublistId = sublistId;
			if(onCurrentLine)
			{
				event.lineId = event.record.getCurrentSublistValue({
					sublistId: sublistId,
					fieldId: '_id'
				});
				event.line = lineNum;
			}
			else
			{
				event.lineId = event.record.getSublistValue({
					sublistId: sublistId,
					fieldId: '_id',
					line: lineNum
				});
				event.line = lineNum;
			}
			event.useLineBuffer = onCurrentLine;
		}

		event.fieldId = recordFieldEvent.recordField.getName();

		if(recordFieldEvent.hasOwnProperty('error'))
		{
			event.error = recordFieldEvent.error;
		}

		return event;
	}

	function onCurrentLine(recordFieldEvent, record)
	{
		var result = false;
		var sublistId = recordFieldEvent.recordField.getSublistName();
		var fieldId = recordFieldEvent.recordField.getName();
		var onSublist = sublistId !== null;

		if(onSublist)
		{
			result = record.getCurrentCachedRecordField(sublistId, fieldId) === recordFieldEvent.recordField;
		}

		return result;
	}

	function translateRecordFieldEventToRecordEvent(recordFieldEvent, record)
	{
		return addRecordFieldEventDetails(getEvent(translateRecordFieldEventTypeToRecordEventType(recordFieldEvent.type), record), recordFieldEvent, onCurrentLine(recordFieldEvent, record));
	}

	function forwardRecordFieldEvent(emitter, record, recordFieldEvent)
	{
		emitter.emit(translateRecordFieldEventToRecordEvent(recordFieldEvent, record));
	}

	function forwardRecordFieldEvents(emitter, record, recordField)
	{
		var forward = forwardRecordFieldEvent.bind(null, emitter, record);

		recordField.on({
			types: [
				recordFieldEvent.Type.FIELD_VALUE_CHANGE
			],
			listener: forward
		});
	}

	return Object.freeze({
		Type : EVENT_TYPE,
		emitError: emitError,
		emitUpdateAll: emitUpdateAll,
		emitUpdateFieldOptions: emitUpdateFieldOptions,
		forwardModelControllerEvents: forwardModelControllerEvents,
		forwardRecordStateEvents: forwardRecordStateEvents,
		forwardMetadataEvents: forwardMetadataEvents,
		forwardRecordFieldEvents: forwardRecordFieldEvents,
		wrapEmitError: wrapEmitError,
		wrapEmitLineValidationError: wrapEmitLineValidationError,
		eventCompress: recordDefinitionEventCompressor.compress,
		eventNoCompress: recordDefinitionEventCompressor.noCompress
	});
});

/**
 * SuiteScript record sublist line definition common module
 *
 * @private
 * @module N/common/record/line/lineDefinition
 * @NApiVersion 2.x
 *
 */
define(
	'N/common/record/line/lineDefinition',['N/record/line/lineProxy', 'N/utilityFunctions', 'N/error',
	 'N/common/record/recordActualWork', 'N/record/line/sublistLineImplementation', 'N/eventEmitter', 'N/common/record/recordDefinitionEvent'],
	function (lineProxy, utilityFunctions, error,
	          recordBehaviorDelegateService, sublistLineImplementation, eventEmitter, recordDefinitionEvent)
	{
		/**
		 * Primary object used to encapsulate a record sublist line object.
		 *
		 * @protected
		 * @param {Object} options
		 * @param {Record} options.unproxiedRecord - Instance of recordDefinition that owns the Line object.
		 * @param {string} options.sublistId
		 * @param {string} options.lineInstanceId
		 * @param {boolean} options.fromBuffer
		 * @param {boolean} options.isReadOnly
		 * @return {Line}
		 * @constructor
		 */
		function Line(options)
		{
			var that = this;
			var exposedLineProxy;
			var lineConstructorOptions = options;
			var lineInstanceId, sublistId, useBuffer, isReadOnly;
			var unproxiedRecord;
			var isInited = false;
			var recordBehaviorDelegate = recordBehaviorDelegateService.create({ delegate: this });
			var implementation;

			lineInstanceId = options.lineInstanceId;
			sublistId = options.sublistId;
			useBuffer = options.fromBuffer;
			unproxiedRecord = options.unproxiedRecord;
			isReadOnly = !!options.isReadOnly;
			implementation = sublistLineImplementation.create({ useBuffer: useBuffer, line: this});

			(function processOptions(options)
			{
				var isRecordDynamic = !!unproxiedRecord.isDynamic || false;
				var isLineReadOnly = options.isReadOnly || false;

				exposedLineProxy = (function ()
				{
					var proxyCache = null;

					return function ()
					{
						if (!proxyCache)
						{
							var wrappedLine = lineProxy.wrap({
								delegate: that,
								isDynamic: isRecordDynamic,
								isReadOnly: isLineReadOnly
							});
							proxyCache = wrappedLine;
						}
						return proxyCache;
					}.bind(null, that);
				}());

			}(lineConstructorOptions));

			unproxiedRecord.on({
				types: [
					recordDefinitionEvent.Type.ERROR,
					recordDefinitionEvent.Type.UPDATE_FIELD_VALUE,
					recordDefinitionEvent.Type.UPDATE_FIELD_OPTIONS,
					recordDefinitionEvent.Type.CREATE_LINE,
					recordDefinitionEvent.Type.UPDATE_LINE,
					recordDefinitionEvent.Type.INSERT_LINE,
					recordDefinitionEvent.Type.REMOVE_LINE,
					recordDefinitionEvent.Type.SELECT_LINE,
					recordDefinitionEvent.Type.FIELD_IS_MANDATORY_CHANGE,
					recordDefinitionEvent.Type.FIELD_IS_HIDDEN_CHANGE,
					recordDefinitionEvent.Type.FIELD_IS_DISABLED_CHANGE,
					recordDefinitionEvent.Type.FIELD_IS_VISIBLE_CHANGE,
					recordDefinitionEvent.Type.FIELD_IS_DISPLAY_CHANGE,
					recordDefinitionEvent.Type.FIELD_IS_READ_ONLY_CHANGE,
					recordDefinitionEvent.Type.FIELD_LABEL_CHANGE,
					recordDefinitionEvent.Type.LINE_VALIDATION_FAILED
				],
				listener: function(event)
				{
					if (event.sublistId === sublistId && event.lineId === lineInstanceId && event.useLineBuffer === useBuffer)
					{
						emitter.emit(event);
					}
				}
			});

			var emitter = eventEmitter.create({
				eventTypes: Object.keys(recordDefinitionEvent.Type).map(function(v){ return recordDefinitionEvent.Type[v]; }),
				async: typeof setTimeout === 'function',
				insulated: true
			});

			function getHack()
			{
				return getUnproxiedRecord();
			}
			this.getHack = getHack;

			function getExposedLineProxy() { return exposedLineProxy; }
			this.getExposedLineProxy = getExposedLineProxy;
			utilityFunctions.addReadOnlyProperty(this, 'proxy', getExposedLineProxy);

			function getLineInstanceId() { return lineInstanceId; }
			this.getLineInstanceId = getLineInstanceId;
			utilityFunctions.addReadOnlyProperty(this, 'instanceId', getLineInstanceId);

			function getSublistId() { return sublistId; }
			this.getSublistId = getSublistId;
			utilityFunctions.addReadOnlyProperty(this, 'sublistId', getSublistId);

			function getSequence() { return unproxiedRecord.getModelController().getSublistLineValueForInstance(sublistId, '_sequence', lineInstanceId, useBuffer); }
			this.getSequence = getSequence;
			utilityFunctions.addReadOnlyProperty(this, 'sequence', getSequence);

			function getRecord() { return unproxiedRecord; }
			this.getRecord = getRecord;
			utilityFunctions.addReadOnlyProperty(this, 'record', getRecord);

			function getUnproxiedRecord() { return unproxiedRecord; }
			this.getUnproxiedRecord = getUnproxiedRecord;

			function validateTextApi(isTextApi, fieldState, methodName, suggestedMethod)
			{
				getUnproxiedRecord().validateTextApi(isTextApi, fieldState, methodName, suggestedMethod);
			}
			this.validateTextApi = validateTextApi;

			function getFieldLevelMetadataForBodyField(fieldId)
			{
				return getUnproxiedRecord().getFieldLevelMetadataForSublistField(getSublistId(), fieldId);
			}
			this.getFieldLevelMetadataForBodyField = getFieldLevelMetadataForBodyField;

			function isValidBodyField(fieldId)
			{
				return getUnproxiedRecord().isValidSublistField(getSublistId(), fieldId);
			}
			this.isValidBodyField = isValidBodyField;
			
			function getFieldState(fieldId)
			{
				return implementation.getFieldState(fieldId)
			}
			this.getFieldState = getFieldState;

			function parseValue(isValidField, fieldLevelMetadata, value)
			{
				return getUnproxiedRecord().parseValue(isValidField, fieldLevelMetadata, value);
			}
			this.parseValue = parseValue;

			function setParsedValueAndUpdateFieldState(fieldId, value, fieldState)
			{
				implementation.setParsedValueForBodyField(fieldId, value, fieldState);
				fieldState.isParsed = true;
			}
			this.setParsedValueAndUpdateFieldState = setParsedValueAndUpdateFieldState;


			//TODO remove sublistId once refactor getSetFieldMetadata
			function getSetFieldMetadata(sublistId, fieldId)
			{
				var fieldLevelMetadata = getFieldLevelMetadataForBodyField(fieldId);
				return {
					isValidField : isValidBodyField(fieldId),
					isMultiSelect: !!fieldLevelMetadata ? fieldLevelMetadata.isTypeMultiSelect : false,
					isSelect: !!fieldLevelMetadata ? fieldLevelMetadata.isTypeSelect : false,
					isRadio: !!fieldLevelMetadata ? fieldLevelMetadata.isTypeRadio : false,
					isNumeric: !!fieldLevelMetadata ? fieldLevelMetadata.isNumeric : false,
					isCurrency: !!fieldLevelMetadata ? fieldLevelMetadata.isCurrency : false,
					type: !!fieldLevelMetadata ? fieldLevelMetadata.type : null
				};
			}
			this.getSetFieldMetadata = getSetFieldMetadata;

			function extractInforFromFieldLevelMetadata(sublistId, fieldId)
			{
				var fieldLevelMetadata = getFieldLevelMetadataForBodyField(fieldId);
				return {
					fieldId: fieldId,
					sublistId: getSublistId(),
					radioSet: !!fieldLevelMetadata ? fieldLevelMetadata.radioSet : false,
					hasBlankString: !!fieldLevelMetadata ? fieldLevelMetadata.hasBlankString : false,
					blankString: !!fieldLevelMetadata ? fieldLevelMetadata.blankString : undefined,
					supplementedOptions: !!fieldLevelMetadata ? fieldLevelMetadata.supplementedOptions : undefined
				}
			}
			this.extractInforFromFieldLevelMetadata = extractInforFromFieldLevelMetadata;


			function cancel()
			{
				recordBehaviorDelegate.cancel();
				return exposedLineProxy();
			}
			this.cancel = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: cancel,
				emitter: emitter
			});

			function commit()
			{
				recordBehaviorDelegate.commit();
				return exposedLineProxy();
			}
			this.commit = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: commit,
				emitter: emitter
			});
			function commitPromise()
			{
				return new Promise(
					function(resolve, reject)
					{
						try
						{
							recordBehaviorDelegate.commit();
							resolve(exposedLineProxy());
						}
						catch(e)
						{
							reject(e);
						}
					}
				);
			}
			this.commit.promise = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: commitPromise,
				emitter: emitter
			});


			function getFields()
			{
				return recordBehaviorDelegate.getFields();
			}
			this.getFields = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: getFields,
				emitter: emitter
			});

			function getField(options)
			{
				return recordBehaviorDelegate.getField(options);
			}
			this.getField = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: getField,
				emitter: emitter
			});

			function hasSubrecord(options)
			{
				return recordBehaviorDelegate.hasSubrecord(options);
			}
			this.hasSubrecord = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: hasSubrecord,
				emitter: emitter
			});

			function getSubrecord(options)
			{
				var subrecord = recordBehaviorDelegate.getSubrecord(options);
				return subrecord;
			}
			this.getSubrecord = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: getSubrecord,
				emitter: emitter
			});

			function removeSubrecord(options)
			{
				recordBehaviorDelegate.removeSubrecord(options);
				return exposedLineProxy();
			}
			this.removeSubrecord = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: removeSubrecord,
				emitter: emitter
			});

			function getValue(options)
			{
				return recordBehaviorDelegate.getValue(options);
			}
			/**
			 * return value of the field on the line instance
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked after using setText
			 */
			this.getValue = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: getValue,
				emitter: emitter
			});

			function doGetValue(fieldId)
			{
				return implementation.doGetValue(fieldId);
			}
			this.doGetValue = doGetValue;

			function getParsedValueForBodyField(fieldId, delegator)
			{
				var delegator = delegator || recordBehaviorDelegate;
				return implementation.getParsedValueForBodyField(fieldId, delegator);
			}
			this.getParsedValueForBodyField = getParsedValueForBodyField;

			function setValue(options)
			{
				recordBehaviorDelegate.setValue(options);
				return exposedLineProxy();
			}
			this.setValue = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: setValue,
				emitter: emitter
			});

			function doSetValue(fieldId, value, fireFieldChange, delegator)
			{
				return implementation.doSetValue(fieldId, value, fireFieldChange, delegator);
			}
			this.doSetValue = doSetValue;

			function getText(options)
			{
				return recordBehaviorDelegate.getText(options);
			}
			/**
			 * get value of the field in text representation
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.getText = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: getText,
				emitter: emitter
			});

			function doGetText(fieldId, delegator)
			{
				delegator = delegator || recordBehaviorDelegate;
				return implementation.doGetText(fieldId, delegator);
			}
			this.doGetText = doGetText;

			function setText(options)
			{
				recordBehaviorDelegate.setText(options);
				return exposedLineProxy();
			}
			this.setText = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: setText,
				emitter: emitter
			});

			function doSetText(fieldId, text, fireFieldChange, delegator)
			{
				return implementation.doSetText(fieldId, text, fireFieldChange, delegator);
			}
			this.doSetText = doSetText;

			function doGetField(fieldId, delegator)
			{
				delegator = delegator || recordBehaviorDelegate;
				return implementation.doGetField(fieldId, delegator);
			}
			this.doGetField = doGetField;

			function doGetFields()
			{
				return implementation.doGetFields();
			}
			this.doGetFields = doGetFields;

			function doCommit()
			{
				return implementation.doCommit();
			}
			this.doCommit = doCommit;

			function doCancel()
			{
				return implementation.doCancel();
			}
			this.doCancel = doCancel;

			function doHasSubrecord(fieldId)
			{
				return implementation.hasSubrecord(fieldId);
			}
			this.doHasSubrecord = doHasSubrecord;

			function doGetSubrecord(fieldId)
			{
				return implementation.getSubrecord(fieldId);
			}
			this.doGetSubrecord = doGetSubrecord;

			function doRemoveSubrecord(fieldId)
			{
				return implementation.removeSubrecord(fieldId)
			}
			this.doRemoveSubrecord = doRemoveSubrecord;

			/*
		         * Makes a copy of the line and adds it as a new line.
			 * @returns {Line} reference to new line.
			 */
			function makeCopy()
			{
				return recordBehaviorDelegate.makeCopy()
			}
			this.makeCopy = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: makeCopy,
				emitter: emitter
			});

			function doMakeCopy()
			{
				return implementation.makeCopy()
			}
			this.doMakeCopy = doMakeCopy;

			function on(options)
			{
				var types = options.types,
					listener = options.listener;

				utilityFunctions.checkArgs([types, listener], ['types', 'listener'], getMissingArgumentErrorMessageFillerValue('on'));
				emitter.on({
					types: types,
					listener: listener
				});

				return exposedLineProxy();
			}
			this.on = on;

			function off(options)
			{
				var types = options.types,
					listener = options.listener;

				utilityFunctions.checkArgs([types, listener], ['types', 'listener'], getMissingArgumentErrorMessageFillerValue('off'));
				emitter.off({
					types: types,
					listener: listener
				});

				return exposedLineProxy();
			}
			this.off = off;

			function toJSON()
			{
				return {
					lineInstanceId : that.instanceId,
					sublistId : that.sublistId,
					fields: unproxiedRecord.getModelController().getSublistLineJSON(that.sublistId, that.instanceId, useBuffer)
				}
			}
			this.toJSON = toJSON;

			function toString()
			{
				return "line.Line";
			}
			this.toString = toString;

			function setIsInited() { isInited = true; }

			function getIsInited() { return isInited; }

			function getMissingArgumentErrorMessageFillerValue(methodName)
			{
				return exposedLineProxy().toString() + '.' + methodName;
			}
			this.getMissingArgumentErrorMessageFillerValue = getMissingArgumentErrorMessageFillerValue;

			utilityFunctions.checkArgs([lineInstanceId, sublistId, unproxiedRecord], ['lineInstanceId', 'sublistId', 'unproxiedRecord'], getMissingArgumentErrorMessageFillerValue("Line() constructor"));

			setIsInited();
			return that;
		}

		return Line;
	});

/**
 * SuiteScript module
 *
 * @private
 * @module N/util/slaving
 * @suiteScriptVersion 2.x
 */
define('N/util/slaving',['N/utilityFunctions', 'N/record/recordUtilityFunctions'], function(utilityFunctions, recordUtilityFunctions){

slavingUtil =
	function ()
	{
		//noinspection JSUnresolvedVariable
		var MULTISELECT = "multiselect";

		var SlavingMetadataKey = {
			QUERY_URL: "queryurl",
			EDIT:"edit",
			DISPLAY_ONLY:"displayonly",
			AUX_FIELDS:"auxfields",
			MULTILINE:"ln",
			MASTER:"master",
			FIELD_OBJECT: {
				NAME:"name",
				MACHINE:"machine",
				HTML_REF:"htmlReference",
				REQUIRED:"required",
				REQUIRED_SCRIPT:"requiredScript",
				IS_REQUIRED:"isRequired"
			}
		};

		var QueryRequst = {
			URL: "url",
			PAYLOAD: "payload"
		};

		var SlaveResultKey ={
			NAME : 'name',
			MACHINE_NAME : 'machine',
			FIRE_FIELDCHANGE : 'firechange',
			IS_CLIENT_SLAVING: 'isClientSlaving',
			OPTIONS : 'options',
			VALUE : 'value',
			TEXT : 'text',
			NO_OVERRIDE : 'nooverride',
			CONDITION : 'condition'
		};

		function RemoteRecordDelegate(recordDelegate)
		{
			var record = recordDelegate.currentRecord;
			var utilFunctionsFromRecordInstance = recordDelegate.util;
			/* Helper Function for finding option index */
			function getFieldOptionIndexById(options, id)
			{
				for(var i = 0; i < options.length; i++)
				{
					if(options[i].id == id)
						return i;
				}
				return -1;
			}

			function getFieldOptions() { return utilFunctionsFromRecordInstance.getFieldOptions(); }
			function setFieldNoSlaving(fieldInfo, noslaving)
			{
				utilFunctionsFromRecordInstance.setFieldNoSlaving(fieldInfo.machineName, fieldInfo.fieldName, fieldInfo.lineNum, noslaving);
			}
			function getValue(params)
			{
				var value = "";
				if(params.isMachineField === true)
				{
					if(!!params.lineInstanceId)
					{
						var useBuffer = true;
						value = record.getSublistLineValueAsLegacyStringForInstance(params.machineName, params.fieldName, params.lineInstanceId, useBuffer);
					}
					else if(params.ln && params.ln !== -1)
					{
						value = record.getSublistLineValueAsLegacyString(params.machineName, params.fieldName, params.ln);
						value = value === null || value === undefined ? "" : value;
					}
					else
					{
						value = record.getCurrentSublistLineValueAsLegacyString(params.machineName, params.fieldName);
					}
				}
				else if(params.isMultiSelectField)
					value = record.getValueAsLegacyStringArray(params.fieldName);
				else
					value = record.getValueAsLegacyString(params.fieldName);

				return recordUtilityFunctions.emptyIfNullOrUndefined(value);
			}
			function setValue(params, value, fireFieldChange, isClientSlaving)
			{
				var noslaving = isClientSlaving ? false : true;
				if(params.isMachineField === true)
					record.doSetCurrentSublistFieldValue(params.machineName, params.fieldName, value, fireFieldChange, noslaving, true, true);
				else if(params.isMultiSelectField)
					record.doSetFieldValue(params.fieldName, value, fireFieldChange, noslaving, true, true);
				else
					record.doSetFieldValue(params.fieldName, value, fireFieldChange, noslaving, true, true);
			}
			function setSelectValue(params, value, text, fireFieldChange)
			{
				if(!value && value !== '')
				{
					if(params.isMachineField === true)
						record.doSetCurrentSublistText(params.machineName, params.fieldName, text, fireFieldChange, true, true);
					else
						record.doSetText(params.fieldName, value, fireFieldChange, true, true);
				}
				else
					setValue(params, value, fireFieldChange);
			}
			function getFieldOptionFromCache(params)
			{
				if(getFieldOptions() !== null && !(getFieldOptions().get(params.machineName, params.fieldName, params.lineNum)))
					putFieldOptionInCache(params, []);

				return getFieldOptions().get(params.machineName, params.fieldName, params.lineNum);
			}
			function putFieldOptionInCache(params, obj)
			{
				getFieldOptions().put(params.machineName, params.fieldName, params.lineNum, obj);
			}
			function removeOption(params, value)
			{
				var options = getFieldOptionFromCache(params);
				if(options.length > 0)
				{
					if(value || value === 0)
					{
						var idx = getFieldOptionIndexById(options, value);
						options.splice(idx,1);
					}
					else
					{
						options.splice(0, options.length);
					}
					putFieldOptionInCache(params, options);
				}
			}
			function insertOption(params, value, text)
			{
				var options = getFieldOptionFromCache(params);
				if(options && options instanceof Array)
				{
					options.push({ text:text, id:value });
					putFieldOptionInCache(params, options);
				}
			}

			this.setFieldNoSlaving = setFieldNoSlaving;
			this.getValue = getValue;
			this.setValue = setValue;
			this.setSelectValue = setSelectValue;
			this.removeOption = removeOption;
			this.insertOption = insertOption;
			this.isEditableSublist = utilFunctionsFromRecordInstance.isEditableSublist;
			this.isFieldMultiSelect = utilFunctionsFromRecordInstance.isFieldMultiSelect;
			this.returnEmptyIfNull = utilityFunctions.returnEmptyIfNull;
			this.isValEmpty = utilityFunctions.isValEmpty;

			this.getCurrentLineItemIndex = function(sublist){ return record.getCurrentSublistIndex({sublistId: sublist});};
			this.triggerPostSourcing = utilFunctionsFromRecordInstance.postSourcing;
		}

		function BrowserRecordDelegate()
		{
			function setFieldNoSlaving(fieldInfo, noslaving)
			{
				var field = getFieldObject(fieldInfo);
				if(field)
					field.noslaving = noslaving;
			}
			function getFieldObject(params)
			{
				if(params.isMachineField === true)
					return nlapiGetLineItemField(params.machineName, params.fieldName, params.lineNum);
				else
					return nlapiGetField(params.fieldName);
			}
			function getValue(params)
			{
				var value = "";
				if(params.isMachineField === true)
				{
					if(!!params.lineInstanceId)
					{
						var useBuffer = true;
						value = record.getSublistLineValueAsLegacyStringForInstance(params.machineName, params.fieldName, params.lineInstanceId, useBuffer);
					}
					else if(params.ln)
						value = utilityFunctions.returnEmptyIfNull(nlapiGetLineItemValue(params.machineName, params.fieldName, params.ln));
					else
						value = nlapiGetCurrentLineItemValue(params.machineName, params.fieldName);
				}
				else if(params.isMultiSelectField)
					value = nlapiGetFieldValues(params.fieldName);
				else
					value = nlapiGetFieldValue(params.fieldName);

				return value;
			}
			function setValue(params, value, fireFieldChange)
			{
				if(params.isMachineField === true)
					nlapiSetCurrentLineItemValue(params.machineName, params.fieldName, value, fireFieldChange, true);
				else if(params.isMultiSelectField)
					nlapiSetFieldValues(params.fieldName, value, fireFieldChange, true);
				else
					nlapiSetFieldValue(params.fieldName, value, fireFieldChange, true);
			}
			function setSelectValue(params, value, text, fireFieldChange)
			{
				if(params.isMachineField === true)
					nlapiSetCurrentLineItemSelectValue(params.machineName, params.fieldName, value, text, fireFieldChange, getSlavingAsync());
				else
					nlapiSetSelectValue(params.fieldName, text, fireFieldChange, getSlavingAsync());
			}
			function insertSelectOption(fieldName, value, text)
			{
				var form = typeof(ftabs) != 'undefined' && ftabs[getFieldName(fieldName)] != null ? document.forms[ftabs[getFieldName(fieldName)]+'_form'] : document.forms[0];
				doInsertSelectOption(form, fieldName, text, value);
			}
			function insertLineItemOption(machineName, fieldName, value, text)
			{
				var form = document.forms[machineName+'_form'];
				doInsertSelectOption(form, fieldName, text, value);
			}
			function doInsertSelectOption(form, fieldName, text, value)
			{
				var fld = getFormElement( form, getFieldName(fieldName) );
				if (fld != null)
					addSelectOption( document, fld, text, value );
			}
			function removeSelectOption(fieldName, value)
			{
				var form = typeof(ftabs) != 'undefined' && ftabs[getFieldName(fieldName)] != null ? document.forms[ftabs[getFieldName(fieldName)]+'_form'] : document.forms[0];
				doRemoveSelectOption(form, fieldName, value);
			}

			function removeLineItemOption(machineName, fieldName, value)
			{
				var form = document.forms[machineName+'_form'];
				doRemoveSelectOption(form, fieldName, value);
			}
			function doRemoveSelectOption(form, fieldName, value)
			{
				var fld = getFormElement( form, getFieldName(fieldName) );
				if (fld != null)
				{
					if(value != null)
						deleteOneSelectOption( fld, value );
					else
						deleteAllSelectOptions( fld, window );
				}
			}
			function removeOption(params, value)
			{
				if(params.isMachineField === true)
					removeLineItemOption(params.machineName, params.fieldName, value);
				else
					removeSelectOption(params.fieldName, value)
			}
			function insertOption(params, value, text)
			{
				if(params.isMachineField === true)
					insertLineItemOption(params.machineName, params.fieldName, value, text);
				else
					insertSelectOption(params.fieldName, value, text)
			}
			function isFieldMultiSelect(sublistId, fieldId, line)
			{
				var field = getFieldObject({isMachineField: !!sublistId, machineName: sublistId, fieldName: fieldId, lineNum: line});
				return field ? field.getType() === MULTISELECT : false;
			}

			this.setFieldNoSlaving = setFieldNoSlaving;
			this.getValue = getValue;
			this.setValue = setValue;
			this.setSelectValue = setSelectValue;
			this.removeOption = removeOption;
			this.insertOption = insertOption;
			this.isEditableSublist = isEditMachine;
			this.isFieldMultiSelect = isFieldMultiSelect;
			this.serverCall = nsServerCall;
			this.returnEmptyIfNull = emptyIfNull;
			this.isValEmpty = isValEmpty;

			this.getCurrentLineItemIndex = nlapiGetCurrentLineItemIndex;
		}

		/**
		 * getQueryRequest - static util function which transform metadata and dynamic recordDelegate context to query request object
		 *
		 * @param metadata - slaving metadata for current field
		 * @param masterInfo - a js object with 'queryFieldName', 'queryFieldValue', 'lineNum', 'fieldspec'
		 * @param recordDelegate - recordDelegate scope for client object. It should be null for Browser
		 * @returns {*}
		 */
		function getQueryRequest(metadata, masterInfo, recordDelegate)
		{
			var IS_EDIT = 'e';
			var RECORD_ID = 'id';
			var QUERY_PARAMETER_NAME = 'q';
			var QUERY_PARAMETER_VALUE = 'si';
			var MACHINE_NAME = 'machine';
			var QUERYREQUEST_SLAVING_FIELD = 'f';
			var LIST_MACHINE_LINE_NUMBER = 'ln';

			var RecordDelegate = (recordDelegate) ? new RemoteRecordDelegate(recordDelegate) : new BrowserRecordDelegate();
			var isBrowserRequest = (recordDelegate) ? false : true;
			var lineNum = masterInfo.hasOwnProperty('lineNum') && masterInfo.lineNum != null ? masterInfo.lineNum : null;
			var lineInstanceId = masterInfo.hasOwnProperty('lineInstanceId') && masterInfo.lineInstanceId != null ? masterInfo.lineInstanceId : null;
			var sublistName = masterInfo.sublistId;
			var result = cleanupQueryURL(metadata[SlavingMetadataKey.QUERY_URL]);
			var url = result[QueryRequst.URL];
			var payload = result[QueryRequst.PAYLOAD];

			// adding id and edit flag
			if (metadata[SlavingMetadataKey.EDIT] === 'T')
			{
				var id = (recordDelegate ? recordDelegate.currentRecord.id : RecordDelegate.getValue({fieldName: 'id'}));
				if(id || id === 0)
					payload[RECORD_ID] = String(id);
				if (metadata[SlavingMetadataKey.DISPLAY_ONLY] !== 'T')
					payload[IS_EDIT] = 'T';
			}
			// adding q and si
			payload[QUERY_PARAMETER_NAME] = masterInfo['queryFieldName'];
			payload[QUERY_PARAMETER_VALUE] = masterInfo['queryFieldValue'];
			if(sublistName)
				payload[MACHINE_NAME] = sublistName;
			if(masterInfo['fieldspec'].length != 0)
				payload[QUERYREQUEST_SLAVING_FIELD] = masterInfo['fieldspec'];
			// adding ln -- list machine field only
			if (metadata[SlavingMetadataKey.MULTILINE] === 'T' && lineNum > 0 )
				payload[LIST_MACHINE_LINE_NUMBER] = String(lineNum);

			// adding aux fields params
			var valid = addAuxFieldValueToPayloadAndReturnFalseWhenInvalid(isBrowserRequest, metadata, lineNum, lineInstanceId, payload, RecordDelegate);
			if(!valid)
				return null;
			// adding master of query field
			addMasterValueToPayload(metadata, lineNum, payload, RecordDelegate);

			return { url : url, payload : payload /* all value should be String */};
		}
		/*
		 * Description: helper function to add aux field value to payload for field query request
		 */
		function addAuxFieldValueToPayloadAndReturnFalseWhenInvalid(isBrowserRequest, metadata, lineNum, lineInstanceId, payload, RecordDelegate)
		{
			var auxfields = metadata[SlavingMetadataKey.AUX_FIELDS];
			for (var idx = 0; auxfields && idx < auxfields.length; idx++)
			{
				var auxfld = auxfields[idx];
				var fieldName = auxfld.hasOwnProperty(SlavingMetadataKey.FIELD_OBJECT.NAME) ? auxfld[SlavingMetadataKey.FIELD_OBJECT.NAME] : "";
				var machineName = auxfld.hasOwnProperty(SlavingMetadataKey.FIELD_OBJECT.MACHINE) ? auxfld[SlavingMetadataKey.FIELD_OBJECT.MACHINE] : null;
				var htmlReference = auxfld.hasOwnProperty(SlavingMetadataKey.FIELD_OBJECT.HTML_REF) ? auxfld[SlavingMetadataKey.FIELD_OBJECT.HTML_REF] : null;
				var fieldValue = RecordDelegate.getValue({isMachineField: machineName !== null, machineName: machineName, fieldName: fieldName, ln: lineNum, lineInstanceId: lineInstanceId});

				if(isBrowserRequest && !fieldValue && fieldValue !== 0 && fieldValue !== "")
					fieldValue = eval(htmlReference);

				if(auxfld[SlavingMetadataKey.FIELD_OBJECT.REQUIRED] === 'T' && isInvalidRequiredAuxField(isBrowserRequest, auxfld, fieldValue))
					return false;

				payload['si_'+fieldName] = fieldValue;
			}

			return true;
		}
		/*
		 * Description: helper function to add master value of the query field to payload for field query request
		 */
		function addMasterValueToPayload(metadata, lineNum, payload, RecordDelegate)
		{
			if (metadata[SlavingMetadataKey.MASTER] && metadata[SlavingMetadataKey.MASTER] !== '')
			{
				var fld = metadata[SlavingMetadataKey.MASTER];
				var masterFieldName = fld[SlavingMetadataKey.FIELD_OBJECT.NAME];
				var machineName = fld.hasOwnProperty(SlavingMetadataKey.FIELD_OBJECT.MACHINE) ? fld[SlavingMetadataKey.FIELD_OBJECT.MACHINE] : null;
				// adding master value
				payload['si_' + masterFieldName] = RecordDelegate.getValue({isMachineField: machineName !== null, machineName: machineName, fieldName: masterFieldName, ln: lineNum});
			}
		}

		/*
		 * Description: helper function to separate the base url into url and payload
		 */
		function cleanupQueryURL(url)
		{
			var payload = {};
			if(url.indexOf("?") !== -1)
			{
				var list = url.split("?");
				url = list[0];
				if(list[1].length >0)
				{
					var params = list[1].split("&");

					for(var i=0; i < params.length; i++)
					{
						//noinspection JSUnfilteredForInLoop
						if(params[i].length >0)
						{
							//noinspection JSUnfilteredForInLoop
							var pair = params[i].split("=");
							payload[pair[0]] = String(pair[1]);
						}
					}
				}
			}
			return { url : url, payload : payload };
		}

		function isInvalidRequiredAuxField(isBrowserRequest, field, value)
		{
			var requiredScriptCondition = true;
			if (isBrowserRequest && field.hasOwnProperty(SlavingMetadataKey.FIELD_OBJECT.REQUIRED_SCRIPT))
				requiredScriptCondition = ( eval(field[SlavingMetadataKey.FIELD_OBJECT.REQUIRED_SCRIPT]) ) ? true : false;
			else if(field.hasOwnProperty(SlavingMetadataKey.FIELD_OBJECT.IS_REQUIRED) && field.isRequired)
				requiredScriptCondition = true;

			var isValidValue = (value && value.length != 0) ? true : false;

			return requiredScriptCondition && !isValidValue;
		}

		function getURL(metadata, masterInfo)
		{
			var requestObj = getQueryRequest(metadata, masterInfo, undefined /* no remote record context required */);
			var fullUrl = requestObj['url'];
			var payload = requestObj['payload'];
			if(fullUrl.indexOf('?') == -1)
			{
				fullUrl+='?';
			}
			var first = true;
			for(var key in payload)
			{
				if(!first)
					fullUrl+='&';
				else
					first = false;

				if(key.indexOf('si_')===0 || key==='q' || key==='si' || key==='id')
					fullUrl = fullUrl+key+'='+encodeURIComponent(emptyIfNull(payload[key])) ;
				else
					fullUrl = fullUrl+key+'='+emptyIfNull(payload[key]) ;
			}

			return fullUrl;
		}

		function addEscaping(value)
		{
			value= value.replace(/\\/g, "\\\\");
			value= value.replace(/'/g, "\\\'");
			value= value.replace(/"/g, "\\\"");
			return value;
		}

		/**
		 * static function that verifies that slaving data sent from server using new format are the same that were set by legacy code.
		 *  fields parameter is needed so we call verify before slaving script execution as fields can be modified by slave script.
		 * @param fields  fields that need to be checked on the current level
		 * @param slavingValues array of all slaving values
		 */
		function verifySlavingValues(fields,slavingValues)
		{
			try{
				for(var j = 0; fields && j < fields.length; j++)
				{
					for (var idx = 0; slavingValues && idx < slavingValues.length; idx++)
					{
						var slaveInfo = slavingValues[idx];
						if(isFunction(slaveInfo))
						{
							continue;
						}
						if(slaveInfo['name'] != fields[j][0] || (slaveInfo['machine']!= null && slaveInfo['machine']!= fields[j][1] || slaveInfo['machine'] == null && fields[j][1] != ""))
							continue;
						var options = slaveInfo["options"];
						var fld = nlapiGetLineItemField(slaveInfo["machine"],slaveInfo["name"]);
						if(slaveInfo["machine"] != null)
						{
							if(options != null)
							{
								var legacyValues = getLineItemOptionValues(slaveInfo["machine"],slaveInfo["name"],fld.type);
								var legacyTexts = getLineItemOptionTexts(slaveInfo["machine"],slaveInfo["name"],fld.type);
								if(legacyValues.length != options.length)
									nsServerCall('/app/common/scripting/nlapijsonhandler.nl', 'logSlavingError',['Json option Length mismatch',
										'Options length do not match. Field name:' + slaveInfo['name'] +' ,path = '+  window.location.pathname]);
								else
								{
									for( var i= 0; options && i <options.length; i++)
									{
										var option = options[i];
										// need to take care of escape character difference
										var legacyValue= addEscaping(legacyValues[i]);
										var legacyText= addEscaping(legacyTexts[i]);
										// some options have extra CR in legacy ignoring it
										legacyText = legacyText.replace('\n','');


										if(option[0] != legacyValue)
										{
											nsServerCall('/app/common/scripting/nlapijsonhandler.nl', 'logSlavingError',['Json option Value mismatch',
												'Options slaving value do not match. Field name:' + slaveInfo['name'] +' jsonValue =' +option[0] +' legacyValue = ' + legacyValues[i]  +' ,path = '+  window.location.pathname]);
											break;
										}
										if(option[1] != legacyText)
										{
											nsServerCall('/app/common/scripting/nlapijsonhandler.nl', 'logSlavingError',['Json option Value mismatch',
												'Options slaving text do not match. Field name:' + slaveInfo['name'] +' jsonValue =' +option[1] +' legacyValue = ' + legacyTexts[i]  +' ,path = '+  window.location.pathname]);
										   break;
										}
									}
								}

							}

							// don't know the old value (before slaving)
							// so can not check values for this case.
							if(slaveInfo["nooverride"] != null)
							{
								continue;
							}
							if(slaveInfo["condition"] != null)
								if(!eval(slaveInfo["condition"]))
									continue;
							// need to take care of escape character difference
							var oldvalue = nlapiGetCurrentLineItemValue(slaveInfo["machine"],slaveInfo["name"]);
							oldvalue= addEscaping(oldvalue);

							if(slaveInfo["value"] != null && slaveInfo["value"] != oldvalue  )
							{
								nsServerCall('/app/common/scripting/nlapijsonhandler.nl', 'logSlavingError',['Json Value mismatch',
									'Value slaving result do not match. Field name:' + slaveInfo['name'] + ', jsonText = '+ slaveInfo["value"]+', actualValue  = ' + oldvalue +' ,path = '+  window.location.pathname]);

							}
							if(slaveInfo["text"] != null)
							{
								// need to take care of escape character difference
								var oldtext = nlapiGetCurrentLineItemText(slaveInfo["machine"],slaveInfo["name"]);
								oldtext= addEscaping(oldtext);

								if(slaveInfo["text"] != oldtext)
								{
									nsServerCall('/app/common/scripting/nlapijsonhandler.nl',
											'logSlavingError',['Json Value mismatch',
												'Value slaving result do not match. Field name:' + slaveInfo['name'] + ', jsonText = '+ slaveInfo['text'] +', actualValue  = ' + oldtext +' ,path = '+ window.location.pathname]);

								}
							}
						}
						else
						{
							// need to take care of escape character difference

							var oldvalue = nlapiGetFieldValue(slaveInfo["name"]);
							oldvalue=  addEscaping(oldvalue);

							var options = slaveInfo["options"];
							var fld = nlapiGetField(slaveInfo["name"]);
							if(options != null)
							{
								var legacyValues = getOptionValues(slaveInfo["name"], fld.type);
								var legacyTexts = getOptionTexts(slaveInfo["name"],fld.type);

								if(legacyValues.length != options.length)
									nsServerCall('/app/common/scripting/nlapijsonhandler.nl', 'logSlavingError',['Json option Length mismatch',
										'Options length do not match. Field name:' + slaveInfo['name']  +' ,path = '+  window.location.pathname]);
								else
								{
									for( var i= 0; options && i <options.length; i++)

									{
										var option = options[i];
										var legacyValue=  addEscaping(legacyValues[i]);
										var legacyText= addEscaping(legacyTexts[i]);
										// some options have extra CR in legacy ignoring it
										legacyText = legacyText.replace('\n','');

										if(option[0] != legacyValue)
										{
											nsServerCall('/app/common/scripting/nlapijsonhandler.nl', 'logSlavingError',['Json option Value mismatch',
												'Options slaving value do not match. Field name:' + slaveInfo['name'] +' jsonValue =' +option[0] +' legacyValue = ' + legacyValues[i]  +' ,path = '+  window.location.pathname]);
											break;
										}
										if(option[1] != legacyText)
										{
											nsServerCall('/app/common/scripting/nlapijsonhandler.nl', 'logSlavingError',['Json option Value mismatch',
												'Options slaving text do not match. Field name:' + slaveInfo['name'] +' jsonValue =' +option[1] +' legacyValue = ' + legacyText[i]  +' ,path = '+  window.location.pathname]);
											break;
										}
									}
								}
							}
							// don't know the old value (before slaving)
							// so can not check values for this case.
							if(slaveInfo["nooverride"] != null)
							{
								continue;
							}
							if(slaveInfo["condition"] != null)
								if(!eval(slaveInfo["condition"]))
									continue;

							if(slaveInfo["value"] != null && slaveInfo["value"] != oldvalue  )
							{
								nsServerCall('/app/common/scripting/nlapijsonhandler.nl', 'logSlavingError',['Json Value mismatch',
									'Value slaving result do not match. Field name:' + slaveInfo['name'] + ', jsonText = '+ slaveInfo['value'] +', actualValue  = ' + oldvalue +' ,path = '+
																																	window.location.pathname]);

							}
							if(slaveInfo["text"] != null)
							{
								// need to take care of escape character difference
								var oldtext = nlapiGetFieldText(slaveInfo["name"]);
								oldtext= addEscaping(oldtext);;

								if(slaveInfo["text"] != oldtext)
								{
									nsServerCall('/app/common/scripting/nlapijsonhandler.nl', 'logSlavingError',['Json Value mismatch',
										'Value slaving result do not match. Field name:' + slaveInfo['name'] + ', jsonText = '+ slaveInfo['text'] +', actualValue  = ' + oldtext +' ,path = '+
										window.location.pathname]);
								}
							}
						}
					}
				}
			}
			catch(err)
			{
				nsServerCall('/app/common/scripting/nlapijsonhandler.nl', 'logSlavingError',['Excepion in verifying values', err.msg +' ,path = '+	  window.location.pathname]);
			}
		}

		function isFunction(obj)
		{
			return Object.prototype.toString.call(obj) === '[object Function]';
		}

		/**
		 * static utility function that process the slavingResponse data in the json format and sets the data in the DOM using Nlapi when possible.
		 * @param slavingValues
		 * @param record
		 */
		function processSlavingValues(slavingValues, record)
		{
			var RecordDelegate = (record) ? new RemoteRecordDelegate(record) : new BrowserRecordDelegate();
			for (var idx = 0; slavingValues && idx < slavingValues.length; idx++)
			{
				var slaveResult = slavingValues[idx];
				var fieldName = slaveResult[SlaveResultKey.NAME];
				var isMachineField = slaveResult.hasOwnProperty(SlaveResultKey.MACHINE_NAME);
				var machineName = (isMachineField) ? slaveResult[SlaveResultKey.MACHINE_NAME] : null;
				var lineNum = (isMachineField) ? RecordDelegate.getCurrentLineItemIndex(machineName) : -1;
				var fieldInfo = {isMachineField: isMachineField, machineName: machineName, fieldName: fieldName, lineNum: lineNum};
				fieldInfo.isMultiSelectField = RecordDelegate.isFieldMultiSelect(machineName, fieldName, lineNum);

				if(isFunction(slaveResult))
				{
					slaveResult(RecordDelegate);
					continue;
				}

				try
				{
					applySlaveValueToRecord(RecordDelegate, slaveResult, fieldInfo);
				}
				catch(err)
				{
					if(RecordDelegate instanceof BrowserRecordDelegate)
						RecordDelegate.serverCall('/app/common/scripting/nlapijsonhandler.nl', 'logSlavingError',['Excepion in processing values', err.msg +',path =  '+  ((record)? "" : window.location.pathname)]);
					else
						throw err;
					// this will allow the code to proceed further even if there is an error in slaving
					// we probably need to do something here rather than fail silently
				}
				finally
				{
					if(record == null)
						RecordDelegate.setFieldNoSlaving(fieldInfo, false);
				}
			}
		}

		function applySlaveValueToRecord(RecordDelegate, slaveResult, fieldInfo)
		{
			var fireFieldChangeEvent = slaveResult.hasOwnProperty(SlaveResultKey.FIRE_FIELDCHANGE);
			var isClientSlaving = slaveResult.hasOwnProperty(SlaveResultKey.IS_CLIENT_SLAVING);

			RecordDelegate.setFieldNoSlaving(fieldInfo, !fireFieldChangeEvent);

			var options = slaveResult[SlaveResultKey.OPTIONS];
			if(options)
			{
				var oldValue = RecordDelegate.getValue(fieldInfo);

				var isOldValueInOptions = false;
				RecordDelegate.removeOption(fieldInfo); // clear all options
				for(var j = 0; j < options.length; j++)
				{
					var option = options[j];
					RecordDelegate.insertOption(fieldInfo, option[0], option[1]);
					if(oldValue === option[0])
						isOldValueInOptions = true;
				}

				var preserveOriginalValueWhenOptionSlavingOnly = (RecordDelegate.isValEmpty(slaveResult[SlaveResultKey.VALUE]) && !RecordDelegate.isValEmpty(oldValue) && isOldValueInOptions);
				if(preserveOriginalValueWhenOptionSlavingOnly)
					RecordDelegate.setValue(fieldInfo, oldValue, false);
			}

			/* skip slaving when there is old value */
			if(slaveResult[SlaveResultKey.NO_OVERRIDE] != null && !RecordDelegate.isValEmpty(RecordDelegate.getValue(fieldInfo)))
				return;

			/* skip slaving when condition is not met */
			var slavingCondition = typeof slaveResult[SlaveResultKey.CONDITION] === 'boolean' ? slaveResult[SlaveResultKey.CONDITION] : eval(slaveResult[SlaveResultKey.CONDITION]);
			if(slaveResult.hasOwnProperty(SlaveResultKey.CONDITION) && !slavingCondition)
				return;

			if(slaveResult.hasOwnProperty(SlaveResultKey.TEXT))
				RecordDelegate.setSelectValue(fieldInfo, slaveResult[SlaveResultKey.VALUE], slaveResult[SlaveResultKey.TEXT], fireFieldChangeEvent, isClientSlaving);
			else if(slaveResult.hasOwnProperty(SlaveResultKey.VALUE))
				RecordDelegate.setValue(fieldInfo, slaveResult[SlaveResultKey.VALUE],  fireFieldChangeEvent, isClientSlaving);
		}


		/**
		 * redraws edit machines in case new slaving response is used.
		 * @param machinedata
		 */
		function redrawEditMachines(machinedata)
		{
			for (var machineName in machinedata)
			{

				var slaveMachineData =  machinedata[machineName];

				if( slaveMachineData['edit'] != null && (slaveMachineData["nooverride"] == null || document.forms[0].elements['next' + machineName  + 'idx'].value == 1))
				{
					var data = slaveMachineData['data'];
					var strValue='';
					for (var i = 0; data && i < data.length; i++)
					{
						var row = data[i];
						for (var j = 0; row && j < row.length; j++)
						{
							if(strValue != '')
								strValue += String.fromCharCode(1);
							strValue +=row[j];
						}
						if(i != data.length -1)
							strValue += String.fromCharCode(2);
					}
					document.forms[0].elements[machineName+'data'].value=strValue;
					clearLineArray(name);

					document.forms[0].elements['next'+ machineName  + 'idx'].value=data==null?1:data.length+1;
					document.forms[0].elements[machineName+'valid'].value='T';
					setMachineContentUpdated(machineName, true);
					clearLineArray(name);
					if (parent.document.forms.main_form.elements[machineName+'loaded'] != null) parent.document.forms.main_form.elements[machineName+'loaded'].value = 'T';
					if (parent.document.forms.main_form.elements[machineName+'dotted'] != null) parent.document.forms.main_form.elements[machineName+'dotted'].value = 'T';
					if(window[machineName+'_machine'] != null)
					{
						window[machineName+'_machine'].refresheditmachine(true);

						window[machineName+'_machine'].recalc();
					}
					var tabTD = parent.document.getElementById(machineName+'lnkdot');
					if (tabTD != null) { tabTD.style.display='';}
				}
				if(isFunction(slaveMachineData['metadata']))
				{
					slaveMachineData['metadata'].call();
					continue;
				}
			}
		}

		function getOptionValues(fldnam,type)
		{
			var form = typeof(ftabs) != 'undefined' && ftabs[getFieldName(fldnam)] != null ? document.forms[ftabs[getFieldName(fldnam)]+'_form'] : document.forms[0];
			var fld = getFormElement( form, getFieldName(fldnam) );
			if (fld != null)
				if(type === MULTISELECT)
					return getMultiDropdown(fld,window).getValues();
				else
					return getDropdown(fld,window).getValues();
			else
				return null;
		}
		function getOptionTexts(fldnam,type)
		{
			var form = typeof(ftabs) != 'undefined' && ftabs[getFieldName(fldnam)] != null ? document.forms[ftabs[getFieldName(fldnam)]+'_form'] : document.forms[0];
			var fld = getFormElement( form, getFieldName(fldnam) );
			if (fld != null)
				if(type === MULTISELECT)
					return getMultiDropdown(fld,window).textArray;
				else
					return getDropdown(fld,window).getTexts();
			else
				return null;
		}
		function getLineItemOptionValues(machine,fldnam, type)
		{
			var form = document.forms[machine+'_form'];
			var fld = getFormElement( form, getFieldName(fldnam) );
			if (fld != null)
				if(type === MULTISELECT)
					return getMultiDropdown(fld,window).getValues();
				else
					return getDropdown(fld,window).getValues();
			else
				return null;
		}
		function getLineItemOptionTexts(machine,fldnam, type)
		{
			var form = document.forms[machine+'_form'];
			var fld = getFormElement( form, getFieldName(fldnam) );
			if (fld != null)
				if(type === MULTISELECT)
					return getMultiDropdown(fld,window).textArray;
				else
					return getDropdown(fld,window).getTexts();
			else
				return null;
		}

		return {
				cleanupQueryURL: cleanupQueryURL,
				getQueryRequest: getQueryRequest,
				getURL: getURL,
				processSlavingValues:processSlavingValues,
				verifySlavingValues:verifySlavingValues,
				redrawEditMachines:redrawEditMachines
			};
	}();

if (typeof Object.freeze == 'function')
	slavingUtil = Object.freeze(slavingUtil);

    return slavingUtil;});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/readOnlyRecord
 * @suiteScriptVersion 2.x
 */
define(
	'N/record/proxy/readOnlyRecord',['N/nsobject', 'N/record/recordConstants', 'N/utilityFunctions', 'N/environment'],
	function (nsobject, constants, utilityFunctions, environment)
	{
		/**
		 * ReadOnly Record interface (with the interactive API)
		 * @param {Record} delegate = underlying implementation of record, to be wrapped
		 * @param {boolean} isInteractive = true to create this record proxy wraper with the interactive API
		 * @param {boolean} isCurrentRecord = (optional) true if we are proxy-wrapping to create a current record object.
		 * @returns {ReadOnlyRecord} (proxied record.Record)
		 * @constructor* @since 2016.2
		 */
		function ReadOnlyRecord(delegate, isInteractive, isCurrentRecord)
		{
			var proxyOptions = Object.freeze({isInteractive: isInteractive});

			/**
			 * contains necessary macro information, performs macro operation (specified by getMacro)
			 * and returns result; the Macro.promise returns a Promise
			 * @name Macro
			 * @function
			 * @param {Object} [params]
			 * @returns {Object} [macro result]
			 */

			/**
			 * provides available macros
			 * @returns {Object} a set of macros (@see Macro) defined on the record indexed by macroId
			 */
			this.getMacros = delegate.getMacros;

			/**
			 * provides a macro to execute
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @returns {?Macro} [executor function for macro (@see Macro) specified by options, or null if not found]
			 */
			this.getMacro = delegate.getMacro;

			/**
			 * performs macro operation and returns result
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @param {Object} [options.params] macro arguments
			 * @returns {Object} [macro result, or null]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
			 */
			this.executeMacro = function executeMacro(options)
			{
				return delegate.executeMacro(options, isInteractive);
			};

			/**
			 * same as excuteMacro but returns a Promise
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @param {Object} [options.params] macro arguments
			 * @returns {Object} [macro result, or null]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
			 */
			this.executeMacro.promise = function executeMacroPromise(options)
			{
				return delegate.executeMacro.promise(options, isInteractive);
			};

			/**
			 * The id of the record
			 * @name Record#id
			 * @type number
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'id', function getId() { return delegate.id; });

			/**
			 * The type of the record
			 * @name Record#type
			 * @type string
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'type', function getType() { return delegate.type; });

			/**
			 * return true if record is a dynamic record
			 * @name Record#isDynamic
			 * @type boolean
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'isDynamic', function getIsDynamic() { return delegate.isDynamic; });

			/**
			 * Object to retrieve all messages stored on the record via the getMessages method
			 * @name MessageService
			 * @class
			 */

			/**
			 * provides record's MessageService object
			 * @returns {MessageService} record's MessageService instance
			 */
			this.getMessageService = delegate.getMessageService;

			/**
			 * JSON.stringify() implementation.
			 * @returns {Object}
			 */
			this.toJSON = delegate.toJSON;

			/**
			 * Returns the object type name (ReadOnlyRecord)
			 * @returns {string}
			 */
			this.toString = function () {return constants.RECORD_MODE.READ_ONLY_RECORD;};
			if (isCurrentRecord)
				this.toString = function () {return constants.CURRENT_RECORD_MODE.READ_ONLY_CURRENT_RECORD;};

			/**
			 * Object corresponding to a record action. It contains the necessary action information
			 * and can be executed (both synchronously and asynchronously using Action.promise).
			 * @name Action
			 * @function
			 * @param {Object} params
			 * @returns {Object} action result; the actual return value returned by the action implementation is stored in the response property
			 */

			/**
			 * Provides available record actions for this record instance.
			 * @returns {Object} a set of actions (@see Action) defined on the record type indexed by action ID
			 */
			this.getActions = delegate.getActions;
			/**
			 * Returns an executable record action for this record instance.
			 * @param {Object} options
			 * @param {String} options.id action ID
			 * @returns {?Action} record action executor for action specified by options
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
			 */
			this.getAction = delegate.getAction;
			/**
			 * Executes record action and returns its result. Record ID and type is automatically taken from this record instance.
			 * @param {Object} options
			 * @param {String} options.id action ID
			 * @param {Object} [options.params] action arguments
			 * @returns {Object} action result; the actual return value returned by the action implementation is stored in the response property
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
			 */
			this.executeAction = delegate.executeAction;

			/**
			 * return array of names of all body fields, including machine header field and matrix header fields
			 * @returns {string[]}
			 */
			this.getFields = delegate.getFields;

			/**
			 * returns the specified sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {Sublist} [requested sublist]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 */
			this.getSublist = delegate.getSublist;

			/**
			 * return array of names of all sublists
			 * @returns {string[]}
			 */
			this.getSublists = delegate.getSublists;

			/**
			 * return array of names of all fields in a sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {Array}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 */
			this.getSublistFields = delegate.getSublistFields;

			/**
			 * return value of the field
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked after using setText
			 */
			this.getValue = delegate.getValue;

			/**
			 * get value of the field in text representation
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked prior using setText
			 */
			this.getText = delegate.getText;

			/**
			 * return field object from record
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Field} [requested field]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.getField = delegate.getField;

			/**
			 * return field object from record's sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {Field} [requested field]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if line number is invalid
			 */
			this.getSublistField = delegate.getSublistField;

			/**
			 * return line count of sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {number}
			 */
			this.getLineCount = delegate.getLineCount;

			/**
			 * return the line number for the first occurrence of a field value in a sublist and return -1 if not found
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {(number|Date|string|Array|boolean)} options.value
			 * @returns {number}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing or undefined
			 */
			this.findSublistLineWithValue = delegate.findSublistLineWithValue;

			/**
			 * return value of a sublist field
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked after using setSublistText
			 */
			this.getSublistValue = delegate.getSublistValue;

			/**
			 * return value of a sublist field in text representation
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked prior using setSublistText
			 */
			this.getSublistText = delegate.getSublistText;

			/**
			 * return a value indicating if the field has a subrecord
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {boolean}
			 */
			this.hasSubrecord = delegate.hasSubrecord;

			/**
			 * get the subrecord for the associated field
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Record} [requested subrecord]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 * @throws {SuiteScriptError} FIELD_1_IS_NOT_A_SUBRECORD_FIELD if field is not a subrecord field
			 * @throws {SuiteScriptError} FIELD_1_IS_DISABLED_YOU_CANNOT_APPLY_SUBRECORD_OPERATION_ON_THIS_FIELD if field is disable
			 */
			this.getSubrecord = function getSubrecord()
			{
				var subrecord = delegate.getSubrecord.apply(delegate, arguments);
				return !subrecord ? null : subrecord.proxy(proxyOptions);
			};

			/**
			 * return a value indicating if the associated sublist field has a subrecord
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {boolean}
			 */
			this.hasSublistSubrecord = delegate.hasSublistSubrecord;

			/**
			 * get the subrecord for the associated sublist field
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {Record} [requested subrecord]
			 */
			this.getSublistSubrecord = function getSublistSubrecord()
			{
				var subrecord = delegate.getSublistSubrecord.apply(delegate, arguments);
				return !subrecord ? null : subrecord.proxy(proxyOptions);
			};

			/**
			 * get the value for the associated header in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number|Date|string}
			 */
			this.getMatrixHeaderValue = delegate.getMatrixHeaderValue;

			/**
			 * get the value for the associated field in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.line - the line number for the field
			 * @param {number} options.column - the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number|Date|string}
			 */
			this.getMatrixSublistValue = delegate.getMatrixSublistValue;

			/**
			 * get the field for the specified header in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {Field} [requested field]
			 */
			this.getMatrixHeaderField = delegate.getMatrixHeaderField;

			/**
			 * get the field for the specified sublist in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @param {number} options.line - the line number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {Field} [requested field]
			 */
			this.getMatrixSublistField = delegate.getMatrixSublistField;

			/**
			 * returns the line number of the first line that contains the specified value in the specified column of the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.value - the column number for the field
			 * @param {number} options.column - the line number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number}
			 */
			this.findMatrixSublistLineWithValue = delegate.findMatrixSublistLineWithValue;

			/**
			 * returns the number of columns for the specified matrix.
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number}
			 */
			this.getMatrixHeaderCount = delegate.getMatrixHeaderCount;

			/* If we are being asked to create a proxy wrapper for the current record, add/remove these methods. */
			if (isCurrentRecord)
			{
				/* Strip out and do not expose these methods on the wrapper when the underlying implementation lacks them (DomCurrentRecord). */
				if (delegate.toString() === constants.RECORD_UNDERLYING_IMPL_NAME.DOM_CURRENT_RECORD)
				{
					delete(this.toJSON);
					delete(this.getFields);
					delete(this.getSublists);
					delete(this.getSublistFields);
				}
			}


			/* If we are being asked to create a proxy wrapper for interactive mode, add the interactive-only API's. */
			if (isInteractive)
			{
				/* Nothing shoukd ever try to wrap the DOM current record as interactive, as the underlying support isn't there. */
				if (delegate.toString() === constants.RECORD_UNDERLYING_IMPL_NAME.DOM_CURRENT_RECORD)
					utilityFunctions.throwSuiteScriptError(error.Type.YOU_HAVE_ATTEMPTED_AN_UNSUPPORTED_ACTION);

				/**
				 * return true if record is read-only.
				 * @name Record#isReadOnly
				 * @type boolean
				 * @readonly
				 * @throws READ_ONLY when setting the property is attempted
				 */
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'isReadOnly', function () { return true; });

				/**
				 * return true if record is being seen in interactive mode.
				 * @name Record#isInteractive
				 * @type boolean
				 * @readonly
				 * @throws READ_ONLY when setting the property is attempted
				 */
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'isInteractive', function () { return true; });

				/**
				 * get query url and parameters
				 * @name Record#query
				 * @type Object
				 * @readonly
				 * @throws READ_ONLY when setting the property is attempted
				 */
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'query', function getQuery() { return delegate.query; });

/*deleteme*/	this.getLine = delegate.getLine;
/*deleteme*/
/*deleteme*/ 	this.getLineIterator = delegate.getLineIterator;

				//
				// !!@TODO - write properly formed JSDoc here for this new MLB API
				//
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'getLines', function getFunc_getLines() { return delegate.getLines; });

				//
				// !!@TODO - write properly formed JSDoc here for this new MLB API
				//
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'getCommittedLine', function getFunc_getCommittedLine() { return delegate.getCommittedLine; });

				//
				// !!@TODO - write properly formed JSDoc here for this new MLB API
				//
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'getCommittedLinesIterator', function getFunc_getCommittedLinesIterator() { return delegate.getCommittedLinesIterator; });
			}

			return this;
		}

		ReadOnlyRecord.prototype = nsobject.getNewInstance();

		Object.freeze(ReadOnlyRecord);

		return ReadOnlyRecord;
	});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/deferredDynamicRecord
 * @suiteScriptVersion 2.x
 */
define(
	'N/record/proxy/deferredDynamicRecord',['N/nsobject', 'N/record/recordConstants', 'N/utilityFunctions', 'N/environment'],
	function (nsobject, constants, utilityFunctions, environment)
	{
		/**
		 * Deferred Dynamic Record interface (with the interactive API)
		 * @param {Record} delegate = underlying implementation of record, to be wrapped
		 * @param {boolean} isInteractive = true to create this record proxy wraper with the interactive API
		 * @param {boolean} isCurrentRecord = This should NEVER be true because it's not supported for current record to be deferred-dynamic.
		 * @returns {DeferredDynamicRecord} (proxied record.Record)
		 * @constructor
		 */
		function DeferredDynamicRecord(delegate, isInteractive, isCurrentRecord)
		{
			var proxyOptions = Object.freeze({isInteractive: isInteractive});

			/* Nothing should ever try to wrap the current record as deferred dynamic, because it is an unsupported case that should never occur. */
			if (isCurrentRecord)
				utilityFunctions.throwSuiteScriptError(error.Type.YOU_HAVE_ATTEMPTED_AN_UNSUPPORTED_ACTION);
			/**
			 * The id of the record
			 * @name Record#id
			 * @type number
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'id', function getId() { return delegate.id; });

			/**
			 * The type of the record
			 * @name Record#type
			 * @type string
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'type', function getType() { return delegate.type; });

			/**
			 * return true if record is a dynamic record
			 * @name Record#isDynamic
			 * @type boolean
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'isDynamic', function getIsDynamic() { return delegate.isDynamic; });

			/**
			 * Object to retrieve all messages stored on the record via the getMessages method
			 * @name MessageService
			 * @class
			 */

			/**
			 * provides record's MessageService object
			 * @returns {MessageService} record's MessageService instance
			 */
			this.getMessageService = delegate.getMessageService;

			/**
			 * save record updates to the system
			 * @governance 20 units for transactions, 4 for custom records, 10 for all other records
			 *
			 * @param {Object} options
			 * @param {boolean} [options.enableSourcing=false] enable sourcing during record update
			 * @param {boolean} [options.ignoreMandatoryFields=false] ignore mandatory field during record submission
			 * @returns {number} id of submitted record
			 */
			this.save = delegate.save;

			/**
			 * JSON.stringify() implementation.
			 * @returns {Object}
			 */
			this.toJSON = delegate.toJSON;

			/**
			 * Returns the object type name (DeferredDynamicRecord)
			 * @returns {string}
			 */
			this.toString = function () {return constants.RECORD_MODE.DEFERRED_DYNAMIC_RECORD;};

			/**
			 * remove body field data
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.removeField = function removeField()
			{
				delegate.removeField.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return array of names of all body fields, including machine header field and matrix header fields
			 * @returns {string[]}
			 */
			this.getFields = delegate.getFields;

			/**
			 * returns the specified sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {Sublist} [requested sublist]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 */
			this.getSublist = delegate.getSublist;

			/**
			 * return array of names of all sublists
			 * @returns {string[]}
			 */
			this.getSublists = delegate.getSublists;

			/**
			 * return array of names of all fields in a sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {string[]}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 */
			this.getSublistFields = delegate.getSublistFields;

			/**
			 * return value of the field
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked after using setText
			 */
			this.getValue = delegate.getValue;

			/**
			 * set value of the field
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @param {number|Date|string|Array|boolean} options.value
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.setValue = function setValue()
			{
				delegate.setValue.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * get value of the field in text representation
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked prior using setText
			 */
			this.getText = delegate.getText;

			/**
			 * set value of the field by text representation
			 *
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @param {string} options.text
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.setText = function setText()
			{
				delegate.setText.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return field object from record
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Field} [requested field]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.getField = delegate.getField;

			/**
			 * return field object from record's sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {Field} [requested field]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if line number is invalid
			 */
			this.getSublistField = delegate.getSublistField;

			/**
			 * return line count of sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {number}
			 */
			this.getLineCount = delegate.getLineCount;

			/**
			 * insert a sublist line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @param {boolean} [ignoreRecalc=false] options.ignoreRecalc ignore recalc scripting
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId or line index is invalid or if machine is not editable
			 */
			this.insertLine = function insertLine()
			{
				var line = delegate.insertLine.apply(delegate, arguments);
/*deleteme*/	if (isInteractive)
/*deleteme*/		return line;
/*deleteme*/	else
					return delegate.proxy(proxyOptions);
			};

			/**
			 * remove a sublist line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @param {boolean} [ignoreRecalc=false] options.ignoreRecalc ignore recalc scripting
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId or line index is invalid or if machine is not editable
			 */
			this.removeLine = function removeLine()
			{
				delegate.removeLine.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return the line number for the first occurrence of a field value in a sublist and return -1 if not found
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {(number|Date|string|Array|boolean)} options.value
			 * @returns {number}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing or undefined
			 */
			this.findSublistLineWithValue = delegate.findSublistLineWithValue;

			/**
			 * return value of a sublist field
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked after using setSublistText
			 */
			this.getSublistValue = delegate.getSublistValue;

			/**
			 * set the value of a sublist field
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @param {(number|Date|string|Array|boolean)} options.value
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 */
			this.setSublistValue = function setSublistValue()
			{
				delegate.setSublistValue.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return value of a sublist field in text representation
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked prior using setSublistText
			 */
			this.getSublistText = delegate.getSublistText;

			/**
			 * set the value of a sublist field in text representation
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @param {string} options.text
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 */
			this.setSublistText = function setSublistText()
			{
				delegate.setSublistText.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return a value indicating if the field has a subrecord
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {boolean}
			 */
			this.hasSubrecord = delegate.hasSubrecord;

			/**
			 * get the subrecord for the associated field
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Record} [requested subrecord]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 * @throws {SuiteScriptError} FIELD_1_IS_NOT_A_SUBRECORD_FIELD if field is not a subrecord field
			 * @throws {SuiteScriptError} FIELD_1_IS_DISABLED_YOU_CANNOT_APPLY_SUBRECORD_OPERATION_ON_THIS_FIELD if field is disable
			 */
			this.getSubrecord = function getSubrecord()
			{
				var subrecord = delegate.getSubrecord.apply(delegate, arguments);
				return !subrecord ? null : subrecord.proxy(proxyOptions);
			};

			/**
			 * remove the subrecord for the associated field
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Record}
			 */
			this.removeSubrecord = function removeSubrecord()
			{
				delegate.removeSubrecord.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return a value indicating if the associated sublist field has a subrecord
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {boolean}
			 */
			this.hasSublistSubrecord = delegate.hasSublistSubrecord;

			/**
			 * get the subrecord for the associated sublist field
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {Record} [requested subrecord]
			 */
			this.getSublistSubrecord = function getSublistSubrecord()
			{
				var subrecord = delegate.getSublistSubrecord.apply(delegate, arguments);
				return !subrecord ? null : subrecord.proxy(proxyOptions);
			};

			/**
			 * remove the subrecord for the associated sublist field
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {Record}
			 */
			this.removeSublistSubrecord = function removeSublistSubrecord()
			{
				delegate.removeSublistSubrecord.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * set the value for the associated header in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @param {string} options.value - the value to set it to
			 * @param {boolean} [options.ignoreFieldChange=false] Ignore the field change script
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {Record}
			 */
			this.setMatrixHeaderValue = function setMatrixHeaderValue()
			{
				delegate.setMatrixHeaderValue.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * get the value for the associated header in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number|Date|string}
			 */
			this.getMatrixHeaderValue = delegate.getMatrixHeaderValue;

			/**
			 * set the value for the associated field in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.line - the line number for the field
			 * @param {number} options.column - the column number for the field
			 * @param {string} options.value - the value to set it to
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {Record}
			 */
			this.setMatrixSublistValue = function setMatrixSublistValue()
			{
				delegate.setMatrixSublistValue.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * get the value for the associated field in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.line - the line number for the field
			 * @param {number} options.column - the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number|Date|string}
			 */
			this.getMatrixSublistValue = delegate.getMatrixSublistValue;

			/**
			 * get the field for the specified header in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {Field} [requested field]
			 */
			this.getMatrixHeaderField = delegate.getMatrixHeaderField;
			/**
			 * get the field for the specified sublist in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @param {number} options.line - the line number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {Field} [requested field]
			 */
			this.getMatrixSublistField = delegate.getMatrixSublistField;

			/**
			 * returns the line number of the first line that contains the specified value in the specified column of the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.value - the column number for the field
			 * @param {number} options.column - the line number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number}
			 */
			this.findMatrixSublistLineWithValue = delegate.findMatrixSublistLineWithValue;

			/**
			 * returns the number of columns for the specified matrix.
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number}
			 */
			this.getMatrixHeaderCount = delegate.getMatrixHeaderCount;

			/* This is added server-side only. It comes from server implementation of N/record/recordService */
			if (delegate._addToTemplateRenderer)
				this._addToTemplateRenderer = delegate._addToTemplateRenderer;

			/* If we are being asked to create a proxy wrapper for interactive mode, add the interactive-only API's. */
			if (isInteractive)
			{
				/**
				 * return true if record is being seen in interactive mode.
				 * @name Record#isInteractive
				 * @type boolean
				 * @readonly
				 * @throws READ_ONLY when setting the property is attempted
				 */
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'isInteractive', function () { return true; });

				/**
				 * Save record updates to the system and return object with additional information about the saved record.
				 * @governance 20 units for transactions, 4 for custom records, 10 for all other records
				 *
				 * @param {Object} options
				 * @param {boolean} [options.enableSourcing=false] enable sourcing during record update
				 * @param {boolean} [options.ignoreMandatoryFields=false] ignore mandatory field during record submission
				 * @returns {Object} contains id of submitted record
				 */
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'saveAndFetch', function getFunc_saveAndFetch() { return delegate.saveAndFetch; });

/*deleteme*/	this.getLine = delegate.getLine;
/*deleteme*/
/*deleteme*/ 	this.getLineIterator = delegate.getLineIterator;

				//
				// !!@TODO - write properly formed JSDoc here for this new MLB API
				//
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'getLines', function getFunc_getLines() { return delegate.getLines; });

				//
				// !!@TODO - write properly formed JSDoc here for this new MLB API
				//
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'getCommittedLine', function getFunc_getCommittedLine() { return delegate.getCommittedLine; });

				//
				// !!@TODO - write properly formed JSDoc here for this new MLB API
				//
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'getCommittedLinesIterator', function getFunc_getCommittedLinesIterator() { return delegate.getCommittedLinesIterator; });
			}

			return this;
		}

		DeferredDynamicRecord.prototype = nsobject.getNewInstance();

		Object.freeze(DeferredDynamicRecord);

		return DeferredDynamicRecord;
	});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/dynamicRecord
 * @suiteScriptVersion 2.x
 */
define(
	'N/record/proxy/dynamicRecord',['N/nsobject', 'N/record/recordConstants', 'N/utilityFunctions', 'N/environment'],
	function (nsobject, constants, utilityFunctions, environment)
	{
		/**
		 * Dynamic Record interface (with the interactive API)
		 * @param {Record} delegate = underlying implementation of record, to be wrapped
		 * @param {boolean} isInteractive = true to create this record proxy wraper with the interactive API
		 * @param {boolean} isCurrentRecord = (optional) true if we are proxy-wrapping to create a current record object.
		 * @returns {DynamicRecord} (proxied record.Record)
		 * @constructor
		 * @since 2015.2
		 */
		function DynamicRecord(delegate, isInteractive, isCurrentRecord)
		{
			function augmentWithInteractive(args)
			{
				return utilityFunctions.augmentArguments(args, "isInteractive", isInteractive)
			}

			var proxyOptions = Object.freeze({isInteractive: isInteractive});

			/**
			 * contains necessary macro information, performs macro operation (specified by getMacro)
			 * and returns result; the Macro.promise returns a Promise
			 * @name Macro
			 * @function
			 * @param {Object} [params]
			 * @returns {Object} [macro result]
			 */

			/**
			 * provides available macros
			 * @returns {Object} a set of macros (@see Macro) defined on the record indexed by macroId
			 */
			this.getMacros = delegate.getMacros;

			/**
			 * provides a macro to execute
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @returns {?Macro} [executor function for macro (@see Macro) specified by options, or null if not found]
			 */
			this.getMacro = delegate.getMacro;

			/**
			 * performs macro operation and returns result
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @param {Object} [options.params] macro arguments
			 * @returns {Object} [macro result, or null]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
			 */
			this.executeMacro = function executeMacro(options)
			{
				return delegate.executeMacro(options, isInteractive);
			};

			/**
			 * same as excuteMacro but returns a Promise
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @param {Object} [options.params] macro arguments
			 * @returns {Object} [macro result, or null]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
			 */
			this.executeMacro.promise = function executeMacroPromise(options)
			{
				return delegate.executeMacro.promise(options, isInteractive);
			};

			/**
			 * The id of the record
			 * @name Record#id
			 * @type number
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'id', function getId() { return delegate.id; });

			/**
			 * The type of the record
			 * @name Record#type
			 * @type string
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'type', function getType() { return delegate.type; });

			/**
			 * return true if record is a dynamic record
			 * @name Record#isDynamic
			 * @type boolean
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'isDynamic', function getIsDynamic() { return delegate.isDynamic; });

			/**
			 * Object to retrieve all messages stored on the record via the getMessages method
			 * @name MessageService
			 * @class
			 */

			/**
			 * provides record's MessageService object
			 * @returns {MessageService} record's MessageService instance
			 */
			this.getMessageService = delegate.getMessageService;

			/**
			 * save record updates to the system
			 * @governance 20 units for transactions, 4 for custom records, 10 for all other records
			 *
			 * @param {Object} options
			 * @param {boolean} [options.enableSourcing=false] enable sourcing during record update
			 * @param {boolean} [options.ignoreMandatoryFields=false] ignore mandatory field during record submission
			 * @returns {number} id of submitted record
			 */
			this.save = delegate.save;

			/**
			 * JSON.stringify() implementation.
			 * @returns {Object}
			 */
			this.toJSON = delegate.toJSON;

			/**
			 * Returns the object type name (DynamicRecord)
			 * @returns {string}
			 */
			this.toString = function () {return constants.RECORD_MODE.DYNAMIC_RECORD;};
			if (isCurrentRecord)
				this.toString = function () {return constants.CURRENT_RECORD_MODE.CURRENT_RECORD;};

			/**
			 * remove body field data
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.removeField = function removeField()
			{
				delegate.removeField.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return array of names of all body fields, including machine header field and matrix header fields
			 * @returns {string[]}
			 */
			this.getFields = delegate.getFields;

			/**
			 * returns the specified sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {Sublist} [requested sublist]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 */
			this.getSublist = delegate.getSublist;

			/**
			 * return array of names of all sublists
			 * @returns {string[]}
			 */
			this.getSublists = delegate.getSublists;

			/**
			 * return array of names of all fields in a sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {string[]}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 */
			this.getSublistFields = delegate.getSublistFields;

			/**
			 * return value of the field
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.getValue = delegate.getValue;

			/**
			 * set value of the field
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @param {number|Date|string|Array|boolean} options.value
			 * @param {boolean} [options.ignoreFieldChange=false] Ignore the field change script
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.setValue = function setValue()
			{
				delegate.setValue.apply(delegate, augmentWithInteractive(arguments));
				return delegate.proxy(proxyOptions);
			};

			/**
			 * get value of the field in text representation
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.getText = delegate.getText;

			/**
			 * set value of the field by text representation
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @param {string} options.text
			 * @param {boolean} [options.ignoreFieldChange=false] ignore field change script and slaving event if set to true
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.setText = function setText()
			{
				delegate.setText.apply(delegate, augmentWithInteractive(arguments));
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return field object from record
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Field} [requested field]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.getField = delegate.getField;

			/**
			 * return field object from record's sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {Field} [requested field]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if line number is invalid
			 */
			this.getSublistField = delegate.getSublistField;

			/**
			 * return line count of sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {number}
			 */
			this.getLineCount = delegate.getLineCount;

			/**
			 * insert a sublist line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @param {boolean} [ignoreRecalc=false] options.ignoreRecalc ignore recalc scripting
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId or line index is invalid or if machine is not editable
			 */
			this.insertLine = function insertLine()
			{
				var line = delegate.insertLine.apply(delegate, arguments);
/*deleteme*/	if (isInteractive)
/*deleteme*/		return line;
/*deleteme*/	else
					return delegate.proxy(proxyOptions);
			};

			/**
			 * remove a sublist line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @param {boolean} [ignoreRecalc=false] options.ignoreRecalc ignore recalc scripting
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId or line index is invalid or if machine is not editable
			 */
			this.removeLine = function removeLine()
			{
				delegate.removeLine.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return the line number for the first occurrence of a field value in a sublist and return -1 if not found
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {(number|Date|string|Array|boolean)} options.value
			 * @returns {number}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or field is missing
			 */
			this.findSublistLineWithValue = delegate.findSublistLineWithValue;

			/**
			 * cancel the current selected line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId is invalid or if machine is not editable
			 * @restriction only available in dynamic record
			 */
			this.cancelLine = function cancelLine()
			{
				delegate.cancelLine.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * commit the current selected line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id
			 * @restriction only available in dynamic record
			 */
			this.commitLine = function commitLine()
			{
				delegate.commitLine.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * select line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or line is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id or line index
			 * @restriction only available in dynamic record
			 */
			this.selectLine = function selectLine()
			{
				var line = delegate.selectLine.apply(delegate, arguments);
/*deleteme*/	if (isInteractive)
/*deleteme*/    	return line;
/*deleteme*/	else
					return delegate.proxy(proxyOptions);
			};

			/**
			 * select a new line at the end of sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id or sublist is not editable
			 * @restriction only available in dynamic record
			 */
			this.selectNewLine = function selectNewLine()
			{
				var line = delegate.selectNewLine.apply(delegate, arguments);
/*deleteme*/	if (isInteractive)
/*deleteme*/    	return line;
/*deleteme*/	else
					return delegate.proxy(proxyOptions);
			};

			/**
			 * return value of a sublist field on the current selected sublist line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @returns {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id or field id
			 * @restriction only available in dynamic record
			 */
			this.getCurrentSublistValue = delegate.getCurrentSublistValue;

			/**
			 * return value of a sublist field
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id or line number
			 */
			this.getSublistValue = delegate.getSublistValue;

			/**
			 * set the value for field in the current selected line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {(number|Date|string|Array|boolean)} options.value
			 * @param {boolean} [options.ignoreFieldChange=false] ignore field change script and slaving event if set to true
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} A_SCRIPT_IS_ATTEMPTING_TO_EDIT_THE_1_SUBLIST_THIS_SUBLIST_IS_CURRENTLY_IN_READONLY_MODE_AND_CANNOT_BE_EDITED_CALL_YOUR_NETSUITE_ADMINISTRATOR_TO_DISABLE_THIS_SCRIPT_IF_YOU_NEED_TO_SUBMIT_THIS_RECORD if user tries to edit readonly sublist field
			 */
			this.setCurrentSublistValue = function setCurrentSublistValue()
			{
				delegate.setCurrentSublistValue.apply(delegate, augmentWithInteractive(arguments));
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return the value for field in the current selected line by text representation
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @returns {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id or field id
			 * @restriction only available in dynamic record
			 */
			this.getCurrentSublistText = delegate.getCurrentSublistText;

			/**
			 * return value of a sublist field in text representation
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id or line number
			 */
			this.getSublistText = delegate.getSublistText;

			/**
			 * set the value for field in the current selected line by text representation
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {(number|Date|string|Array|boolean)} options.text
			 * @param {boolean} [options.ignoreFieldChange=false] ignore field change script and slaving event if set to true
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} A_SCRIPT_IS_ATTEMPTING_TO_EDIT_THE_1_SUBLIST_THIS_SUBLIST_IS_CURRENTLY_IN_READONLY_MODE_AND_CANNOT_BE_EDITED_CALL_YOUR_NETSUITE_ADMINISTRATOR_TO_DISABLE_THIS_SCRIPT_IF_YOU_NEED_TO_SUBMIT_THIS_RECORD if user tries to edit readonly sublist field
			 * @restriction only available in dynamic record
			 */
			this.setCurrentSublistText = function setCurrentSublistText()
			{
				delegate.setCurrentSublistText.apply(delegate, augmentWithInteractive(arguments));
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return the line number of current selected line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {number}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 * @restriction only available in dynamic record
			 */
			this.getCurrentSublistIndex = delegate.getCurrentSublistIndex;

			/**
			 * return a value indicating if the field has a subrecord
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {boolean}
			 */
			this.hasSubrecord = delegate.hasSubrecord;

			/**
			 * get the subrecord for the associated field
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Record} [requested subrecord]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 * @throws {SuiteScriptError} FIELD_1_IS_NOT_A_SUBRECORD_FIELD if field is not a subrecord field
			 * @throws {SuiteScriptError} FIELD_1_IS_DISABLED_YOU_CANNOT_APPLY_SUBRECORD_OPERATION_ON_THIS_FIELD if field is disable
			 */
			this.getSubrecord = function getSubrecord()
			{
				var subrecord = delegate.getSubrecord.apply(delegate, arguments);
				return !subrecord ? null : subrecord.proxy(proxyOptions);
			};

			/**
			 * remove the subrecord for the associated field
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Record}
			 */
			this.removeSubrecord = function removeSubrecord()
			{
				delegate.removeSubrecord.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return a value indicating if the associated sublist field has a subrecord
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @restriction only available in deferred dynamic record
			 * @returns {boolean}
			 */
			this.hasSublistSubrecord = delegate.hasSublistSubrecord;

			/**
			 * return a value indicating if the associated sublist field has a subrecord on the current line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @returns {boolean}
			 * @restriction only available in dynamic record
			 */
			this.hasCurrentSublistSubrecord = delegate.hasCurrentSublistSubrecord;

			/**
			 * get the subrecord for the associated sublist field on the current line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @returns {Record} [requested subrecord]
			 * @restriction only available in dynamic record
			 */
			this.getCurrentSublistSubrecord = function getCurrentSublistSubrecord()
			{
				var subrecord = delegate.getCurrentSublistSubrecord.apply(delegate, arguments);
				return !subrecord ? null : subrecord.proxy(proxyOptions);
			};

			/**
			 * remove the subrecord for the associated sublist field on the current line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @returns {Record}
			 * @restriction only available in dynamic record
			 */
			this.removeCurrentSublistSubrecord = function removeCurrentSublistSubrecord()
			{
				delegate.removeCurrentSublistSubrecord.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return field object from record's sublist current line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @returns {Field} [requested field]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @restriction only available in dynamic record
			 */
			this.getCurrentSublistField = delegate.getCurrentSublistField;

			/**
			 * set the value for the associated header in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @param {string} options.value - the value to set it to
			 * @param {boolean} [options.ignoreFieldChange=false] Ignore the field change script
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {Record}
			 */
			this.setMatrixHeaderValue = function setMatrixHeaderValue()
			{
				delegate.setMatrixHeaderValue.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * get the value for the associated header in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number|Date|string}
			 */
			this.getMatrixHeaderValue = delegate.getMatrixHeaderValue;

			/**
			 * set the value for the associated field in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.line - the line number for the field
			 * @param {number} options.column - the column number for the field
			 * @param {string} options.value - the value to set it to
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {Record}
			 */
			this.setMatrixSublistValue = function setMatrixSublistValue()
			{
				delegate.setMatrixSublistValue.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * get the value for the associated field in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.line - the line number for the field
			 * @param {number} options.column - the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number|Date|string}
			 */
			this.getMatrixSublistValue = delegate.getMatrixSublistValue;

			/**
			 * set the value for the line currently selected in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @param {string} options.value - the value to set it to
			 * @param {boolean} [options.ignoreFieldChange=false] Ignore the field change script
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @restriction only available in dynamic record
			 * @returns {Record}
			 */
			this.setCurrentMatrixSublistValue = function setCurrentMatrixSublistValue()
			{
				delegate.setCurrentMatrixSublistValue.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * get the value for the line currently selected in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number|Date|string}
			 * @restriction only available in dynamic record
			 */
			this.getCurrentMatrixSublistValue = delegate.getCurrentMatrixSublistValue;

			/**
			 * get the field for the specified header in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {Field} [requested field]
			 */
			this.getMatrixHeaderField = delegate.getMatrixHeaderField;

			/**
			 * get the field for the specified sublist in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @param {number} options.line - the line number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {Field} [requested field]
			 */
			this.getMatrixSublistField = delegate.getMatrixSublistField;

			/**
			 * returns the line number of the first line that contains the specified value in the specified column of the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.value - the column number for the field
			 * @param {number} options.column - the line number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number}
			 */
			this.findMatrixSublistLineWithValue = delegate.findMatrixSublistLineWithValue;

			/**
			 * returns the number of columns for the specified matrix.
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number}
			 */
			this.getMatrixHeaderCount = delegate.getMatrixHeaderCount;

			/**
			 * Notes about the callback passed to on() and off():
			 * This callback type is called `eventCallback` and is displayed as a global symbol.
			 * @callback eventCallback
			 * @param {Object} event
			 */

			/**
			 * Start listening to events
			 * @param {Object} options
			 * @param {string[]} options.types [required]
			 * @param {eventCallback} options.listener [required]
			 * @returns {Record} same record
			 */
			this.on = function on()
			{
				delegate.on.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * Stop listening to events
			 * @param {Object} options
			 * @param {string[]} options.types [required]
			 * @param {eventCallback} options.listener [required]
			 * @returns {Record} same record
			 */
			this.off = function off()
			{
				delegate.off.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * Call restricted method.
			 * @param {Object} options
			 * @param {Object} options.token  token required for access to restricted methods
			 * @param {string} options.methodName  name of the method to invoke
			 * @param {Array} options.args  (optional) arguments to pass to the method
			 */
			Object.defineProperty(this, 'callRestrictedMethod', {
				get: function ()
				{
					return delegate.callRestrictedMethod;
				}
			});

			/* This is added server-side only. It comes from server implementation of N/record/recordService */
			if (delegate._addToTemplateRenderer)
				this._addToTemplateRenderer = delegate._addToTemplateRenderer;

			/* If we are being asked to create a proxy wrapper for the current record, add/remove these methods. */
			if (isCurrentRecord)
			{
				/* Strip out and do not expose these methods on the wrapper when the underlying implementation lacks them (DomCurrentRecord). */
				if (delegate.toString() === constants.RECORD_UNDERLYING_IMPL_NAME.DOM_CURRENT_RECORD)
				{
					delete(this.save);
					delete(this.toJSON);
					delete(this.removeField);
					delete(this.getFields);
					delete(this.getSublists);
					delete(this.getSublistFields);
					delete(this.getCurrentSublistField);
					delete(this.on);
					delete(this.off);
					delete(this._addToTemplateRenderer);
				}
			}

			/* If we are being asked to create a proxy wrapper for interactive mode, add the interactive-only API's. */
			if (isInteractive)
			{
				/* Nothing shoukd ever try to wrap the DOM current record as interactive, as the underlying support isn't there. */
				if (delegate.toString() === constants.RECORD_UNDERLYING_IMPL_NAME.DOM_CURRENT_RECORD)
					utilityFunctions.throwSuiteScriptError(error.Type.YOU_HAVE_ATTEMPTED_AN_UNSUPPORTED_ACTION);

				/**
				 * return true if record is being seen in interactive mode.
				 * @name Record#isInteractive
				 * @type boolean
				 * @readonly
				 * @throws READ_ONLY when setting the property is attempted
				 */
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'isInteractive', function () { return true; });

				/**
				 * copy the current line of the sublist to the new line
				 * @param {Object} options
				 * @param {string} options.sublistId
				 * @returns {Record}
				 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing
				 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId is invalid or not editable
				 */
				this.copyLine = function copyLine()
				{
					delegate.copyLine.apply(delegate, arguments);
					return delegate.proxy(proxyOptions);
				};

				/**
				 * get query url and parameters
				 * @name Record#query
				 * @type Object
				 * @readonly
				 * @throws READ_ONLY when setting the property is attempted
				 */
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'query', function getQuery() { return delegate.query; });

				/**
				 * Save record updates to the system and return object with additional information about the saved record.
				 * @governance 20 units for transactions, 4 for custom records, 10 for all other records
				 *
				 * @param {Object} options
				 * @param {boolean} [options.enableSourcing=false] enable sourcing during record update
				 * @param {boolean} [options.ignoreMandatoryFields=false] ignore mandatory field during record submission
				 * @returns {Object} contains id of submitted record
				 */
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'saveAndFetch', function getFunc_saveAndFetch() { return delegate.saveAndFetch; });

/*deleteme*/	this.getLine = delegate.getLine;
/*deleteme*/
/*deleteme*/ 	this.getLineIterator = delegate.getLineIterator;

				//
				// !!@TODO - write properly formed JSDoc here for this new MLB API
				//
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'getLines', function getFunc_getLines() { return delegate.getLines; });

				//
				// !!@TODO - write properly formed JSDoc here for this new MLB API
				//
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'getCommittedLine', function getFunc_getCommittedLine() { return delegate.getCommittedLine; });

				//
				// !!@TODO - write properly formed JSDoc here for this new MLB API
				//
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'getPendingLine', function getFunc_getPendingLine() { return delegate.getPendingLine; });

				//
				// !!@TODO - write properly formed JSDoc here for this new MLB API
				//
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'getCommittedLinesIterator', function getFunc_getCommittedLinesIterator() { return delegate.getCommittedLinesIterator; });

				//
				// !!@TODO - write properly formed JSDoc here for this new MLB API
				//
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'getPendingLinesIterator', function getFunc_getPendingLinesIterator() { return delegate.getPendingLinesIterator; });

				//
				// !!@TODO - write properly formed JSDoc here for this new MLB API
				//
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'addLine', function getFunc_addLine() { return delegate.addLine; });

				/**
				 * same as commitLine, but returns a Promise
				 * @param {Object} options
				 * @param {string} options.sublistId
				 * @returns {Object} a promise with the record object
				 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
				 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id
				 * @restriction only available in dynamic record
				 */
				this.commitLine.promise = function commitLinePromise()
				{
					return delegate.commitLine.promise(delegate, arguments, proxyOptions);
				};
			}

			return this;
		}

		DynamicRecord.prototype = nsobject.getNewInstance();


		Object.freeze(DynamicRecord);

		return DynamicRecord;
	});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/readOnlySubrecord
 * @suiteScriptVersion 2.x
 */
define(
	'N/record/proxy/readOnlySubrecord',['N/nsobject', 'N/record/recordConstants', 'N/utilityFunctions', 'N/environment'],
	function (nsobject, constants, utilityFunctions, environment)
	{
		/**
		 * Deferred Dynamic Record interface (with the interactive API)
		 * @param {Record} delegate = underlying implementation of record, to be wrapped
		 * @param {boolean} isInteractive = true to create this record proxy wraper with the interactive API
		 * @param {boolean} isCurrentSubrecord = (optional) true if we are proxy-wrapping to create subrecord for a current record object.
		 * @returns {ReadOnlySubrecord} (proxied record.Record)
		 * @constructor
		 * @since 2015.2
		 */
		function ReadOnlySubrecord(delegate, isInteractive, isCurrentSubrecord)
		{
			var proxyOptions = Object.freeze({isInteractive: isInteractive});

			/**
			 * The id of the subrecord (always null for subrecords)
			 * @name Record#id
			 * @type number
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'id', function getId() { return null; });

			/**
			 * The type of the subrecord (always null for subrecords)
			 * @name Record#type
			 * @type string
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'type', function getType() { return null; });

			/**
			 * contains necessary macro information, performs macro operation (specified by getMacro)
			 * and returns result; the Macro.promise returns a Promise
			 * @name Macro
			 * @function
			 * @param {Object} [params]
			 * @returns {Object} [macro result]
			 */

			/**
			 * provides available macros
			 * @returns {Object} a set of macros (@see Macro) defined on the record indexed by macroId
			 */
			this.getMacros = function getMacros()
			{
				return delegate.getMacros();
			};

			/**
			 * provides a macro to execute
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @returns {?Macro} [executor function for macro specified by options, or null if not found]
			 */
			this.getMacro = function getMacro(options)
			{
				return delegate.getMacro(options);
			};

			/**
			 * performs macro operation and returns result
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @param {Object} [options.params] macro arguments
			 * @returns {Object} [macro result, or null]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
			 */
			this.executeMacro = function executeMacro(options)
			{
				return delegate.executeMacro(options, isInteractive);
			};

			/**
			 * same as excuteMacro but returns a Promise
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @param {Object} [options.params] macro arguments
			 * @returns {Object} [macro result, or null]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
			 */
			this.executeMacro.promise = function executeMacroPromise(options)
			{
				return delegate.executeMacro.promise(options, isInteractive);
			};

			/**
			 * return true if record is a dynamic record
			 * @name Record#isDynamic
			 * @type boolean
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'isDynamic', function getIsDynamic() { return delegate.isDynamic; });

			/**
			 * JSON.stringify() implementation.
			 * @returns {Object}
			 */
			this.toJSON = delegate.toJSON;

			/**
			 * Returns the object type name (ReadOnlySubrecord)
			 * @returns {string}
			 */
			this.toString = function () {return constants.SUBRECORD_MODE.READ_ONLY_SUBRECORD;};
			if (isCurrentSubrecord)
				this.toString = function () { return constants.CURRENT_SUBRECORD_MODE.READ_ONLY_CURRENT_SUBRECORD;};

			/**
			 * return array of names of all body fields, including machine header field and matrix header fields
			 * @returns {string[]}
			 */
			this.getFields = delegate.getFields;

			/**
			 * return array of names of all sublists
			 * @returns {string[]}
			 */
			this.getSublists = delegate.getSublists;

			/**
			 * return array of names of all fields in a sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {string[]}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.sublistId is missing or undefined
			 */
			this.getSublistFields = delegate.getSublistFields;

			/**
			 * return value of the field
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {number|Date|string|Array|boolean}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked after using setText
			 */
			this.getValue = delegate.getValue;

			/**
			 * get value of the field in text representation
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked prior using setText
			 */
			this.getText = delegate.getText;

			/**
			 * return field object from record
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Field} [requested field]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 */
			this.getField = delegate.getField;

			/**
			 * return field object from record's sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {boolean} options.line
			 * @returns {Field} [requested field]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if line number is invalid
			 */
			this.getSublistField = delegate.getSublistField;

			/**
			 * return line count of sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {number}
			 */
			this.getLineCount = delegate.getLineCount;

			/**
			 * return the line number for the first occurrence of a field value in a sublist and return -1 if not found
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number|Date|string|Array|boolean} options.value
			 * @returns {number}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing or undefined
			 */
			this.findSublistLineWithValue = delegate.findSublistLineWithValue;

			/**
			 * return value of a sublist field
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {number|Date|string|Array|boolean}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked after using setSublistText
			 */
			this.getSublistValue = delegate.getSublistValue;

			/**
			 * return value of a sublist field in text representation
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked prior using setSublistText
			 */
			this.getSublistText = delegate.getSublistText;

			/* If we are being asked to create a proxy wrapper for interactive mode, add the interactive-only API's. */
			if (isInteractive)
			{
				/**
				 * return true if record is read-only.
				 * @name Record#isReadOnly
				 * @type boolean
				 * @readonly
				 * @throws READ_ONLY when setting the property is attempted
				 */
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'isReadOnly', function () { return true; });

				/**
				 * return true if record is being seen in interactive mode.
				 * @name Record#isInteractive
				 * @type boolean
				 * @readonly
				 * @throws READ_ONLY when setting the property is attempted
				 */
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'isInteractive', function () { return true; });

/*deleteme*/	this.getLine = delegate.getLine;
/*deleteme*/
/*deleteme*/ 	this.getLineIterator = delegate.getLineIterator;

				//
				// !!@TODO - write properly formed JSDoc here for this new MLB API
				//
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'getLines', function getFunc_getLines() { return delegate.getLines; });

				//
				// !!@TODO - write properly formed JSDoc here for this new MLB API
				//
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'getCommittedLine', function getFunc_getCommittedLine() { return delegate.getCommittedLine; });

				//
				// !!@TODO - write properly formed JSDoc here for this new MLB API
				//
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'getCommittedLinesIterator', function getFunc_getCommittedLinesIterator() { return delegate.getCommittedLinesIterator; });
			}

			return this;
		}

		ReadOnlySubrecord.prototype = nsobject.getNewInstance();

		Object.freeze(ReadOnlySubrecord);

		return ReadOnlySubrecord;
	});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/deferredDynamicSubrecord
 * @suiteScriptVersion 2.x
 */
define(
	'N/record/proxy/deferredDynamicSubrecord',['N/nsobject', 'N/record/recordConstants', 'N/utilityFunctions', 'N/environment'],
	function (nsobject, constants, utilityFunctions, environment)
	{
		/**
		 * Deferred Dynamic Record interface (with the interactive API)
		 * @param {Record} delegate = underlying implementation of record, to be wrapped
		 * @param {boolean} isInteractive = true to create this record proxy wraper with the interactive API
		 * @returns {DeferredDynamicSubrecord} (proxied record.Record)
		 * @constructor
		 * @since 2015.2
		 */
		function DeferredDynamicSubrecord(delegate, isInteractive)
		{
			var proxyOptions = Object.freeze({isInteractive: isInteractive});

			/**
			 * The id of the subrecord (always null for subrecords)
			 * @name Record#id
			 * @type number
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'id', function getId() { return null; });

			/**
			 * The type of the subrecord (always null for subrecords)
			 * @name Record#type
			 * @type string
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'type', function getType() { return null; });

			/**
			 * return true if record is a dynamic record
			 * @name Subrecord#isDynamic
			 * @type boolean
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'isDynamic', function getIsDynamic() { return delegate.isDynamic; });

			/**
			 * Object to retrieve all messages stored on the record via the getMessages method
			 * @name MessageService
			 * @class
			 */

			/**
			 * provides record's MessageService object
			 * @returns {MessageService} record's MessageService instance
			 */
			this.getMessageService = delegate.getMessageService;

			/**
			 * JSON.stringify() implementation.
			 * @returns {Object}
			 */
			this.toJSON = delegate.toJSON;

			/**
			 * Returns the object type name (DeferredDynamicSubrecord)
			 * @returns {string}
			 */
			this.toString = function () {return constants.SUBRECORD_MODE.DEFERRED_DYNAMIC_SUBRECORD;};

			/**
			 * remove body field data
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 */
			this.removeField = function removeField()
			{
				delegate.removeField.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return array of names of all body fields, including machine header field and matrix header fields
			 * @returns {Array}
			 */
			this.getFields = delegate.getFields;

			/**
			 * return array of names of all sublists
			 * @returns {Array}
			 */
			this.getSublists = delegate.getSublists;

			/**
			 * return array of names of all fields in a sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {Array}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.sublistId is missing or undefined
			 */
			this.getSublistFields = delegate.getSublistFields;

			/**
			 * return value of the field
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {number|Date|string|Array}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked after using setText
			 */
			this.getValue = delegate.getValue;

			/**
			 * set value of the field
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @param {number|Date|string|Array} options.value
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 */
			this.setValue = function setValue()
			{
				delegate.setValue.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * get value of the field in text representation
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked prior using setText
			 */
			this.getText = delegate.getText;

			/**
			 * set value of the field by text representation
			 *
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @param {string} options.text
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 */
			this.setText = function setText()
			{
				delegate.setText.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return field object from record
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Field} [requested field]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 */
			this.getField = delegate.getField;

			/**
			 * return field object from record's sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {boolean} options.line
			 * @returns {Field} [requested field]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if line number is invalid
			 */
			this.getSublistField = delegate.getSublistField;

			/**
			 * return line count of sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {number}
			 */
			this.getLineCount = delegate.getLineCount;

			/**
			 * insert a sublist line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @param {boolean} [ignoreRecalc=false] options.ignoreRecalc ignore recalc scripting
			 * @returns {DeferredDynamicSubrecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId or line index is invalid or if machine is not editable
			 */
			this.insertLine = function insertLine()
			{
				var line = delegate.insertLine.apply(delegate, arguments);
/*deleteme*/	if (isInteractive)
/*deleteme*/		return line;
/*deleteme*/	else
					return delegate.proxy(proxyOptions);
			};

			/**
			 * remove a sublist line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @param {boolean} [ignoreRecalc=false] options.ignoreRecalc ignore recalc scripting
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId or line index is invalid or if machine is not editable
			 */
			this.removeLine = function removeLine()
			{
				delegate.removeLine.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return the line number for the first occurrence of a field value in a sublist and return -1 if not found
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number|Date|string|Array} options.value
			 * @returns {number}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing or undefined
			 */
			this.findSublistLineWithValue = delegate.findSublistLineWithValue;

			/**
			 * return value of a sublist field
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {number|Date|string|Array}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked after using setSublistText
			 */
			this.getSublistValue = delegate.getSublistValue;

			/**
			 * set the value of a sublist field
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @param {number|Date|string|Array} options.value
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 */
			this.setSublistValue = function setSublistValue()
			{
				delegate.setSublistValue.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return value of a sublist field in text representation
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked prior using setSublistText
			 */
			this.getSublistText = delegate.getSublistText;

			/**
			 * set the value of a sublist field in text representation
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @param {string} options.text
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 */
			this.setSublistText = function setSublistText()
			{
				delegate.setSublistText.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/* If we are being asked to create a proxy wrapper for interactive mode, add the interactive-only API's. */
			if (isInteractive)
			{
				/**
				 * return true if record is being seen in interactive mode.
				 * @name Record#isInteractive
				 * @type boolean
				 * @readonly
				 * @throws READ_ONLY when setting the property is attempted
				 */
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'isInteractive', function () { return true; });

/*deleteme*/	this.getLine = delegate.getLine;
/*deleteme*/
/*deleteme*/ 	this.getLineIterator = delegate.getLineIterator;

				//
				// !!@TODO - write properly formed JSDoc here for this new MLB API
				//
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'getLines', function getFunc_getLines() { return delegate.getLines; });

				//
				// !!@TODO - write properly formed JSDoc here for this new MLB API
				//
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'getCommittedLine', function getFunc_getCommittedLine() { return delegate.getCommittedLine; });

				//
				// !!@TODO - write properly formed JSDoc here for this new MLB API
				//
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'getCommittedLinesIterator', function getFunc_getCommittedLinesIterator() { return delegate.getCommittedLinesIterator; });
			}

			return this;
		}

		DeferredDynamicSubrecord.prototype = nsobject.getNewInstance();

		Object.freeze(DeferredDynamicSubrecord);

		return DeferredDynamicSubrecord;
	});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/dynamicSubrecord
 * @suiteScriptVersion 2.x
 */
define('N/record/proxy/dynamicSubrecord',['N/nsobject', 'N/record/recordConstants', 'N/utilityFunctions', 'N/error', 'N/environment'],
	function (nsobject, constants, utilityFunctions, error, environment)
	{
		/**
		 * Dynamic Record interface (with the interactive API)
		 * @param {Record} (recordDefinition.Record)
		 * @returns {Record} (proxied record.Record)
		 * @param {boolean} isInteractive = true to create this record proxy wraper with the interactive API
		 * @constructor
		 * @since 2015.2
		 */
		function DynamicSubrecord(delegate, isInteractive)
		{
			var proxyOptions = Object.freeze({isInteractive: isInteractive});

			/* This check is needed for every API, but only for dynamic subrecord. */
			function validateIfSubrecordIsDereferencedFromParent()
			{
				if (delegate.isDereferencedFromParent && delegate.isDereferencedFromParent())
					utilityFunctions.throwSuiteScriptError(error.Type.OPERATION_IS_NOT_ALLOWED);
			}

			/**
			 * The id of the subrecord (always null for subrecords)
			 * @name Record#id
			 * @type number
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'id', function getId() { return null; });

			/**
			 * The type of the subrecord (always null for subrecords)
			 * @name Record#type
			 * @type string
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'type', function getType() { return null; });

			/**
			 * Object to retrieve all messages stored on the record via the getMessages method
			 * @name MessageService
			 * @class
			 */

			/**
			 * provides record's MessageService object
			 * @returns {MessageService} record's MessageService instance
			 */
			this.getMessageService = delegate.getMessageService;

			/**
			 * contains necessary macro information, performs macro operation (specified by getMacro)
			 * and returns result; the Macro.promise returns a Promise
			 * @name Macro
			 * @function
			 * @param {Object} [params]
			 * @returns {Object} [macro result]
			 */

			/**
			 * provides available macros
			 * @returns {Object} a set of macros (@see Macro) defined on the record indexed by macroId
			 */
			this.getMacros = function getMacros()
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.getMacros();
			};

			/**
			 * provides a macro to execute
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @returns {?Macro} [executor function for macro specified by options, or null if not found]
			 */
			this.getMacro = function getMacro(options)
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.getMacro(options);
			};

			/**
			 * performs macro operation and returns result
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @param {Object} [options.params] macro arguments
			 * @returns {Object} [macro result or null]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
			 */
			this.executeMacro = function executeMacro(options)
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.executeMacro(options, isInteractive);
			};

			/**
			 * same as excuteMacro but returns a Promise
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @param {Object} [options.params] macro arguments
			 * @returns {Object} [macro result or null]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
			 */
			this.executeMacro.promise = function executeMacroPromise(options)
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.executeMacro.promise(options, isInteractive);
			};

			/**
			 * return true if record is a dynamic record
			 * @name Subrecord#isDynamic
			 * @type boolean
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'isDynamic', function getIsDynamic() { return delegate.isDynamic; });

			/**
			 * JSON.stringify() implementation.
			 * @returns {Object}
			 */
			this.toJSON = delegate.toJSON;

			/**
			 * Returns the object type name (record.DynamicSubrecord)
			 * @returns {string}
			 */
			this.toString = function(){ return constants.SUBRECORD_MODE.DYNAMIC_SUBRECORD;};

			/**
			 * remove body field data
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 */
			this.removeField = function removeField()
			{
				validateIfSubrecordIsDereferencedFromParent();
				delegate.removeField.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return array of names of all body fields, including machine header field and matrix header fields
			 * @returns {Array}
			 */
			this.getFields = function getFields()
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.getFields();
			};

			/**
			 * returns the specified sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {Sublist} [sublist, or null if sublist not found]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 */
			this.getSublist = function getSublist(options)
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.getSublist(options);
			};

			/**
			 * return array of names of all sublists
			 * @returns {Array}
			 */
			this.getSublists = function getSublists()
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.getSublists();
			};

			/**
			 * return array of names of all fields in a sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {Array}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.sublistId is missing or undefined
			 */
			this.getSublistFields = function getSublistFields(options)
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.getSublistFields(options);
			};

			/**
			 * return value of the field
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {number|Date|string|Array}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 */
			this.getValue = function getValue(options)
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.getValue(options);
			};

			/**
			 * set value of the field
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @param {number|Date|string|Array} options.value
			 * @param {boolean} [options.ignoreFieldChange=false] ignore field change script and slaving event if set to true
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 */
			this.setValue = function setValue()
			{
				validateIfSubrecordIsDereferencedFromParent();
				delegate.setValue.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * get value of the field in text representation
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 */
			this.getText = function getText(options)
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.getText(options);
			};

			/**
			 * set value of the field by text representation
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @param {string} options.text
			 * @param {boolean} [options.ignoreFieldChange=false] ignore field change script and slaving event if set to true
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 */
			this.setText = function setText()
			{
				validateIfSubrecordIsDereferencedFromParent();
				delegate.setText.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return field object from record
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Field} [field, or null if not found]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 */
			this.getField = function getField(options)
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.getField(options);
			};

			/**
			 * return field object from record's sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {boolean} options.line
			 * @returns {Field} [field, or null if not found]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if line number is invalid
			 */
			this.getSublistField = function getSublistField(options, fieldId, line)
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.getSublistField(options, fieldId, line);
			};

			/**
			 * return line count of sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {number}
			 */
			this.getLineCount = function getLineCount(options)
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.getLineCount(options);
			};

			/**
			 * insert a sublist line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @param {boolean} [ignoreRecalc=false] options.ignoreRecalc ignore recalc scripting
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId or line index is invalid or if machine is not editable
			 */
			this.insertLine = function insertLine()
			{
				validateIfSubrecordIsDereferencedFromParent();
				var line = delegate.insertLine.apply(delegate, arguments);
/*deleteme*/	if (isInteractive)
/*deleteme*/		return line;
/*deleteme*/	else
					return delegate.proxy(proxyOptions);
			};

			/**
			 * remove a sublist line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @param {boolean} [ignoreRecalc=false] options.ignoreRecalc ignore recalc scripting
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId or line index is invalid or if machine is not editable
			 */
			this.removeLine = function removeLine()
			{
				validateIfSubrecordIsDereferencedFromParent();
				delegate.removeLine.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return the line number for the first occurrence of a field value in a sublist and return -1 if not found
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number|Date|string|Array} options.value
			 * @returns {number}
			 */
			this.findSublistLineWithValue = function findSublistLineWithValue(options, fieldId, value)
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.findSublistLineWithValue(options, fieldId, value);
			};

			/**
			 * cancel the current selected line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId is invalid or if machine is not editable
			 */
			this.cancelLine = function cancelLine()
			{
				validateIfSubrecordIsDereferencedFromParent();
				delegate.cancelLine.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * commit the current selected line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id
			 */
			this.commitLine = function commitLine(options)
			{
				validateIfSubrecordIsDereferencedFromParent();
				delegate.commitLine(options);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * select line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or line is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id or line index
			 */
			this.selectLine = function selectLine(options, line)
			{
				validateIfSubrecordIsDereferencedFromParent();
				var line = delegate.selectLine(options, line);
/*deleteme*/	if (isInteractive)
/*deleteme*/		return line;
/*deleteme*/	else
					return delegate.proxy(proxyOptions);
			};

			/**
			 * select a new line at the end of sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id or sublist is not editable
			 */
			this.selectNewLine = function selectNewLine()
			{
				validateIfSubrecordIsDereferencedFromParent();
				var line = delegate.selectNewLine.apply(delegate, arguments);
/*deleteme*/	if (isInteractive)
/*deleteme*/		return line;
/*deleteme*/	else
					return delegate.proxy(proxyOptions);
			};

			/**
			 * return value of a sublist field on the current selected sublist line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @returns {number|Date|string|Array}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id or field id
			 */
			this.getCurrentSublistValue = function getCurrentSublistValue(options, fieldId)
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.getCurrentSublistValue(options, fieldId);
			};

			/**
			 * return value of a sublist field
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {number|Date|string|Array}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id or line number
			 */
			this.getSublistValue = function getSublistValue(options, fieldId, line)
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.getSublistValue(options, fieldId, line);
			};

			/**
			 * set the value for field in the current selected line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number|Date|string|Array} options.value
			 * @param {boolean} [options.ignoreFieldChange=false] ignore field change script and slaving event if set to true
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} A_SCRIPT_IS_ATTEMPTING_TO_EDIT_THE_1_SUBLIST_THIS_SUBLIST_IS_CURRENTLY_IN_READONLY_MODE_AND_CANNOT_BE_EDITED_CALL_YOUR_NETSUITE_ADMINISTRATOR_TO_DISABLE_THIS_SCRIPT_IF_YOU_NEED_TO_SUBMIT_THIS_RECORD if user tries to edit readonly sublist field
			 */
			this.setCurrentSublistValue = function setCurrentSublistValue()
			{
				validateIfSubrecordIsDereferencedFromParent();
				delegate.setCurrentSublistValue.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return the value for field in the current selected line by text representation
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @returns {number|Date|string|Array}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id or field id
			 */
			this.getCurrentSublistText = function getCurrentSublistText(options, fieldId)
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.getCurrentSublistText(options, fieldId);
			};

			/**
			 * return value of a sublist field in text representation?
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {string}?
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id or line number
			 */
			this.getSublistText = function getSublistText(options, fieldId, line)
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.getSublistText(options, fieldId, line);
			};

			/**
			 * set the value for field in the current selected line by text representation
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number|Date|string|Array} options.text
			 * @param {boolean} [options.ignoreFieldChange=false] ignore field change script and slaving event if set to true
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} A_SCRIPT_IS_ATTEMPTING_TO_EDIT_THE_1_SUBLIST_THIS_SUBLIST_IS_CURRENTLY_IN_READONLY_MODE_AND_CANNOT_BE_EDITED_CALL_YOUR_NETSUITE_ADMINISTRATOR_TO_DISABLE_THIS_SCRIPT_IF_YOU_NEED_TO_SUBMIT_THIS_RECORD if user tries to edit readonly sublist field
			 */
			this.setCurrentSublistText = function setCurrentSublistText()
			{
				validateIfSubrecordIsDereferencedFromParent();
				delegate.setCurrentSublistText.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return the line number of current selected line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {number}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 */
			this.getCurrentSublistIndex = function getCurrentSublistIndex(options)
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.getCurrentSublistIndex(options);
			};

			/**
			 * validate the subrecord
			 * @returns {Record}
			 */
			this.validate = function validate()
			{
				validateIfSubrecordIsDereferencedFromParent();
				delegate.validate.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * copy the subrecord inorder to perform cancellable actions
			 * @returns {Record}
			 */
			this.clone = function clone()
			{
				validateIfSubrecordIsDereferencedFromParent();
				var clone = delegate.clone.apply(clone, arguments);
				return clone.proxy(proxyOptions);
			};

			/**
			 * merge changes into original subrecord
			 * @returns {Record}
			 */
			this.merge = function merge()
			{
				validateIfSubrecordIsDereferencedFromParent();
				delegate.merge.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * This callback type is called `eventCallback` and is displayed as a global symbol.
			 * @callback eventCallback
			 * @param {Object} event
			 */

			/**
			 * Start listening to events
			 * @param {Object} options
			 * @param {string[]} options.types [required]
			 * @param {eventCallback} options.listener [required]
			 * @returns {Record} record
			 */
			this.on = function on()
			{
				delegate.on.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * Stop listening to events
			 * @param {Object} options
			 * @param {string[]} options.types [required]
			 * @param {eventCallback} options.listener [required]
			 * @returns {Record} record
			 */
			this.off = function off()
			{
				delegate.off.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/* If we are being asked to create a proxy wrapper for interactive mode, add the interactive-only API's. */
			if (isInteractive)
			{
				/**
				 * return true if record is being seen in interactive mode.
				 * @name Record#isInteractive
				 * @type boolean
				 * @readonly
				 * @throws READ_ONLY when setting the property is attempted
				 */
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'isInteractive', function () { return true; });

/*deleteme*/ 	this.getLine = function getLine()
/*deleteme*/	{
/*deleteme*/		validateIfSubrecordIsDereferencedFromParent();
/*deleteme*/		return delegate.getLine.apply(delegate, arguments);
/*deleteme*/	};
/*deleteme*/
/*deleteme*/  	this.getLineIterator = delegate.getLineIterator;

				//
				// !!@TODO - write properly formed JSDoc here for this new MLB API
				//
				function getLines()
				{
					validateIfSubrecordIsDereferencedFromParent();
					return delegate.getLines.apply(delegate, arguments);
				}

				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'getLines', function getFunc_getLines() { return getLines; });

				//
				// !!@TODO - write properly formed JSDoc here for this new MLB API
				//
				function getCommittedLine()
				{
					validateIfSubrecordIsDereferencedFromParent();
					return delegate.getCommittedLine.apply(delegate, arguments);
				}

				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'getCommittedLine', function getFunc_getCommittedLine() { return getCommittedLine; });

				//
				// !!@TODO - write properly formed JSDoc here for this new MLB API
				//
				function getPendingLine()
				{
					validateIfSubrecordIsDereferencedFromParent();
					return delegate.getPendingLine.apply(delegate, arguments);
				}

				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'getPendingLine', function getFunc_getPendingLine() { return getPendingLine; });

				//
				// !!@TODO - write properly formed JSDoc here for this new MLB API
				//
				function getCommittedLinesIterator()
				{
					validateIfSubrecordIsDereferencedFromParent();
					return delegate.getCommittedLinesIterator.apply(delegate, arguments);
				}

				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'getCommittedLinesIterator', function getFunc_getCommittedLinesIterator() { return getCommittedLinesIterator; });

				//
				// !!@TODO - write properly formed JSDoc here for this new MLB API
				//
				function getPendingLinesIterator()
				{
					validateIfSubrecordIsDereferencedFromParent();
					return delegate.getPendingLinesIterator.apply(delegate, arguments);
				}

				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'getPendingLinesIterator', function getFunc_getPendingLinesIterator() { return getPendingLinesIterator; });

				//
				// !!@TODO - write properly formed JSDoc here for this new MLB API
				//
				function addLine()
				{
					validateIfSubrecordIsDereferencedFromParent();
					return delegate.addLine.apply(delegate, arguments);
				}

				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'addLine', function getFunc_addLine() { return addLine; });

				/**
				 * same as commitLine, but returns a Promise
				 * @param {Object} options
				 * @param {string} options.sublistId
				 * @returns {Object} a promise with the record object
				 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
				 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id
				 */
				this.commitLine.promise = function commitLine()
				{
					validateIfSubrecordIsDereferencedFromParent();
					return delegate.commitLine.promise(delegate, arguments, proxyOptions);
				};
			}

			return this;
		}

		DynamicSubrecord.prototype = nsobject.getNewInstance();

		Object.freeze(DynamicSubrecord);

		return DynamicSubrecord;
	});

/**
 * SuiteScript record proxy module.
 *
 * Creates a wrapper around the record that selectively exposes the record interface.
 *
 * @private
 * @module N/record/recordProxy
 * @NApiVersion 2.x
 */
define(
	'N/record/recordProxy',['N/utilityFunctions', 'N/record/recordConstants', 'N/error',
		'N/record/proxy/readOnlyRecord', 'N/record/proxy/deferredDynamicRecord', 'N/record/proxy/dynamicRecord',
		'N/record/proxy/readOnlySubrecord', 'N/record/proxy/deferredDynamicSubrecord', 'N/record/proxy/dynamicSubrecord', 'N/environment'],
	function (utilityFunctions, constants, error,
		ReadOnlyRecord, DeferredDynamicRecord, DynamicRecord,
		ReadOnlySubrecord, DeferredDynamicSubrecord, DynamicSubrecord, environment)
	{
		/**
		 * returns a record  proxy based on the input configuration
		 *
		 * @param options
		 * @param {Record} options.delegate = the actual underlying record instance (from recordDefinition)
		 * @param {boolean} options.isReadOnly = true if the record instance is read only instance
		 * @param {boolean} options.isSubrecord = true if the record instance is a subrecord
		 * @param {boolean} options.isDynamic = true if the record instance is a dynamic record
		 * @param {boolean} options.isInteractive = true if the record instance is an interactive record
		 * @param {boolean} isCurrentRecord = (optional) true if we are proxy-wrapping to create a current record object.
		 * @return {ReadOnlyRecord|DeferredDynamicRecord|DynamicRecord|ReadOnlySubrecord|DeferredDynamicSubrecord|DynamicSubrecord} (proxied
		 *     record.Record)
		 */
		function wrap(options, isCurrentRecord)
		{
			var wrappedRecord;
			var record = options.delegate;
			var isReadOnly = !!options.isReadOnly;
			var isSubrecord = !!options.isSubrecord;
			var isDynamic = !!options.isDynamic;
			var isInteractive = !!options.isInteractive;

			if (isReadOnly)
			{
				wrappedRecord = isSubrecord ? new ReadOnlySubrecord(record, isInteractive, isCurrentRecord) : new ReadOnlyRecord(record, isInteractive, isCurrentRecord);
			}
			else if (!isDynamic)
			{
				wrappedRecord = isSubrecord ? new DeferredDynamicSubrecord(record, isInteractive, isCurrentRecord) : new DeferredDynamicRecord(record, isInteractive, isCurrentRecord);
			}
			else if (isDynamic)
			{
				wrappedRecord = isSubrecord ? new DynamicSubrecord(record, isInteractive, isCurrentRecord) : new DynamicRecord(record, isInteractive, isCurrentRecord);
			}
			else
			{
				utilityFunctions.throwSuiteScriptError(error.Type.YOU_HAVE_ATTEMPTED_AN_UNSUPPORTED_ACTION);
			}

			Object.freeze(wrappedRecord);

			return wrappedRecord;
		}

		/**
		 * These are the signatures of other underlying record implementations (other than recordDefinition)
		 * that can be wrapped.
		 * @param kind
		 * @returns {boolean}
		 */
		function isKindToAlwaysWrap(kind)
		{
			return constants.ALL_RECORD_UNDERLYING_IMPL_NAMES.indexOf(kind) >= 0;
		}

		/**
		 * These are other known names of a the proxy of an already wrapped record. Don't try to re-wrap tham.
		 * @param kind
		 * @returns {boolean}
		 */
		function isKindToNeverWrap(kind)
		{
			return constants.ALL_RECORD_PROXY_NAMES.indexOf(kind) >= 0;
		}

		/*
		 * We do this to be double-proxy resilient. Check if the the record is already a correct record proxy.
		 * If so, caller should not try to proxy it.
		 */
		function alreadyIsProxy(options)
		{
			var record = options.delegate;
			var kind = record.toString();

			/* For better performance, we do these checks as early as possible when proxying is or isn't needed. */
			if (isKindToAlwaysWrap(kind))
			{
				return false;
			}
			if (isKindToNeverWrap(kind))
			{
				return true;
			}

			/* If we get here, we assume the object is a wrappable pseudo-record, probably created by a unit test.
			 * We will let the caller try to wrap it.*/
			return false;
		}

		function supportsInteractiveApi(options)
		{
			if (!!options.isClientRecord)
			{
				if (!!options.isCurrentRecord)
				{
					return environment.isNewUI();
				}
				else
				{
					return environment.isDebug();
				}
			}
			else
			{
				return false;
			}
		}

		/**
		 * Method used to get a user-facing, sealed proxy of the recordDefinition.
		 *
		 * @param {boolean} proxyOptions.isInteractive = true to get back a record object whose record API has the new, interactive
		 *     API.
		 */
		function proxy(proxyDelegate, recordOptions, proxyOptions)
		{
			var isInteractive;
			if (supportsInteractiveApi(recordOptions))
			{
				// get isInteractive from the calling context if interactive mode is supported
				if (proxyOptions && proxyOptions.hasOwnProperty('isInteractive'))
				{
					isInteractive = proxyOptions.isInteractive;
				}
				else
				{
					utilityFunctions.throwSuiteScriptError(error.Type.MISSING_REQD_ARGUMENT, 'recordProxy#proxy', 'proxyOptions.isInteractive');
				}
			}
			else
			{
				isInteractive = false;
			}

			var recordProxyCreationOptions = {
				delegate: proxyDelegate,
				isClientRecord: recordOptions.isClientRecord,
				isSubrecord: recordOptions.isSubrecord,
				isReadOnly: recordOptions.isReadOnly,
				isDynamic: recordOptions.isDynamic,
				isInteractive: isInteractive,
				isCurrentRecord: recordOptions.isCurrentRecord
			};
			return recordProxyCache(recordProxyCreationOptions);
		}

		/**
		 * Cache of all unique proxy instances for each record delegate
		 * @return {innerGetCachedRecordInterfaceProxy}
		 */
		var recordProxyCache = (function RecordInterfaceProxyCacheClass()
		{
			var allProxyCaches = [];

			/**
			 * Provides proxy instance from a proxy cache for a given record delegate
			 * @param delegate {Record} record delegate for which a proxy should be retrieved
			 * @returns {Object} proxy cache for a given reord delegate
			 */
			function getProxyCache(delegate)
			{
				// get proxy cache for the delegate
				var cachedEntry = allProxyCaches.filter(function (entry)
				{
					return entry.record === delegate;
				})[0];
				// or create a new cache for it
				if (!cachedEntry)
				{
					cachedEntry = {record: delegate, proxyCache: []};
					allProxyCaches.push(cachedEntry);
				}
				// return a cached proxy instance if present in delegate's cache
				return cachedEntry.proxyCache;
			}

			/**
			 * @param options = Record API expression options
			 * @param {Record} options.delegate underlying record implementation
			 * @param {boolean} options.isSubrecord = true if the record instance is a subrecord
			 * @param {boolean} options.isReadOnly = true if the record instance is read only instance
			 * @param {boolean} options.isDynamic = true if the record instance is a dynamic record
			 * @param {boolean} options.isInteractive = true if the record API to be used for dynamic mode is the new, interactive
			 *     API
			 * @param {boolean} options.isCurrentRecord = true if the record is the current record of the page
			 */
			function innerGetCachedRecordInterfaceProxy(options)
			{
				var isReadOnly = options.isReadOnly || false;
				var isSubrecord = options.isSubrecord || false;
				var isDynamic = options.isDynamic || false;
				var isInteractive = options.isInteractive || false;
				var isCurrentRecord = options.isCurrentRecord || false;
				var unproxiedRecord = options.delegate;

				var wrapOptions = {
					delegate: unproxiedRecord,
					isReadOnly: isReadOnly,
					isSubrecord: isSubrecord,
					isDynamic: isDynamic,
					isInteractive: isInteractive
				};

				if (alreadyIsProxy(wrapOptions))
				{
					return unproxiedRecord;
				}

				var cacheKey = isReadOnly + ':'
					+ isSubrecord + ':'
					+ isDynamic + ':'
					+ isInteractive + ':'
					+ isCurrentRecord;

				var proxyCache = getProxyCache(unproxiedRecord);
				var wrappedRecord = proxyCache[cacheKey];
				if (!wrappedRecord)
				{
					wrappedRecord = wrap(wrapOptions, isCurrentRecord);
					proxyCache[cacheKey] = wrappedRecord;
				}
				return wrappedRecord;
			}

			return innerGetCachedRecordInterfaceProxy;
		})();

		return Object.freeze({
			proxy: proxy,
			supportsInteractiveApi: supportsInteractiveApi
		});
	}
);

/**
 * SuiteScript RelatedRecord module
 * @private Ignore for JSDoc stub generation
 * @module N/record/relatedRecord
 * @NApiVersion 2.x
 *
 */
define('N/record/relatedRecord',['N/restricted/remoteApiBridge', 'N/restricted/invoker','N/error', 'N/nsobject', 'N/util/slaving', 'N/pagination/paginationObject', 'N/utilityFunctions', 'N/format'],
       function (remoteApi, invoker, error, nsobject, slaving, paginationObject, utilityFunctions, format){

    var SORTING_DIRECTION = ["ASC", "DESC"];
    var freezeObjectIfPossible = utilityFunctions.freezeObjectIfPossible;

    var LINK_TYPE = Object.freeze({
        NONE: "NONE",
        REGULAR: "REGULAR",
        POPUP: "POPUP"
    });

    /**
     * Data model for search result machine
     *
     * @protected
     * @param {Object} options
     * @return {RelatedRecord}
     * @constructor
     */
    function RelatedRecord(options)
    {
        var that = this,
                id = options.id,
                notify = options.notify,
                sourceRecordType = options.owningRecordType,
                queryField = options.queryField,
                formUrl = options.queryUrl,
                currentView,
                customViews,
                exposedUtil = { notify: notify, getQueryRequest: getQueryRequest };

        var searchDefinition;

        function initializeRelatedRecord(config)
        {
            var views = config.customViews;
            var _customViews = [];
            views.forEach(function(v){
                if(v.isSelected)
                    currentView = v.id;

                _customViews.push(new CustomView(v));
            });
            utilityFunctions.checkArgs([currentView], ['currentView'], 'relatedRecord.initialize');

            customViews = freezeObjectIfPossible(_customViews);
            initializeSearchDefinition(config)
        }
        initializeRelatedRecord(options);

        function validateView(viewId)
        {
            var found = null;
            customViews.forEach(function(v){
                if(v.id === String(viewId))
                    found = v;
            });

            if(!found)
                utilityFunctions.throwSuiteScriptError(error.Type.INVALID_CUSTOM_VIEW_VALUE, viewId);
            return found;
        }

        function setView(view)
        {
            var oldView = currentView;
            var result = validateView(view);
            currentView = String(view);
            postViewChanged(view, oldView);
            return result;
        }

        function postViewChanged(view, oldView)
        {
            var request = getQueryRequest(queryField);
            var relatedRecordObj = invoker(remoteApi, "getRelatedRecord", [sourceRecordType, request.url, request.payload], null /* callback */, false /* parseResult */);
            relatedRecordObj.currentView = view;
            initializeSearchDefinition(relatedRecordObj);
        }

        function getQueryRequest(queryField)
        {
            var request = slaving.cleanupQueryURL(formUrl);
            request.payload.q = queryField;
            request.payload.si = "0"; //default loading first page
            request.payload.machine = id;
            request.payload.si_searchid = currentView;

            return request;
        }

        function initializeSearchDefinition(relatedRecordObj)
        {
            relatedRecordObj.util = exposedUtil;
            searchDefinition = new RelatedRecordSearchDefinition(relatedRecordObj);
        }

        function toJSON()
        {
            return {
                id: that.id,
                currentView: that.currentView,
                customViews: that.customViews
            }
        }

        function toString()
        {
            return "record.RelatedRecord"
        }

        /**
         * Search definition of the related record
         * @name RelatedRecord#searchDefinition
         * @type SearchDefinition
         * @readonly
         */
        Object.defineProperty(this, 'searchDefinition', {
            get: function() {
                return searchDefinition
            },
            set: function() {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'searchDefinition');
            },
            enumerable: true,
            configurable: false
        });
        /**
         * The list of available custom views
         * @name RelatedRecord#customViews
         * @type CustomView[]
         * @readonly
         */
        Object.defineProperty(this, 'customViews', {
            get: function() {
                return customViews;
            },
            set: function() {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'customViews');
            },
            enumerable: true,
            configurable: false
        });
        /**
         * Return the currently selected custom view (as CustomView object)
         * @name RelatedRecord#currentView
         * @type CustomView
         * @readonly
         */
        Object.defineProperty(this, 'currentView', {
            get: function() {
                return validateView(currentView)
            },
            set: function() {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'currentView');
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Select custom view with the given ID
         * @param {Object} options  the options object
         * @param {string} options.id  ID of the view
         * @returns {CustomView} object corresponding to the selected view
         * @throws {SuiteScriptError} INVALID_CUSTOM_VIEW_VALUE if input value is invalid
         */
        this.selectView = function selectView(options)
        {
            var id;
            if(options !== undefined && options !== null)
            {
                id = options.id;
            }
            utilityFunctions.checkArgs([id], ['id'], 'RelatedRecord.selectView');
            
            return setView(id);
        };
        /**
         * JSON.stringify() implementation
         * @returns {Object}
         */
        this.toJSON = toJSON;
        /**
         * Returns the object type name
         * @returns {string}
         */
        this.toString = toString;
    }
    RelatedRecord.prototype = nsobject.getNewInstance();
    freezeObjectIfPossible(RelatedRecord);


    function ReadonlyRelatedRecordSearchDefinition(searchDefinition)
    {
        Object.defineProperty(this, 'type', {
            value : searchDefinition.type,
            enumerable: true,
            configurable: false,
            writable: false
        });
        Object.defineProperty(this, 'columns', {
            value : searchDefinition.columns,
            enumerable: true,
            configurable: false,
            writable: false
        });
        Object.defineProperty(this, 'filters', {
            value : searchDefinition.filters,
            enumerable: true,
            configurable: false,
            writable: false
        });
        Object.defineProperty(this, 'sortBy', {
            value : searchDefinition.sortBy,
            enumerable: true,
            configurable: false,
            writable: false
        });
        this.getFilterValue = searchDefinition.getFilterValue;
        this.toJSON = searchDefinition.toJSON;
        this.toString = function (){ return searchDefinition.toString() + "(readonly)"; }
    }
    ReadonlyRelatedRecordSearchDefinition.prototype = nsobject.getNewInstance();
    freezeObjectIfPossible(ReadonlyRelatedRecordSearchDefinition);


    function RelatedRecordSearchDefinition(options)
    {
        var that = this,
                notify = options.notify,
                currentView = options.currentView,
                _util = options.util,
                id = options.id,
                queryField = options.queryField,
                sourceRecordType = options.owningRecordType,
                searchType = options.recordType,
                formUrl = options.queryUrl,
                filterFieldMetadata, /* internal map */
                returnFieldMetadata, /* internal map */
                filters,
                columns,
                filterFields,
                sortBy;

        function initializeSearchDefinition(config)
        {
            var rawFilterFields = config.filterFields,
                rawReturnFields = config.fields,
                _returnFieldMetadata = {},
                _columns = [],
                _filterFieldMetadata = {},
                _filterFields = [],
                _sortBy;

            // initialize filters
            filters = {};

            rawReturnFields.forEach(function(field){
                _returnFieldMetadata[field.id] = field;
                var c = new Column(field);
                _columns.push(freezeObjectIfPossible(c));
            });
            rawFilterFields.forEach(function(field){
                _filterFieldMetadata[field.id] = field;
                var f = new FilterField(field);

                _filterFields.push(freezeObjectIfPossible(f));
                setDefaultValue(filters, field);
            });

            if(config.defaultSortCol)
            {
                _sortBy = {};
                _sortBy.columnId = config.defaultSortCol;
                _sortBy.direction = config.defaultSortDir;
            }

            returnFieldMetadata = freezeObjectIfPossible(_returnFieldMetadata);
            columns = freezeObjectIfPossible(_columns);
            sortBy = freezeObjectIfPossible(_sortBy);
            filterFieldMetadata = freezeObjectIfPossible(_filterFieldMetadata);
            filterFields = freezeObjectIfPossible(_filterFields);
        }
        initializeSearchDefinition(options);

        function resetFilters()
        {
            filterFields.forEach(function(fieldObj) {
                setDefaultValue(filters, filterFieldMetadata[fieldObj.id]);
            });
        }

        function setDefaultValue(data, metadata)
        {
            if(metadata.defaultValue)
            {
                if(metadata.type === 'select')
                {
                    if(!!metadata.isMultiSelect)
                        data[metadata.id] = metadata.defaultValue.split(String.fromCharCode(5));
                    else
                        data[metadata.id] = metadata.defaultValue;
                }
                else
                    data[metadata.id] = parseFilterValue(metadata, metadata.defaultValue);
            }
        }

        function runPaged(){
            var pagedDataOptions = doGetPagedData(null);
            var pagedData = new RelatedRecordPagedData(postGetRelatedRecordPagedData(pagedDataOptions));
            return new paginationObject.PagedData(pagedData);
        }

        function runPagedPromise()
        {
            return new Promise(function(resolve, reject){
                function callback(result) {
                    if (result instanceof Error) {
                        reject(result);
                    }
                    else {

                        var pagedData = new RelatedRecordPagedData(postGetRelatedRecordPagedData(result));
                        resolve(new paginationObject.PagedData(pagedData));
                    }
                }

                try {
                    doGetPagedData(callback);
                }
                catch(e)
                {
                    reject(e);
                }
            });
        }

        function getQueryRequestWithDynamicValues()
        {
            var request = _util.getQueryRequest(queryField);
            updateSortingForQueryRequest(request.payload);
            updateFilterValuesForQueryRequest(request.payload);
            return request;
        }

        function doGetPagedData(callback)
        {
            var request = getQueryRequestWithDynamicValues();
            return invoker(remoteApi, 'getRelatedRecordPagedData', [sourceRecordType, request.url, request.payload], callback, true /* parseResult */);
        }

        function postGetRelatedRecordPagedData(pagedDataOptions)
        {
            pagedDataOptions.parent = that;
            var requestorConfiguration = {
                rawUrl: formUrl,
                id: id,
                view: currentView,
                recordType: sourceRecordType,
                queryField: queryField,
                pageRanges: pagedDataOptions.pageRanges,
                dynamicValues: {}
            };
            updateSortingForQueryRequest(requestorConfiguration.dynamicValues);
            updateFilterValuesForQueryRequest(requestorConfiguration.dynamicValues);
            pagedDataOptions.pageRequestor = new RelatedRecordPageRequestor(requestorConfiguration);
            pagedDataOptions.returnFieldMetadata = returnFieldMetadata;
            return pagedDataOptions;
        }

        function updateSortingForQueryRequest(payload){
            if(sortBy)
            {
                payload.si_sortcol = returnFieldMetadata[sortBy.columnId].alias_key;
                payload.si_sortdir = sortBy.direction;
            }
        }

        function updateFilterValuesForQueryRequest(payload){
            for(var fieldId in filters)
            {
                if(filters.hasOwnProperty(fieldId))
                    payload['si_' + fieldId] = formatFilterValue(filterFieldMetadata[fieldId]);
            }
        }

        function setSortBy(options)
        {
            var columnId, direction;
            if(options !== undefined && options !== null)
            {
                columnId = options.columnId;
                direction = options.direction || 'ASC';
            }
            utilityFunctions.checkArgs([columnId], ['columnId'], 'RelatedRecord.sortBy');

            validateColumnId(columnId);
            validateDirection(direction);

            sortBy = {columnId: columnId, direction: direction};
        }

        function validateColumnId(columnId)
        {
            if(!returnFieldMetadata.hasOwnProperty(columnId))
                utilityFunctions.throwSuiteScriptError(error.Type.INVALID_COLUMN_FOR_SORTING, columnId);
        }

        function validateDirection(dir)
        {
            if(SORTING_DIRECTION.indexOf(dir) === -1)
                utilityFunctions.throwSuiteScriptError(error.Type.INVALID_DIRECTION_FOR_SORTING, dir);
        }

        function getSortBy()
        {
            return sortBy;
        }

        function getFilterValue(options)
        {
            var fieldId;
            if(options !== undefined && options !== null)
            {
                fieldId = options.fieldId;
            }
            utilityFunctions.checkArgs([fieldId], ['fieldId'], 'RelatedRecord.getFilterValue');

            return doGetFilterValue(fieldId);
        }

        function doGetFilterValue(fieldId)
        {
            if(filterFieldMetadata.hasOwnProperty(fieldId))
                return (filters[fieldId] !== undefined) ? filters[fieldId] : "";
            else
                return undefined;
        }

        function setFilterValue(options)
        {
            var fieldId, value;
            if(options !== undefined && options !== null)
            {
                fieldId = options.fieldId;
                value = options.value;
            }
            utilityFunctions.checkArgs([fieldId], ['fieldId'], 'RelatedRecord.setFilterValue');

            doSetFilterValue(fieldId, value);
        }

        function doSetFilterValue(fieldId, value)
        {
            var metadata = filterFieldMetadata[fieldId];
            if(!!metadata.isMultiSelect && !util.isArray(value))
                value = [value];

            filters[fieldId] = validateAndFormatFilterValue(metadata, value);
        }

        function validateAndFormatFilterValue(metadata, value)
        {
            if(!metadata)
                utilityFunctions.throwSuiteScriptError(error.Type.INVALID_FILTER_FIELD_FOR_CURRENT_VIEW, metadata.id);

            var formattedValue = '';
            if(value && value !== 0 && value !== false)
            {
                if(metadata.type === 'select')
                {
                    formattedValue = validateSelectFilter(metadata, value);
                }
                else if(metadata.type === 'date')
                    formattedValue = validateDateFilter(metadata, value);
                else
                    formattedValue = String(value);
            }

            return formattedValue;
        }

        function validateSelectFilter(metadata, value)
        {
            var input = util.isArray(value) ? value : [value];

            input.forEach(function(v){
                var isValid = false;
                for(var index in metadata.options)
                {
                    if(v === metadata.options[index].id)
                    {
                        isValid = true;
                        break;
                    }
                }

                if(!isValid)
                    utilityFunctions.throwSuiteScriptError(error.Type.INVALID_FIELD_VALUE, v, metadata.id);
            });

            return value;
        }

        function validateDateFilter(metadata, toValidate)
        {
            if (!(toValidate instanceof Date || Object.prototype.toString.call(toValidate) === '[object Date]'))
                utilityFunctions.throwSuiteScriptError(error.Type.INVALID_FIELD_VALUE, toValidate, metadata.id);

            return toValidate;
        }

        function formatFilterValue(metadata)
        {
            var formattedValue;
            var value = filters[metadata.id];
            if(!value || value === '')
            {
                formattedValue = '';
            }
            else if(metadata.type === 'select' && !!metadata.isMultiSelect)
            {
                value = (util.isArray(value)) ? value : [value];
                formattedValue = value.join(String.fromCharCode(5));
            }
            else
            {
                formattedValue = String(format.format({value: value, type: metadata.type}));
            }

            return formattedValue;
        }

        function parseFilterValue(metadata, value)
        {
            if(metadata.type === 'date')
            {
                value = format.parse({value: value, type: metadata.type});
            }
            return value;
        }

        function toJSON()
        {
            return {
                type: that.type,
                sortBy: that.sortBy,
                filters: filters,
                columns: that.columns
            }
        }

        function toString()
        {
            return "SearchDefinition"
        }

        /**
         * The type of the related record
         * @name RelatedRecordSearchDefinition#type
         * @type string
         * @readonly
         */
        Object.defineProperty(this, 'type', {
            get: function () {
                return searchType;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'type' );
            },
            enumerable: true,
            configurable: false
        });

        /**
         * The list of return columns
         * @name RelatedRecordSearchDefinition#columns
         * @type Column[]
         * @readonly
         */
        Object.defineProperty(this, 'columns', {
            get: function () {
                return columns;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'columns' );
            },
            enumerable: true,
            configurable: false
        });

        /**
         * The list of return filter fields
         * @name RelatedRecordSearchDefinition#filters
         * @type FilterField[]
         * @readonly
         */
        Object.defineProperty(this, 'filters', {
            get: function () {
                return filterFields;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'filters' );
            },
            enumerable: true,
            configurable: false
        });
        /**
         * The property determines how related record is sorted. The value is an object with two properties:
         * columnId - determines column for sorting
         * direction - sorting order, values are "ASC" or "DESC"
         * @name RelatedRecordSearchDefinition#sortBy
         * @type Object
         * @throws {SuiteScriptError} INVALID_COLUMN_FOR_SORTING if columnId is invalid
         * @throws {SuiteScriptError} INVALID_DIRECTION_FOR_SORTING if direction is invalid
         */
        Object.defineProperty(this, 'sortBy', {
            get: getSortBy,
            set: setSortBy,
            enumerable: true,
            configurable: false
        });

        /**
         * Change the filter value for related record query
         * @param {Object} options the options object
         * @param {string} options.fieldId the id of the filter field
         * @param {Object} options.value value to be set
         * @throws {SuiteScriptError} INVALID_FILTER_FIELD_FOR_CURRENT_VIEW if options.fieldId is invalid
         * @throws {SuiteScriptError} INVALID_FIELD_VALUE if options.value is invalid
         */
        this.setFilterValue = setFilterValue;
        /**
         * Return the filter value for related record query
         * @param {Object} options the options object
         * @param {string} options.fieldId the id of the filter field
         * @returns {Object} current filter setting for the given filter field
         */
        this.getFilterValue = getFilterValue;
        /**
         * Reset the filter values to the default state for the currently selected custom view
         */
        this.resetFilters = resetFilters;
        /**
         * Pagination API for related record
         * @returns {PagedData}
         * @since 2016.1
         */
        this.runPaged = runPaged;
        /**
         * Pagination API for related record using promise
         * @returns {Promise}
         * @since 2016.1
         */
        this.runPaged.promise = runPagedPromise;
        /**
         * JSON.stringify() implementation
         * @returns {Object}
         */
        this.toJSON = toJSON;
        /**
         * Returns the object type name
         * @returns {string}
         */
        this.toString = toString;
    }
    RelatedRecordSearchDefinition.prototype = nsobject.getNewInstance();
    freezeObjectIfPossible(RelatedRecordSearchDefinition);


    /**
    * Requestor for Related Record Page
    *
    * @private
    * @param {Object} config
    * @param {String} config.rawUrl the raw url for record handler, which includes some default parameters
    * @param {String} config.recordType the source record type
    * @param {String} config.queryField the page range field id
    * @param {String} config.id the id of the search result machine
    * @param {String} config.view the selected custom view of the search result machine
    * @param {Object} config.dynamicValues the dynamic values of the search result machine
    * @return {RelatedRecordPageRequestor}
    * @constructor
    */
    function RelatedRecordPageRequestor(config){
        var pageRequest = slaving.cleanupQueryURL(config.rawUrl);
        var sourceRecordType = config.recordType;
        var recordUrl = pageRequest.url;
        var payload = util.extend({
            q: config.queryField,
            machine: config.id,
            si_searchid: config.view
        }, pageRequest.payload);
        payload = util.extend(config.dynamicValues, payload);

        function request(index, callback){
            payload.si = String(index);
            return invoker(remoteApi, 'getRelatedRecordPage', [sourceRecordType, recordUrl, payload], callback, true /* parseResult */);
        }

        this.request = request;
    }

    /**
     * Data model for relatedrecord filter field
     *
     * @private
     * @param {Object} field
     * @return {FilterField}
     * @constructor
     */
    function FilterField(field)
    {
        var that = this, options;

        /**
         * The ID of the filter field
         * @name FilterField#id
         * @type string
         * @readonly
         */
        Object.defineProperty(this, 'id', {
            get: function () {
                return field.id;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'id' );
            },
            enumerable: true,
            configurable: false
        });
        /**
        * The label of the filter field
        * @name FilterField#label
        * @type string
        * @readonly
        */
        Object.defineProperty(this, 'label', {
            get: function () {
                return field.label;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'label' );
            },
            enumerable: true,
            configurable: false
        });
        /**
        * The type of the filter field
        * @name FilterField#type
        * @type string
        * @readonly
        */
        Object.defineProperty(this, 'type', {
            get: function () {
                return field.type;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'type' );
            },
            enumerable: true,
            configurable: false
        });
        /**
         * The hidden property of the filter field
         * @name FilterField#isHidden
         * @type string
         * @readonly
         */
        Object.defineProperty(this, 'isHidden', {
            get: function () {
                return field.isHidden;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isHidden' );
            },
            enumerable: true,
            configurable: false
        });
        /**
         * The multi-select property of the filter field
         * @name FilterField#isMultiSelect
         * @type string
         * @readonly
         */
        Object.defineProperty(this, 'isMultiSelect', {
            get: function () {
                return field.isMultiSelect;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isMultiSelect' );
            },
            enumerable: true,
            configurable: false
        });

        function getSelectOptions()
        {
            if(!options)
            {
                var options = [];
                if(field.options)
                {
                    field.options.forEach(function (v) {
                        options.push(freezeObjectIfPossible({value: v.id, text: v.text}));
                    });
                }
            }
            return options;
        }


        function toJSON()
        {
            return {
                id: that.id,
                type: that.type,
                label: that.label,
                isHidden: that.isHidden,
                isMultiSelect: that.isMultiSelect
            }
        }
        if(that.type === 'select')
        {
            /**
             * Return available options for select type filter field
             * @returns {Object[]}
             */
            this.getSelectOptions = getSelectOptions;
        }
        this.toJSON = toJSON;
        this.toString = function (){ return "RelatedRecord.FilterField"; }
    }
    FilterField.prototype = nsobject.getNewInstance();
    freezeObjectIfPossible(FilterField);

    /**
     * Data model for relatedrecord column
     *
     * @private
     * @param {Object} field
     * @return {Column}
     * @constructor
     */
    function Column(field)
    {
        var that = this;
        /**
         * The index of the column
         * @name Column#index
         * @type string
         * @readonly
         */
        Object.defineProperty(this, 'index', {
            get: function () {
                return field.index;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'index' );
            },
            enumerable: true,
            configurable: false
        });
        /**
         * The ID of the column
         * @name Column#columnId
         * @type string
         * @readonly
         */
        Object.defineProperty(this, 'columnId', {
            get: function () {
                return field.id;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'columnId' );
            },
            enumerable: true,
            configurable: false
        });
        /**
         * The label of the column
         * @name Column#label
         * @type string
         * @readonly
         */
        Object.defineProperty(this, 'label', {
            get: function () {
                return field.label;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'label' );
            },
            enumerable: true,
            configurable: false
        });
        /**
         * The value type of the column
         * @name Column#type
         * @type string
         * @readonly
         */
        Object.defineProperty(this, 'type', {
            get: function () {
                return field.type;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'type' );
            },
            enumerable: true,
            configurable: false
        });
        /**
         * Record type of the column, if applicable
         * @name Column#recordType
         * @type string
         * @readonly
         */
        Object.defineProperty(this, 'recordType', {
            get: function () {
                return field.rec_type ? field.rec_type : null;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'recordType' );
            },
            enumerable: true,
            configurable: false
        });
        /**
         * Indicates whether the data returned in this column is expected to contain a link URL
         * @name Column#hasLink
         * @type boolean
         * @readonly
         * @deprecated [use linkType instead]
         */
        Object.defineProperty(this, 'hasLink', {
            get: function () {
                return field.has_link;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'hasLink' );
            },
            enumerable: true,
            configurable: false
        });
        /**
         * Indicates what kind of link URL is expected in the data returned for this column. Uses values from the LinkType enum:
         * NONE = no link URL
         * REGULAR = link URL that should be opened in the same window
         * POPUP = link URL that should be opened in a new window
         * @name Column#linkType
         * @type string
         * @readonly
         */
        Object.defineProperty(this, 'linkType', {
            get: function () {
                return Object.keys(LINK_TYPE)[field.linktype];
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'linkType' );
            },
            enumerable: true,
            configurable: false
        });
        function toJSON()
        {
            return {
                index: that.index,
                columnId: that.columnId,
                label: that.label,
                type: that.type,
                recordType: that.recordType,
                hasLink: that.hasLink,
                linkType: that.linkType
            }
        }
        this.toJSON = toJSON;
        this.toString = function (){ return "RelatedRecord.Column"; }
    }
    Column.prototype = nsobject.getNewInstance();
    freezeObjectIfPossible(Column);

    /**
     * Data model for custom view option
     *
     * @private
     * @param {Object} view
     * @return {CustomView}
     * @constructor
     */
    function CustomView(view)
    {
        var that = this;

        /**
         * The ID of the custom view
         * @name CustomView#id
         * @type string
         * @readonly
         */
        Object.defineProperty(this, 'id', {
            get: function () {
                return view.id;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'id' );
            },
            enumerable: true,
            configurable: false
        });

        /**
         * The name of the custom view
         * @name CustomView#text
         * @type string
         * @readonly
         */
        Object.defineProperty(this, 'text', {
            get: function () {
                return view.text;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'text' );
            },
            enumerable: true,
            configurable: false
        });

        function toJSON()
        {
            return {id: that.id, text: that.text};
        }

        function toString()
        {
            return "RelatedRecord.CustomView";
        }

        this.toJSON = toJSON;
        this.toString = toString;
    }
    CustomView.prototype = nsobject.getNewInstance();
    freezeObjectIfPossible(CustomView);

    /**
     * PageRange implementation for RelatedRecord
     *
     * @private
     * @param {Object} options JS Object for RelatedRecordPageRange
     * @return {RelatedRecordPageRange}
     * @constructor
     */
    function RelatedRecordPageRange(options)
    {
        function getIndex() { return parseInt(options.id, 10);};
        function getCompoundLabel() { return options.text; };

        Object.defineProperty(this, 'index', {
            get: function () {
                return getIndex();
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'index' );
            },
            enumerable: true,
            configurable: false
        });

        Object.defineProperty(this, 'compoundLabel', {
            get: function () {
                return getCompoundLabel();
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'compoundLabel' );
            },
            enumerable: true,
            configurable: false
        });
        this.getIndex = getIndex;
        this.getCompoundLabel = getCompoundLabel;
    }
    RelatedRecordPageRange.prototype = nsobject.getNewInstance();
    freezeObjectIfPossible(RelatedRecordPageRange);

    /**
     * PagedData implementation for RelatedRecord
     *
     * @protected
     * @param {Object} options JS Object for RelatedRecordPagedData
     * @return {RelatedRecordPagedData}
     * @constructor
     */
    function RelatedRecordPagedData(options)
    {
        var that = this,
            pageRequestor = options.pageRequestor,
            readOnlyRelatedRecord = new ReadonlyRelatedRecordSearchDefinition(options.parent),
            returnFieldMetadata = options.returnFieldMetadata,
            totalRows = isNaN(options.totalRows) ? -1 : options.totalRows,
            pageSize = isNaN(options.pageSize) ? -1 : options.pageSize,
            pageRanges = Array.isArray(options.pageRanges) && options.pageRanges.map(function(v,i,a){return new RelatedRecordPageRange(v);}) || [],
            firstPageData = options.firstPageData; //createRelatedRecordPageInstance({index : 0, page: options.firstPageData});

        function createRelatedRecordPageInstance(configs)
        {
            var options = {
                parent: that,
                isFirst: configs.index === 0,
                isLast: configs.index === pageRanges.length-1,
                pageRange: pageRanges[configs.index]
            };

            if(configs.page && util.isArray(configs.page.data))
            {
                var page = [];
                configs.page.data.forEach(function(row){
                    page.push(new RelatedRecordResult({columns: configs.page.columns, row: row, returnFieldMetadata: returnFieldMetadata}));
                });
                options.data = page;
            }
            return new RelatedRecordPage(options);
        }

        function validateIndex(index)
        {
            if(index < 0 || index >= pageRanges.length)
            {
                utilityFunctions.throwSuiteScriptError(error.Type.INVALID_PAGE_RANGE, 'fetch' );
            }
        }

        function getPage(index)
        {
            validateIndex(index);
            var pageData = doGetPageRawResult(index, null);
            var page = createRelatedRecordPageInstance({index : index, page: pageData});
            return new paginationObject.Page(page);
        }

        function getPagePromise(index)
        {
            var result;
            if(index < 0 || index >= pageRanges.length)
            {
                result = Promise.reject(error.create({
                                                         name: error.Type.INVALID_PAGE_RANGE,
                                                         message: 'Invalid page range: fetch.promise.',
                                                         notifyOff: false
                                                     }));
            }
            else
            {
                result = new Promise(function(resolve, reject){
                    function callback(result) {
                        if (result instanceof Error) {
                            reject(result);
                        }
                        else {
                            var page = createRelatedRecordPageInstance({index : index, page: result});
                            resolve(new paginationObject.Page(page));
                        }
                    }

                    try {
                        doGetPageRawResult(index, callback);
                    }
                    catch(e)
                    {
                        reject(e);
                    }
                });
            }
            return result;
        }

        function doGetPageRawResult(index, callback)
        {
            var pageData;
            if(index === 0)
            {
                pageData = (callback) ? callback(firstPageData) : firstPageData;
            }
            else
            {
                pageData = pageRequestor.request(index, callback);
            }
            return pageData;
        }

        function toJSON(){
            return {
                count: that.count,
                pageRanges: that.pageRanges,
                pageSize: that.pageSize,
                searchDefinition: that.searchDefinition
            }
        }

        function toString()
        {
            return "search.PagedData"
        }

        this.searchDefinition = readOnlyRelatedRecord;
        this.pageRanges = pageRanges;
        this.pageSize = pageSize;
        this.count = totalRows;
        this.fetch = getPage;
        this.fetch.promise = getPagePromise;
        this.toJSON = toJSON;
        this.toString = toString;
    }
    RelatedRecordPagedData.prototype = nsobject.getNewInstance();
    freezeObjectIfPossible(RelatedRecordPagedData);

    function RelatedRecordPage(options)
    {
        var that = this,
            parentPagedData = options.parent,
            pageRange = options.pageRange;

        function getNextPage()
        {
            if(that.isLast)
            {
                utilityFunctions.throwSuiteScriptError(error.Type.INVALID_PAGE_RANGE, 'next' );
            }
            return parentPagedData.fetch(pageRange.getIndex()+1);
        }
        function getPrevPage()
        {
            if(that.isFirst)
            {
                utilityFunctions.throwSuiteScriptError(error.Type.INVALID_PAGE_RANGE, 'prev' );
            }
            return parentPagedData.fetch(pageRange.getIndex()-1);
        }
        function getNextPagePromise()
        {
            var result;
            if(that.isLast)
            {
                result = Promise.reject(error.create({
                                                         name: error.Type.INVALID_PAGE_RANGE,
                                                         message: 'Invalid page range: next.promise.',
                                                         notifyOff: false
                                                     }));
            }
            else
            {
                result = parentPagedData.fetch.promise(pageRange.getIndex()+1);
            }
            return result;
        }
        function getPrevPagePromise()
        {
            var result;
            if(that.isFirst)
            {
                result = Promise.reject(error.create({
                                                name: error.Type.INVALID_PAGE_RANGE,
                                                message: 'Invalid page range: prev.promise.',
                                                notifyOff: false
                                            }));
            }
            else
            {
                result = parentPagedData.fetch.promise(pageRange.getIndex() - 1);
            }
            return result;
        }

        this.data = options.data;
        this.pagedData = options.parent;
        this.pageRange = options.pageRange;
        this.isFirst = options.isFirst;
        this.isLast = options.isLast;
        this.next = getNextPage;
        this.prev = getPrevPage;
        this.next.promise = getNextPagePromise;
        this.prev.promise = getPrevPagePromise;
    }
    RelatedRecordPage.prototype = nsobject.getNewInstance();
    freezeObjectIfPossible(RelatedRecordPage);

    function RelatedRecordResult(options)
    {
        var returnFieldMetadata = options.returnFieldMetadata,
            dataByIndex = [],
            dataByFieldId= {};

        (function(opt){
            var columns = opt.columns;
            var row = opt.row;
            row.forEach(function(v,i){
                dataByIndex[i] = v;
                dataByFieldId[columns[i]] = v;
            })
        })(options);

        function getValue(options)
        {
            var index, columnId;
            if(options instanceof Column)
            {
                index = options.index;
                columnId = options.columnId;
            }
            else if(!!options && utilityFunctions.isObject(options))
            {
                columnId = options.columnId;
            }

            utilityFunctions.checkArgs([columnId],['columnId'], 'Result.getValue');

            return doGetValue(index, columnId);
        }
        function doGetValue(index, id)
        {
            var returnValue = doGetValueById(id);
            return returnValue;
        }

        function doGetValueByIndex(index)
        {
            if(index < 0 || index >= dataByIndex.length)
                utilityFunctions.throwSuiteScriptError(error.Type.INVALID_FIELD_INDEX, index );

            return dataByIndex[index];
        }

        function doGetValueById(id)
        {
            if(!returnFieldMetadata.hasOwnProperty(id))
                utilityFunctions.throwSuiteScriptError(error.Type.INVALID_FIELD_ID, id );

            return dataByFieldId[returnFieldMetadata[id].alias];
        }

        function toJSON()
        {
            var toRet = {};
            for(var id in returnFieldMetadata)
            {
                if(returnFieldMetadata.hasOwnProperty(id))
                    toRet[id] = dataByFieldId[returnFieldMetadata[id].alias];
            }

            return toRet;
        }
        function toString()
        {
            return "RelatedRecord.Result";
        }

        this.getValue = getValue;
        this.toJSON = toJSON;
        this.toString = toString;
    }
    RelatedRecordResult.prototype = nsobject.getNewInstance();
    freezeObjectIfPossible(RelatedRecordResult);

    function doGetRelatedRecord(options, callback)
    {
        var rec = options != null ? options.record : null;
        var sublistId = options != null ? options.sublistId : null;
        utilityFunctions.checkArgs([rec, sublistId], ['record', 'sublistId'], 'relatedRecord.get');

        var request = rec.query;
        if (!request)
            utilityFunctions.throwSuiteScriptError(error.Type.SSS_UNSUPPORTED_METHOD); // not supported on this type of record object
        request.payload['machine'] = sublistId;
        request.payload['r'] = "T";
        return invoker(remoteApi, "getRelatedRecord", [rec.type, request.url, request.payload], callback, false /* parseResult */);
    }

    function getRelatedRecord(options)
    {
        var relatedRecordObj = doGetRelatedRecord(options, null);
        relatedRecordObj.owningRecordType = options.record.type;

        return new RelatedRecord(relatedRecordObj);
    }

    function promiseToGetRelatedRecord(options)
    {
        var myPromise = new Promise(function (resolve, reject)
        {
            function callback(result)
            {
                if (result instanceof Error)
                {
                    reject(result);
                    return;
                }
                result.owningRecordType = options.record.type;
                resolve(new RelatedRecord(result));
            }

            try
            {
                doGetRelatedRecord(options, callback);
            }
            catch (e)
            {
                reject(e);
            }
        });
        return myPromise;
    }

    getRelatedRecord.promise = promiseToGetRelatedRecord;

    return {
        /**
         * Obtain the related record object that can be used to fetch search result machine data.
         *
         * @param {Object} options
         * @param {Record} options.record  the record object that the sublist is related to
         * @param {string} options.sublistId  the ID of the sublist
         * @return {RelatedRecord}
         *
         * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if one of the arguments is missing
         * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if options.sublistId is incorrect
         *
         * @since 2017.1
         */
        get: getRelatedRecord,

        /**
         * Enum for link types contained within column data.
         * @enum {string}
         */
        LinkType: LINK_TYPE
    };
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/subrecordUtilityFunctions
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/subrecordUtilityFunctions',['N/error', 'N/utilityFunctions', 'N/record/recordUtilityFunctions'],
       function(error, utilityFunctions, recordUtil){

    var getNextSysId = (function(){
       var nextSysId = Date.now();

       return function getNextSysId(){
           return nextSysId++;
       };
    }());

    /**
     * validate if the given field is summary field
     * @param {RecordField} field
     * @param {string} fieldId
     * @throws {SuiteScriptError} FIELD_1_IS_NOT_A_SUBRECORD_FIELD
     */
    function validateIfSummaryField(field, fieldId)
    {
        if (field === null || field.getType() !== 'summary')
        {
            utilityFunctions.throwSuiteScriptError(error.Type.FIELD_1_IS_NOT_A_SUBRECORD_FIELD, fieldId);
        }
    }

    return {
        SYS_OP: 'sys_op',
        SYS_ID: 'sys_id',
        SYS_PARENT_ID: 'sys_parentid',
        getNextSysId: getNextSysId,
        validateIfSummaryField: validateIfSummaryField
    };
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/sublistLine
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/sublistLine',['N/record/recordUtilityFunctions', 'N/record/sublistLineEvent', 'N/eventEmitter'],
	function(recordUtil, sublistLineEvent, eventEmitter)
	{
	    /**
	     * data structure to hold the sublist line data
	     *
	     * @param {Object} options
	     * @param {SublistLine} [options.toBeCloned]
	     * @param {string} options.id sublistId
	     * @param {number} options.lineIndex
	     * @param {Object} [options.defaultLineData={}]
	     * @return {SublistLine}
	     * @constructor
	     */
	    function SublistLine(options)
	    {
	        var that = this;
	        var id, lineIndex, data = {};
	        var emitter = eventEmitter.create();

	        if(options.toBeCloned)
	        {
	            var toBeCloned = options.toBeCloned;
	            id = toBeCloned.id;
	            if(options.lineIndex || options.lineIndex === 0)
	            {
	                lineIndex = options.lineIndex;
	            }
	            else
	                lineIndex =  -1;
	            setValues(toBeCloned);
	        }
	        else
	        {
	            id = options.id;
	            if(options.lineIndex || options.lineIndex === 0)
	            {
	                lineIndex = options.lineIndex;
	            }
	            else
	                lineIndex =  -1;
	            if(options.defaultLineData)
	            {
	                recordUtil.forEachProperty(options.defaultLineData, function(fieldId, value){
	                    data[fieldId] = {value: value, legacyStringValue: value};
	                })

	            }
	        }

	        /**
	         * sublist id
	         * @name SublistLine#id
	         * @type {string}
	         */
	        Object.defineProperty(this, 'id', {
	            get: function ()
	            {
	                return id;
	            },
	            enumerable: true,
	            configurable: false
	        });

	        /**
	         * sublist id
	         * @name SublistLine#index
	         * @type {number}
	         */
	        Object.defineProperty(this, 'index', {
	            get: function ()
	            {
	                return lineIndex;
	            },
	            set: function (idx)
	            {
	                lineIndex = parseInt(idx,10);
	            },
	            enumerable: true,
	            configurable: false
	        });

	        function setValues(anotherLine)
	        {
	            recordUtil.forEachProperty(anotherLine.getData(), function(fieldId, value){
	                var oldValue = getFieldValue(fieldId);
	                if(!recordUtil.matchRecordFieldValueSchema(value))
	                {
	                    value = util.isArray(value) && value.length === 1 ? value[0] : value;
	                    value = {value: undefined, legacyStringValue: value};
	                }
	                data[fieldId] = {value: value.value, legacyStringValue: value.legacyStringValue};
	                var newValue = getFieldValue(fieldId);
	                if(oldValue !== newValue)
	                {
	                    sublistLineEvent.updateField(emitter, that, fieldId, oldValue, newValue);
	                }
	            });
	        }
	        this.setValues = setValues;

	        function removeFieldValue(fieldId)
	        {
	            if(data.hasOwnProperty(fieldId))
	            {
	                var oldValue = getFieldValue(fieldId);
	                delete data[fieldId];
	                sublistLineEvent.updateField(emitter, that, fieldId, oldValue);
	            }
	        }
	        this.removeFieldValue = removeFieldValue;

	        function setPrimitiveValue(fieldId, value)
	        {
	            var oldValue = getFieldValue(fieldId);
	            if(hasFieldValue(fieldId))
	                data[fieldId].value = value;
	            else
	                data[fieldId] = {value: value, legacyStringValue: undefined};
	            var newValue = getFieldValue(fieldId);
	            if(oldValue !== newValue)
	            {
	                sublistLineEvent.updateField(emitter, that, fieldId, oldValue, newValue, true);
	            }
	        }
	        this.setPrimitiveValue = setPrimitiveValue;

	        function hasFieldValue(fieldId) {
	            return data.hasOwnProperty(fieldId);
	        }
	        this.hasFieldValue = hasFieldValue;

	        function setFieldValue(fieldId, recordFieldValue)
	        {
	            recordUtil.validateRecordFieldValueSchema(recordFieldValue);
	            var oldValue = getFieldValue(fieldId);
	            data[fieldId] = recordFieldValue;
	            var newValue = getFieldValue(fieldId);
	            if(oldValue !== newValue)
	            {
	                sublistLineEvent.updateField(emitter, that, fieldId, oldValue, newValue);
	            }
	        }
	        this.setFieldValue = setFieldValue;

	        function getFieldValue(fieldId)
	        {
	            var fieldValue = "";
	            if(util.isObject(data[fieldId]))
	            {
	                if(!!data[fieldId].value || data[fieldId].value === "" || data[fieldId].value === 0 || data[fieldId].value === false)
	                    fieldValue = data[fieldId].value;
	                else
	                    fieldValue = recordUtil.emptyIfNullOrUndefined(data[fieldId].legacyStringValue);
	            }

	            return fieldValue;
	        }
	        this.getFieldValue = getFieldValue;

	        function getValueAsLegacyString(fieldId)
	        {
	            var fieldValue = "";
	            if(util.isObject(data[fieldId]))
	            {
	                if(!!data[fieldId].legacyStringValue || data[fieldId].legacyStringValue === "" || data[fieldId].legacyStringValue === 0 || data[fieldId].legacyStringValue === false)
	                    fieldValue = data[fieldId].legacyStringValue;
	            }
	            return fieldValue;
	        }
	        this.getValueAsLegacyString = getValueAsLegacyString;

	        function getData()
	        {
	            var toRet = {};
	            recordUtil.forEachProperty(data, function(fieldId, value){
	                toRet[fieldId] = value;
	            });
	            return toRet;
	        }
	        this.getData = getData;

	        function toJSON()
	        {
	            return data;
	        }
	        this.toJSON = toJSON;

	        this.on = emitter.on;
	        this.off = emitter.off;
	    }



	    return {
	        /**
	         * create record sublist line data storage
	         * @param options
	         * @returns {SublistLine}
	         */
	        create: function (options){
	            return new SublistLine(options);
	        },
	        /**
	         * return true if object is an instance of SublistLine
	         * @param {Object} obj
	         * @returns {boolean}
	         */
	        isInstance: function(obj) { return obj instanceof SublistLine; }
	    }
	});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/selectFieldOptionTextCache
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/selectFieldOptionTextCache',[], function(){

	function createKey(sublistId, fieldId, value){
		return [sublistId, fieldId, value].join(String.fromCharCode(1));
	}

	function SelectFieldOptionTextCache()
	{
		var cache = {};

		function set(sublistId, fieldId, value, text){
				cache[createKey(sublistId, fieldId, value)] = text;
		}
		this.set = set;

		function get(sublistId, fieldId, value){
				return cache[createKey(sublistId, fieldId, value)];
		}
		this.get = get;

		function has(sublistId, fieldId, value){
				return cache.hasOwnProperty(createKey(sublistId, fieldId, value));
		}
		this.has = has;

		return this;
	}

	return {
		create: function(){
			return new SelectFieldOptionTextCache();
		}
	};
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/util/uuid
 * @NApiVersion 2.x
 *
 */
define('N/util/uuid',[], function () {
	function getRandomHexString(length)
	{
		var result = '';

		while(result.length < length)
		{
			result += getHexString(getRandomValue());
		}

		return result;
	}

	function getRandomValue()
	{
		return Math.floor(Math.random() * 16);
	}

	function getHexString(value)
	{
		return value.toString(16);
	}


	function generateV4()
	{
		return getRandomHexString(8) + '-' +
			getRandomHexString(4) + '-' +
			'4' + getRandomHexString(3) + '-' +
			getHexString(getRandomValue(1) & 11 | 8) + getRandomHexString(3) + '-' +
			getRandomHexString(12);
	}

	/**
	 * @alias N/util/uuid
	 */
	return Object.freeze({
		generateV4: generateV4
	});
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/model
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/model',['N/record/recordUtilityFunctions', 'N/record/subrecordUtilityFunctions', 'N/record/sublistLine', 'N/record/selectFieldOptionTextCache',
        'N/record/modelEvent', 'N/eventEmitter',
        'N/util/uuid'],
    function(recordUtil, subrecordUtil, sublistLine, selectOptionTextCache,
             modelEvent, eventEmitter,
             uuid){

    function SublistsController()
    {
        var that = this;
        var ID_FIELD = '_id';
        var SEQUENCE_FIELD = '_sequence';
        var sublists = {};

        function getLineInstanceId(sublistLine)
        {
            return sublistLine.getFieldValue(ID_FIELD);
        }

        function getLineSequence(sublistLine)
        {
            return sublistLine.getFieldValue(SEQUENCE_FIELD);
        }

        function sublistExists(sublistId)
        {
            return sublists.hasOwnProperty(sublistId);
        }
        this.sublistExists = sublistExists;

        function getSublist(sublistId)
        {
            if (!sublistExists(sublistId))
            {
                sublists[sublistId] = {};
            }

            return sublists[sublistId];
        }

        function getSublists(){
            return Object.keys(sublists);
        }
        this.getSublists = getSublists;

        function hasSublistLine(sublistId, lineInstanceId)
        {
            var hasLine = false;
            var hasSublist = sublistExists(sublistId);

            if(hasSublist)
            {
                var sublist = getSublist(sublistId);
                hasLine = sublist.hasOwnProperty(lineInstanceId);
            }

            return hasLine;
        }
        this.hasSublistLine = hasSublistLine;

        function getSublistLine(sublistId, lineInstanceId)
        {
            var sublistLine = null;
            var hasLine = hasSublistLine(sublistId, lineInstanceId);

            if(hasLine)
            {
                var sublist = getSublist(sublistId);
                sublistLine = sublist[lineInstanceId];
            }

            return sublistLine;
        }
        this.getSublistLine = getSublistLine;

        function putSublistLine(sublistLine)
        {
            var sublistId = sublistLine.id;
            var lineInstanceId = getLineInstanceId(sublistLine);
            var previousSublistLine = getSublistLine(sublistId, lineInstanceId);

            getSublist(sublistId)[lineInstanceId] = sublistLine;

            return previousSublistLine;
        }
        this.putSublistLine = putSublistLine;

        function removeSublistLine(sublistId, lineInstanceId)
        {
            var removedSublistLine = getSublistLine(sublistId, lineInstanceId);
            delete getSublist(sublistId)[lineInstanceId];

            return removedSublistLine;
        }
        this.removeSublistLine = removeSublistLine;

        function getSublistLineCount(sublistId)
        {
            return sublistExists(sublistId) && Object.keys(getSublist(sublistId)).length || 0;
        }
        this.getSublistLineCount = getSublistLineCount;

        function getSublistLinesAsOrderedList(sublistId)
        {
            return Object.keys(getSublist(sublistId)).
                map(function(lineInstanceId){ return getSublistLine(sublistId, lineInstanceId); }).
                sort(function(line1, line2){return getLineSequence(line1) - getLineSequence(line2)});
        }
        this.getSublistLinesAsOrderedList = getSublistLinesAsOrderedList;

        function getSequenceToInstanceIdMap(sublistId)
        {
            return Object.keys(getSublist(sublistId)).
                reduce(function(result, lineInstanceId){
                    result[getLineSequence(getSublistLine(sublistId, lineInstanceId))] = lineInstanceId;

                    return result;
                }, {});
        }
        this.getSequenceToInstanceIdMap = getSequenceToInstanceIdMap;
    }

    function SublistsSequenceToInstanceId(sublistsController)
    {
        var sublists = {};

        function update(sublistId)
        {
            sublists[sublistId] = sublistsController.getSequenceToInstanceIdMap(sublistId);
        }
        this.update = update;

        function get(sublistId, line)
        {
            var sublist = sublists[sublistId];
            if(!sublist)
            {
                update(sublistId);
                sublist = sublists[sublistId];
            }
            return sublist[line];
        }
        this.get = get;
    }

    function SelectedLineController()
    {
        var that = this;
        var sublists = {};

        function sublistExists(sublistId)
        {
            return sublists.hasOwnProperty(sublistId);
        }

        function has(sublistId)
        {
            var result = false;
            var hasSublist = sublistExists(sublistId);
            
            if(hasSublist)
            {
                var thisIdList = sublists[sublistId];
                result = !!thisIdList && (thisIdList.length > 0);
            }
            
            return result;
        }
        this.has = has;

        function getLastAndPop(sublistId, shouldPop)
        {
            var result = null;
            if(has(sublistId))
            {
                var thisIdList = sublists[sublistId];
                if (!shouldPop)
                    thisIdList = thisIdList.slice(-1);

                result = thisIdList.pop();
            }

            return result;
        }

        function get(sublistId)
        {
            return getLastAndPop(sublistId, false);
        }
        this.get = get;

        function put(sublistId, lineInstanceId)
        {
            var previousCurrentSublistLineInstanceId = get(sublistId);
            if (!has(sublistId))
                sublists[sublistId] = [lineInstanceId];
            else
                sublists[sublistId].push(lineInstanceId);
            return previousCurrentSublistLineInstanceId;
        }
        this.put = put;

        function update(sublistId, lineInstanceId)
        {
            remove(sublistId);
            put(sublistId, lineInstanceId);
        }
        this.update = update;

        function remove(sublistId)
        {
            return getLastAndPop(sublistId, true);
        }
        this.remove = remove;
    }

    /**
     * object holds the record data
     *
     * @param {Object} options
     * @param {String} options.type record type
     * @param {RecordCacheController} options.subrecordCache
     * @param {{bodyField:*, sublist: *, sublistFieldState:*, subrecord:* }} options.data serialized data
     * @return {Model}
     * @constructor
     */
    function Model(options)
    {
        var that = this;
        var recordType = options.type;
        var recordDataObj = options.data;
        var emitter = eventEmitter.create();
        var bodyFields = {};
        var subrecordData = {cache: options.subrecordCache};
        var sublists = new SublistsController();
        var sublistsLinesSequencesToInstanceIds = new SublistsSequenceToInstanceId(sublists);
        var sublistsBuffers = new SublistsController();
        var sublistsBuffersLinesSequencesToInstanceIds = new SublistsSequenceToInstanceId(sublistsBuffers);
        var sublistsSelectedLineInstanceIds = new SelectedLineController();
        var optionTextCache = selectOptionTextCache.create();

        (function constructor(recordDataObj)
        {
            function bindCachingFunction(sublistId, fieldId){
                return function(value, text){
                    optionTextCache.set(sublistId, fieldId, value, text);
                }
            }

            (function initSubrecord(data)
            {
                subrecordData.link = data.link || {};

            })(recordDataObj.subrecord || {});

            (function initBodyFields(fields)
            {

                recordUtil.forEachProperty(fields, function(fieldId, value)
                {
                    var cacher = bindCachingFunction(undefined, fieldId);
                    if(!recordUtil.matchRecordFieldValueSchema(value))
                    {
                        value = util.isArray(value) && value.length === 1 ? value[0] : value;
                        value = recordUtil.transformRawValueToFieldValueSchema(value, cacher);
                    }

                    bodyFields[fieldId] = value;
                });


                if (!!subrecordData.link[recordType])
                {
                    if (bodyFields[subrecordUtil.SYS_ID] === undefined)
                    {
                        var valueForSystemId = String(subrecordUtil.getNextSysId());
                        bodyFields[subrecordUtil.SYS_ID] = {value: valueForSystemId, legacyStringValue: valueForSystemId};

                        bodyFields[subrecordUtil.SYS_PARENT_ID] = {value: "0", legacyStringValue: "0"};
                    }
                }
            })(recordDataObj.bodyField || {});


            (function initSublists(sublistData)
            {
                for (var sublistId in sublistData)
                {
                    if (sublistData.hasOwnProperty(sublistId))
                    {
                        var lines = sublistData[sublistId];
                        lines.forEach(function (line, index)
                                      {
                                          var uniqueId = uuid.generateV4();

                                          var sublistline = createSublistLine({
                                              id: sublistId,
                                              lineIndex: index,
                                              sequence: index,
                                              lineInstanceId: uniqueId
                                          });
                                          sublists.putSublistLine(sublistline);

                                          recordUtil.forEachProperty(line, function(fieldId, value){
                                              var cacher = bindCachingFunction(sublistId, fieldId);
                                              if(!recordUtil.matchRecordFieldValueSchema(value))
                                              {
                                                  value = util.isArray(value) && value.length === 1 ? value[0] : value;
                                                  value = recordUtil.transformRawValueToFieldValueSchema(value, cacher)
                                              }

                                              sublistline.setFieldValue(fieldId, value);
                                          });


                                          if (!!subrecordData.link[sublistId])
                                          {
                                              if (sublistline.getFieldValue(subrecordUtil.SYS_ID) === undefined)
                                              {
                                                  var sys_id = String(subrecordUtil.getNextSysId());
                                                  sublistline.setFieldValue(subrecordUtil.SYS_ID, {
                                                      value: sys_id,
                                                      legacyStringValue: sys_id
                                                  });
                                                  sublistline.setFieldValue(subrecordUtil.SYS_PARENT_ID, {
                                                      value: "0",
                                                      legacyStringValue: "0"
                                                  });
                                              }
                                          }
                                      });
                        sublistsLinesSequencesToInstanceIds.update(sublistId);
                    }
                }
            })(recordDataObj.sublist || {});

        })(recordDataObj);

        this.on = emitter.on;
        this.off = emitter.off;

        function createSublistLine(options)
        {
            var newSublistLine = sublistLine.create({
                    id: options.id,
                    lineIndex: options.lineIndex,
                    toBeCloned: options.toBeCloned,
                    defaultLineData: options.defaultLineData
                });

            var lineInstanceId = options.lineInstanceId || uuid.generateV4();
            newSublistLine.setPrimitiveValue('_id', lineInstanceId);

            var sequence = isNaN(options.sequence) ? -1 : options.sequence;
            newSublistLine.setPrimitiveValue('_sequence', sequence);

            var asBuffer = !!options.asBuffer;

            modelEvent.forwardSublistLineEvents(emitter, newSublistLine, asBuffer);
            modelEvent.createLine(emitter, newSublistLine, asBuffer);

            return newSublistLine;
        }

        //TODO: Support Private

        function getSublistLineForInstance(sublistId, lineInstanceId, useBuffer)
        {
            function getSublistCommittedLineForInstance(sublistId, lineInstanceId)
            {
	            return sublists.getSublistLine(sublistId, lineInstanceId);
            }

            function getSublistBufferedLineForInstance(sublistId, lineInstanceId)
            {
                var sublistLineBuffer = sublistsBuffers.getSublistLine(sublistId, lineInstanceId);

                if (!sublistLineBuffer)
                {
                    var sublistLine = getSublistCommittedLineForInstance(sublistId, lineInstanceId);
                    if(!!sublistLine)
                    {
                        sublistLineBuffer = createBuffer({line: sublistLine});
                    }
                }

                return sublistLineBuffer;
            }

            return (!useBuffer ? getSublistCommittedLineForInstance : getSublistBufferedLineForInstance)(sublistId, lineInstanceId);
        }
	    this.getSublistLineForInstance = getSublistLineForInstance;

        function getSublistSelectedLine(sublistId)
        {
            var useBuffer = true;
            var lineInstanceId = sublistsSelectedLineInstanceIds.get(sublistId);
            var sublistLineBuffer = getSublistLineForInstance(sublistId, lineInstanceId, useBuffer);
            return sublistLineBuffer;
        }

	    function removeLineBufferForInstance(sublistId, lineInstanceId, suppressEmit)
        {
            if(sublistsBuffers.hasSublistLine(sublistId, lineInstanceId))
            {
                var bufferIsSelected = lineInstanceId === sublistsSelectedLineInstanceIds.get(sublistId);
                if (bufferIsSelected) {
                    //TODO this can not be removed during a commit
                    // a dead zone exists where data has been moved but the knowledge of the selected line exists
                    // some scripts are taking advantage of this
                    // nlapiGetLineItemField with no line param is being called during recalc
                    //sublistsSelectedLineInstanceIds.remove(sublistId);
                }

                var sublistline = sublistsBuffers.removeSublistLine(sublistId, lineInstanceId);
                modelEvent.unforwardSublistLineEvents(sublistline);
                sublistsBuffersLinesSequencesToInstanceIds.update(sublistId);
                var isBuffer = true;
                modelEvent.deleteLine(emitter, sublistline, isBuffer, !!suppressEmit);
            }
        }

        function removeCurrentLine(sublistId)
        {
            if(sublistsSelectedLineInstanceIds.has(sublistId))
            {
                var lineInstanceId = sublistsSelectedLineInstanceIds.get(sublistId);
                removeLineBufferForInstance(sublistId, lineInstanceId);
            }
        }

        function updateSublistLineSequenceFromStartByAmount(sublistId, start, amount)
        {
            sublists.getSublistLinesAsOrderedList(sublistId).
                filter(function(sublistline){ return start <= sublistline.getFieldValue('_sequence');}).
                forEach(function(sublistline){
                    var newSequence = sublistline.getFieldValue('_sequence') + amount;
                    sublistline.setPrimitiveValue('_sequence', newSequence);
                    sublistline.index += amount;

                    var id = sublistline.getFieldValue('_id');
                    if(sublistsBuffers.hasSublistLine(sublistId, id))
                    {
                        var sublistlineBuffer = sublistsBuffers.getSublistLine(sublistId, id);
                        sublistlineBuffer.setPrimitiveValue('_sequence', newSequence);
                        sublistlineBuffer.index += amount;
                    }
                });

            sublistsBuffers.getSublistLinesAsOrderedList(sublistId).
                filter(function(sublistlineBuffer){
                    var isStartOrGreater = start <= sublistlineBuffer.getFieldValue('_sequence');
                    var isUncommitted = !sublists.hasSublistLine(sublistId, sublistlineBuffer.getFieldValue('_id'));

                    return isStartOrGreater && isUncommitted;
                }).
                forEach(function(sublistlineBuffer){
                    var newSequence = sublistlineBuffer.getFieldValue('_sequence') + amount;
                    sublistlineBuffer.setPrimitiveValue('_sequence', newSequence);
                    sublistlineBuffer.index += amount;
                });
        }

        function updateSublistLineSequenceFromStartByPos1(sublistId, start)
        {
            updateSublistLineSequenceFromStartByAmount(sublistId, start, 1);
        }

        function updateSublistLineSequenceFromStartByNeg1(sublistId, start)
        {
            updateSublistLineSequenceFromStartByAmount(sublistId, start, -1);
        }

        function runFunctionWhileSilentlySelectingLine(sublistId, lineInstanceId, func, thisArg, argList)
        {
        	try
	        {
	            sublistsSelectedLineInstanceIds.put(sublistId, lineInstanceId);
	            func.apply(thisArg, argList);
	        }
	        finally
	        {
	            sublistsSelectedLineInstanceIds.remove(sublistId);
	        }
        }
        this.runFunctionWhileSilentlySelectingLine = runFunctionWhileSilentlySelectingLine;

        function doSelect(sublistId, sublistline)
        {
            var isBuffer = true;
            var previousSelectedLineInstanceId = sublistsSelectedLineInstanceIds.get(sublistId);
            if(previousSelectedLineInstanceId !== null && !sublists.hasSublistLine(sublistId, previousSelectedLineInstanceId))
            {
                removeLineBufferForInstance(sublistId, previousSelectedLineInstanceId);
            }

            sublistsSelectedLineInstanceIds.put(sublistId, sublistline.getFieldValue('_id'));
            modelEvent.selectLine(emitter, sublistline, isBuffer);
        }

        function doInsert(sublistId, sublistline)
        {
            var line = sublistline.getFieldValue('_sequence');
            updateSublistLineSequenceFromStartByPos1(sublistId, line);
            sublists.putSublistLine(sublistline);
            sublistsLinesSequencesToInstanceIds.update(sublistId);
            sublistsBuffersLinesSequencesToInstanceIds.update(sublistId);
            modelEvent.insertLine(emitter, sublistline);
        }

        function doUpdate(sublistId, sublistline)
        {
            sublists.putSublistLine(sublistline);
            modelEvent.updateLine(emitter, sublistline);
        }

        function createBuffer(options){
            var sublistLineOptions = {
                asBuffer: true
            };

            if(!!options.line)
            {
                sublistLineOptions.id = options.line.id;
                sublistLineOptions.lineInstanceId = options.line.getFieldValue('_id');
                sublistLineOptions.lineIndex = options.line.index;
                sublistLineOptions.sequence = options.line.getFieldValue('_sequence');
                sublistLineOptions.toBeCloned = options.line;
            }
            else
            {
                sublistLineOptions.id = options.sublistId;
                sublistLineOptions.lineInstanceId = options.lineInstanceId;
                sublistLineOptions.lineIndex = options.index;
                sublistLineOptions.sequence = options.sequence;
                sublistLineOptions.defaultLineData = options.defaultLineData;
            }

            var sublistlineBuffer = createSublistLine(sublistLineOptions);

            sublistsBuffers.putSublistLine(sublistlineBuffer);
            sublistsBuffersLinesSequencesToInstanceIds.update(sublistLineOptions.id);
            //modelEvent.insertLine(emitter, sublistline); TODO Event for opening buffer - multiline - should be independent from select???

            return sublistlineBuffer;
        }

        function updateNewLineBufferWithCopy(sublistLineOptions)
        {
        	var fromBuffer = true;
	        var newNewLineBuffer = createSublistLine(sublistLineOptions);
	        sublistsBuffers.putSublistLine(newNewLineBuffer);
	        modelEvent.updateLine(emitter, newNewLineBuffer, fromBuffer);
	        modelEvent.selectLine(emitter, newNewLineBuffer, fromBuffer);
	        return newNewLineBuffer.getFieldValue('_id');
        }
        this.updateNewLineBufferWithCopy = updateNewLineBufferWithCopy;

		function putCopyIntoNewLineBuffer(sublistId, line)
		{
			var useBuffer = true;
			var previousNewLineIndex = getSublistNewLineIndex(sublistId);
			var previousNewLineInstanceId = getSublistLineInstanceIdForIndex(sublistId, previousNewLineIndex, useBuffer);
			var wasPreviousNewLineSelected = sublistsSelectedLineInstanceIds.get(sublistId) === previousNewLineInstanceId;
			var sublistLineOptions = {
				asBuffer: useBuffer,
				id: sublistId,
				lineIndex: previousNewLineIndex,
				sequence: previousNewLineIndex,
				toBeCloned: line
			};

			removeLineBufferForInstance(sublistId, previousNewLineInstanceId);

			var newNewLineBuffer = createSublistLine(sublistLineOptions);
			var newNewLineInstanceId = newNewLineBuffer.getFieldValue('_id');
			sublistsBuffers.putSublistLine(newNewLineBuffer);
			sublistsBuffersLinesSequencesToInstanceIds.update(sublistLineOptions.id);

			if (wasPreviousNewLineSelected)
				sublistsSelectedLineInstanceIds.put(sublistId, newNewLineInstanceId);

			return newNewLineInstanceId;
		}
		this.putCopyIntoNewLineBuffer = putCopyIntoNewLineBuffer;

        //TODO: Support Public
        function getSublists()
        {
            return sublists.getSublists();
        }
        this.getSublists = getSublists;

        function getSublistLineCount(sublistId)
        {
            return sublists.getSublistLineCount(sublistId);
        }
        this.getSublistLineCount = getSublistLineCount;

        function getSublistNewLineIndex(sublistId)
        {
            return getSublistLineCount(sublistId);
        }
        this.getSublistNewLineIndex = getSublistNewLineIndex;

        function getSublistSelectedLineInstanceId(sublistId)
        {
            return sublistsSelectedLineInstanceIds.get(sublistId);
        }
        this.getSublistSelectedLineInstanceId = getSublistSelectedLineInstanceId;

        function isSublistLineInstanceIdSelected(sublistId, lineInstanceId)
        {
            var selectedLineInstanceId = sublistsSelectedLineInstanceIds.get(sublistId);

            return lineInstanceId === selectedLineInstanceId;
        }
        this.isSublistLineInstanceIdSelected = isSublistLineInstanceIdSelected;

        function isSublistLineInstanceIdValid(sublistId, lineInstanceId, useBuffer)
        {
            var sublistsController = useBuffer ? sublistsBuffers : sublists;
            var isValid = sublistsController.hasSublistLine(sublistId, lineInstanceId);

            return isValid;
        }
        this.isSublistLineInstanceIdValid = isSublistLineInstanceIdValid;

        function getSublistLineInstanceIdForIndex(sublistId, line, useBuffer)
        {
            var lineInstanceId = null;
            if(!!useBuffer)
            {
                lineInstanceId = sublistsBuffersLinesSequencesToInstanceIds.get(sublistId, line);
            }
            else
            {
                lineInstanceId = sublistsLinesSequencesToInstanceIds.get(sublistId, line);
            }

            lineInstanceId = lineInstanceId || null;

            return lineInstanceId;
        }
        this.getSublistLineInstanceIdForIndex = getSublistLineInstanceIdForIndex;







        function getBodyFieldIds()
        {
            var fieldIds = [];
            for (var fieldId in bodyFields)
                fieldIds.push(fieldId);

            return fieldIds;
        }
        this.getBodyFieldIds = getBodyFieldIds;

        function getSublistLineFieldIds(sublistId, lineInstanceId, useBuffer)
        {
            var fieldIds = null;
            var sublistLine = getSublistLineForInstance(sublistId, lineInstanceId, !!useBuffer);

            if (!!sublistLine)
            {
                fieldIds = Object.keys(sublistLine.getData());
            }
            return fieldIds;
        }
        this.getSublistLineFieldIds = getSublistLineFieldIds;

        function getBodyValue(fieldId)
        {
            var fieldValue = "";
            if (util.isObject(bodyFields[fieldId]))
            {
                if (!!bodyFields[fieldId].value || bodyFields[fieldId].value === "" || bodyFields[fieldId].value === 0 || bodyFields[fieldId].value === false)
                    fieldValue = bodyFields[fieldId].value;
                else
                    fieldValue = recordUtil.emptyIfNullOrUndefined(bodyFields[fieldId].legacyStringValue);
            }

            return fieldValue;
        }
        this.getBodyValue = getBodyValue;

        function getSublistLineValue(sublistId, lineInstanceId, fieldId, useBuffer)
        {
            var value = null;
	        if (doesSublistExist(sublistId, useBuffer))
            {
                var sublistline = getSublistLineForInstance(sublistId, lineInstanceId, !!useBuffer);
                if (!!sublistline)
                {
                    value = sublistline.getFieldValue(fieldId);
                }
            }

            return value;
        }
        this.getSublistLineValue = getSublistLineValue;

        function getBodyValueAsLegacyString(fieldId)
        {
            var fieldValue = "";
            if(util.isObject(bodyFields[fieldId]))
            {
                if(!!bodyFields[fieldId].legacyStringValue || bodyFields[fieldId].legacyStringValue === "" || bodyFields[fieldId].legacyStringValue === 0 || bodyFields[fieldId].legacyStringValue === false)
                    fieldValue = bodyFields[fieldId].legacyStringValue;
            }
            return fieldValue;
        }
        this.getBodyValueAsLegacyString = getBodyValueAsLegacyString;

        function getSublistLineValueAsLegacyString(sublistId, lineInstanceId, fieldId, useBuffer)
        {
            var value = null;
	        if (doesSublistExist(sublistId, useBuffer))
            {
                var sublistline = getSublistLineForInstance(sublistId, lineInstanceId, !!useBuffer);
                if(!!sublistline)
                {
                    value = sublistline.getValueAsLegacyString(fieldId);
                }
            }
            return value;
        }
        this.getSublistLineValueAsLegacyString = getSublistLineValueAsLegacyString;

        function setBodyValue(fieldId, recordFieldValue)
        {
            recordUtil.validateRecordFieldValueSchema(recordFieldValue);
            var oldValue = getBodyValue(fieldId);
            bodyFields[fieldId] = recordFieldValue;
            var newValue = getBodyValue(fieldId);
            if(oldValue !== newValue)
            {
                modelEvent.updateField(emitter, fieldId, oldValue, newValue);
            }
        }
        this.setBodyValue = setBodyValue;

        function setSublistLineValue(sublistId, lineInstanceId, fieldId, recordFieldValue, useBuffer)
        {
            recordUtil.validateRecordFieldValueSchema(recordFieldValue);
            var sublistline = getSublistLineForInstance(sublistId, lineInstanceId, !!useBuffer);
            if(!!sublistline)
            {
                sublistline.setFieldValue(fieldId, recordFieldValue);
            }
        }
        this.setSublistLineValue = setSublistLineValue;

        function setBodyValuePrimitive(fieldId, value)
        {
            var oldValue = getBodyValue(fieldId);
            if (hasBodyValue(fieldId))
                bodyFields[fieldId].value = value;
            else
                bodyFields[fieldId] = {value: value, legacyStringValue: undefined};
            var newValue = getBodyValue(fieldId);
            if(oldValue !== newValue)
            {
                modelEvent.updateField(emitter, fieldId, oldValue, newValue, true);
            }
        }
        this.setBodyValuePrimitive = setBodyValuePrimitive;

        function setSublistLineValuePrimitive(sublistId, lineInstanceId, fieldId, value, useBuffer)
        {
            var sublistLine = getSublistLineForInstance(sublistId, lineInstanceId, !!useBuffer);
            sublistLine.setPrimitiveValue(fieldId, value);
        }
        this.setSublistLineValuePrimitive = setSublistLineValuePrimitive;

        function hasBodyValue(fieldId)
        {
            return bodyFields.hasOwnProperty(fieldId);
        }
        this.hasBodyValue = hasBodyValue;

        function hasSublistLineValue(sublistId, lineInstanceId, fieldId, useBuffer)
        {
            var result = false;
	        if (doesSublistExist(sublistId, useBuffer))
            {
                var sublistline = getSublistLineForInstance(sublistId, lineInstanceId, !!useBuffer);
                if(!!sublistline)
                {
                    result = sublistline.hasFieldValue(fieldId);
                }
            }
            return result;
        }
        this.hasSublistLineValue = hasSublistLineValue;

	    function doesSublistExist(sublistId, useBuffer)
	    {
		    var sublistContainer = !!useBuffer ? sublistsBuffers : sublists;
		    return sublistContainer.sublistExists(sublistId);
	    }
	    this.doesSublistExist = doesSublistExist;

        function removeBodyValue(fieldId)
        {
            if (bodyFields.hasOwnProperty(fieldId)) {
                var oldValue = getBodyValue(fieldId);
                delete bodyFields[fieldId];
                modelEvent.updateField(emitter, fieldId, oldValue);
            }
        }
        this.removeBodyValue = removeBodyValue;

        function removeSublistLineValue(sublistId, lineInstanceId, fieldId, useBuffer)
        {
            var sublistline = getSublistLineForInstance(sublistId, lineInstanceId, !!useBuffer);
            sublistline.removeFieldValue(fieldId);
        }
        this.removeSublistLineValue = removeSublistLineValue;

        function insertSublistLine(sublistId, beforeLineInstanceId)
        {
            var result = null;
            var beforeSublistline = (function(){
                    var result = null;
                    var useBuffer = null;

                    if(sublists.hasSublistLine(sublistId, beforeLineInstanceId))
                    {
                        useBuffer = false;
                    }
                    else if(sublistsBuffers.hasSublistLine(sublistId, beforeLineInstanceId))
                    {
                        useBuffer = true;
                    }

                    if(useBuffer !== null)
                    {
                        result = getSublistLineForInstance(sublistId, beforeLineInstanceId, useBuffer);
                    }

                    return result;
                })();

            var line = !!beforeSublistline ? beforeSublistline.index : getSublistLineCount(sublistId);
            var sublistline = createSublistLine({id: sublistId, lineIndex: line, sequence: line});
            doInsert(sublistId, sublistline);
            result = sublistline.getFieldValue('_id');

            return result;
        }
        this.insertSublistLine = insertSublistLine;

        function removeSublistLine(sublistId, lineInstanceId)
        {
            if (sublists.hasSublistLine(sublistId, lineInstanceId))
            {
                cancelSublistLine(sublistId, lineInstanceId, true);

                var sublistline = sublists.removeSublistLine(sublistId, lineInstanceId);
                modelEvent.unforwardSublistLineEvents(sublistline);
                var line = sublistline.getFieldValue('_sequence');
                updateSublistLineSequenceFromStartByNeg1(sublistId, line);
                sublistsLinesSequencesToInstanceIds.update(sublistId);
                sublistsBuffersLinesSequencesToInstanceIds.update(sublistId);
                modelEvent.deleteLine(emitter, sublistline);
            }
        }
        this.removeSublistLine = removeSublistLine;

        function selectSublistLine(sublistId, lineInstanceId)
        {
            var useBuffer = false;
            var sublistLine = getSublistLineForInstance(sublistId, lineInstanceId, useBuffer);
            var sublistlineBuffer = createBuffer({line: sublistLine});

            //removeCurrentLine(sublistId); TODO discuss with robert
            doSelect(sublistId, sublistlineBuffer);
        }
        this.selectSublistLine = selectSublistLine;

        function selectNewSublistLine(sublistId, defaultValues)
        {
            //var isBuffer = true;
            var line = getSublistNewLineIndex(sublistId);
            //resetCurrentSublistLine(sublistId, line, defaultValues);

            var selectedLineInstanceId = sublistsSelectedLineInstanceIds.get(sublistId);
            var wasCommitted = sublists.hasSublistLine(sublistId, selectedLineInstanceId);
            if(!wasCommitted)
            {
                removeSublistLine(sublistId, selectedLineInstanceId);
            }

            var newSublistline = createBuffer({
                    sublistId: sublistId,
                    index: line,
                    sequence: line,
                    defaultLineData: defaultValues
                });

            doSelect(sublistId, newSublistline);

            return sublistsSelectedLineInstanceIds.get(sublistId);
        }
        this.selectNewSublistLine = selectNewSublistLine;

        function cancelSublistLine(sublistId, lineInstanceId, suppressEmit)
        {
            if(sublistsBuffers.hasSublistLine(sublistId, lineInstanceId))
            {
                removeLineBufferForInstance(sublistId, lineInstanceId, !!suppressEmit);
            }
        }
        this.cancelSublistLine = cancelSublistLine;

        function resetSublistLine(sublistId, lineInstanceId, defaultValues, useBuffer)
        {
            if(isSublistLineInstanceIdValid(sublistId, lineInstanceId, useBuffer))
            {
                var sublistline = getSublistLineForInstance(sublistId, lineInstanceId, useBuffer);
                var newSublistlineOptions = {
                        asBuffer: !!useBuffer,
                        id: sublistline.id,
                        lineInstanceId: sublistline.getFieldValue('_id'),
                        lineIndex: sublistline.index,
                        sequence: sublistline.getFieldValue('_sequence'),
                        defaultLineData: defaultValues
                    };

                var resetSublistline = createSublistLine(newSublistlineOptions);

                var sublistsController = useBuffer ? sublistsBuffers : sublists;
                sublistsController.putSublistLine(resetSublistline);
            }
        }
        this.resetSublistLine = resetSublistLine;

        function getSublistSelectedLineIndex(sublistId)
        {
            var result = -1;
            var sublistline = getSublistSelectedLine(sublistId);
            if(!!sublistline)
            {
                result = sublistline.index;
            }

            return result;
        }
        this.getSublistSelectedLineIndex = getSublistSelectedLineIndex;

        function commitSublistLine(sublistId, lineInstanceId)
        {
            var useBuffer = true;
            var sublistlineBuffer = getSublistLineForInstance(sublistId, lineInstanceId, useBuffer);

            if (!!sublistlineBuffer)
            {
                removeLineBufferForInstance(sublistId, lineInstanceId, true);

                modelEvent.forwardSublistLineEvents(emitter, sublistlineBuffer, false);

                if(!sublists.hasSublistLine(sublistId, sublistlineBuffer.getFieldValue('_id')))
                {
                    doInsert(sublistId, sublistlineBuffer);
                }
                else
                {
                    doUpdate(sublistId, sublistlineBuffer);
                }
            }
        }
        this.commitSublistLine = commitSublistLine;

        function getSubrecordDataForSubmission()
        {
            var result;

            var subrecordLinks = Object.keys(subrecordData.link);
            if (subrecordLinks.length > 0)
            {
                result = {};
                result['subrecord_parent'] = {
                    fields: ['parent'],
                    size: subrecordLinks.length,
                    data: subrecordLinks.map(function (v, i, a)
                                             {
                                                 return [v];
                                             })
                };
            }

            subrecordLinks.forEach(function (sublistId, i1, a1)
                                   {
                                       var link = subrecordData.link[sublistId];

                                       result['children_' + sublistId] = {
                                           fields: ['childfieldname', 'childmachinename', 'childlinktype', 'childtype'],
                                           size: link.length,
                                           data: link.map(function (v2, i2, a2)
                                                          {
                                                              return [v2.childfieldname, v2.childmachinename, v2.childlinktype, v2.childtype];
                                                          })
                                       };

                                       link.forEach(function (v2, i2, a2)
                                                    {
                                                        var fieldId = v2.childfieldname,
                                                                subrecords;

                                                        if(!!v2.sublinks && v2.sublinks.length > 0)
                                                        {
                                                            result['children_' + v2.childmachinename] = {
                                                                fields : ['childfieldname', 'childmachinename', 'childlinktype', 'childtype'],
                                                                size : v2.sublinks.length,
                                                                data : v2.sublinks.map(function(v3, i3, a3){
                                                                    return [v3.childfieldname || null, v3.childmachinename, v3.childlinktype, v3.childtype];
                                                                })
                                                            };
                                                        }

                                                        if(!!v2.sublinks && v2.sublinks.length > 0)
                                                        {
                                                            result['children_' + v2.childmachinename] = {
                                                                fields : ['childfieldname', 'childmachinename', 'childlinktype', 'childtype'],
                                                                size : v2.sublinks.length,
                                                                data : v2.sublinks.map(function(v3, i3, a3){
                                                                    return [v3.childfieldname || null, v3.childmachinename, v3.childlinktype, v3.childtype];
                                                                })
                                                            };
                                                        }

                                                        if (sublistId === recordType)
                                                        {
                                                            subrecords = subrecordData.cache.get(null, fieldId);
                                                            subrecords = subrecords === undefined ? [] : [subrecords];
                                                        }
                                                        else
                                                        {
                                                            subrecords = subrecordData.cache.getSublist(sublistId);
                                                            subrecords = subrecords === undefined ? [] :
                                                                Object.keys(subrecords).map(function(lineInstanceId){
                                                                    var cache = subrecords[lineInstanceId];
                                                                    return !!cache && cache.get(fieldId) || undefined;
                                                                }).reduce(function (p, c){
                                                                    if (c !== undefined)
                                                                    {
                                                                        p.push(c);
                                                                    }
                                                                    return p;
                                                                }, []);
                                                        }

                                                        if (subrecords.length > 0)
                                                        {

                                                            subrecords.forEach(function (v3, i3, a3)
                                                                               {
                                                                                   var initial = v3.initial, current = v3.current;

                                                                                   var isExistingSubrecord = !!initial && !!current && initial.getValueAsLegacyString(subrecordUtil.SYS_ID) === current.getValueAsLegacyString(subrecordUtil.SYS_ID);
                                                                                   if (isExistingSubrecord)
                                                                                   {
                                                                                       storeSubrecordAsSublist(result, current, 'EDIT', v2.childmachinename, v2.sublinks);
                                                                                   }
                                                                                   else
                                                                                   {
                                                                                       var isNewSubrecord = !!current;
                                                                                       if (isNewSubrecord)
                                                                                       {

                                                                                           storeSubrecordAsSublist(result, current, 'CREATE', v2.childmachinename, v2.sublinks);
                                                                                       }
                                                                                       var isSubrecordDeleted = !!initial;
                                                                                       if (isSubrecordDeleted)
                                                                                       {
                                                                                           storeSubrecordAsSublist(result, initial, 'DELETE', v2.childmachinename, v2.sublinks);

                                                                                       }
                                                                                   }
                                                                               });
                                                        }
                                                    });
                                   });
            return result;
        }
        this.getSubrecordDataForSubmission = getSubrecordDataForSubmission;

        function storeSubrecordAsSublist(data, record, operation, childmachinename, sublinks)
        {
            var fieldIds = [subrecordUtil.SYS_OP].concat(record.getFields());
            var values = fieldIds.map(function(fieldId){return recordUtil.emptyIfNullOrUndefined(record.getValueAsLegacyString(fieldId));});
            values[0] = operation;

            storeAsSublist(data, childmachinename, fieldIds, values);
            storeSubrecordSublistsAsSublist(data, record, operation, sublinks);
        }
        function storeSubrecordSublistsAsSublist(data, record, operation, sublinks)
        {
            if(!!sublinks && sublinks.length > 0)
            {
                sublinks.forEach(function (sublink){
                    storeSubrecordSublistAsSublist(data, record, sublink.childtype, operation, sublink.childmachinename, sublink.childfieldname);
                });
            }
        }
        function storeSubrecordSublistAsSublist(data, record, sublistId, operation, childmachinename, childfieldname)
        {
            var fieldIds, values;

            if (childfieldname === 'null')
            {
                fieldIds = [subrecordUtil.SYS_OP, subrecordUtil.SYS_PARENT_ID, subrecordUtil.SYS_ID].concat(record.getSublistFields(sublistId));

                for (var line_0 = 0; line_0 < record.doGetLineCount(sublistId); line_0 += 1)
                {
                    values = fieldIds.map(function (fieldId) {return recordUtil.emptyIfNullOrUndefined(record.getSublistLineValueAsLegacyString(sublistId, fieldId, line_0));});
                    values[0] = operation;

                    if (operation === 'EDIT')
                    {
                        if (!record.getSublistState(sublistId).isLineChanged(line_0))
                        {
                            values[0] = 'VIEW';
                        }
                        if (record.getSublistState(sublistId).isLineInserted(line_0))
                        {
                            values[0] = 'CREATE';
                        }
                    }

                    storeAsSublist(data, childmachinename, fieldIds, values);
                }
            }
        }

        function storeAsSublist(sublistData, sublistId, fieldIds, values)
        {
            sublistData[sublistId] = sublistData[sublistId] || {};
            sublistData[sublistId].fields = sublistData[sublistId].fields || fieldIds;
            sublistData[sublistId].data = sublistData[sublistId].data || [];
            sublistData[sublistId].data.push(values);
            sublistData[sublistId].size = sublistData[sublistId].data.length;
        }


        function getData()
        {
            return {body: bodyFields, sublists: getSublistData()};
        }
        this.getData = getData;

        function getSublistData()
        {
            var sublistData = {};
	        sublists.getSublists().forEach(function(sublistId){
                var currentLine = getSublistSelectedLine(sublistId);
                sublistData[sublistId] = {currentline: (!!currentLine ? currentLine.toJSON() : {})};

                sublists.getSublistLinesAsOrderedList(sublistId).
                    forEach(function(sublistline) {
                        sublistData[sublistId]['line ' + sublistline.getFieldValue('_sequence')] = sublistline.toJSON();
                    });
            });

            return sublistData;
        }
        this.getSublistData = getSublistData;

	    function getSublistLineJSON(sublistId, lineInstanceId, useBuffer)
	    {
		    return getSublistLineForInstance(sublistId, lineInstanceId, useBuffer).toJSON();
	    }
	    this.getSublistLineJSON = getSublistLineJSON;

        function getClonedData()
        {
            return {
                        bodyField: getClonedBodyFields(),
                        sublist: getClonedSublistData(),
                        subrecord: recordDataObj.subrecord
                    };
        }
        this.getClonedData = getClonedData;

        function cloneRecordValue(val)
        {
            var clone = val;
            if(util.isObject(val))
            {
                clone = recordUtil.clone({},val);
            }
            else if(util.isArray(val))
            {
                clone = val.map(function(entry){
                    return cloneRecordValue(entry);
                })
            }
            else if(util.isDate(val))
            {
                clone = new Date(val);
            }

            return clone;
        }

        function getClonedBodyFields()
        {
            var clone = {};
            recordUtil.forEachProperty(bodyFields, function(fieldId, value){
                clone[fieldId] = cloneRecordValue(value);
            });

            return clone;
        }

        function getClonedSublistData()
        {
            return getSublists().reduce(function(result, sublistId){
                result[sublistId] = sublists.getSublistLinesAsOrderedList(sublistId).
                    map(function(sublistline){
                        var rawData = sublistline.getData();
                        var clonedLine = {};
                        recordUtil.forEachProperty(rawData, function(fieldId, value){
                            clonedLine[fieldId] = cloneRecordValue(value);
                        });

                        return clonedLine;
                    });

                return result;
            }, {});
        }

        function toJSON()
        {
            var currentLines = {};
            return {
                body: bodyFields,
                sublists: getSublists().reduce(function(result, sublistId){
                    result[sublistId] = sublists.getSublistLinesAsOrderedList(sublistId);

                    return result;
                },{}),
                currentsublists: sublistsBuffers.getSublists().reduce(function(result, sublistId){
                    if(sublistsSelectedLineInstanceIds.has(sublistId))
                    {
                        var lineInstanceId = sublistsSelectedLineInstanceIds.get(sublistId);
                        result[sublistId] = sublistsBuffers.getSublistLine(sublistId, lineInstanceId);
                    }

                    return result;
                },{})
            };
        }

        function shouldSetupSublistSystemId(id)
        {
            var hasExplicitLink = !!subrecordData.link[id];
            var hasImplicitLink = !!getBodyValue(subrecordUtil.SYS_ID) &&
                                  !!getBodyValue(subrecordUtil.SYS_PARENT_ID) && getBodyValue(subrecordUtil.SYS_PARENT_ID) !== '0';

            return hasExplicitLink || hasImplicitLink;
        }
        this.shouldSetupSublistSystemId = shouldSetupSublistSystemId;

        /**
         * retrieve the select option text from the cache by value
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {string} value
         */
        function getSelectOptionTextFromCache(sublistId, fieldId, value)
        {
            return optionTextCache.get(sublistId, fieldId, value);
        }
        this.getSelectOptionTextFromCache = getSelectOptionTextFromCache;

        /**
         * cache the option text into cache
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {string} value
         * @param {string} text
         */
        function cacheSelectOptionText(sublistId, fieldId, value, text)
        {
            optionTextCache.set(sublistId, fieldId, value, text);
        }
        this.cacheSelectOptionText = cacheSelectOptionText;
    }

    return {
        /**
         * create record model
         * @param options
         * @returns {Model}
         */
        create: function create(options)
        {
            return new Model(options);
        }
    };
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/recordCache
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/recordCache',[], function(){

    /**
     * javascript object for holding cached object for record
     *
     * @protected
     * @return {RecordCache}
     * @constructor
     */
    function RecordCache()
    {
        var cache = {};

        /**
         * return true if entry existed
         *
         * @param {string} fieldId
         * @return {boolean}
         */
        function has(fieldId)
        {
            return cache.hasOwnProperty(fieldId);
        }
        this.has = has;

        /**
         * cache an entry
         *
         * @param {string} fieldId
         * @param {*} object
         */
        function put(fieldId, object)
        {
            cache[fieldId] = object;
        }
        this.put = put;

        /**
         * return a cached entry
         *
         * @param {string} fieldId
         * @return {*}
         */
        function get(fieldId)
        {
            return cache[fieldId];
        }
        this.get = get;

        /**
         * delete a cached entry
         *
         * @param {string} fieldId
         */
        function invalidate(fieldId)
        {
            delete cache[fieldId];
        }
        this.invalidate = invalidate;

        /**
         * get all cache keys
         *
         */
        function keys()
        {
            var keys = [];
            for(var k in cache)
                if(cache.hasOwnProperty(k))
                    keys[keys.length] = k;

            return keys;
        }
        this.keys = keys;
        return this;
    }

    return {
        /**
         * return a new instance of RecordCache
         * @returns {RecordCache}
         */
        create: function() { return new RecordCache(); }
    };
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/recordCacheController
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/recordCacheController',['N/record/recordCache'], function(recordCache){

    /**
     * record cache controller
     *
     * @protected
     * @return {RecordCacheController}
     * @constructor
     */
    function RecordCacheController()
    {
        var body = recordCache.create();
        var sublists = {};
        var sublistsBuffers = {};

        /**
         * put an entry into given record cache
         *
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {string} lineId
         * @param {boolean} useBuffer
         */
        function has(sublistId, fieldId, lineId, useBuffer)
        {
            var result = false;
            var cache = getRecordCache(sublistId, lineId, useBuffer);
            if(cache)
                result = cache.has(fieldId);

            return result;
        }
        this.has = has;

        /**
         * put an entry into given record cache
         *
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {string} lineId
         * @param {boolean} useBuffer
         * @param {*} object
         */
        function put(sublistId, fieldId, lineId, object, useBuffer)
        {
            var cache = getRecordCache(sublistId, lineId, useBuffer);
            if(cache)
                cache.put(fieldId, object);
        }
        this.put = put;

        /**
         * get an entry from given record cache
         *
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {string} lineId
         * @param {boolean} useBuffer
         * @return {RecordCache}
         */
        function get(sublistId, fieldId, lineId, useBuffer)
        {
            var obj;
            var cache = getRecordCache(sublistId, lineId, useBuffer);
            if(cache)
                obj = cache.get(fieldId);

            return obj;
        }
        this.get = get;

        /**
         * invalidate an entry for given record cache
         *
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {string} lineId
         * @param {boolean} useBuffer
         */
        function invalidate(sublistId, fieldId, lineId, useBuffer)
        {
            var cache = null;

            if(!sublistId)
            {
                cache = getRecordCache();
            }
            else
            {
                if(!!lineId)
                {
                    if(!!fieldId)
                    {
                        cache = getRecordCache(sublistId, lineId, useBuffer);
                    }
                    else
                    {
                        var sublist = !!useBuffer ? getSublistBuffer(sublistId) : getSublist(sublistId);
                        delete sublist[lineId];
                    }
                }
                else
                {
                    if(useBuffer)
                    {
                        delete sublistsBuffers[sublistId];
                    }
                    else
                    {
                        delete sublists[sublistId];
                    }
                }
            }

            if(!!cache)
            {
                cache.invalidate(fieldId);
            }
        }
        this.invalidate = invalidate;

        /**
         * invalidate the sublist cache
         * @param {String} sublistId
         */
        function invalidateSublist(sublistId)
        {
            invalidate(sublistId, null, null, false);
        }
        this.invalidateSublist = invalidateSublist;

        /**
         * get record cache
         *
         * @param {string} sublistId
         * @param {string} lineId
         * @param {boolean} useBuffer
         * @return {RecordCache}
         */
        function getRecordCache(sublistId, lineId, useBuffer)
        {
            var cache = null;
            if (!!sublistId)
            {
                cache = getSublistCache(sublistId, lineId, useBuffer);
            }
            else
            {
                cache = body
            }

            return cache;
        }

        /**
         * get sublist cache
         *
         * @param {string} sublistId
         * @return {Object} sublist cache with sublistId as key
         */
        function getSublist(sublistId)
        {
            if (!sublists.hasOwnProperty(sublistId))
                sublists[sublistId] = {};
            return sublists[sublistId];
        }
        this.getSublist = getSublist;

        /**
         * get sublist buffer cache
         *
         * @param {string} sublistId
         * @return {Object} sublist buffer cache with sublistId as key
         */
        function getSublistBuffer(sublistId)
        {
            if (!sublistsBuffers.hasOwnProperty(sublistId))
                sublistsBuffers[sublistId] = {};
            return sublistsBuffers[sublistId];
        }
        this.getSublistBuffer = getSublistBuffer;

        /**
         * get sublist cache by line id
         *
         * @param {string} sublistId
         * @param {string} lineId
         * @param {boolean} useBuffer
         * @return {RecordCache}
         */
        function getSublistCache(sublistId, lineId, useBuffer)
        {
            var sublist = !!useBuffer ? getSublistBuffer(sublistId) : getSublist(sublistId);

            var cache = sublist[lineId] || null;
            if(!cache)
            {
                cache = sublist[lineId] = recordCache.create();
            }
            return cache;
        }

        function fields(sublistId, lineId, useBuffer)
        {
            var cache = getRecordCache(sublistId, lineId, useBuffer);
            return cache.keys();
        }
        this.fields = fields;

        /**
         * copy/clone the data from sublist cache to sublist buffer cache
         * @param {String} sublistId
         * @param {String} lineId
         * @param {Function} function to migrate the cache arg1 is fieldId, arg2 is the entry to be migrated, arg3 is sublist buffer cache
         */
        function migrateFromSublistToSublistBuffer(sublistId, lineId, functionToMigrate)
        {
                    var sublistBufferCache = getSublistCache(sublistId, lineId, true);
            var sublistCache = getSublistCache(sublistId, lineId, false);

            sublistCache.keys().forEach(function(cacheKey){
                functionToMigrate(cacheKey, sublistCache.get(cacheKey), sublistBufferCache);
            });
        }
        this.migrateFromSublistToSublistBuffer = migrateFromSublistToSublistBuffer;


        /**
         * commit the data in sublist buffer cache to sublist cache
         * @param {String} sublistId
         * @param {String} lineId
         * @param {Function}functionToCommit function to commit the sublist buffer cache: arg1 is fieldId, arg2 is the entry to be committed, arg3 is sublist cache
         */
        function commitFromSublistBufferToSublist(sublistId, lineId, functionToCommit)
        {
            var sublistCache = getSublistCache(sublistId, lineId, false);
            var sublistBufferCache = getSublistCache(sublistId, lineId, true);

            sublistBufferCache.keys().forEach(function(cacheKey){
                functionToCommit(cacheKey, sublistBufferCache.get(cacheKey), sublistCache);
            });
        }
        this.commitFromSublistBufferToSublist = commitFromSublistBufferToSublist;

        return this;
    }


    return {
        /**
         * get a new instance of RecordCacheController
         * @return {RecordCacheController}
         */
        create: function()
        {
            return new RecordCacheController();
        }
    }
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/modelController
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/modelController',['N/record/model', 'N/record/recordCacheController', 'N/utilityFunctions', 'N/record/recordUtilityFunctions', 'N/record/subrecordUtilityFunctions'],
	function(model, recordCacheController, utilityFunctions, recordUtil, subrecordUtil){

    /**
     *
     * @param {Object} options
     * @param {string} options.type recordType
     * @param {string} options.sublistFieldState recordType
     * @returns {ModelController}
     * @constructor
     */
    function ModelController(options)
    {
        var recordType = options.type;
        var sublistFieldStates = {};
        var fieldObjectCache = recordCacheController.create();
        var userFieldCache = recordCacheController.create();
        var selectOptionsCache = recordCacheController.create();
        var subrecordCache = recordCacheController.create();
        var subrecordTracker = {};

        options.subrecordCache = subrecordCache;
        var _model = model.create(options);


        (function setSublistFieldState(sublistFieldState)
        {
            recordUtil.forEachProperty(sublistFieldState, function(sublistId, lines){
                sublistFieldStates[sublistId] = [];
                for (var line = 0; line < lines.length; line++)
                {
                    sublistFieldStates[sublistId][line] = {};
                    for (var fieldId in lines[line])
                    {
                        if (lines[line].hasOwnProperty(fieldId))
                        {
                            var state = lines[line][fieldId];
                            sublistFieldStates[sublistId][line][fieldId] = util.extend({}, state);
                        }
                    }
                }
            })
        })(options.sublistFieldState || {});


        /**
         * get the persisted field states
         * @param {string} sublistId
         * @param {Number} line
         * @returns {Object}
         */
        function getSublistFieldStates(sublistId, line)
        {
            return sublistFieldStates.hasOwnProperty(sublistId) &&
                   line >= 0 ? sublistFieldStates[sublistId][line] : null;
        }
        this.getSublistFieldStates = getSublistFieldStates;

        /**
         * return true if field exists
         * @param fieldId
         * @returns {boolean}
         */
        function hasFieldValue (fieldId) {
            return _model.hasBodyValue(fieldId);
        }
        this.hasFieldValue = hasFieldValue;

        function getSublistSelectedLineInstanceId(sublistId)
        {
            return _model.getSublistSelectedLineInstanceId(sublistId);
        }
        this.getSublistSelectedLineInstanceId = getSublistSelectedLineInstanceId;

        function isSublistLineInstanceIdValid(sublistId, lineInstanceId, useBuffer)
        {
            return _model.isSublistLineInstanceIdValid(sublistId, lineInstanceId, useBuffer);
        }
        this.isSublistLineInstanceIdValid = isSublistLineInstanceIdValid;

        function isSublistLineInstanceIdValidWithFallback(sublistId, lineInstanceId, useBuffer)
        {
            var exists = isSublistLineInstanceIdValid(sublistId, lineInstanceId, useBuffer);
            if (!exists && useBuffer)
                exists = isSublistLineInstanceIdValid(sublistId, lineInstanceId, !useBuffer);
            return exists;
        }
        this.isSublistLineInstanceIdValidWithFallback = isSublistLineInstanceIdValidWithFallback;

        function getSublistLineForInstance(sublistId, lineInstanceId, useBuffer)
        {
            return _model.getSublistLineForInstance(sublistId, lineInstanceId, useBuffer);
        }
        this.getSublistLineForInstance = getSublistLineForInstance;

        function isSublistLineInstanceIdSelected(sublistId, lineInstanceId)
        {
            return _model.isSublistLineInstanceIdSelected(sublistId, lineInstanceId);
        }
        this.isSublistLineInstanceIdSelected = isSublistLineInstanceIdSelected;

        /**
         * set value by js primitive form for body field
         * @param {string} fieldId
         * @param {Object} value
         */
        function setParsedValueForBodyField(fieldId, value)
        {
            _model.setBodyValuePrimitive(fieldId, value);
        }
        this.setParsedValueForBodyField = setParsedValueForBodyField;

        function setParsedValueForSublistFieldForInstance(sublistId, lineInstanceId, fieldId, value, useBuffer)
        {
            _model.setSublistLineValuePrimitive(sublistId, lineInstanceId, fieldId, value, useBuffer);
        }
        this.setParsedValueForSublistFieldForInstance = setParsedValueForSublistFieldForInstance;

        /**
         * set value by js primitive form for sublist field
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Number} line
         * @param value
         */
        function setParsedValueForSublistField(sublistId, fieldId, line, value)
        {
            var useBuffer = false;
            var lineInstanceId = getSublistLineInstanceIdForLine(sublistId, line, useBuffer);
            setParsedValueForSublistFieldForInstance(sublistId, lineInstanceId, fieldId, value, useBuffer);
        }
        this.setParsedValueForSublistField = setParsedValueForSublistField;

        /**
         * set value by js primitive form for current sublist field
         * @param {string} sublistId
         * @param {string} fieldId
         * @param value
         */
        function setParsedValueForCurrentSublistField(sublistId, fieldId, value)
        {
            var useBuffer = true;
            var lineInstanceId = getSublistSelectedLineInstanceId(sublistId);
            setParsedValueForSublistFieldForInstance(sublistId, lineInstanceId, fieldId, value, useBuffer);
        }
        this.setParsedValueForCurrentSublistField = setParsedValueForCurrentSublistField;

        function setParsedValueForSublistLineBufferField(sublistId, lineInstanceId, fieldId, value)
        {
            var useBuffer = true;
            setParsedValueForSublistFieldForInstance(sublistId, lineInstanceId, fieldId, value, useBuffer);
        }
        this.setParsedValueForSublistLineBufferField = setParsedValueForSublistLineBufferField;

        /**
         * set field value
         * @param {string} fieldId
         * @param {Object} recordFieldValue
         * @param {string|Number|Boolean|Date} recordFieldValue.value
         * @param {string} recordFieldValue.legacyStringValue
         */
        function setFieldValue(fieldId, recordFieldValue)
        {
            _model.setBodyValue(fieldId, recordFieldValue);
        }
        this.setFieldValue = setFieldValue;

        /**
         * return the primitive value for body field
         * @param {string} fieldId
         * @returns {string}
         */
        function getFieldValue(fieldId)
        {
            return hasFieldValue(fieldId) ? _model.getBodyValue(fieldId) : "";
        }
        this.getFieldValue = getFieldValue;

        /**
         * return the value for body field as legacy string format
         * @param {string} fieldId
         * @returns {string}
         */
        function getValueAsLegacyString(fieldId)
        {
            return hasFieldValue(fieldId) ? _model.getBodyValueAsLegacyString(fieldId) : null;
        }
        this.getValueAsLegacyString = getValueAsLegacyString;

        /**
         * return list of all body fields with value
         * @returns {string[]}
         */
        function getBodyFieldIds()
        {
            return _model.getBodyFieldIds();
        }
        this.getBodyFieldIds = getBodyFieldIds;

        /**
         * remove field
         * @param {string} fieldId
         */
        function removeFieldValue(fieldId)
        {
            _model.removeBodyValue(fieldId);
            invalidateRecordCacheForInstance(null, fieldId, null);
        }
        this.removeFieldValue = removeFieldValue;

        /**
         * remove all sublist line
         * @param {string} sublistId
         */
        function clearSublistData(sublistId)
        {
            for(var line = getSublistLineCount(sublistId)-1; line >= 0; line --)
                removeSublistLine(sublistId,line);
        }
        this.clearSublistData = clearSublistData;

        /**
         * @returns {string[]} list of sublist in model
         */
        function getSublists()
        {
            return _model.getSublists();
        }
        this.getSublists = getSublists;

        /**
         * get sublist line count
         * @param {string} sublistId
         * @returns {Number}
         */
        function getSublistLineCount(sublistId)
        {
            return _model.getSublistLineCount(sublistId);
        }
        this.getSublistLineCount = getSublistLineCount;

	    /**
	     * get sublist line count
	     * @param {string} sublistId
	     * @returns {Number}
	     */
	    function doesSublistExist(sublistId, useBuffer)
	    {
		    return _model.doesSublistExist(sublistId, useBuffer);
	    }
	    this.doesSublistExist = doesSublistExist;	    

        /**
         * get the index for new line
         * @param {string} sublistId
         * @return {Number} new line index
         */
        function getNewLineIndex(sublistId)
        {
            return _model.getSublistNewLineIndex(sublistId);
        }
        this.getNewLineIndex = getNewLineIndex;


        function hasSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer)
        {
            return _model.hasSublistLineValue(sublistId, lineInstanceId, fieldId, useBuffer);
        }
        this.hasSublistLineValueForInstance = hasSublistLineValueForInstance;

        /**
         * return true if sublist field has value
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Number} line
         * @returns {Boolean}
         */
        function hasSublistLineValue(sublistId, fieldId, line)
        {
            var useBuffer = false;
            var lineInstanceId = getSublistLineInstanceIdForLine(sublistId, line, useBuffer);
            var result = hasSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer);

            return result;
        }
        this.hasSublistLineValue = hasSublistLineValue;

        function getSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer)
        {
            return _model.getSublistLineValue(sublistId, lineInstanceId, fieldId, useBuffer);
        }
        this.getSublistLineValueForInstance = getSublistLineValueForInstance;

        /**
         * return the primitive value for sublist field
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Number} line
         * @returns {string|Number|Boolean|Date}
         */
        function getSublistLineValue(sublistId, fieldId, line)
        {
            var useBuffer = false;
            var lineInstanceId = getSublistLineInstanceIdForLine(sublistId, line, useBuffer);
            var result = getSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer);

            return result;
        }
        this.getSublistLineValue = getSublistLineValue;

        function getSublistLineValueAsLegacyStringForInstance(sublistId, fieldId, lineInstanceId, useBuffer)
        {
            return _model.getSublistLineValueAsLegacyString(sublistId, lineInstanceId, fieldId, useBuffer);
        }
        this.getSublistLineValueAsLegacyStringForInstance = getSublistLineValueAsLegacyStringForInstance;

        /**
         * return the value for sublist field as legacy string format
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Number} line
         * @returns {string}
         */
        function getSublistLineValueAsLegacyString(sublistId, fieldId, line)
        {
            var useBuffer = false;
            var lineInstanceId = getSublistLineInstanceIdForLine(sublistId, line, useBuffer);
            var result = getSublistLineValueAsLegacyStringForInstance(sublistId, fieldId, lineInstanceId, useBuffer);

            return result;
        }
        this.getSublistLineValueAsLegacyString = getSublistLineValueAsLegacyString;

        function setSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, recordFieldValue, useBuffer)
        {
            _model.setSublistLineValue(sublistId, lineInstanceId, fieldId, recordFieldValue, useBuffer);
        }
        this.setSublistLineValueForInstance = setSublistLineValueForInstance;

        /**
         * set sublist value
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Number} line
         * @param {Object} recordFieldValue
         * @param {string|Number|Boolean|Date} recordFieldValue.value
         * @param {string} recordFieldValue.legacyStringValue
         */
        function setSublistLineValue(sublistId, fieldId, line, recordFieldValue)
        {
            var useBuffer = false;
            var lineInstanceId = getSublistLineInstanceIdForLine(sublistId, line, useBuffer);
            var result = setSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, recordFieldValue, useBuffer);

            return result;
        }
        this.setSublistLineValue = setSublistLineValue;

        function insertSublistLineForInstance(sublistId, beforeLineInstanceId)
        {
            var lineInstanceId = _model.insertSublistLine(sublistId, beforeLineInstanceId);
            if(!!lineInstanceId)
            {
                setupSublistSubrecordSystemId(sublistId, lineInstanceId);
                insertLineForRecordCacheForInstance(sublistId, lineInstanceId);
            }

            return lineInstanceId;
        }
        this.insertSublistLineForInstance = insertSublistLineForInstance;

        /**
         * insert sublist line
         * @param {string} sublistId
         * @param {Number} line 0 based index
         */
        function insertSublistLine(sublistId, line)
        {
            var useBuffer = false;
            var beforeLineInstanceId = getSublistLineInstanceIdForLine(sublistId, line, useBuffer);
            var lineInstanceId = insertSublistLineForInstance(sublistId, beforeLineInstanceId);

            return lineInstanceId;
        }
        this.insertSublistLine = insertSublistLine;

        function updateNewLineBufferWithCopy(sublistId, lineToCopy)
        {
	        var useBuffer = true;
	        var currentNewLineIndex = getNewLineIndex(sublistId);
	        var currentNewLineInstanceId = getSublistLineInstanceIdForLine(sublistId, currentNewLineIndex, useBuffer);
	        var sublistLineOptions = {
		        asBuffer: useBuffer,
		        id: sublistId,
		        lineInstanceId: currentNewLineInstanceId,
		        lineIndex: currentNewLineIndex,
		        sequence: currentNewLineIndex,
		        toBeCloned: lineToCopy
	        };
	        return _model.updateNewLineBufferWithCopy(sublistLineOptions);
        }
        this.updateNewLineBufferWithCopy = updateNewLineBufferWithCopy;

        function putCopyIntoNewLineBuffer(sublistId, lineToCopy)
        {
            return _model.putCopyIntoNewLineBuffer(sublistId, lineToCopy);
        }
        this.putCopyIntoNewLineBuffer = putCopyIntoNewLineBuffer;

        function setupSublistSubrecordSystemId(sublistId, lineInstanceId)
        {
            if (_model.shouldSetupSublistSystemId(sublistId))
            {
                var sys_id = String(-1 * subrecordUtil.getNextSysId());
                var parent_sys_id =  String(getFieldValue(subrecordUtil.SYS_ID));
                var useBuffer = false;
                setSublistLineValueForInstance(sublistId, subrecordUtil.SYS_ID, lineInstanceId, {value: sys_id, legacyStringValue: sys_id}, useBuffer);
                setSublistLineValueForInstance(sublistId, subrecordUtil.SYS_PARENT_ID, lineInstanceId, {value: parent_sys_id, legacyStringValue: parent_sys_id}, useBuffer);
            }
        }

        function setupCurrentSublistSubrecordSystemId(sublistId)
        {
            if (_model.shouldSetupSublistSystemId(sublistId))
            {
                var sys_id = String(-1 * subrecordUtil.getNextSysId());
                var parent_sys_id =  String(getFieldValue(subrecordUtil.SYS_ID));
                setCurrentSublistLineValue(sublistId, subrecordUtil.SYS_ID, {value: sys_id, legacyStringValue: sys_id});
                setCurrentSublistLineValue(sublistId, subrecordUtil.SYS_PARENT_ID, {value: parent_sys_id, legacyStringValue: parent_sys_id});
            }
        }


        function removeSublistLineForInstance(sublistId, lineInstanceId)
        {
            var useBuffer = false;
            var lineExists = isSublistLineInstanceIdValid(sublistId, lineInstanceId, useBuffer);

            if(lineExists)
            {
                _model.removeSublistLine(sublistId, lineInstanceId);
                removeLineForRecordCacheForInstance(sublistId, lineInstanceId);
            }
        }
        this.removeSublistLineForInstance = removeSublistLineForInstance;

        /**
         * remove sublist line
         * @param {string} sublistId
         * @param {Number} line 0 based index
         */
        function removeSublistLine(sublistId, line)
        {
            var useBuffer = false;
            var lineInstanceId = getSublistLineInstanceIdForLine(sublistId, line, useBuffer);

            removeSublistLineForInstance(sublistId, lineInstanceId);
        }
        this.removeSublistLine = removeSublistLine;

        function removeSublistFieldValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer)
        {
            if(isSublistLineInstanceIdValid(sublistId, lineInstanceId, useBuffer))
            {
                _model.removeSublistLineValue(sublistId, lineInstanceId, fieldId, useBuffer);
                invalidateRecordCacheForInstance(sublistId, fieldId, lineInstanceId);
            }
        }
        this.removeSublistFieldValueForInstance = removeSublistFieldValueForInstance;

        /**
         * remove sublist field value
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Number} line 0 based index
         */
        function removeSublistFieldValue(sublistId, fieldId, line)
        {
            var useBuffer = false;
            var lineInstanceId = getSublistLineInstanceIdForLine(sublistId, line, useBuffer);

            removeSublistFieldValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
        }
        this.removeSublistFieldValue = removeSublistFieldValue;

        /**
         * get a list of fields in the currently selected sublist line
         * @param {string} sublistId
         * @return {string[]}
         */
        function getCurrentSublistFieldIds(sublistId)
        {
            var useBuffer = true;
            var lineInstanceId = getSublistSelectedLineInstanceId(sublistId);

            return getSublistLineFieldIds(sublistId, lineInstanceId, useBuffer);
        }
        this.getCurrentSublistFieldIds = getCurrentSublistFieldIds;

        function getSublistLineFieldIds(sublistId, lineInstanceId, useBuffer)
        {
            return _model.getSublistLineFieldIds(sublistId, lineInstanceId, useBuffer);
        }
        this.getSublistLineFieldIds = getSublistLineFieldIds;

        function selectSublistLineForInstance(sublistId, lineInstanceId)
        {
            var resultLineInstanceId = null;
            var useBuffer = false;
            var lineInstanceExists = isSublistLineInstanceIdValid(sublistId, lineInstanceId, useBuffer);

            if(lineInstanceExists)
            {
                resultLineInstanceId = lineInstanceId;
                var lineInstanceIsSelected = isSublistLineInstanceIdSelected(sublistId, lineInstanceId);
                if(!lineInstanceIsSelected)
                {
                    var selectedLineInstanceId = getSublistSelectedLineInstanceId(sublistId);
                    var selectedLineIsUncommitted = !isSublistLineInstanceIdValid(sublistId, selectedLineInstanceId, useBuffer);
                    if(selectedLineIsUncommitted)
                    {
                        removeLineForRecordCacheForInstance(sublistId, selectedLineInstanceId);
                    }

                    invalidateCurrentSublistRecordCache(sublistId);
                    _model.selectSublistLine(sublistId, lineInstanceId);
                }
            }

            return resultLineInstanceId;
        }
        this.selectSublistLineForInstance = selectSublistLineForInstance;

        /**
         * select line
         * @param {string} sublistId
         * @param {Number} line
         */
        function selectSublistLine(sublistId, line)
        {
            var useBuffer = false;
            var lineInstanceId = getSublistLineInstanceIdForLine(sublistId, line, useBuffer);

            lineInstanceId = selectSublistLineForInstance(sublistId, lineInstanceId);

            return lineInstanceId;
        }
        this.selectSublistLine = selectSublistLine;

        /**
         * select new line
         * @param {string} sublistId
         * @param {Object} defaultValues
         */
        function selectNewSublistLine(sublistId, defaultValues)
        {
            var lineInstanceId = _model.getSublistSelectedLineInstanceId(sublistId);

            if(getCurrentSublistLineIndex(sublistId) != getNewLineIndex(sublistId))
            {
                lineInstanceId = _model.selectNewSublistLine(sublistId, defaultValues);
                setupCurrentSublistSubrecordSystemId(sublistId);
            }

            return lineInstanceId;
        }
        this.selectNewSublistLine = selectNewSublistLine;

        function cancelSublistLineForInstance(sublistId, lineInstanceId)
        {
            invalidateSublistRecordCacheForInstance(sublistId, lineInstanceId);
            _model.cancelSublistLine(sublistId, lineInstanceId);
        }
        this.cancelSublistLineForInstance = cancelSublistLineForInstance;

        function cancelCurrentSublistLine(sublistId)
        {
            var lineInstanceId = getSublistSelectedLineInstanceId(sublistId);

            cancelSublistLineForInstance(sublistId, lineInstanceId);
        }
        this.cancelCurrentSublistLine = cancelCurrentSublistLine;

        function resetSublistLineForInstance(sublistId, lineInstanceId, defaultValues, useBuffer)
        {
            if(useBuffer)
            {
                invalidateSublistRecordCacheForInstance(sublistId, lineInstanceId);
            }

            _model.resetSublistLine(sublistId, lineInstanceId, defaultValues);
        }
        this.resetSublistLineForInstance = resetSublistLineForInstance;

        function resetSublistLine(sublistId, line, defaultValues)
        {
            var useBuffer = false;
            var lineInstanceId = getSublistLineInstanceIdForLine(sublistId, line, useBuffer);

            if(!!lineInstanceId)
            {
                resetSublistLineForInstance(sublistId, lineInstanceId, defaultValues, useBuffer);
            }
        }
        this.resetSublistLine = resetSublistLine;

        function runFunctionWhileSilentlySelectingLine(sublistId, lineInstanceId, func, thisArg, argList)
        {
	        argList = argList || [];
	        if (util.isFunction(func) && util.isArray(argList))
	        {
        	    _model.runFunctionWhileSilentlySelectingLine(sublistId, lineInstanceId, func, thisArg, argList);
	        }
        }
        this.runFunctionWhileSilentlySelectingLine = runFunctionWhileSilentlySelectingLine;

        /**
         * get index for currently selected line
         * @returns {Number}
         */
        function getCurrentSublistLineIndex(sublistId)
        {
            return _model.getSublistSelectedLineIndex(sublistId);
        }
        this.getCurrentSublistLineIndex = getCurrentSublistLineIndex;

        function getSublistLineInstanceIdForLine(sublistId, line, useBuffer)
        {
            return _model.getSublistLineInstanceIdForIndex(sublistId, line, useBuffer);
        }
        this.getSublistLineInstanceIdForLine = getSublistLineInstanceIdForLine;

        /**
         * get field value in the currently selected line
         * @param {string} sublistId
         * @param {string} fieldId
         */
        function getCurrentSublistLineValue(sublistId, fieldId)
        {
            var useBuffer = true;
            var lineInstanceId = getSublistSelectedLineInstanceId(sublistId);

            return getSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
        }
        this.getCurrentSublistLineValue = getCurrentSublistLineValue;

        function getSublistLineBufferValueForInstance(sublistId, lineInstanceId, fieldId)
        {
            var useBuffer = true;

            return getSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
        }
        this.getSublistLineBufferValueForInstance = getSublistLineBufferValueForInstance;

        /**
         * return the value for sublist field as legacy string format
         * @param {string} sublistId
         * @param {string} fieldId
         * @returns {string}
         */
        function getCurrentSublistLineValueAsLegacyString(sublistId, fieldId)
        {
            var useBuffer = true;
            var lineInstanceId = getSublistSelectedLineInstanceId(sublistId);

            return _model.getSublistLineValueAsLegacyString(sublistId, lineInstanceId, fieldId, useBuffer);
        }
        this.getCurrentSublistLineValueAsLegacyString = getCurrentSublistLineValueAsLegacyString;

        /**
         * update the field in the currently selected line
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Object} recordFieldValue
         * @param {string|Number|Boolean|Date} recordFieldValue.value
         * @param {string} recordFieldValue.legacyStringValue
         */
        function setCurrentSublistLineValue(sublistId, fieldId, recordFieldValue)
        {
            var useBuffer = true;
            var lineInstanceId = getSublistSelectedLineInstanceId(sublistId);

			setSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, recordFieldValue, useBuffer);
        }
        this.setCurrentSublistLineValue = setCurrentSublistLineValue;

        function setSublistLineBufferValueForInstance(sublistId, lineInstanceId, fieldId, recordFieldValue)
        {
            var useBuffer = true;

            setSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, recordFieldValue, useBuffer);
        }
        this.setSublistLineBufferValueForInstance = setSublistLineBufferValueForInstance;

        function hasCurrentSublistLineValue(sublistId, fieldId)
        {
            var useBuffer = true;
            var lineInstanceId = getSublistSelectedLineInstanceId(sublistId);

            return hasSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
        }
        this.hasCurrentSublistLineValue = hasCurrentSublistLineValue;

        function commitSublistLineForInstance(sublistId, lineInstanceId)
        {
            var useBuffer = false;
            var lineInstanceIdIsUncommitted = !isSublistLineInstanceIdValid(sublistId, lineInstanceId, useBuffer);
            if(lineInstanceIdIsUncommitted)
            {
                insertLineForRecordCacheForInstance(sublistId, lineInstanceId);
            }

            _model.commitSublistLine(sublistId, lineInstanceId);
            handleRecordCacheWhileCommittingLine(sublistId, lineInstanceId);
        }
        this.commitSublistLineForInstance = commitSublistLineForInstance;

        /**
         * commit currently selected line
         * @param sublistId
         * @param line
         */
        function commitSublistLine(sublistId, line)
        {
            var useBuffer = true;
            var lineInstanceId = getSublistLineInstanceIdForLine(sublistId, line, useBuffer);
            commitSublistLineForInstance(sublistId, lineInstanceId);
        }
        this.commitSublistLine = commitSublistLine;

        function handleRecordCacheWhileCommittingLine(sublistId, lineInstanceId)
        {
            handleFieldWhileCommittingLine(sublistId, lineInstanceId);
            handleSubrecordsWhileCommittingLine(sublistId, lineInstanceId);
        }

        function handleFieldWhileCommittingLine(sublistId, lineInstanceId)
        {
            fieldObjectCache.commitFromSublistBufferToSublist(sublistId, lineInstanceId, function(fieldId, entryToBeCommitted, sublistCache){
                sublistCache.put(fieldId, entryToBeCommitted);
                fieldObjectCache.invalidate(sublistId, fieldId, lineInstanceId, true);
            });

            userFieldCache.commitFromSublistBufferToSublist(sublistId, lineInstanceId, function(fieldId, entryToBeCommitted, sublistCache){
                sublistCache.put(fieldId, entryToBeCommitted);
                userFieldCache.invalidate(sublistId, fieldId, lineInstanceId, true);
            });
        }

        function handleSubrecordsWhileCommittingLine(sublistId, lineInstanceId)
        {
            subrecordCache.commitFromSublistBufferToSublist(sublistId, lineInstanceId, function(fieldId, entryToBeCommitted, sublistCache){
                var subrecord = entryToBeCommitted.current;
                var useBuffer = false;
                doSetSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer, subrecord);
                useBuffer = true;
                subrecordCache.invalidate(sublistId, fieldId, lineInstanceId, useBuffer);
            });
        }


        /**
         * insert a line buffer to cache
         * @param {string} sublistId
         * @param {string} lineInstanceId
         */
        function insertLineForRecordCacheForInstance(sublistId, lineInstanceId)
        {
            var useBuffer = false;

            userFieldCache.get(sublistId, null, lineInstanceId, useBuffer);
            fieldObjectCache.get(sublistId, null, lineInstanceId, useBuffer);
            selectOptionsCache.get(sublistId, null, lineInstanceId, useBuffer);
            subrecordCache.get(sublistId, null, lineInstanceId, useBuffer);
        }

        /**
         * remove a line buffer to cache
         * @param {string} sublistId
         * @param {string} lineInstanceId
         */
        function removeLineForRecordCacheForInstance(sublistId, lineInstanceId)
        {
            var useBuffer = false;

            userFieldCache.invalidate(sublistId, null, lineInstanceId, useBuffer);
            fieldObjectCache.invalidate(sublistId, null, lineInstanceId, useBuffer);
            selectOptionsCache.invalidate(sublistId, null, lineInstanceId, useBuffer);
            subrecordCache.invalidate(sublistId, null, lineInstanceId, useBuffer);
        }

        /**
         * invalidate a cache object
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Number} lineInstanceId
         */
        function invalidateRecordCacheForInstance(sublistId, fieldId, lineInstanceId)
        {
            var useBuffer = false;

            userFieldCache.invalidate(sublistId, fieldId, lineInstanceId, useBuffer);
            fieldObjectCache.invalidate(sublistId, fieldId, lineInstanceId, useBuffer);
            selectOptionsCache.invalidate(sublistId, fieldId, lineInstanceId, useBuffer);
            subrecordCache.invalidate(sublistId, fieldId, lineInstanceId, useBuffer);
        }

	    /**
	     * invalidate a the field Object Caches when fieldState update occurs.
	     * @param {string} sublistId
	     * @param {string} fieldId
	     * @param {Number} lineInstanceId
	     */
	    function flushBufferCacheForFieldStateUpdate(sublistId, fieldId, lineInstanceId)
	    {
		    var useBuffer = true;
		    userFieldCache.invalidate(sublistId, fieldId, lineInstanceId, useBuffer);
		    fieldObjectCache.invalidate(sublistId, fieldId, lineInstanceId, useBuffer);
	    }
	    this.flushBufferCacheForFieldStateUpdate = flushBufferCacheForFieldStateUpdate;

        function invalidateSublistRecordCacheForInstance(sublistId, lineInstanceId)
        {
            var useBuffer = true;

            fieldObjectCache.invalidate(sublistId, null, lineInstanceId, useBuffer);
            selectOptionsCache.invalidate(sublistId, null, lineInstanceId, useBuffer);
            if(isSublistLineInstanceIdSelected(sublistId, lineInstanceId))
            {
                setCurrentSublistSubrecordCaheEntrysDereferenced(sublistId);
            }
            subrecordCache.invalidate(sublistId, null, lineInstanceId, useBuffer);
        }

        /**
         * invalidate the cache for sublist buffer
         * @param {string} sublistId
         */
        function invalidateCurrentSublistRecordCache(sublistId)
        {
            var useBuffer = true;
            var lineInstanceId = getSublistLineInstanceIdForLine(sublistId, getCurrentSublistLineIndex(sublistId), useBuffer);

            invalidateSublistRecordCacheForInstance(sublistId, lineInstanceId);
        }

	    function shouldUseBuffer(line, useBuffer)
	    {
		    return (line === -1) || useBuffer;
	    }

	    function doGetLineInstanceId(sublistId, line, useBuffer)
	    {
		    var useThisLine = (line === -1) ? getCurrentSublistLineIndex(sublistId) : line;
		    return getSublistLineInstanceIdForLine(sublistId, useThisLine, shouldUseBuffer(line, useBuffer));
	    }

        /**
         * return cache of selec options
         * @returns {RecordCacheController}
         */
        function getSelectOptionCache()
        {
            return selectOptionsCache;
        }
        this.getSelectOptionCache = getSelectOptionCache;

        function cacheSelectOptionsForInstance(sublistId, fieldId, lineInstanceId, options, useBuffer)
        {
            selectOptionsCache.put(sublistId, fieldId, lineInstanceId, options, useBuffer);
        }
        this.cacheSelectOptionsForInstance = cacheSelectOptionsForInstance;

        /**
         * cache select options
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Number} line
         * @param {*} options
         * @param {boolean} useBuffer
         */
        function cacheSelectOptions(sublistId, fieldId, line, options, useBuffer)
        {
			useBuffer = shouldUseBuffer(line, useBuffer);
			var lineInstanceId = doGetLineInstanceId(sublistId, line, useBuffer);

            cacheSelectOptionsForInstance(sublistId, fieldId, lineInstanceId, options, useBuffer);
        }
        this.cacheSelectOptions = cacheSelectOptions;

        function getSelectOptionsForInstance(sublistId, fieldId, lineInstanceId, useBuffer)
        {
            return selectOptionsCache.get(sublistId, fieldId, lineInstanceId, useBuffer);
        }
        this.getSelectOptionsForInstance = getSelectOptionsForInstance;

        /**
         * get select option from cache
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Number} line
         * @param {boolean} useBuffer
         * @returns {*}
         */
        function getSelectOptions(sublistId, fieldId, line, useBuffer)
        {
	        useBuffer = shouldUseBuffer(line, useBuffer);
	        var lineInstanceId = doGetLineInstanceId(sublistId, line, useBuffer);

            return getSelectOptionsForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
        }
        this.getSelectOptions = getSelectOptions;

        function cacheRecordFieldForInstance(sublistId, fieldId, lineInstanceId, field, useBuffer)
        {
            fieldObjectCache.put(sublistId, fieldId, lineInstanceId, field, useBuffer);
        }
        this.cacheRecordFieldForInstance = cacheRecordFieldForInstance;

        /**
         * cache record field object
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Number} line
         * @param field
         * @param {boolean} useBuffer
         */
        function cacheRecordField(sublistId, fieldId, line, field, useBuffer)
        {
	        useBuffer = shouldUseBuffer(line, useBuffer);
	        var lineInstanceId = doGetLineInstanceId(sublistId, line, useBuffer);

            cacheRecordFieldForInstance(sublistId, fieldId, lineInstanceId, field, useBuffer);
        }
        this.cacheRecordField = cacheRecordField;

        function getRecordfieldForInstance(sublistId, fieldId, lineInstanceId, useBuffer)
        {
            return fieldObjectCache.get(sublistId, fieldId, lineInstanceId, useBuffer);
        }
        this.getRecordfieldForInstance = getRecordfieldForInstance;

        /**
         * get cached record field object
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Number} line
         * @param {boolean} useBuffer
         * @returns {RecordField}
         */
        function getRecordfield(sublistId, fieldId, line, useBuffer)
        {
	        useBuffer = shouldUseBuffer(line, useBuffer);
	        var lineInstanceId = doGetLineInstanceId(sublistId, line, useBuffer);

            return getRecordfieldForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
        }
        this.getRecordfield = getRecordfield;

        function cacheUserFieldForInstance(sublistId, fieldId, lineInstanceId, field, useBuffer)
        {
            userFieldCache.put(sublistId, fieldId, lineInstanceId, field, useBuffer);
        }
        this.cacheUserFieldForInstance = cacheUserFieldForInstance;

        /**
         * cache user field
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Number} line
         * @param field
         * @param {boolean} useBuffer
         */
        function cacheUserField(sublistId, fieldId, line, field, useBuffer)
        {
	        useBuffer = shouldUseBuffer(line, useBuffer);
	        var lineInstanceId = doGetLineInstanceId(sublistId, line, useBuffer);

            cacheUserFieldForInstance(sublistId, fieldId, lineInstanceId, field, useBuffer);
        }
        this.cacheUserField = cacheUserField;

        function getUserFieldForInstance(sublistId, fieldId, lineInstanceId, useBuffer)
        {
            return userFieldCache.get(sublistId, fieldId, lineInstanceId, useBuffer);
        }
        this.getUserFieldForInstance = getUserFieldForInstance;

        /**
         * get cached user field
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Number} line
         * @param {boolean} useBuffer
         * @returns {RecordField}
         */
        function getUserField(sublistId, fieldId, line, useBuffer)
        {
	        useBuffer = shouldUseBuffer(line, useBuffer);
	        var lineInstanceId = doGetLineInstanceId(sublistId, line, useBuffer);

            return getUserFieldForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
        }
        this.getUserField = getUserField;

        function hasUserFieldForInstance(sublistId, fieldId, lineInstanceId, useBuffer)
        {
            return userFieldCache.has(sublistId, fieldId, lineInstanceId, useBuffer);
        }
        this.hasUserFieldForInstance = hasUserFieldForInstance;
        /**
         * contain cached user field
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Number} line
         * @param {boolean} useBuffer
         * @returns {boolean}
         */
        function hasUserField(sublistId, fieldId, line, useBuffer)
        {
	        useBuffer = shouldUseBuffer(line, useBuffer);
	        var lineInstanceId = doGetLineInstanceId(sublistId, line, useBuffer);

            return hasUserFieldForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
        }
        this.hasUserField = hasUserField;

        function doCacheSubrecordForInstance(sublistId, fieldId, lineInstanceId, subrecordObj, useBuffer)
        {
            subrecordCache.put(sublistId, fieldId, lineInstanceId, subrecordObj, useBuffer);
        }

        /**
         * cache subrecrd object
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Number} line
         * @param {*} subrecordObj
         * @param {boolean} useBuffer
         */
        function doCacheSubrecord(sublistId, fieldId, line, subrecordObj, useBuffer)
        {
	        useBuffer = shouldUseBuffer(line, useBuffer);
	        var lineInstanceId = doGetLineInstanceId(sublistId, line, useBuffer);

            doCacheSubrecordForInstance(sublistId, fieldId, lineInstanceId, subrecordObj, useBuffer);
        }

        function doGetCachedSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer)
        {
            return subrecordCache.get(sublistId, fieldId, lineInstanceId, useBuffer);
        }

        /**
         * get the cached subrecord object
         * @param {string} sublistId uses null if not sublist field
         * @param {string} fieldId
         * @param {Number} line uses -1 if querying for current sublist field
         * @param {boolean} useBuffer
         * @returns {*} subrecordObj
         */
        function doGetCachedSubrecord(sublistId, fieldId, line, useBuffer)
        {
	        useBuffer = shouldUseBuffer(line, useBuffer);
	        var lineInstanceId = doGetLineInstanceId(sublistId, line, useBuffer);

            return doGetCachedSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
        }

        function _doHasValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer)
        {
            return recordUtil.executeRecordGetterFunctionsForInstance(
                sublistId, fieldId, lineInstanceId, useBuffer,
                hasFieldValue, hasSublistLineValueForInstance);
        }

        function _doHasValue(sublistId, fieldId, line, useBuffer)
        {
	        useBuffer = shouldUseBuffer(line, useBuffer);
	        var lineInstanceId = doGetLineInstanceId(sublistId, line, useBuffer);

            return _doHasValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
        }

        function _doGetValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer)
        {
            return recordUtil.executeRecordGetterFunctionsForInstance(
                sublistId, fieldId, lineInstanceId, useBuffer,
                getFieldValue, getSublistLineValueForInstance);
        }

        function _doGetValue(sublistId, fieldId, line, useBuffer)
        {
	        useBuffer = shouldUseBuffer(line, useBuffer);
	        var lineInstanceId = doGetLineInstanceId(sublistId, line, useBuffer);

            return _doGetValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
        }

        function doHasSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer)
        {
            var cachedSubrecord = doGetCachedSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
            var hasSubrecord = !!cachedSubrecord && cachedSubrecord.current !== null;

            if(!hasSubrecord && _doHasValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer))
            {
                hasSubrecord = !!_doGetValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
            }

            return hasSubrecord;
        }

        /**
         * universal function of hasSubrecord for body field, sublist field, and current sublist field
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {number} line
         * @param {boolean} useBuffer
         * @returns {boolean}
         */
        function doHasSubrecord(sublistId, fieldId, line, useBuffer)
        {
	        useBuffer = shouldUseBuffer(line, useBuffer);
	        var lineInstanceId = doGetLineInstanceId(sublistId, line, useBuffer);

            return doHasSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
        }

        function doGetSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer)
        {
            var cachedSubrecord = doGetCachedSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer);

            return !!cachedSubrecord ? cachedSubrecord.current : null;
        }
	    this.doGetSubrecordForInstance = doGetSubrecordForInstance;
        /**
         * universal function of getSubrecord for body field, sublist field, and current sublist field
         * @param sublistId
         * @param fieldId
         * @param line
         * @param {boolean} useBuffer
         * @returns {*}
         */
        function doGetSubrecord(sublistId, fieldId, line, useBuffer)
        {
	        useBuffer = shouldUseBuffer(line, useBuffer);
	        var lineInstanceId = doGetLineInstanceId(sublistId, line, useBuffer);

            return doGetSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
        }

        function doSetSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer, subrecord)
        {
            var cachedEntry = doGetCachedSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
            if(!cachedEntry)
            {
                cachedEntry = {};
                var existingSubrecordId = parseInt(_doGetValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer));
                var isValidRecordId = !isNaN(existingSubrecordId);

                if(isValidRecordId)
                {
                    var hasExistingSubrecord = !!subrecord && subrecord.id === existingSubrecordId;
                    if(hasExistingSubrecord)
                        cachedEntry.initial = subrecord;
                    else
                        cachedEntry.initial = createSubrecordReference(existingSubrecordId);
                }

                doCacheSubrecordForInstance(sublistId, fieldId, lineInstanceId, cachedEntry, useBuffer);
            }
            cachedEntry.current = subrecord;

            if(!!subrecord)
            {
                var subrecordSystemId = subrecord.doGetValue(subrecordUtil.SYS_ID);
                if(!subrecordSystemId || subrecordSystemId === "0")
                {
                    var sys_id = String(subrecordUtil.getNextSysId() * (cachedEntry.initial === subrecord ? 1 : -1));
                    subrecord.doSetValue(subrecordUtil.SYS_ID, sys_id);
                    updateDependentSysIds();
                }
                if(!subrecord.doGetValue(subrecordUtil.SYS_PARENT_ID))
                {
                    var systemParentId = String(_doGetValueForInstance(sublistId, subrecordUtil.SYS_ID, lineInstanceId, useBuffer));
                    subrecord.doSetValue(subrecordUtil.SYS_PARENT_ID, systemParentId);
                }
            }

            var isCurrentSublistSubrecord = useBuffer && isSublistLineInstanceIdSelected(sublistId, lineInstanceId);
            if(!isCurrentSublistSubrecord)
            {
                var parentSystemId = getParentSystemIdForInstance(sublistId, lineInstanceId);

                subrecordTracker[parentSystemId] = subrecordTracker[parentSystemId] || {};
                subrecordTracker[parentSystemId][fieldId] = { isDeleted: !subrecord };
            }
        }

        /**
         * universal function of setSubrecord for body field, sublist field, and current sublist field
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Number} line
         * @param {Record} subrecord
         * @param {boolean} useBuffer
         */
        function doSetSubrecord(sublistId, fieldId, line, subrecord, useBuffer)
        {
	        useBuffer = shouldUseBuffer(line, useBuffer);
	        var lineInstanceId = doGetLineInstanceId(sublistId, line, useBuffer);

            doSetSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer, subrecord);
        }

        function hasNewlyCommittedSublistSubrecord(systemId, fieldId)
        {
            return subrecordTracker.hasOwnProperty(systemId)
                   && subrecordTracker[systemId][fieldId]
                   && !subrecordTracker[systemId][fieldId].isDeleted;
        }
        this.hasNewlyCommittedSublistSubrecord = hasNewlyCommittedSublistSubrecord;

        function getParentSystemIdForInstance(sublistId, lineInstanceId, useBuffer)
        {
            var sys_parent_id = !!sublistId ?
                    getSublistSystemIdForInstance(sublistId, lineInstanceId, useBuffer) :
                    getSystemId();

            return sys_parent_id;
        }
        this.getParentSystemIdForInstance = getParentSystemIdForInstance;

        function getParentSystemId(sublistId, line, useBuffer)
        {
	        useBuffer = shouldUseBuffer(line, useBuffer);
	        var lineInstanceId = doGetLineInstanceId(sublistId, line, useBuffer);

            return getParentSystemIdForInstance(sublistId, lineInstanceId, useBuffer);
        }
        this.getParentSystemId = getParentSystemId;

        function getSystemId()
        {
            return getFieldValue(subrecordUtil.SYS_ID);
        }
        this.getSystemId = getSystemId;

        function getSublistSystemIdForInstance(sublistId, lineInstanceId, useBuffer)
        {
            return getSublistLineValueForInstance(sublistId, subrecordUtil.SYS_ID, lineInstanceId, useBuffer);
        }
        this.getSublistSystemIdForInstance = getSublistSystemIdForInstance;

        function getSublistSystemId(sublistId, line, useBuffer)
        {
	        useBuffer = shouldUseBuffer(line, useBuffer);
	        var lineInstanceId = doGetLineInstanceId(sublistId, line, useBuffer);

            return getSublistSystemIdForInstance(sublistId, lineInstanceId, useBuffer);
        }
        this.getSublistSystemId = getSublistSystemId;

        function getCurrentSublistSystemId(sublistId)
        {
            return getCurrentSublistLineValue(sublistId, subrecordUtil.SYS_ID);
        }
        this.getCurrentSublistSystemId = getCurrentSublistSystemId;

        function createSubrecordReference(id)
        {
            var data = {}, result = {};

            data[subrecordUtil.SYS_ID] = subrecordUtil.getNextSysId();
            data[subrecordUtil.SYS_PARENT_ID] = getParentSystemId(subrecordUtil.SYS_ID);
            data.id = String(id);
            result.id = parseInt(data.id, 10);
            result.getFields = function(){
                return Object.keys(data);
            };

            function fetchValue(fieldId) { return data[fieldId]; }
	        function fetchValueAsString(fieldId)
	        {
		        var returnMe = data[fieldId];
		        return utilityFunctions.isValEmpty(returnMe) ? null : String(returnMe);
	        }
            result.getValue = fetchValue;
            result.doGetValue = fetchValue;
            result.getFieldValue = fetchValue;
	        result.getValueAsLegacyString = fetchValueAsString;
            return result;
        }

        function updateDependentSysIds()
        {
            //TODO: update sublist lines sys_parentid field
        }

        /**
         * return true if field has a subrecord instance
         * @param {string} fieldId
         * @returns {boolean}
         */
        function hasSubrecord(fieldId)
        {
	        var useBuffer = false;
            return doHasSubrecord(null, fieldId, -1, useBuffer);
        }
        this.hasSubrecord = hasSubrecord;

        /**
         * return the subrecord instance of given field
         * @param {string} fieldId
         * @returns {*}
         */
        function getSubrecord(fieldId)
        {
	        var useBuffer = false;
            return doGetSubrecord(null, fieldId, -1, useBuffer);
        }
        this.getSubrecord = getSubrecord;

        /**
         * update the subrecord instance of the given field
         * @param {string} fieldId
         * @param {*} subrecord
         */
        function cacheSubrecord(fieldId, subrecord)
        {
	        var useBuffer = false;
            return doSetSubrecord(null, fieldId, -1, subrecord, useBuffer);
        }
        this.cacheSubrecord = cacheSubrecord;

        function hasSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer)
        {
            return doHasSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
        }
        this.hasSublistSubrecordForInstance = hasSublistSubrecordForInstance;
        /**
         * return true if sublist field has a subrecord instance
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Number} line
         * @param {boolean} useBuffer
         */
        function hasSublistSubrecord(sublistId, fieldId, line, useBuffer)
        {
	        useBuffer = shouldUseBuffer(line, useBuffer);
	        var lineInstanceId = doGetLineInstanceId(sublistId, line, useBuffer);

            return hasSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
        }
        this.hasSublistSubrecord = hasSublistSubrecord;

        /**
         * return the subrecord instance of given sublist field
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Number} line
         * @param {boolean} useBuffer
         * @returns {*} subrecordObject
         */
        function getSublistSubrecord(sublistId, fieldId, line, useBuffer)
        {
	        return doGetSubrecord(sublistId, fieldId, line, useBuffer);
        }
        this.getSublistSubrecord = getSublistSubrecord;

        function cacheSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer, subrecord)
        {
            return doSetSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer, subrecord);
        }
        this.cacheSublistSubrecordForInstance = cacheSublistSubrecordForInstance;
	    
        function clearSubrecordCacheForInstance(sublistId, fieldId, lineInstanceId, useBuffer)
        {
	        return doSetSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer, null);
        }
	    this.clearSubrecordCacheForInstance = clearSubrecordCacheForInstance;	    
	    
        /**
         * update the subrecord instance of the given sublist field
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Number} line
         * @param {*} subrecord
         * @param {boolean} useBuffer
         */
        function cacheSublistSubrecord(sublistId, fieldId, line, subrecord, useBuffer)
        {
	        useBuffer = shouldUseBuffer(line, useBuffer);
	        var lineInstanceId = doGetLineInstanceId(sublistId, line, useBuffer);

            return cacheSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer, subrecord);
        }
        this.cacheSublistSubrecord = cacheSublistSubrecord;


        /**
         * return true if current sublist field has a subrecord instance
         * @param {string} sublistId
         * @param {string} fieldId
         */
        function hasCurrentSublistSubrecord(sublistId, fieldId)
        {
	        var useBuffer = true;
            return doHasSubrecord(sublistId, fieldId, -1, useBuffer);
        }
        this.hasCurrentSublistSubrecord = hasCurrentSublistSubrecord;

        /**
         * return the subrecord instance of given current sublist field
         * @param {string} sublistId
         * @param {string} fieldId
         * @returns {*}
         */
        function getCurrentSublistSubrecord(sublistId, fieldId)
        {
	        var useBuffer = true;
            return doGetSubrecord(sublistId, fieldId, -1, useBuffer);
        }
        this.getCurrentSublistSubrecord = getCurrentSublistSubrecord;

        /**
         * update the subrecord instance of the current sublist field
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {*} subrecord
         */
        function setCurrentSublistSubrecord(sublistId, fieldId, subrecord)
        {
	        var useBuffer = true;
            return doSetSubrecord(sublistId, fieldId, -1, subrecord, useBuffer);
        }
        this.setCurrentSublistSubrecord = setCurrentSublistSubrecord;

        function getData()
        {
            return _model.getData();
        }
        this.getData = getData;

        function getSublistData()
        {
            return _model.getSublistData();
        }
        this.getSublistData = getSublistData;

        function getSubrecordDataForSubmission()
        {
            return _model.getSubrecordDataForSubmission();
        }
        this.getSubrecordDataForSubmission = getSubrecordDataForSubmission;

        function clone()
        {
            return new ModelController({
                type: options.type,
                sublistFieldState: options.sublistFieldState,
                data: _model.getClonedData()
            });
        }
        this.clone = clone;


        function validateCurrentSublistSubrecords(sublistId)
        {
            var useBuffer = true;
            var lineInstanceId = getSublistLineInstanceIdForLine(sublistId, getCurrentSublistLineIndex(sublistId), useBuffer);
            validateCurrentSublistSubrecordsForInstance(sublistId, lineInstanceId);
        }
        this.validateCurrentSublistSubrecords = validateCurrentSublistSubrecords;

        function validateCurrentSublistSubrecordsForInstance(sublistId, lineInstanceId)
        {
            var useBuffer = true;            
            var fields = subrecordCache.fields(sublistId, lineInstanceId, useBuffer);
            fields.forEach(function(fieldId){
                var entry = subrecordCache.get(sublistId, fieldId, lineInstanceId, useBuffer);
                var subrecord = entry ? entry.current : null;
                if(subrecord != null && !subrecord.isValidated())
                {
                    subrecord.validate();
                    subrecord.setDereferencedFromParent(true);
                }
            })
        }
        this.validateCurrentSublistSubrecordsForInstance = validateCurrentSublistSubrecordsForInstance;

        function setSubrecordCacheEntryDereferencedForInstance(sublistId, fieldId, lineInstanceId, useBuffer)
        {
            var entry = subrecordCache.get(sublistId, fieldId, lineInstanceId, useBuffer);
            var subrecord = entry ? entry.current : null;
            if(subrecord != null)
            {
                subrecord.setDereferencedFromParent(true);
            }
        }

        function setSubrecordCacheEntryDereferenced(sublistId, fieldId, line, useBuffer)
        {
	        useBuffer = shouldUseBuffer(line, useBuffer);
	        var lineInstanceId = doGetLineInstanceId(sublistId, line, useBuffer);

            setSubrecordCacheEntryDereferencedForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
        }

        function setCurrentSublistSubrecordCaheEntrysDereferenced(sublistId)
        {
            var useBuffer = true;
            var lineInstanceId = getSublistLineInstanceIdForLine(sublistId, getCurrentSublistLineIndex(sublistId), useBuffer);
            var fields = subrecordCache.fields(sublistId, lineInstanceId, useBuffer);
            fields.forEach(function(fieldId){
                var entry = subrecordCache.get(sublistId, fieldId);
                var subrecord = entry ? entry.current : null;
                if(subrecord != null)
                {
                    subrecord.setDereferencedFromParent(true);
                }
            });
        }

	    function getSublistLineJSON(sublistId, lineInstanceId, useBuffer)
	    {
		    return _model.getSublistLineJSON(sublistId, lineInstanceId, useBuffer);
	    }
	    this.getSublistLineJSON = getSublistLineJSON;

        /**
         * retrieve the select option text from the cache by value
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {string} value
         */
        function getSelectOptionTextFromCache(sublistId, fieldId, value)
        {
            return _model.getSelectOptionTextFromCache(sublistId, fieldId, value)
        }
        this.getSelectOptionTextFromCache = getSelectOptionTextFromCache;

        /**
         * cache the option text into cache
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {string} value
         * @param {string} text
         */
        function cacheSelectOptionText(sublistId, fieldId, value, text)
        {
            _model.cacheSelectOptionText(sublistId, fieldId, value, text);
        }
        this.cacheSelectOptionText = cacheSelectOptionText;

        function on(options)
        {
            _model.on(options);
        }
        this.on = on;

        function off(options)
        {
            _model.off(options);
        }
        this.off = off;

        return this;
    }

    return {
        /**
         * return a new instance of ModelController
         * @param {Object} options
         * @returns {ModelController}
         */
        create: function create(options){
            return new ModelController(options);
        },
        /**
         * return true if object is an instance of ModelController
         * @param {Object} obj
         * @returns {boolean}
         */
        isInstance: function(obj) { return obj instanceof ModelController; }
    };
});

/**
 * SuiteScript dynamic record impl
 *
 * @private
 * @module N/record/dynamicRecordImpl
 * @NApiVersion 2.x
 *
 */
define(
	'N/record/dynamicRecordImpl',['N/record/recordUtilityFunctions', 'N/utilityFunctions', 'N/util/validator'],
	function (recordUtil, utilityFunctions, validator)
	{
		/**
		 * Dynamic Record Implementation for record behavior
		 * @param {Record} record
		 * @constructor
		 */
		function DynamicRecordImpl(record)
		{
			var that = this;
			var undef = undefined;
			var recordScriptingScope;

			function initRecord(record, scope)
			{
				recordScriptingScope = scope;
				recordScriptingScope.pageInit();
			}

			this.initRecord = initRecord;

			function isDynamic() { return true; }

			this.isDynamic = isDynamic;

			this.validateTextApi = recordUtil.no_op_function;

			function getLineInstanceId(sublistId, line, useBuffer)
			{
				return record.getModelController().getSublistLineInstanceIdForLine(sublistId, line, useBuffer);
			}

			this.getLineInstanceId = getLineInstanceId;

			function shouldValidateFieldPermissions()
			{
				return 'T' === record.getRecordRequestContext().enablefieldpermissions && !record.isInternal();
			}

			this.shouldValidateFieldPermissions = shouldValidateFieldPermissions;

			function validateLineIndex(lineNumberIndex, lowerBoundInclusive, upperBoundExclusive)
			{
				lineNumberIndex = parseInt(lineNumberIndex, 10);
				recordUtil.assertValidSublistOperation(lowerBoundInclusive <= lineNumberIndex && lineNumberIndex < upperBoundExclusive)
			}

			this.validateLineIndex = validateLineIndex;

			function getCachedOptionsForRecordField(sublistId, fieldId, line)
			{
				return record.getModelController().getSelectOptions(sublistId, fieldId, line);
			}

			this.getCachedOptionsForRecordField = getCachedOptionsForRecordField;

			function doGetText(fieldId, delegator)
			{
				return delegator.getTextValue(fieldId);
			}

			this.doGetText = doGetText;

			function getParsedValueForBodyField(fieldId, delegator)
			{
				return delegator.getParsedValue(fieldId);
			}

			this.getParsedValueForBodyField = getParsedValueForBodyField;

			function doSetValue(fieldId, value, fireFieldChange, noSlaving)
			{
				value = recordUtil.emptyIfNullOrUndefined(value);
				if (record.isFieldMultiSelect(undef, fieldId))
					value = recordUtil.formatValueToArrayType(value);
				else if (record.isFieldRadio(undef, fieldId))
					value = String(value);
				var validatedValue = record.validateAndFormatFieldValue(undef, fieldId, value);
				record.doSetFieldValue(fieldId, validatedValue, fireFieldChange, noSlaving);
			}

			this.doSetValue = doSetValue;

			function doSetText(fieldId, text, fireFieldChange, noSlaving, isUpdatingSlaveField)
			{
				var value, recordField;
				var useBuffer = false;
				noSlaving = !!noSlaving;
				isUpdatingSlaveField = !!isUpdatingSlaveField;
				if (record.isFieldMultiSelect(undef, fieldId))
				{
					var texts = recordUtil.formatValueToArrayType(text);
					record.doSetTexts(fieldId, texts, fireFieldChange, noSlaving);
				}
				else if (record.isFieldSelectType(undef, fieldId))
				{
					value = "";
					var unwrappedText = recordUtil.formatArrayToStringType(text);
					if (unwrappedText || unwrappedText === "")
					{
						recordField = record.getCachedRecordField(undef, fieldId, -1, useBuffer);
						value = recordField.validateSelectFieldByText(text);
					}
					record.doSetFieldValue(fieldId, value, fireFieldChange, noSlaving, true, isUpdatingSlaveField);
				}
				else if (record.isFieldRadio(undef, fieldId))
				{
					var fieldLevelMetadata = record.getFieldLevelMetadataForBodyField(fieldId);
					value = validator.validateRadioFieldByText(fieldId, text, fieldLevelMetadata.radioSet);
					record.doSetFieldValue(fieldId, value, fireFieldChange, noSlaving, true, isUpdatingSlaveField);
				}
				else
				{
					if (record.isFieldCheckbox(undef, fieldId))
						validator.validateCheckBoxField(fieldId, text);
					var fieldLevelMetadata = record.getFieldLevelMetadataForBodyField(fieldId);
					value = record.parseValue(record.isValidBodyField(fieldId), fieldLevelMetadata, text);
					record.doSetValue(fieldId, value, fireFieldChange, noSlaving);
				}

				record.getFieldState(fieldId).useTextApi = true;
			}

			this.doSetText = doSetText;

			function validateAndFormatFieldValue(sublistId, fieldId, value)
			{
				var useBuffer = (!!sublistId);
				var lineInstanceId = (!!sublistId) ? record.getModelController().getSublistSelectedLineInstanceId(sublistId) : null;
				return validateAndFormatFieldValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer, value);
			}

			this.validateAndFormatFieldValue = validateAndFormatFieldValue;

			function validateAndFormatFieldValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer, value, isInteractive)
			{
				var validatedValue = value;
				var toValidate = record.shouldValidateField() && record.isValidField(sublistId, fieldId);
				if(toValidate)
				{
					var field = record.getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
					validatedValue = field.validateAndFormatFieldValue(value, isInteractive);
				}

				return validatedValue;
			}

			this.validateAndFormatFieldValueForInstance = validateAndFormatFieldValueForInstance;

			function doGetParsedSublistValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer, delegator)
			{
				return delegator.getParsedValue(fieldId);
			}

			this.doGetParsedSublistValueForInstance = doGetParsedSublistValueForInstance;

			this.setSublistValue = recordUtil.no_op_function;

			function doGetSublistTextForInstance(sublistId, fieldId, lineInstanceId, useBuffer, delegator)
			{
				return delegator.getTextValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
			}

			this.doGetSublistTextForInstance = doGetSublistTextForInstance;

			this.setSublistText = recordUtil.no_op_function;


			function preInsertLine(sublistId, line)
			{
				var lineObj;
				if (record.doGetCurrentSublistIndex(sublistId) !== line && line <= record.doGetLineCount(sublistId) - 1)
					lineObj = record.doSelectLine(sublistId, line);
				record.triggerValidateInsertScript(sublistId);
				return lineObj;
			}

			this.preInsertLine = preInsertLine;

			function preInsertLineForInstance(sublistId, beforeLineInstanceId)
			{
				record.getModelController().runFunctionWhileSilentlySelectingLine(sublistId, beforeLineInstanceId, record.triggerValidateInsertScript, that, [sublistId]);
			}

			this.preInsertLineForInstance = preInsertLineForInstance;

			function postInsertLine(sublistId, line, ignoreRecalc)
			{
				var lineObj;
				if (!ignoreRecalc)
					record.triggerRecalcScript(sublistId, false, 'insert');
				record.doResetSublistLine(sublistId, line, record.getMetadata().getSublistDefaultValue(sublistId));
				lineObj = record.doSelectLine(sublistId, line);
				return lineObj;
			}

			this.postInsertLine = postInsertLine;

			function postInsertLineForInstance(sublistId, lineInstanceId, ignoreRecalc)
			{
				var lineObj;
				if (!ignoreRecalc)
					record.triggerRecalcScript(sublistId, false, 'insert');
				record.doResetSublistLineForInstance(sublistId, lineInstanceId, record.getMetadata().getSublistDefaultValue(sublistId));
				lineObj = record.doSelectLineForInstance(sublistId, lineInstanceId);
				return lineObj;
			}

			this.postInsertLineForInstance = postInsertLineForInstance;

			function removeSublistLine(sublistId, line, ignoreRecalc)
			{
				var lineObj;
				if (record.doGetCurrentSublistIndex(sublistId) !== line)
					lineObj = record.doSelectLine(sublistId, line);
				record.triggerValidateDeleteScript(sublistId);
				record.doRemoveSublistLine(sublistId, line);
				if (!ignoreRecalc)
					record.triggerRecalcScript(sublistId, false, 'remove');
				return lineObj;
			}

			this.removeSublistLine = removeSublistLine;

			function doRemoveSublistLine(sublistId, lineInstanceId, ignoreRecalc)
			{
				record.triggerValidateDeleteScript(sublistId);
				record.doRemoveSublistLineForInstance(sublistId, lineInstanceId);
				if (!ignoreRecalc)
					record.triggerRecalcScript(sublistId, false, 'remove');
			}

			function removeSublistLineForInstance(sublistId, lineInstanceId, ignoreRecalc)
			{
				record.getModelController().runFunctionWhileSilentlySelectingLine(sublistId, lineInstanceId, doRemoveSublistLine, that, [sublistId, lineInstanceId, ignoreRecalc]);
			}

			this.removeSublistLineForInstance = removeSublistLineForInstance;

			function postRemoveLine(sublistId, line, isLastLine)
			{
				var lineObj = null;
				record.postDeleteLine(sublistId, line);
				if (isLastLine)
					lineObj = record.doSelectNewLine(sublistId);
				else if (line <= record.doGetLineCount(sublistId))
					lineObj = record.doSelectLine(sublistId, line);
				return lineObj;
			}

			this.postRemoveLine = postRemoveLine;

			function postRemoveLineForInstance(sublistId, lineInstanceId, useBuffer)
			{
				record.postDeleteLineForInstance(sublistId, lineInstanceId, useBuffer)
			}

			this.postRemoveLineForInstance = postRemoveLineForInstance;

			function selectLine(options, line)
			{
				var sublistId, lineInstanceId, lineObj;
				if (line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					line = options.line;
					lineInstanceId = options.lineInstanceId;

					utilityFunctions.checkMutuallyExclusiveArguments(line, lineInstanceId, 'line', 'lineInstanceId');
				}

				if (line != undef)
				{
					utilityFunctions.checkArgs([sublistId, line], ['sublistId', 'line'], record.getMissingArgumentErrorMessageFillerValue("selectLine"));
					lineObj = record.doSelectLine(sublistId, line);
				}
				else
				{
					utilityFunctions.checkArgs([sublistId, lineInstanceId], ['sublistId', 'lineInstanceId'], record.getMissingArgumentErrorMessageFillerValue('selectLine'));
					lineObj = record.doSelectLineForInstance(sublistId, lineInstanceId);
				}

				return lineObj;
			}

			this.selectLine = selectLine;

			function selectNewLine(options)
			{
				var sublistId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'sublistId', record.getMissingArgumentErrorMessageFillerValue("selectNewLine"));
				recordUtil.assertValidSublistOperation(record.isSublistAnEditMachine(sublistId));
				return record.doSelectNewLine(sublistId);
			}

			this.selectNewLine = selectNewLine;

			function cancelLine(options)
			{
				var sublistId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'sublistId', record.getMissingArgumentErrorMessageFillerValue("cancelLine"));
				recordUtil.assertValidSublistOperation(record.isSublistAnEditMachine(sublistId));
				record.doCancelLine(sublistId);
			}

			this.cancelLine = cancelLine;

			function cancelLineForInstance(sublistId, lineInstanceId)
			{
				recordUtil.assertValidSublistOperation(record.isSublistAnEditMachine(sublistId));
				record.getModelController().runFunctionWhileSilentlySelectingLine(sublistId, lineInstanceId, record.doCancelLineForInstance, that, [sublistId, lineInstanceId]);
			}

			this.cancelLineForInstance = cancelLineForInstance;

			function commitLine(options)
			{
				var sublistId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'sublistId', record.getMissingArgumentErrorMessageFillerValue("commitLine"));
				var ignoreRecalc = options !== undef && options !== null && options.hasOwnProperty('ignoreRecalc') ? options.ignoreRecalc : false;
				recordUtil.assertValidSublistOperation(record.isSublistEditable(sublistId));
				record.doCommitLine(sublistId, ignoreRecalc);
			}

			this.commitLine = commitLine;

			function commitLineForInstance(sublistId, lineInstanceId)
			{
				recordUtil.assertValidSublistOperation(record.isSublistAnEditMachine(sublistId));
				var ignoreRecalc = false;
				record.getModelController().runFunctionWhileSilentlySelectingLine(sublistId, lineInstanceId, record.doCommitLineForInstance, that, [sublistId, lineInstanceId, ignoreRecalc]);
			}

			this.commitLineForInstance = commitLineForInstance;

			function getCurrentSublistValue(options, fieldId, delegator)
			{
				var sublistId;
				if (fieldId !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
				}
				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], record.getMissingArgumentErrorMessageFillerValue("getCurrentSublistValue"));

				var lineInstanceId = record.getModelController().getSublistSelectedLineInstanceId(sublistId);
				var lineDefinitionObject = record.getLineObjectFromCache(sublistId, lineInstanceId, true);
				return lineDefinitionObject.getParsedValueForBodyField(fieldId);
			}

			this.getCurrentSublistValue = getCurrentSublistValue;

			function setCurrentSublistValue(options, fieldId, value, isInteractive)
			{
				var sublistId, fireFieldChange = true, noSlaving = false;
				if (fieldId !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					value = options.value;
					fireFieldChange = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChange;
					noSlaving = util.isBoolean(options.noslaving) ? options.noslaving : noSlaving;
					isInteractive = util.isBoolean(options.isInteractive) ? options.isInteractive : false;
				}
				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], record.getMissingArgumentErrorMessageFillerValue("setCurrentSublistValue"));
				recordUtil.validateAgainstSqlInjection(fieldId, value);

				record.doSetCurrentSublistValue(sublistId, fieldId, value, fireFieldChange, noSlaving, isInteractive);

			}

			this.setCurrentSublistValue = setCurrentSublistValue;

			function setSublistBufferValue(options)
			{
				var sublistId = options.sublistId,
					fieldId = options.fieldId,
					lineInstanceId = options.lineInstanceId,
					value = options.value,
					fireFieldChange = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : true,
					noSlaving = util.isBoolean(options.noslaving) ? options.noslaving : false;

				utilityFunctions.checkArgs([sublistId, fieldId, lineInstanceId], ['sublistId', 'fieldId', 'lineInstanceId'], record.getMissingArgumentErrorMessageFillerValue("setSublistBufferValue"));
				recordUtil.validateAgainstSqlInjection(fieldId, value);

				record.doSetSublistBufferValue(sublistId, fieldId, lineInstanceId, value, fireFieldChange, noSlaving);
			}

			this.setSublistBufferValue = setSublistBufferValue;

			function getCurrentSublistText(options, fieldId)
			{
				var sublistId;
				if (fieldId !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
				}
				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], record.getMissingArgumentErrorMessageFillerValue("getCurrentSublistText"));

				var lineInstanceId = record.getModelController().getSublistSelectedLineInstanceId(sublistId);
				var lineDefinitionObject = record.getLineObjectFromCache(sublistId, lineInstanceId, true);
				return lineDefinitionObject.doGetText(fieldId);
			}

			this.getCurrentSublistText = getCurrentSublistText;

			function setCurrentSublistText(options, fieldId, text, isInteractive)
			{
				var sublistId, fireFieldChange = true, noSlaving = false;
				if (fieldId !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					text = options.text;
					fireFieldChange = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChange;
					noSlaving = util.isBoolean(options.noslaving) ? options.noslaving : noSlaving;
					isInteractive = util.isBoolean(options.isInteractive) ? options.isInteractive : false;
				}
				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], record.getMissingArgumentErrorMessageFillerValue("setCurrentSublistText"));
				recordUtil.validateAgainstSqlInjection(fieldId, text);

				record.doSetCurrentSublistText(sublistId, fieldId, text, fireFieldChange, noSlaving, false, isInteractive);
			}

			this.setCurrentSublistText = setCurrentSublistText;

			function postSetFieldValue(sublistId, fieldId, dbValue, fireFieldChange, noSlaving, isUpdatingSlavingField)
			{
				var internalFieldChangeScriptFieldId = 'nlapiFC';
				if (fireFieldChange === undef)
					fireFieldChange = true;

				if (noSlaving === undef)
					noSlaving = false;

				var nlapiFCValue = null;
				if (!fireFieldChange && !utilityFunctions.isValEmpty(record.doGetValue(internalFieldChangeScriptFieldId)) && !record.isInternal())
				{
					fireFieldChange = true;
					nlapiFCValue = record.getModelController().getFieldValue(internalFieldChangeScriptFieldId);
					record.getModelController().setFieldValue(internalFieldChangeScriptFieldId, {value: '', legacyStringValue: ''});
				}

				if (fireFieldChange)
				{
					var line = record.isSublistAListMachine(sublistId) ? recordUtil.getOneBasedIndex(record.doGetCurrentSublistIndex(sublistId)) : -1;
					if (!isUpdatingSlavingField)
						record.triggerValidateFieldScript(sublistId, fieldId, line);
					record.triggerFieldChangeEvent(sublistId, fieldId, line, dbValue, noSlaving);
				}

				if (!nlapiFCValue)
					record.getModelController().setFieldValue(internalFieldChangeScriptFieldId, {value: nlapiFCValue, legacyStringValue: nlapiFCValue});
			}

			this.postSetFieldValue = postSetFieldValue;

			function postSetFieldValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer, dbValue, fireFieldChange, noSlaving, isUpdatingSlavingField)
			{
				var internalFieldChangeScriptFieldId = 'nlapiFC';
				if (fireFieldChange === undef)
					fireFieldChange = true;

				if (noSlaving === undef)
					noSlaving = false;

				var nlapiFCValue = null;
				if (!fireFieldChange && !utilityFunctions.isValEmpty(record.doGetValue(internalFieldChangeScriptFieldId)) && !record.isInternal())
				{
					fireFieldChange = true;
					nlapiFCValue = record.getModelController().getFieldValue(internalFieldChangeScriptFieldId);
					record.getModelController().setFieldValue(internalFieldChangeScriptFieldId, {value: '', legacyStringValue: ''});
				}

				if (fireFieldChange)
				{
					var line = -1;
					if (record.isSublistAListMachine(sublistId))
					{
						line = record.getModelController().getSublistLineValueForInstance(sublistId, '_sequence', lineInstanceId, useBuffer);
						line = recordUtil.getOneBasedIndex(line);
					}
					if (!isUpdatingSlavingField)
						record.triggerValidateFieldScript(sublistId, fieldId, line);
					record.triggerFieldChangeEventForInstance(sublistId, fieldId, line, lineInstanceId, dbValue, noSlaving);
				}

				if (!nlapiFCValue)
					record.getModelController().setFieldValue(internalFieldChangeScriptFieldId, {value: nlapiFCValue, legacyStringValue: nlapiFCValue});
			}

			this.postSetFieldValueForInstance = postSetFieldValueForInstance;

			function triggerFieldChangeEvent(sublistId, fieldId, line, value, noSlaving)
			{
				record.triggerFieldChangeScript(sublistId, fieldId, line);
				record.doSlaving(sublistId, fieldId, line, value, noSlaving);
			}

			this.triggerFieldChangeEvent = triggerFieldChangeEvent;

			function triggerFieldChangeEventForInstance(sublistId, fieldId, line, lineInstanceId, value, noSlaving)
			{
				record.triggerFieldChangeScript(sublistId, fieldId, line);
				record.doSlavingForInstance(sublistId, fieldId, line, lineInstanceId, value, noSlaving);
			}

			this.triggerFieldChangeEventForInstance = triggerFieldChangeEventForInstance;

			function doProcessSlavingValues(slaveValues, sublistId, fieldId, line)
			{
				if (!!slaveValues)
				{
					record.applySlaveValues(postProcessSlaveValues(slaveValues));
					record.triggerCustomPostSourcingScript(sublistId, fieldId, line);
				}
			}

			function doGetClientSlavingResultFromMetadata(clientSlavingMetadata, stringifiedVal, getMetadataFunction, forceSync)
			{
				if (forceSync)
					return recordUtil.getClientSlavingResultFromMetadata(clientSlavingMetadata, stringifiedVal, getMetadataFunction);
				else
					return new Promise(function (resolve, reject)
					{
						try
						{
							resolve(recordUtil.getClientSlavingResultFromMetadata(clientSlavingMetadata, stringifiedVal, getMetadataFunction));
						}
						catch (e)
						{
							reject(e);
						}
					});
			}

			function doPerformSlaving(sublistId, fieldId, lineNum, lineInstanceId, value, noSlaving, restrictField)
			{
				if (noSlaving === undef)
					noSlaving = false;

				var slaveValues,
					metadata = record.getSlavingMetadata(sublistId, fieldId),
					clientSlavingMetadata = record.getClientSlavingMetadata(sublistId, fieldId),
					forceSync = (metadata && metadata.forceSyncSlaving) ? metadata.forceSyncSlaving : !record.getIsCurrentRecord();

				if (!noSlaving)
				{
					if (metadata && metadata.noSlavingValue !== String(value))
					{
						var ln = (record.isSublistAListMachine(sublistId)) ? record.doGetCurrentSublistIndex(sublistId) : null;
						var fieldToSlave = (restrictField && typeof restrictField !== 'boolean') ? restrictField : 'T';
						var masterInfo = {queryFieldName: String(fieldId), queryFieldValue: String(value), sublistId: sublistId ? String(sublistId) : undef, fieldspec: fieldToSlave, lineNum: lineNum, lineInstanceId: lineInstanceId};

						slaveValues = record.sendSlavingRequest(postProcessSlavingMetadata(metadata), masterInfo);
					}
					else if (clientSlavingMetadata)
					{
						slaveValues = doGetClientSlavingResultFromMetadata(clientSlavingMetadata, String(value), record.getClientSlavingMetadata, forceSync);
					}
				}
				if (!!slaveValues)
				{
					if (forceSync)
						doProcessSlavingValues(slaveValues, sublistId, fieldId, lineNum);
					else
						slaveValues.then(function (result)
										 {
											 function doThis(obj)
											 {
												 var retMe = obj;
												 if (obj.hasOwnProperty("machine")) retMe.lineInstanceId = lineInstanceId;
												 return retMe;
											 }

											 if (!!result && !!result.fields)
												 result.fields = result.fields.map(doThis);
											 record.getModelController().runFunctionWhileSilentlySelectingLine(sublistId, lineInstanceId, doProcessSlavingValues, that, [result, sublistId, fieldId, lineNum]);
										 },
										 function (reason) { throw reason; }); // TODO: (Issue 407340) This needs to be updated when Chris checks in his event CLs

				}
			}

			function doSlaving(sublistId, fieldId, line, value, noSlaving, restrictField)
			{
				var useBuffer = true,
					lineInstanceId = record.getModelController().getSublistLineInstanceIdForLine(sublistId, line, useBuffer);

				doPerformSlaving(sublistId, fieldId, line, lineInstanceId, value, noSlaving, restrictField)
			}

			this.doSlaving = doSlaving;

			function doSlavingForInstance(sublistId, fieldId, line, lineInstanceId, value, noSlaving, restrictField)
			{
				doPerformSlaving(sublistId, fieldId, line, lineInstanceId, value, noSlaving, restrictField)
			}

			this.doSlavingForInstance = doSlavingForInstance;

			function postProcessSlavingMetadata(metadata)
			{
				var REQUIRED_SCRIPT = 'requiredScript';

				var auxfields = metadata['auxfields'];
				for (var idx = 0; auxfields && idx < auxfields.length; idx++)
				{
					var auxfld = auxfields[idx];
					if (auxfld.hasOwnProperty(REQUIRED_SCRIPT))
					{
						auxfld.isRequired = recordScriptingScope.runInternalScriptAndReturnBooleanResult(auxfld[REQUIRED_SCRIPT]);
					}
				}

				return metadata;
			}

			function postProcessSlaveValues(slaveValues)
			{
				var CONDITION = 'condition';

				for (var idx = 0; slaveValues.body && idx < slaveValues.body.length; idx++)
				{
					if (slaveValues.body[idx].hasOwnProperty(CONDITION))
					{
						slaveValues.body[idx][CONDITION] = recordScriptingScope.runInternalScriptAndReturnBooleanResult(slaveValues.body[idx][CONDITION]);
					}
				}

				return slaveValues;
			}


			function triggerPageInitScript()
			{
				recordScriptingScope.pageInit();
			}

			this.triggerPageInitScript = triggerPageInitScript;

			function triggerLineInitScript(sublistId)
			{
				recordScriptingScope.lineInit(sublistId);
			}

			this.triggerLineInitScript = triggerLineInitScript;

			function triggerPostDeleteLineScript(sublistId, line_1)
			{
				recordScriptingScope.postDeleteLine(sublistId, line_1)
			}

			this.triggerPostDeleteLineScript = triggerPostDeleteLineScript;

			function triggerLineCommitScript(sublistId, line_1)
			{
				recordScriptingScope.lineCommit(sublistId, line_1)
			}

			this.triggerLineCommitScript = triggerLineCommitScript;

			function triggerValidateLineScript(sublistId)
			{
				recordScriptingScope.validateLine(sublistId);
			}

			this.triggerValidateLineScript = triggerValidateLineScript;

			function triggerValidateInsertScript(sublistId)
			{
				recordScriptingScope.validateInsert(sublistId);
			}

			this.triggerValidateInsertScript = triggerValidateInsertScript;

			function triggerValidateDeleteScript(sublistId)
			{
				recordScriptingScope.validateDelete(sublistId);
			}

			this.triggerValidateDeleteScript = triggerValidateDeleteScript;

			function triggerValidateFieldScript(sublistId, fieldId, line_1, matrixColumn)
			{
				recordScriptingScope.validateField(sublistId, fieldId, line_1, matrixColumn);
			}

			this.triggerValidateFieldScript = triggerValidateFieldScript;

			function triggerFieldChangeScript(sublistId, fieldId, line_1, matrixColumn)
			{
				recordScriptingScope.fieldChange(sublistId, fieldId, line_1, matrixColumn);
			}

			this.triggerFieldChangeScript = triggerFieldChangeScript;

			function triggerCanCreateSubrecordScript(sublistId, fieldId, line_1)
			{
				recordScriptingScope.canCreateSubrecord(sublistId, fieldId, line_1)
			}

			this.triggerCanCreateSubrecordScript = triggerCanCreateSubrecordScript;

			function triggerSaveRecordScript(ignoreMandatoryFields)
			{
				recordScriptingScope.saveRecord(ignoreMandatoryFields);
			}

			this.triggerSaveRecordScript = triggerSaveRecordScript;

			function triggerRecalcScript(sublistId, localRecalc, operation)
			{
				recordScriptingScope.recalc(sublistId, localRecalc, operation);
			}

			this.triggerRecalcScript = triggerRecalcScript;

			function triggerMachinePostSourcing(postSourcingScript)
			{
				recordScriptingScope.postSublistSourcing(postSourcingScript);
			}

			this.triggerMachinePostSourcing = triggerMachinePostSourcing;

			function triggerCustomPostSourcingScript(sublistId, fieldId, line)
			{
				recordScriptingScope.postSourcing(sublistId, fieldId, line);
			}

			this.triggerCustomPostSourcingScript = triggerCustomPostSourcingScript;
		}

		function create(record)
		{
			return new DynamicRecordImpl(record);
		}

		return {
			/**
			 * create a dynamic record implementation that will supplement record behavior
			 * @param {Record} record
			 */
			create: create
		};
	});

/**
 * SuiteScript dynamic record impl
 *
 * @private
 * @module N/record/deferredDynamicRecordImpl
 * @NApiVersion 2.x
 *
 */
define('N/record/deferredDynamicRecordImpl',['N/record/recordUtilityFunctions', 'N/utilityFunctions', 'N/error'],
	function(recordUtil, utilityFunctions, error)
	{
		/**
		 * Deferred Dynamic Record Implementation for record behavior
		 * @param {Record} record
		 * @constructor
		 */
		function DeferredDynamicRecordImpl(record)
		{
			var undef = undefined;

			function initRecord(record, scope)
			{
				if(record.getIsReadOnlyRecord())
					return;
				scope.pageInit();
				record.resetsetRecordStateController();
			}
			this.initRecord = initRecord;
			this.shouldValidateFieldPermissions = recordUtil.no_op_function;

			function isUnchangedExistingRecord(fieldState)
			{
				return !record.isNewRecord() && !fieldState.isChanged;
			}

			function validateTextApi(isTextApi, fieldState, setterMethod, suggestedMethod)
			{
				if (((isTextApi && !fieldState.useTextApi) || (!isTextApi && fieldState.useTextApi)) && !isUnchangedExistingRecord(fieldState))
				{
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_API_USAGE, suggestedMethod, setterMethod)
				}
			}

			this.validateTextApi = validateTextApi;

			this.validateLineIndex = recordUtil.no_op_function;

			this.getCachedOptionsForRecordField = recordUtil.no_op_function;

			function isSublistAScriptableMachine(sublistId)
			{
				return record.getSublistMetadata(sublistId) && record.getSublistMetadata(sublistId).isScriptableMachine;
			}

			function insertLineIfNewLineAndGetNewInstanceId(sublistId, line, useBuffer)
			{
				var isScriptableOrEditable = (isSublistAScriptableMachine(sublistId) || record.isSublistAnEditMachine(sublistId));
				var isLineZeroAndNoneExists = (line == Math.max(record.doGetLineCount(sublistId), 0));
				if (isScriptableOrEditable && isLineZeroAndNoneExists)
					record.doInsertLine(sublistId, line);
				return record.getModelController().getSublistLineInstanceIdForLine(sublistId, line, useBuffer);
			}

			function getLineInstanceId(sublistId, line, useBuffer)
			{
				var lineInstanceId = record.getModelController().getSublistLineInstanceIdForLine(sublistId, line, useBuffer);
				if (lineInstanceId === null)
					lineInstanceId = insertLineIfNewLineAndGetNewInstanceId(sublistId, line, useBuffer);
				return lineInstanceId;
			}
			this.getLineInstanceId = getLineInstanceId;

			function doGetText(fieldId, delegator)
			{
				var value = undef;
				var fieldState = record.getFieldState(fieldId);
				if (isUnchangedExistingRecord(fieldState))
				{
					value = delegator.getTextValue(fieldId);
				}
				else
					value = record.doGetValue(fieldId);

				return value;
			}

			this.doGetText = doGetText;

			function getParsedValueForBodyField(fieldId, delegator)
			{
				var isFieldChange = record.getFieldState(fieldId).isChanged;
				if (!isFieldChange)
					return delegator.getParsedValue(fieldId);
				else
					return record.doGetValue(fieldId);
			}
			this.getParsedValueForBodyField = getParsedValueForBodyField;

			function doSetValue(fieldId, value, fireFieldChange, noSlaving)
			{
				record.doSetFieldValue(fieldId, value, false, true);
			}

			this.doSetValue = doSetValue;

			this.postSetFieldValue = recordUtil.no_op_function;
			this.postSetFieldValueForInstance = recordUtil.no_op_function;

			function doSetText(fieldId, text)
			{
				var fireFieldChanged = false;
				var noSlaving = true;
				record.doSetFieldValue(fieldId, text, fireFieldChanged, noSlaving);
				record.getFieldState(fieldId).useTextApi = true;
			}

			this.doSetText = doSetText;

			this.validateAndFormatFieldValue = recordUtil.no_op_function;
			this.validateAndFormatFieldValueForInstance = recordUtil.no_op_function;

			function doGetParsedSublistValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer, delegator)
			{
				var value = undef;
				var isFieldChanged = record.getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, useBuffer).isChanged;
				if (!isFieldChanged)
				{
					value = delegator.getParsedValue(fieldId);
				}
				else
				{
					value = record.doGetSublistValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
				}

				return value;
			}
			this.doGetParsedSublistValueForInstance = doGetParsedSublistValueForInstance;


			function setSublistValue(options, fieldId, line, value)
			{
				var sublistId;
				var useBuffer = false;
				if (fieldId !== undef && line !== undef && value != undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					line = options.line;
					value = options.value;
				}
				utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], record.getMissingArgumentErrorMessageFillerValue("setSublistValue"));
				if (line < 0)
					return;
				recordUtil.validateAgainstSqlInjection(fieldId, value);
				record.doSetSublistValue(sublistId, fieldId, line, value);
				record.getSublistFieldState(sublistId, fieldId, line, useBuffer).useTextApi = false;
			}

			this.setSublistValue = setSublistValue;

			function doGetSublistTextForInstance(sublistId, fieldId, lineInstanceId, useBuffer, delegator)
			{
				var value = undef;
				var fieldState = record.getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
				if (isUnchangedExistingRecord(fieldState))
				{
					value = delegator.getTextValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
				}
				else
					value = record.doGetSublistValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer);

				return value;
			}
			this.doGetSublistTextForInstance = doGetSublistTextForInstance;

			function setSublistText(options, fieldId, line, text)
			{
				var sublistId;
				if (fieldId !== undef && line !== undef && text != undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					line = options.line;
					text = options.text;
				}
				utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], record.getMissingArgumentErrorMessageFillerValue("setSublistText"));
				recordUtil.validateAgainstSqlInjection(fieldId, text);
				doSetSublistText(sublistId, fieldId, line, text);
			}

			this.setSublistText = setSublistText;

			function doSetSublistText(sublistId, fieldId, line, text)
			{
				var useBuffer = false;
				record.doSetSublistValue(sublistId, fieldId, line, text);
				record.getSublistFieldState(sublistId, fieldId, line, useBuffer).useTextApi = true;
			}

			this.preInsertLine = recordUtil.no_op_function;
			this.preInsertLineForInstance = recordUtil.no_op_function;
			this.postInsertLine = recordUtil.no_op_function;
			this.postInsertLineForInstance = recordUtil.no_op_function;

			function removeSublistLine(sublistId, line, ignoreRecalc)
			{
				record.doRemoveSublistLine(sublistId, line);
			}
			this.removeSublistLine = removeSublistLine;
			function removeSublistLineForInstance(sublistId, lineInstanceId, ignoreRecalc)
			{
				record.doRemoveSublistLineForInstance(sublistId, lineInstanceId);
			}
			this.removeSublistLineForInstance = removeSublistLineForInstance;

			this.doSlaving = recordUtil.no_op_function;

			this.postRemoveLine = recordUtil.no_op_function;
			this.postRemoveLineForInstance = recordUtil.no_op_function;

			this.selectLine = recordUtil.no_op_function;

			this.selectNewLine = recordUtil.no_op_function;

			this.cancelLine = recordUtil.no_op_function;

			this.cancelLineForInstance = recordUtil.no_op_function;

			this.commitLine = recordUtil.no_op_function;

			this.commitLineForInstance = recordUtil.no_op_function;

			this.getCurrentSublistValue = recordUtil.no_op_function;

			this.setCurrentSublistValue = recordUtil.no_op_function;

			this.getCurrentSublistText = recordUtil.no_op_function;

			this.setCurrentSublistText = recordUtil.no_op_function;

			this.triggerFieldChangeEvent = recordUtil.no_op_function;

			this.triggerPageInitScript = recordUtil.no_op_function;

			this.triggerLineInitScript = recordUtil.no_op_function;

			this.triggerPostDeleteLineScript = recordUtil.no_op_function;

			this.triggerLineCommitScript = recordUtil.no_op_function;

			this.triggerValidateLineScript = recordUtil.no_op_function;

			this.triggerValidateInsertScript = recordUtil.no_op_function;

			this.triggerValidateDeleteScript = recordUtil.no_op_function;

			this.triggerValidateFieldScript = recordUtil.no_op_function;

			this.triggerFieldChangeScript = recordUtil.no_op_function;

			this.triggerCanCreateSubrecordScript = recordUtil.no_op_function;

			this.triggerSaveRecordScript = recordUtil.no_op_function;

			this.triggerRecalcScript = recordUtil.no_op_function;

			this.triggerMachinePostSourcing = recordUtil.no_op_function;

			this.triggerCustomPostSourcingScript = recordUtil.no_op_function;
		}

		function create(record)
		{
			return new DeferredDynamicRecordImpl(record);
		}

		return {
			/**
			 * create a deferred dynamic record implementation that will supplement record behavior
			 * @param {Record} record
			 */
			create : create
		};
	});

/**
 * SuiteScript record impl factory
 *
 * @private
 * @module N/record/recordImplementation
 * @NApiVersion 2.x
 *
 */
define('N/record/recordImplementation',['N/record/dynamicRecordImpl', 'N/record/deferredDynamicRecordImpl'], function(dynamicRecordImpl, deferredDynamicRecordImpl){

    function create(isDynamicRecord, record)
    {
        return isDynamicRecord ? dynamicRecordImpl.create(record) : deferredDynamicRecordImpl.create(record);
    }

    return {
        /**
         * create the corresponding implementation for record object based on the record mode
         * @param {boolean} isDynamicRecord
         * @param {Record} record object
         */
        create : create
    };
});

/**
 * @private
 */
define('N/restricted/scopeRemoteApiBridge',['N/restricted/reflet'], function(reflet){ return reflet; });

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/subrecordController
 * @suiteScriptVersion 2.x
 */
define('N/record/subrecordController',[ 'N/utilityFunctions', 'N/error', 'N/record/matrix', 'N/util/currencyUtility', 'N/util/date', 'N/util/formatter', 'N/record/recordCacheController'],
    function(utilityFunctions, error, matrix, currency, date, formatter, recordCacheController){

        function subrecordController(record)
        {
            var uncommittedSubrecordCache = recordCacheController.create();

            function createSubrecord(fieldId)
            {
                var result = null;
                var field, type, id;

                utilityFunctions.checkArgs([fieldId], ['fieldId'], 'createSubrecord');

                result = uncommittedSubrecordCache.get(null, fieldId);

                if(!!result || record.hasSubrecord(fieldId))
                {
                    utilityFunctions.throwSuiteScriptError(error.Type.FIELD_1_ALREADY_CONTAINS_A_SUBRECORD_YOU_CANNOT_CALL_CREATESUBRECORD,fieldId);
                }
                else
                {
                    result = record.doGetBodySubrecord(fieldId);
                    result = result.internalClone();
                    uncommittedSubrecordCache.put(null, fieldId, null, result);
                }

                return result;
            }

            function editSubrecord(fieldId)
            {
                var result = null;
                var field, type, id;

                utilityFunctions.checkArgs([fieldId], ['fieldId'], 'editSubrecord');

                result = uncommittedSubrecordCache.get(null, fieldId);

                if(!result && record.hasSubrecord(fieldId)){
                    result = record.doGetBodySubrecord(fieldId);
                    result = result.internalClone();
                    uncommittedSubrecordCache.put(null, fieldId, null, result);
                }

                return result;
            }

            function viewSubrecord(fieldId)
            {
                var result = null;
                var field, type, id;

                utilityFunctions.checkArgs([fieldId], ['fieldId'], 'viewSubrecord');

                result = uncommittedSubrecordCache.get(null, fieldId);

                if(!result && record.hasSubrecord(fieldId)){
                    result = record.doGetBodySubrecord(fieldId);
                    result = result.internalClone();
                }

                return result;
            }

            function removeSubrecord(fieldId)
            {
                uncommittedSubrecordCache.invalidate(null, fieldId);
                record.performSubrecordRemoval(fieldId);
            }

            function createCurrentLineItemSubrecord(sublistId, fieldId)
            {
                var result = null;
                var useBuffer = true;
                var modelController = record.getModelController();
                var lineInstanceId = modelController.getSublistLineInstanceIdForLine(sublistId, modelController.getCurrentSublistLineIndex(sublistId), useBuffer);

                if(record.hasCurrentSublistSubrecord(sublistId, fieldId) || uncommittedSubrecordCache.get(sublistId, fieldId, lineInstanceId, useBuffer) != null)
                {
                    utilityFunctions.throwSuiteScriptError(error.Type.FIELD_1_ALREADY_CONTAINS_A_SUBRECORD_YOU_CANNOT_CALL_CREATESUBRECORD,sublistId + "." +fieldId);
                }
                else
                {
                    result = record.doGetCurrentSublistSubrecord(sublistId, fieldId);
                    uncommittedSubrecordCache.put(null, fieldId, null, result);
                }

                return result;
            }

            function editCurrentLineItemSubrecord(sublistId, fieldId)
            {
                var useBuffer = true;
                var modelController = record.getModelController();
                var lineInstanceId = modelController.getSublistLineInstanceIdForLine(sublistId, modelController.getCurrentSublistLineIndex(sublistId), useBuffer);
                var result = uncommittedSubrecordCache.get(sublistId, fieldId, lineInstanceId, useBuffer);

                if(!result && record.hasCurrentSublistSubrecord(sublistId, fieldId))
                {
                    result = record.doGetCurrentSublistSubrecord(sublistId, fieldId);
                    result = result.internalClone();
                    uncommittedSubrecordCache.put(sublistId, fieldId, lineInstanceId, result, useBuffer);
                }

                return !result ? null : result;
            }

            function removeCurrentLineItemSubrecord(sublistId, fieldId)
            {
                var useBuffer = true;
                var modelController = record.getModelController();
                var lineInstanceId = modelController.getSublistLineInstanceIdForLine(sublistId, modelController.getCurrentSublistLineIndex(sublistId), useBuffer);

                uncommittedSubrecordCache.invalidate(sublistId, fieldId, lineInstanceId, useBuffer);
                record.doRemoveSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer)
            }

            function viewCurrentLineItemSubrecord(sublistId, fieldId)
            {
                var useBuffer = true;
                var modelController = record.getModelController();
                var lineInstanceId = modelController.getSublistLineInstanceIdForLine(sublistId, modelController.getCurrentSublistLineIndex(sublistId), useBuffer);
                var result = uncommittedSubrecordCache.get(sublistId, fieldId, lineInstanceId, useBuffer);

                if(!result && record.hasCurrentSublistSubrecord(sublistId, fieldId))
                {
                    result = record.doGetCurrentSublistSubrecord(sublistId, fieldId);
                    result = result.internalClone();
                }

                if(!!result)
                {
                    result.setReadonly();
                }

                return !result ? null : result;
            }

            function viewLineItemSubrecord(sublistId, fieldId, line)
            {
                var useSelectedLineBuffer = line === -1;
                var useBuffer = useSelectedLineBuffer;
                var modelController = record.getModelController();
                var lineInstanceId = useSelectedLineBuffer ?
                        modelController.getSublistLineInstanceIdForLine(sublistId, modelController.getCurrentSublistLineIndex(sublistId), useBuffer) :
                        modelController.getSublistLineInstanceIdForLine(sublistId, line, useBuffer);
                var result = uncommittedSubrecordCache.get(sublistId, fieldId, lineInstanceId, useBuffer);

                if (!result && record.hasSublistSubrecord(sublistId, fieldId, line))
                {
                    result = record.doGetSublistSubrecord(sublistId, fieldId, line);
                    result = result.internalClone();
                }

                if(!!result)
                {
                    result.setReadonly();
                }

                return !result ? null : result;
            }

            function commit(subrecordToCommit)
            {
                var subrecord, sublistId, fieldId;

                if(!!record.subrecordParent)
                {
                    record.triggerSaveRecordScript();
                    record.subrecordParent.commit(record);
                }
                else if(!record.subrecordParent && !!subrecordToCommit)
                {
                    sublistId = subrecordToCommit.subrecordSublistId || null;
                    fieldId = subrecordToCommit.subrecordFieldId;

                    if (sublistId === null)
                    {
                        if (subrecordToCommit === uncommittedSubrecordCache.get(null, fieldId))
                        {
                            subrecord = record.getSubrecord(fieldId);
                            subrecord.setModelController(subrecordToCommit.getModelController());
                            subrecord.setRecordStateController(subrecordToCommit.getRecordStateController());
                            uncommittedSubrecordCache.invalidate(null, fieldId);
                            record.triggerFieldChangeEvent(null, fieldId, -1, record.getFieldValue(fieldId), false);
                        }
                    }
                    else
                    {
                        /*
                         if(subrecord === uncommittedSubrecordCache.get(sublistId, fieldId, -1))
                         {

                         }
                         else
                         {
                         record.triggerFieldChangeEvent(null, fieldId, -1, getFieldValue(fieldId), false);
                         }
                         */
                    }
                }
            }

            function getUncommittedSubrecord(sublistId, fieldId, line0)
            {
                sublistId = sublistId || null;
                line0 = (!isNaN(line0) && line0 >= 0 && line0) || -1;

                var useSelectedLineBuffer = line0 === -1;
                var useBuffer = useSelectedLineBuffer;
                var modelController = record.getModelController();
                var lineInstanceId = useSelectedLineBuffer ?
                        modelController.getSublistLineInstanceIdForLine(sublistId, modelController.getCurrentSublistLineIndex(sublistId), useBuffer) :
                        modelController.getSublistLineInstanceIdForLine(sublistId, line0, useBuffer);

                return uncommittedSubrecordCache.get(sublistId, fieldId, lineInstanceId, useBuffer);
            }

            function invalidateSubrecordCacheForV1RecordScope()
            {
                uncommittedSubrecordCache = recordCacheController.create();
            }

            function invalidateSubrecordCacheEntry(sublistId, fieldId, line_0)
            {
                var useSelectedLineBuffer = line_0 === -1;
                var useBuffer = useSelectedLineBuffer;
                var modelController = record.getModelController();
                var lineInstanceId = useSelectedLineBuffer ?
                        modelController.getSublistLineInstanceIdForLine(sublistId, modelController.getCurrentSublistLineIndex(sublistId), useBuffer) :
                        modelController.getSublistLineInstanceIdForLine(sublistId, line_0, useBuffer);
                uncommittedSubrecordCache.invalidate(sublistId, fieldId, lineInstanceId, useBuffer);
            }

            function insertLineForSubrecordCache(sublistId, line)
            {
                var useSelectedLineBuffer = line === -1;
                var useBuffer = useSelectedLineBuffer;
                var modelController = record.getModelController();
                var lineInstanceId = useSelectedLineBuffer ?
                        modelController.getSublistLineInstanceIdForLine(sublistId, modelController.getCurrentSublistLineIndex(sublistId), useBuffer) :
                        modelController.getSublistLineInstanceIdForLine(sublistId, line, useBuffer);
                uncommittedSubrecordCache.get(sublistId, null, lineInstanceId, useBuffer);
            }

            function removeLineForSubrecordCache(sublistId, line)
            {
                var useSelectedLineBuffer = line === -1;
                var useBuffer = useSelectedLineBuffer;
                var modelController = record.getModelController();
                var lineInstanceId = useSelectedLineBuffer ?
                        modelController.getSublistLineInstanceIdForLine(sublistId, modelController.getCurrentSublistLineIndex(sublistId), useBuffer) :
                        modelController.getSublistLineInstanceIdForLine(sublistId, line, useBuffer);
                uncommittedSubrecordCache.invalidate(sublistId, null, lineInstanceId, useBuffer);
            }

            function invalidateCurrentSublistLineForSubrecordCache(sublistId)
            {
                var useBuffer = true;
                var modelController = record.getModelController();
                var lineInstanceId = modelController.getSublistLineInstanceIdForLine(sublistId, modelController.getCurrentSublistLineIndex(sublistId), useBuffer);

                uncommittedSubrecordCache.invalidate(sublistId, null, lineInstanceId, useBuffer);
            }

            return {
                createSubrecord: createSubrecord,
                editSubrecord: editSubrecord,
                viewSubrecord: viewSubrecord,
                removeSubrecord: removeSubrecord,
                createCurrentLineItemSubrecord: createCurrentLineItemSubrecord,
                editCurrentLineItemSubrecord: editCurrentLineItemSubrecord,
                removeCurrentLineItemSubrecord: removeCurrentLineItemSubrecord,
                viewCurrentLineItemSubrecord: viewCurrentLineItemSubrecord,
                viewLineItemSubrecord: viewLineItemSubrecord,
                commit: commit,
                getUncommittedSubrecord: getUncommittedSubrecord,
                invalidateSubrecordCacheForV1RecordScope: invalidateSubrecordCacheForV1RecordScope,
                invalidateSubrecordCacheEntry: invalidateSubrecordCacheEntry,
                insertLineForSubrecordCache: insertLineForSubrecordCache,
                removeLineForSubrecordCache: removeLineForSubrecordCache,
                invalidateCurrentSublistLineForSubrecordCache: invalidateCurrentSublistLineForSubrecordCache
            }
        }

        function create(record)
        {
            return new subrecordController(record);
        }


        return Object.freeze({create: create});
    }
);

/**
 * SuiteScript nlobjrecord implementation for version 2 record
 *
 * @private
 * @module N/record/legacyNLObjects
 * @NApiVersion 2.x
 *
 */
define('N/record/legacyNLObjects',['N/restricted/remoteApiBridge', 'N/restricted/invoker', 'N/utilityFunctions', 'N/runtime'],
function(remoteApi, invoker, utilityFunctions, runtime) {

	var getRecordModule = (function() {
		var module;
		return function getRecordModule() {
			if (!module)
			{
				require.forceSync(true);
				require(['N/record'], function(rm) {module = rm;});
				require.forceSync(false);
			}
			return module;
		}
	}());

	var getRecordImplModule = (function() {
		var module;
		return function getRecordModule() {
			if (!module)
			{
				require.forceSync(true);
				require.setInternal(true);
				require(['N/record/recordImpl'], function(rm) {module = rm;});
				require.setInternal(false);
				require.forceSync(false);
			}
			return module;
		}
	}());

	var getRecordImplV1Module = (function() {
		var module;
		return function getRecordModule() {
			if (!module)
			{
				require.forceSync(true);
				require.setInternal(true);
				require(['N/record/recordImplV1'], function(rm) {module = rm;});
				require.setInternal(false);
				require.forceSync(false);
			}
			return module;
		}
	}());

	var getRecordImplV1 = function(rawRecord) {
		if (!rawRecord) return null;
		if (rawRecord.constructor.name === 'RecordImplV1') return rawRecord;
		if (rawRecord.constructor.name === 'Record') return getRecordImplV1Module().create({record: rawRecord});
		return null;
	};

	var nlobjRecordGetter = (function()
	{
		var nlobjRecord;
		return function nlobjRecordGetter()
		{
			if (!nlobjRecord)  // must be defined only once so the instanceOf works properly
			{
				nlobjRecord = function nlobjRecord(type, id) {
					this.type = type;
					this.id = id;
					this.fields = {};
					this.fieldnames = [];
					this.lineitems = [];
					this.linetypes = {};
					this.linefields = {};
					this.matrixfields = {};
					this.currentlineitems = {};
					this.currentlineitemindexes = {};
					this.initialized = false;
					this.operations = [];
				};
				nlobjRecord.prototype.getId = function () { return this.id; };
				nlobjRecord.prototype.getRecordType = function () { return this.type; };
				nlobjRecord.prototype.setFieldValue = function (name, value) {
					this.fields[name] = value;
					this.logOperation("setFieldValue", {"field": name, "value": value})
				};
				nlobjRecord.prototype.setFieldValues = function (name, values) {
					this.fields[name] = values;
					this.logOperation("setFieldValues", {"field": name, "value": values})
				};
				nlobjRecord.prototype.getFieldValue = function (name) { return !!this.fields[name] ? this.fields[name] : null; };
				nlobjRecord.prototype.getFieldValues = function (name) { return !!this.fields[name] ? this.fields[name] : null; };
				nlobjRecord.prototype.getAllFields = function () {
					var s = [];
					for (var f in this.fields)
						if (this.fields.hasOwnProperty(f))
							s[s.length++] = f;
					for (var i = 0; i < this.fieldnames.length; i++)
						utilityFunctions.arrayAdd(s, this.fieldnames[i]);
					return s;
				};
				nlobjRecord.prototype.getAllLineItems = function () {
					var s = [];
					for (var f in this.lineitems)
						if (this.lineitems.hasOwnProperty(f))
							s[s.length++] = f;
					return s;
				};
				nlobjRecord.prototype.getAllLineItemFields = function (name) {
					var linegroup = this.linefields[name];
					if (!linegroup)
						return null;

					var s = [];
					for (var i = 0; i < this.linefields[name].length; i++)
						s[s.length++] = this.linefields[name][i];
					return s;
				};
				nlobjRecord.prototype.setLineItemValue = function (group, name, line, value) {
					assertTrue(line > 0 && line - 1 <= this.getLineItemCount(group), 'SSS_INVALID_SUBLIST_OPERATION');
					/* Special case setting fields on the next line for edit machines and UI object list machines (backward compatiblity) */
					if (line - 1 === this.getLineItemCount(group))
						this.selectNewLineItem(group);
					else if (line <= this.getLineItemCount(group))
						this.selectLineItem(group, line);
					this.setCurrentLineItemValue(group, name, value);
					this.commitLineItem(group)
				};
				nlobjRecord.prototype.setAndCommitLineItemValue = function (group, name, line, value) {
					var linegroup = this.lineitems[group];
					if (!linegroup) {
						linegroup = [];
						this.lineitems[group] = linegroup;
					}
					var lineitem = linegroup[line];
					if (!lineitem) {
						lineitem = new Array(1);
						linegroup[line] = lineitem;
					}
					lineitem[name] = value;
				};
				nlobjRecord.prototype.insertLineItem = function (type, line) {
					assertTrue(this.linetypes[type] === 'edit', 'SSS_INVALID_SUBLIST_OPERATION');
					if (this.getCurrentLineItemIndex(type) === -1) {
						if (line - 1 === this.getLineItemCount(type) || isNaN(parseInt(line)))
							this.selectNewLineItem(type);
						else if (line <= this.getLineItemCount(type))
							this.selectLineItem(type, line)
					}
					var linegroup = this.lineitems[type];
					if (!linegroup) {
						linegroup = new Array(1);
						this.lineitems[type] = linegroup;
					}
					linegroup.splice(line, 0, []);
					this.logOperation("insertLineItem", {"type": type})
				};
				nlobjRecord.prototype.removeLineItem = function (type, line) {
					assertTrue(this.linetypes[type] === 'edit', 'SSS_INVALID_SUBLIST_OPERATION');
					if (this.getCurrentLineItemIndex(type) === -1) {
						if (line - 1 === this.getLineItemCount(type) || isNaN(parseInt(line)))
							this.selectNewLineItem(type);
						else if (line <= this.getLineItemCount(type))
							this.selectLineItem(type, line)
					}

					var linegroup = this.lineitems[type];
					if (!linegroup || this.getLineItemCount(type) < line)
						return;
					linegroup.splice(line, 1);
					this.logOperation("removeLineItem", {"type": type});
					if (this.getCurrentLineItemIndex(type) !== -1) {
						this.currentlineitems[type] = null;
						this.currentlineitemindexes[type] = null;
					}
				};
				nlobjRecord.prototype.getLineItemValue = function (group, name, line) {
					var value = null;
					var linegroup = this.lineitems[group];
					if (!!linegroup) {
						var lineitem = linegroup[line];
						if (!!lineitem)
							value = lineitem[name];
					}
					return value != null ? value : null;
				};
				nlobjRecord.prototype.getLineItemCount = function (group) {
					var linegroup = this.lineitems[group];
					return !!linegroup ? linegroup.length - 1 /* zeroth line is unused. */ : 0;
				};
				nlobjRecord.prototype.setLineItemMatrixValue = function (type, fldnam, linenum, column, value) {
					if (this.isMatrixField(type, fldnam))
						this.setLineItemValue(type, this.getMatrixFieldName(type, fldnam, column), linenum, value)
				};
				nlobjRecord.prototype.getLineItemMatrixValue = function (type, fldnam, linenum, column) {
					if (this.isMatrixField(type, fldnam))
						return this.getLineItemValue(type, this.getMatrixFieldName(type, fldnam, column), linenum);
					return null;
				};
				nlobjRecord.prototype.findLineItemValue = function (type, fldnam, value) {
					for (var linenum = 1; linenum <= this.getLineItemCount(type); linenum++)
						if (value == this.getLineItemValue(type, fldnam, linenum))
							return linenum;
					return -1;
				};
				nlobjRecord.prototype.findLineItemMatrixValue = function (type, fldnam, column, value) {
					if (this.isMatrixField(type, fldnam))
						return this.findLineItemValue(type, this.getMatrixFieldName(type, fldnam, column), value);
					return -1;
				};
				nlobjRecord.prototype.setMatrixValue = function (type, fldnam, column, value) {
					if (this.isMatrixField(type, fldnam)) {
						this.fields[this.getFieldValue(type + 'header') + column] = value;
						this.logOperation("setMatrixValue", {"type": type, "field": name, "column": column, "value": value})
					}
				};
				nlobjRecord.prototype.getMatrixValue = function (type, fldnam, column) {
					return this.isMatrixField(type, fldnam) ? this.getFieldValue(this.getFieldValue(type + 'header') + column) : null;
				};
				nlobjRecord.prototype.getMatrixCount = function (type, fldnam) {
					return this.isMatrixField(type, fldnam) ? this.getFieldValue(this.getFieldValue(type + 'headercount')) : null;
				};
				nlobjRecord.prototype.selectLineItem = function (type, linenum) {
					assertTrue(!!this.linetypes[type] && linenum > 0 && linenum <= this.getLineItemCount(type), 'SSS_INVALID_SUBLIST_OPERATION');
					this.currentlineitems[type] = {};
					this.currentlineitemindexes[type] = linenum;
					var flds = this.getAllLineItemFields(type);
					for (var i = 0; i < flds.length; i++)
						this.currentlineitems[type][flds[i]] = this.getLineItemValue(type, flds[i], linenum)
					this.logOperation("selectLineItem", {"type": type, "linenum": linenum})
				};
				nlobjRecord.prototype.selectNewLineItem = function (type) {
					assertTrue(!!this.linetypes[type] && this.linetypes[type] === 'edit', 'SSS_INVALID_SUBLIST_OPERATION');
					this.currentlineitems[type] = {};
					this.currentlineitemindexes[type] = this.getLineItemCount(type) + 1;
					this.logOperation("selectNewLineItem", {"type": type})
				};
				nlobjRecord.prototype.cancelLineItem = function (type) {
					assertTrue(this.getCurrentLineItemIndex(type) !== -1, 'SSS_INVALID_SUBLIST_OPERATION');
					this.currentlineitems[type] = null;
					this.currentlineitemindexes[type] = null;
					this.logOperation("cancelLineItem", {"type": type})
				};
				nlobjRecord.prototype.commitLineItem = function (type) {
					assertTrue(this.getCurrentLineItemIndex(type) !== -1, 'SSS_INVALID_SUBLIST_OPERATION');
					var flds = this.getAllLineItemFields(type);
					var linenum = this.getCurrentLineItemIndex(type);
					for (var i = 0; i < flds.length; i++)
						this.setAndCommitLineItemValue(type, flds[i], linenum, this.currentlineitems[type][flds[i]])
					this.currentlineitems[type] = null;
					this.currentlineitemindexes[type] = null;
					this.logOperation("commitLineItem", {"type": type})
				};
				nlobjRecord.prototype.getCurrentLineItemIndex = function (type) { return !!this.currentlineitems[type] ? this.currentlineitemindexes[type] : -1; };
				nlobjRecord.prototype.getCurrentLineItemValue = function (type, name) {
					assertTrue(this.getCurrentLineItemIndex(type) !== -1, 'SSS_INVALID_SUBLIST_OPERATION');
					return this.currentlineitems[type][name]
				};
				nlobjRecord.prototype.setCurrentLineItemValue = function (type, name, value) {
					assertTrue(this.getCurrentLineItemIndex(type) !== -1, 'SSS_INVALID_SUBLIST_OPERATION');
					this.currentlineitems[type][name] = value;
					this.logOperation("setCurrentLineItemValue", {"type": type, "field": name, "value": value})
				};
				nlobjRecord.prototype.setCurrentLineItemMatrixValue = function (type, fldnam, column, value) {
					assertTrue(this.getCurrentLineItemIndex(type) !== -1, 'SSS_INVALID_SUBLIST_OPERATION');
					this.currentlineitems[type][this.getMatrixFieldName(type, fldnam, column)] = value;
					this.logOperation("setCurrentLineItemMatrixValue", {
						"type": type,
						"field": fldnam,
						"column": column,
						"value": value
					})
				};
				nlobjRecord.prototype.getCurrentLineItemMatrixValue = function (type, fldnam, column) {
					assertTrue(this.getCurrentLineItemIndex(type) !== -1, 'SSS_INVALID_SUBLIST_OPERATION');
					return this.currentlineitems[type][this.getMatrixFieldName(type, fldnam, column)]
				};
				/* field text APIs and field metadata APIs not yet supported via nlobjRecord interface in Client SuiteScript */

				nlobjRecord.prototype.setFieldText = function (name, text) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.setFieldTexts = function (name, texts) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getFieldText = function (name) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getFieldTexts = function (name) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getLineItemText = function (type, name, line) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getCurrentLineItemText = function (type, name) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.setCurrentLineItemText = function (type, name, text) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getField = function (fldnam) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getSublist = function (type) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getMatrixField = function (type, fldnam) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getLineItemField = function (type, name, linenum) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getLineItemField = function (type, name, linenum) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getFieldDisabled = function (name) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getFieldMandatory = function (name) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getFieldDisplay = function (name) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getFieldVisibility = function (name) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getFieldLabel = function (name) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getLineItemDisplay = function (name) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getLineItemDisabled = function (type, name, linenum) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getLineItemMandatory = function (type, name, linenum) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getLineItemLabel = function (type, name) { throwLegacyUnsupportedError(); };

				/* internal nlobjRecord helper methods */
				nlobjRecord.prototype.isMatrixField = function (type, fld) {
					return this.getFieldValue(type + 'matrixfields') != null && utilityFunctions.arrayIndexOf(this.getFieldValue(type + 'matrixfields')
						.split(","), fld) !== -1;
				};
				nlobjRecord.prototype.getMatrixFieldName = function (type, fldnam, column) { return this.isMatrixField(type, fldnam) ? fldnam + "_" + column + "_" : null; };
				nlobjRecord.prototype.logOperation = function (operation, args) {
					if (this.initialized) this.operations.push({
						"operation": operation,
						"args": args
					});
				};
				nlobjRecord.prototype.getDateTimeValue = function (fldname, timezone) {
					if (!timezone)
						return this.getFieldValue(fldname);
					else {
						var storedDateTime = this.getFieldValue(fldname);
						var preferredTimeZone = runtime.getCurrentUser().getPreference("TIMEZONE");
						if (preferredTimeZone === timezone)
							return storedDateTime;
						else
							return invoker(remoteApi, 'calculateGetDateTimeWithTimeZone', [storedDateTime, timezone]);
					}
				};

				nlobjRecord.prototype.setDateTimeValue = function (fldname, value, timezone) {
					if (!timezone)
						return this.setFieldValue(fldname, value);
					else {
						var preferredTimeZone = runtime.getCurrentUser().getPreference("TIMEZONE");
						if (preferredTimeZone === timezone)
							return this.setFieldValue(fldname, value);
						else {
							var newVal = invoker(remoteApi, 'calculateGetDateTimeWithTimeZone', [value, timezone]);
							return this.setFieldValue(fldname, newVal);
						}
					}
				};

				// this is only supported on server-side dynamic record
				nlobjRecord.prototype.calculateTax = function () { throwLegacyUnsupportedError(); };
			}
			return nlobjRecord;
		};
	})();

	var nlobjRecordWrapper = function(record, operation, options)
	{
		if (!record) return record;

		var v1Record = getRecordImplV1(record);
		if (v1Record)
		{
			var nlobjrecord = new (nlobjRecordGetter())(v1Record.getRecordType(), v1Record.getId());

			nlobjrecord.fieldnames = v1Record.getAllFields() || [];
			nlobjrecord.fieldnames.forEach(function (fld) {
				var val = v1Record.getFieldValue(fld);
				nlobjrecord.setFieldValue(fld, val);
			});

			nlobjrecord.linetypes = (function () {
				var linetypes = {};
				(v1Record.getAllSublists() || []).forEach(function (sl) {
					linetypes[sl] = v1Record.getSublistType(sl);
				});
				return linetypes;
			})();

			nlobjrecord.linefields = (function () {
				var linefields = {};
				(v1Record.getAllSublists() || []).forEach(function (sl) {
					linefields[sl] = v1Record.getAllLineItemFields(sl) || [];

					var lineCount = v1Record.getLineItemCount(sl);
					for (var line_1 = 1; line_1 < lineCount+1; line_1++)
					{
						linefields[sl].forEach(function (lineFld) {
							var val = v1Record.getLineItemValue(sl, lineFld, line_1);
							nlobjrecord.setAndCommitLineItemValue(sl, lineFld, line_1, val)
						});
					}
				});
				return linefields;
			})();

			nlobjrecord.matrixfields = (function () {
				var matrixfields = {};
				(v1Record.getAllSublists() || []).forEach(function (sl) {
					var mfv = v1Record.getFieldValue(sl + 'matrixfields');
					if (!!mfv) matrixfields[sl] = mfv.split(',');
				});
				return matrixfields;
			})();

			nlobjrecord.initialized = true;

			nlobjrecord.logOperation(operation, {'defaultValues': options.defaultValues});

			return nlobjrecord;
		}
	};

	var nlobjSublistGetter = (function()
	{
		var nlobjSubList;

		return function nlobjSublistGetter(record)
		{
			var getSublist = function(name) {
				var sl = null;
				var v1Record = getRecordImplV1(record);
				if (!v1Record)
					return sl;
				return v1Record.getSublist(name) || null;
			};

			if (!nlobjSubList)  // must be defined only once so the instanceOf works properly
			{
				nlobjSubList = function nlobjSubList(name) {
					var sl = getSublist(name);
					this.name = name;
					this.type = sl ? sl.getType() : null;
					this.label = null;
					this.hidden = false;
					this.display = true;
				};

				nlobjSubList.prototype.getName = function () { return this.name; };
				nlobjSubList.prototype.getType = function () { return this.type; };
				nlobjSubList.prototype.getLabel = function () { return this.label != null ? this.label : ""; };
				nlobjSubList.prototype.isHidden = function () { return this.hidden; };
				nlobjSubList.prototype.isDisplay = function () { return this.display; };
				nlobjSubList.prototype.isChanged = function () {
					var sl = getSublist(this.name);
					return sl ? sl.isChanged() : false;
				};

				nlobjSubList.prototype.setLabel = function (label) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.setHelpText = function (help) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.setDisplayType = function (type) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.setLineItemValue = function (field, line, value) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.setLineItemMatrixValue = function (field, line, column, value) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.setLineItemValues = function (values) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.getField = function (name) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.getAllFields = function () { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.getAllHeaderFields = function () { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.addField = function (name, type, label, source, group) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.addHeaderField = function (name, type, label, source) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.setAmountField = function (fldnam) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.setUniqueField = function (fldnam) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.getMatrixCount = function (field) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.addButton = function (name, label, script) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.getButton = function (name) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.addRefreshButton = function () { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.addMarkAllButtons = function () { throwLegacyUnsupportedError(); };
			}
			return nlobjSubList;
		};
	})();

	var nlobjSublistWrapper = function(record, sublist)
	{
		if (!sublist) return sublist;

		var nlobjsublist = new (nlobjSublistGetter(record))(sublist.getName());
		nlobjsublist.type = sublist.getType();
		nlobjsublist.hidden = !!sublist.isHidden();
		nlobjsublist.display = !!sublist.isDisplay();
		return  nlobjsublist;
	};

	var nlobjFieldGetter = (function()
	{
		var nlobjField;

		return function nlobjFieldGetter(record)
		{
			var getField = function(name, sublist, line_1)
			{
				var fld = null;
				var v1Record = getRecordImplV1(record);
				if (!v1Record)
					return fld;

				if (sublist) {
					fld = v1Record.getLineItemField(sublist, name, line_1);
				}
				else {
					fld = v1Record.getField(name);
				}
				return fld;
			};

			if (!nlobjField)  // must be defined only once so the instanceOf works properly
			{
				nlobjField = function nlobjField(name, type, sublist) {
					this.name = name;
					this.type = type;
					this.noslaving = false;
					this.sublist = sublist;
					this.label = null;
					this.required = false;
					this.disabled = false;
					this.hidden = false;
					this.display = false;
					this.visible = false;
					this.popup = false;
					this.readonly = false;
					this.parent = null;
					this.uifield = null;
					this.linenum = -1;
				};

				nlobjField.prototype.getName = function () { return this.name; };
				nlobjField.prototype.getType = function () { return this.type; };
				nlobjField.prototype.getLabel = function () { return this.label != null ? this.label : "" };
				nlobjField.prototype.getSubList = function () { return this.sublist; };
				nlobjField.prototype.getParent = function () { return this.parent; };
				nlobjField.prototype.getLine = function () { return this.linenum; };
				nlobjField.prototype.getUIField = function () { return this.uifield; };
				nlobjField.prototype.noSlaving = function () { return this.noslaving; };
				nlobjField.prototype.isMandatory = function () { return this.required; };
				nlobjField.prototype.isDisabled = function () { return this.disabled; };
				nlobjField.prototype.isHidden = function () { return this.hidden; };
				nlobjField.prototype.isPopup = function () { return this.popup; };
				nlobjField.prototype.isDisplay = function () { return this.display; };
				nlobjField.prototype.isVisible = function () { return this.visible; };
				nlobjField.prototype.isReadOnly = function () { return this.readonly; };

				nlobjField.DISPLAY_TYPE =
					{
						INLINE: 'inline', //not yet supported, throws SSS_NOT_YET_SUPPORTED
						HIDDEN: 'hidden',
						READ_ONLY: 'readonly', //only works for text area or rich text (different from server, where only text area works)
						ENTRY: 'entry',   //does not override Display Type : "Disabled" or "Hidden" UI setting
						DISABLED: 'disabled',
						NORMAL: 'normal'  //does override Display Type : "Disabled" or "Hidden" UI setting
					};

				nlobjField.prototype.setDisplayType = function (displayType) {
					checkArgs([displayType], ['displayType'], 'nlobjField.setDisplayType');
					console.log('setDisplayType: ' + displayType);

					var fld = getField(this.name, this.sublist, this.line);
					if (!fld)
						return;

					switch (displayType.toLowerCase()) {
						case nlobjField.DISPLAY_TYPE.INLINE:
							throwLegacyUnsupportedError();
							break;

						case nlobjField.DISPLAY_TYPE.HIDDEN:
							fld.setDisplay(false);
							fld.setVisible(false);

							this.hidden = true;
							this.visible = false;
							this.display = false;
							break;

						case nlobjField.DISPLAY_TYPE.READ_ONLY:
							if (!this.type || this.type !== "textarea")
								return;
							fld.setDisabled(true);
							this.disabled = true;
							break;

						case nlobjField.DISPLAY_TYPE.ENTRY:
							if (this.hidden || this.disabled)
								return;

							fld.setDisabled(false);
							fld.setDisplay(true);
							fld.setVisible(true);

							this.hidden = false;
							this.visible = true;
							this.display = true;
							this.disabled = false;
							break;

						case nlobjField.DISPLAY_TYPE.DISABLED:
							fld.setDisabled(true);
							this.disabled = true;
							break;

						case nlobjField.DISPLAY_TYPE.NORMAL:
							fld.setDisabled(false);
							fld.setDisplay(true);
							fld.setVisible(true);

							this.hidden = false;
							this.visible = true;
							this.display = true;
							this.disabled = false;
							break;

						default:
							break;
					}
				};

				nlobjField.prototype.setLabel = function (required) { throwLegacyUnsupportedError(); };
				nlobjField.prototype.setAlias = function (required) { throwLegacyUnsupportedError(); };
				nlobjField.prototype.setDefaultValue = function (required) { throwLegacyUnsupportedError(); };
				nlobjField.prototype.setDisabled = function (disabled) { throwLegacyUnsupportedError(); };
				nlobjField.prototype.setMandatory = function (disabled) { throwLegacyUnsupportedError(); };
				nlobjField.prototype.setMaxLength = function (disabled) { throwLegacyUnsupportedError(); };
				nlobjField.prototype.setLayoutType = function (disabled) { throwLegacyUnsupportedError(); };
				nlobjField.prototype.setLinkText = function (disabled) { throwLegacyUnsupportedError(); };
				nlobjField.prototype.setHelpText = function (text) { throwLegacyUnsupportedError(); };
				nlobjField.prototype.setDisplaySize = function (disabled) { throwLegacyUnsupportedError(); };
				nlobjField.prototype.setPadding = function (disabled) { throwLegacyUnsupportedError(); };
				nlobjField.prototype.addSelectOption = function (disabled) { throwLegacyUnsupportedError(); };
				nlobjField.prototype.getSelectOptions = function (token) { throwLegacyUnsupportedError(); };
			}
			return nlobjField;
		}
	})();

	var nlobjFieldWrapper = function(record, field, linenum)
	{
		if (!field) return field;

		var fieldState = record && record.hasOwnProperty("getFieldState") ? record.getFieldState(field.getName()) : null;

		var nlobjfield = new (nlobjFieldGetter(record))(field.getName(), field.getType(), field.getSublistName());

		nlobjfield.noslaving = field.noSlaving();
		nlobjfield.label = field.getLabel();
		nlobjfield.required = field.isMandatory();
		nlobjfield.disabled = field.isDisabled();
		nlobjfield.hidden = (fieldState && fieldState.isHidden) || false;
		nlobjfield.display = field.isDisplay();
		nlobjfield.visible = field.isVisible();
		nlobjfield.popup = field.isPopup();
		nlobjfield.readonly = field.isReadOnly();
		nlobjfield.parent = null; // most likely not doable in NEW UI
		nlobjfield.uifield = null;  // most likely not doable in NEW UI
		nlobjfield.linenum = linenum != null ? linenum : -1;

		return nlobjfield;
	};

	var nlobjErrorGetter = (function()
	{
		var nlobjError;

		return function nlobjErrorGetter()
		{
			function stacktrace()
			{
				var stackstring = "stacktrace: ";
				var history = [];
				var func = arguments.callee.caller;

				while (func != null)
				{
					var funcName = getFuncName(func);
					var funcArgs = getFuncArgs(func);
					var caller = func.caller;
					var infiniteLoopDetected = history.indexOf(funcName) !== -1;
					var historyTooLong = history.length > 50;
					var callerIsSelf = (caller === func);

					if (infiniteLoopDetected || historyTooLong || callerIsSelf)
						break;

					stackstring += funcName + funcArgs + "\n\n";
					history.push(funcName);
					func = caller;
				}
				return stackstring;
			}

			function getFuncArgs(a)
			{
				var s = "arguments: {";
				for (var i = 0; i < a.arguments.length; i++)
				{
					if (typeof a.arguments[i] == "undefined")
						s += '\'undefined\'';
					else if (a.arguments[i] == null)
						s += 'null';
					else if (typeof a.arguments[i] == "string")
						s += "'" + a.arguments[i].toString() + "'";
					else
						s += a.arguments[i].toString();
					if (i < a.arguments.length -1)
						s += ",";
				}
				s += "}";
				return s;
			}

			function getFuncName(f)
			{
				var s = f.toString();
				if (s.indexOf("anonymous") >= 0)
				{
					if (s.length > 100)
						return s.substr(0, 100) + "\n";
					else
						return s + "\n";
				}
				else
				{
					s = s.match(/function[^{]*/);
					if (s !== null)
						s = s[0];
				}
				if ((s == null) || (s.length == 0)) return "anonymous \n";
				return s;
			}

			if (!nlobjError)
			{
				nlobjError = function nlobjError(code, error, suppressnotification)
				{
					this.id = null;
					this.code = code;
					this.details = error;
					this.stacktrace = stacktrace();
					this.suppressnotification = suppressnotification;
					if (code instanceof nlobjError)
					{
						this.id = code.getId();
						this.code = code.getCode();
						this.details = code.getDetails();
						this.stacktrace = code.getStackTrace();
					}
					this.name = this.code;
					this.message = this.details;
					this.description = this.details;
				};
				nlobjError.prototype.getId = function( ) { return this.id; };
				nlobjError.prototype.getCode = function( ) { return this.code; };
				nlobjError.prototype.getDetails = function( ) { return this.details; };
				nlobjError.prototype.getStackTrace = function( ) { return this.stacktrace; };
			}
			return nlobjError;
		}
	})();

	var nlobjErrorWrapper = function(exception)
	{
		return exception && exception.hasOwnProperty('notifyOff') ? new (nlobjErrorGetter())(exception.name, exception.message, exception.notifyOff) : exception;
	};
	nlobjErrorWrapper.wrapEmitLegacyError = function(func)
	{
		var fun = func;
		return function()
		{
			try {
				return fun.apply(this, arguments);
			}
			catch (e)
			{
				throw nlobjErrorWrapper(e);
			}
		}
	};

	function throwLegacyError(code, error, suppressnotification) { throw new (nlobjErrorGetter())(code, error, suppressnotification); }
	function throwLegacyUnsupportedError() { throwLegacyError('SSS_NOT_YET_SUPPORTED'); }

	var assertTrue = nlobjErrorWrapper.wrapEmitLegacyError(utilityFunctions.assertTrue);

	var checkArgs = nlobjErrorWrapper.wrapEmitLegacyError(utilityFunctions.checkArgs);

	var nonRecordV1Functions = function() {

		// ==================== OPERATIONS THAT RETURN A RECORD ====================

		function createRecord(type, initializeValues)
		{
			var options = {type: type, defaultValues: initializeValues};

			return nlobjRecordWrapper(getRecordImplModule().create_raw(options), 'createRecord', options);
		}
		this.createRecord = nlobjErrorWrapper.wrapEmitLegacyError(createRecord);

		function copyRecord(type, id, initializeValues)
		{
			var options = {type: type, id: id, defaultValues: initializeValues};
			return nlobjRecordWrapper(getRecordImplModule().copy_raw(options), 'copyRecord', options);
		}
		this.copyRecord = nlobjErrorWrapper.wrapEmitLegacyError(copyRecord);

		function loadRecord(type, id, initializeValues)
		{
			var options = {type: type, id: id, defaultValues: initializeValues};
			return nlobjRecordWrapper(getRecordImplModule().load_raw(options), 'loadRecord', options);
		}
		this.loadRecord = nlobjErrorWrapper.wrapEmitLegacyError(loadRecord);

		function transformRecord(type, id, transformType, transformValues)
		{
			var options = {fromType: type, fromId: id, toType: transformType, defaultValues: transformValues};
			return nlobjRecordWrapper(getRecordImplModule().transform_raw(options), 'transformRecord', options);
		}
		this.transformRecord = nlobjErrorWrapper.wrapEmitLegacyError(transformRecord);

		// ==================== OPERATIONS THAT DO NOT RETURN A RECORD ====================

		function deleteRecord(type, id)
		{
			var options = {type: type, id: id};
			getRecordModule()['delete'](options);
		}
		this.deleteRecord = nlobjErrorWrapper.wrapEmitLegacyError(deleteRecord);

		function submitField(type, id, fields, values, doSourcing)
		{
			checkArgs([type, id, fields], ['type', 'id', 'fields'], 'nlapiSubmitField');

			try
			{
				var valuesObj = {};
				var flds = util.isArray(fields) ? fields : [fields];
				var vals = util.isArray(values) ? values : [values];
				for (var i = 0; i < flds.length; i++)
					valuesObj[flds[i]] = vals[i];
				var options = {type: type, id: id, values: valuesObj, enableSourcing: doSourcing};
				getRecordModule().submitFields(options);
			}
			catch(e)
			{
				throw nlobjErrorWrapper(e.constructor.name === 'SuiteScriptError' ? e : utilityFunctions.createSuiteScriptError(e));
			}
		}
		this.submitField = nlobjErrorWrapper.wrapEmitLegacyError(submitField);

		function attachRecord(type, id, type2, id2, attributes)
		{
			var options = {record: {type: type, id: id}, to: {type: type2, id: id2}, attributes: attributes};
			getRecordModule().attach(options);
		}
		this.attachRecord = nlobjErrorWrapper.wrapEmitLegacyError(attachRecord);

		function detachRecord(type, id, type2, id2, attributes)
		{
			var options = {record: {type: type, id: id}, from: {type: type2, id: id2}, attributes: attributes};
			getRecordModule().detach(options);
		}
		this.detachRecord = nlobjErrorWrapper.wrapEmitLegacyError(detachRecord);

		function submitRecord(nlobjRecord, options, ignoreMandatoryFields)
		{
			checkArgs([nlobjRecord], ['nlobjRecord'], 'nlapiSubmitRecord');

			if (runtime.getCurrentScript().getRemainingUsage() < 0)
				throwLegacyError('SCRIPT_EXECUTION_USAGE_LIMIT_EXCEEDED', 'Script Execution Usage Limit Exceeded');

			if (nlobjRecord.constructor.name !== 'nlobjRecord')
				throwLegacyError('SSS_INVALID_RECORD_OBJ', 'The record is not a valid object.');

			try
			{
				var attributes = {
					'enableSourcing':  ""+(options === true || (!!options && options.enableSourcing === true)),
					'disableTriggers': ""+(!!options && options.disableTriggers === true),
					'ignoreMandatoryFields': ""+(ignoreMandatoryFields === true || (!!options && options.ignoreMandatoryFields === true))
				};

				var recordData = JSON.stringify({
					attributes: attributes,
					type: nlobjRecord.type,
					id: nlobjRecord.id,
					load: nlobjRecord.operations[0],
					operations: Array.prototype.slice.call(nlobjRecord.operations, 1)
				});

				var sKey = invoker(remoteApi, 'submitLegacyRecord', [recordData]);
				// TODO: check if need to charge usage
				//nlapiGetContext().setUsage('nlapiSubmitRecord', nlobjRecord.getRecordType());
				return sKey;
			}
			catch(e)
			{
				throw nlobjErrorWrapper(e.constructor.name === 'SuiteScriptError' ? e : utilityFunctions.createSuiteScriptError(e));
			}
		}
		this.submitRecord = nlobjErrorWrapper.wrapEmitLegacyError(submitRecord);

		return Object.freeze(this);
		/** END: Non-record functions */
	};

	var nlobjWrappers = Object.freeze({
		nlobjRecordWrapper:  nlobjRecordWrapper,
		nlobjSublistWrapper:  nlobjSublistWrapper,
		nlobjFieldWrapper: nlobjFieldWrapper,
		nlobjErrorWrapper: nlobjErrorWrapper
	});
	var nlobjGetters = Object.freeze({
		nlobjRecordGetter: nlobjRecordGetter,
		nlobjSublistGetter: nlobjSublistGetter,
		nlobjFieldGetter: nlobjFieldGetter,
		nlobjErrorGetter: nlobjErrorGetter
	});

	return {
		nonRecordV1Functions: new(nonRecordV1Functions),
		nlobjWrappers: nlobjWrappers,
		nlobjGetters: nlobjGetters
	};
});

/**
 * SuiteScript module that allows access to a record (or subrecord) in a v1 manner based on a v2 record.
 *
 * @private
 * @module N/record/recordImplV1Util
 * @suiteScriptVersion 2.x
 */

define('N/record/recordImplV1Util',['N/error', 'N/utilityFunctions', 'N/record/recordUtilityFunctions', 'N/restricted/invoker', 'N/restricted/remoteApiBridge', 'N/record/sublist', 'N/record/legacyNLObjects'],
	function(error, utilityFunctions, recordUtil, invoker, remoteApi, sublist, legacyNLObjects) {

		/**
		 * @param {Record} record
		 * @param {Object} subrecordControllerV1
		 * @constructor
		 */
		function RecordImplV1(record, subrecordControllerV1)
		{
			var undef = undefined;

			this.nonRecordV1Functions = legacyNLObjects.nonRecordV1Functions;
			this.nlobjects = {
				nlobjRecordWrapper: legacyNLObjects.nlobjWrappers.nlobjRecordWrapper,
				nlobjSublistWrapper:  legacyNLObjects.nlobjWrappers.nlobjSublistWrapper.bind(null, record),
				nlobjFieldWrapper: legacyNLObjects.nlobjWrappers.nlobjFieldWrapper.bind(null, record),
				nlobjErrorWrapper: legacyNLObjects.nlobjWrappers.nlobjErrorWrapper,

				nlobjRecordGetter: legacyNLObjects.nlobjGetters.nlobjRecordGetter,
				nlobjSublistGetter: legacyNLObjects.nlobjGetters.nlobjSublistGetter.bind(null, record),
				nlobjFieldGetter: legacyNLObjects.nlobjGetters.nlobjFieldGetter.bind(null, record),
				nlobjErrorGetter: legacyNLObjects.nlobjGetters.nlobjErrorGetter
			};

			var wrapEmitLegacyError = legacyNLObjects.nlobjWrappers.nlobjErrorWrapper.wrapEmitLegacyError;

			function getDelegate()
			{
				return record;
			}
			this.getDelegate = wrapEmitLegacyError(getDelegate);

			function getId()
			{
				return record.id;
			}
			this.getId = wrapEmitLegacyError(getId);

			function getRecordType()
			{
				return record.getRecordType();
			}
			this.getRecordType = wrapEmitLegacyError(getRecordType);

			function fixNullEmptyBug()
			{
				return true;
			}

			function removeField(fieldId)
			{
				return record.doRemoveField(fieldId);
			}
			this.removeField = wrapEmitLegacyError(removeField);

			function removeLineItemField(sublistId, fieldId, line_1)
			{
				//TODO missing in recordDefinition.js
			}
			this.removeLineItemField = wrapEmitLegacyError(removeLineItemField);

			function getFieldValue(fieldId)
			{
				var value;
				//get redirect
				var subrecordRedirect = record.getSubrecordRedirect(null, fieldId);
				if (!!subrecordRedirect)
				{
					var subrecord = subrecordControllerV1.getUncommittedSubrecord(null, subrecordRedirect.subrecordFieldId, -1);
					if (!!subrecord)
					{
						value = subrecord.getValueAsLegacyString(subrecordRedirect.fieldId);
					}
					else if (record.hasSubrecord(subrecordRedirect.subrecordFieldId))
					{
						subrecord = record.doGetBodySubrecord(subrecordRedirect.subrecordFieldId);
						value = subrecord.getValueAsLegacyString(subrecordRedirect.fieldId);
					}
					else
						value = "";
				}
				else
				{
					value = record.getValueAsLegacyString(fieldId);
					value = fixNullEmptyBug() ? recordUtil.emptyIfNullOrUndefined(value) : value;
				}
				return value;
			}
			this.getFieldValue = wrapEmitLegacyError(getFieldValue);

			this.nlapiGetFieldValue = wrapEmitLegacyError(getFieldValue);

			function getFieldText(fieldId)
			{
				var returnText = "";
				var isMultiSelect = record.isFieldMultiSelect(null, fieldId);
				if (record.isFieldSelectType(null, fieldId) || isMultiSelect)
				{
					var value = record.getValue(fieldId);
					if (!utilityFunctions.isEmpty(value))
					{
						var useBuffer = true;
						returnText = record.doGetTextValueForSelectFieldForInstance(null, fieldId, value, null, useBuffer, isMultiSelect);
					}
				}
				return returnText;
			}
			this.getFieldText = wrapEmitLegacyError(getFieldText);

			function getFieldValues(fieldId)
			{
				var value = null;
				if (record.isFieldMultiSelect(null, fieldId))
				{
					value = record.getValueAsLegacyStringArray(fieldId);
					value = (value) ? value : (fixNullEmptyBug() ? [] : null);
				}

				return value;
			}
			this.getFieldValues = wrapEmitLegacyError(getFieldValues);

			function getFieldTexts(fieldId)
			{
				var value = null;
				if (record.isFieldMultiSelect(null, fieldId))
				{
					value = record.getText(fieldId);
					value = (value) ? value : (fixNullEmptyBug() ? [] : null);
				}
				return value;
			}
			this.getFieldTexts = wrapEmitLegacyError(getFieldTexts);

			function setFieldValue(fieldId, value, fireFieldChange, noSlaving)
			{
				fireFieldChange = util.isBoolean(fireFieldChange) ? fireFieldChange : fireFieldChange || true;

				var subrecordRedirect = record.getSubrecordRedirect(null, fieldId);
				if (!!subrecordRedirect)
				{
					var subrecord = subrecordControllerV1.getUncommittedSubrecord(null, subrecordRedirect.subrecordFieldId, -1);
					if (!!subrecord)
					{
						subrecord.setFieldValue(subrecordRedirect.fieldId, value, fireFieldChange, noSlaving);
					}

					subrecord = record.doGetBodySubrecord(subrecordRedirect.subrecordFieldId);
					subrecord.setValue({fieldId: subrecordRedirect.fieldId, value: value});
				}
				else
				{
					record.setFieldValue(fieldId, value, fireFieldChange, noSlaving);
				}
			}
			this.setFieldValue = wrapEmitLegacyError(setFieldValue);

			function setFieldText(fieldId, text, fireFieldChange)
			{
				fireFieldChange = util.isBoolean(fireFieldChange) ? fireFieldChange : fireFieldChange || true;
				record.setFieldtext(fieldId, text, fireFieldChange);
			}
			this.setFieldText = wrapEmitLegacyError(setFieldText);

			function setFieldValues(fieldId, values, fireFieldChange, noSlaving)
			{
				fireFieldChange = util.isBoolean(fireFieldChange) ? fireFieldChange : fireFieldChange || true;

				var subrecordRedirect = record.getSubrecordRedirect(null, fieldId);
				if (!!subrecordRedirect)
				{
					var subrecord = subrecordControllerV1.getUncommittedSubrecord(null, subrecordRedirect.subrecordFieldId, -1);
					if (!!subrecord)
					{
						subrecord.setFieldValues(subrecordRedirect.fieldId, values, fireFieldChange, noSlaving);
					}

					subrecord = record.doGetBodySubrecord(subrecordRedirect.subrecordFieldId);
					subrecord.setValue({fieldId: subrecordRedirect.fieldId, value: values});
				}
				else
				{
					record.setFieldValues(fieldId, values, fireFieldChange, noSlaving);
				}
			}
			this.setFieldValues = wrapEmitLegacyError(setFieldValues);

			function setFieldTexts(fieldId, texts, fireFieldChange)
			{
				fireFieldChange = util.isBoolean(fireFieldChange) ? fireFieldChange : fireFieldChange || true;
				record.setFieldTexts(fieldId, texts, fireFieldChange);
			}this.setFieldTexts = wrapEmitLegacyError(setFieldTexts);

			function calculateGetDateTimeWithTimeZone(dateTime, timeZone)
			{
				var context = invoker(remoteApi, "nlapiGetContext", []);
				if (dateTime && context.getPreference("TIMEZONE") !== timeZone)
				{
					//noinspection JSUnresolvedVariable
					dateTime = invoker(remoteApi, 'calculateGetDateTimeWithTimeZone', [dateTime, timeZone]);
				}
				return dateTime;
			}

			function calculateSetDateTimeWithNewTimeZone(dateTime, timeZone)
			{
				var context = invoker(remoteApi, "nlapiGetContext", []);
				if (dateTime && context.getPreference("TIMEZONE") !== timeZone)
				{
					//noinspection JSUnresolvedVariable
					dateTime = invoker(remoteApi, 'calculateSetDateTimeWithNewTimeZone', [dateTime, timeZone]);
				}
				return dateTime;
			}

			function getDateTimeValue(fieldId, timezone)
			{
				var dateTime = getFieldValue(fieldId);
				return calculateGetDateTimeWithTimeZone(dateTime, timezone);
			}
			this.getDateTimeValue = wrapEmitLegacyError(getDateTimeValue);

			function setDateTimeValue(fieldId, value, timezone)
			{
				value = calculateSetDateTimeWithNewTimeZone(value, timezone);
				return setFieldValue(fieldId, value);
			}
			this.setDateTimeValue = wrapEmitLegacyError(setDateTimeValue);

			function getLineItemValue(sublistId, fieldId, line_1)
			{
				var line_0 = recordUtil.getZeroBasedIndex(line_1);
				var value;
				//TODO: subrecord backward compatiability redirect
				value = record.getSublistLineValueAsLegacyString(sublistId, fieldId, line_0);
				value = fixNullEmptyBug() ? recordUtil.emptyIfNullOrUndefined(value) : value;
				return value;
			}
			this.getLineItemValue = wrapEmitLegacyError(getLineItemValue);

			function getLineItemText(sublistId, fieldId, line_1)
			{
				var line_0 = recordUtil.getZeroBasedIndex(line_1);
				var returnText = "";
				if (record.isFieldSelectType(sublistId, fieldId))
				{
					if (record.isFieldMultiSelect(sublistId, fieldId))
					{
						var values = getLineItemTexts(sublistId, fieldId, line_0);
						returnText = values.join(",");
					}
					else
					{
						returnText = record.getSublistText(sublistId, fieldId, line_0);
					}
				}
				return returnText;
			}
			this.getLineItemText = wrapEmitLegacyError(getLineItemText);

			function getLineItemValues(sublistId, fieldId, line_1)
			{
				var line_0 = recordUtil.getZeroBasedIndex(line_1);

				var value = null;
				if(record.isFieldMultiSelect(sublistId, fieldId))
				{
					value = getLineItemValue(sublistId, fieldId, line_0);
					value = fixNullEmptyBug() ? recordUtil.emptyIfNullOrUndefined(value) : value;
				}
				return value;
			}
			this.getLineItemValues = wrapEmitLegacyError(getLineItemValues);

			function getLineItemTexts(sublistId, fieldId, line_1)
			{
				var line_0 = recordUtil.getZeroBasedIndex(line_1);
				var texts = null;
				if (record.isFieldMultiSelect(sublistId, fieldId))
				{
					texts = record.getSublistText(sublistId, fieldId, line_0);
					texts = (texts) ? texts : (fixNullEmptyBug() ? [] : null);
				}
				return texts;
			}
			this.getLineItemTexts = wrapEmitLegacyError(getLineItemTexts);

			function setLineItemValue(sublistId, fieldId, line_1, value)
			{
				if (record.isSublistValid(sublistId))
				{
					recordUtil.validateAgainstSqlInjection(fieldId, value);
					var line_0 = recordUtil.getZeroBasedIndex(line_1);
					// For list machine UI compatibility, autoset the current line whenever the line item value is set directly
					var autosetCurrentLine = record.isDynamic && record.doGetCurrentSublistIndex(sublistId) == line_1 && record.isSublistAListMachine(sublistId);

					var subrecordRedirect = record.getSubrecordRedirect(sublistId, fieldId);
					var subrecord;
					var fireFieldChange = false;

					value = recordUtil.emptyIfNullOrUndefined(value);
					if (record.getSublistMetadata(sublistId).displayOnly)
						utilityFunctions.throwSuiteScriptError(error.Type.INVALID_SCRIPT_OPERATION_ON_READONLY_SUBLIST_FIELD, sublistId);

					/* Special case setting fields on the next line for edit machines and UI object list machines (backward compatiblity) */
					if (record.isSublistAnEditMachine(sublistId) && line_0 === record.getModelController().getNewLineIndex(sublistId))
						record.doInsertLine(sublistId, line_0);
					record.validateLineIndex(line_0, 0, record.doGetLineCount(sublistId) + 1);

					if (!!subrecordRedirect)
					{
						subrecord = subrecordControllerV1.getUncommittedSubrecord(sublistId, subrecordRedirect.subrecordFieldId, line_0);
						if (!!subrecord)
						{
							subrecord.setValue({fieldId: subrecordRedirect.fieldId, value: value, fireFieldChange: fireFieldChange});
						}

						subrecord = record.doGetSublistSubrecord(sublistId, subrecordRedirect.subrecordFieldId, line_0);
						subrecord.setValue({fieldId: subrecordRedirect.fieldId, value: value, fireFieldChange: fireFieldChange});


						if (autosetCurrentLine)
						{
							subrecord = subrecordControllerV1.getUncommittedSubrecord(sublistId, subrecordRedirect.subrecordFieldId);
							if (!!subrecord)
							{
								subrecord.setValue({fieldId: subrecordRedirect.fieldId, value: value, fireFieldChange: fireFieldChange});
							}

							var currentSubrecord = record.doGetCurrentSublistSubrecord(sublistId, subrecordRedirect.subrecordFieldId);
							currentSubrecord.setValue({fieldId: subrecordRedirect.fieldId, value: value, fireFieldChange: fireFieldChange});
						}
					}
					else
					{
						record.setLineItemValue(sublistId, fieldId, line_0, value);
						// For list machine UI compatibility, autoset the current line whenever the line item value is set directly
						if (autosetCurrentLine)
							setCurrentLineItemValue(sublistId, fieldId, value, false);
					}
				}
			}
			this.setLineItemValue = wrapEmitLegacyError(setLineItemValue);


			function getCurrentLineItemValue(sublistId, fieldId)
			{
				var value;
				//TODO: subrecord backward compatiability redirect
				value = record.getCurrentSublistLineValueAsLegacyString(sublistId, fieldId);
				value = recordUtil.emptyIfNullOrUndefined(value);
				return value;
			}
			this.getCurrentLineItemValue = wrapEmitLegacyError(getCurrentLineItemValue);

			function getCurrentLineItemText(sublistId, fieldId)
			{
				var returnText = "";
				if (record.isFieldSelectType(sublistId, fieldId))
				{
					if (record.isFieldMultiSelect(sublistId, fieldId))
					{
						var values = getCurrentLineItemTexts(sublistId, fieldId);
						returnText = values.join(",");
					}
					else
					{
						returnText = record.getCurrentSublistText(sublistId, fieldId);
					}
				}
				return returnText;
			}
			this.getCurrentLineItemText = wrapEmitLegacyError(getCurrentLineItemText);

			function getCurrentLineItemValues(sublistId, fieldId)
			{
				if (record.isFieldMultiSelect(sublistId, fieldId))
				{
					var value = getCurrentLineItemValue(sublistId, fieldId);
					return recordUtil.formatValueToArrayType(value);
				}
			}
			this.getCurrentLineItemValues = wrapEmitLegacyError(getCurrentLineItemValues);

			function getCurrentLineItemTexts(sublistId, fieldId)
			{
				var texts = null;
				if (record.isFieldMultiSelect(sublistId, fieldId))
				{
					texts = record.getCurrentSublistText(sublistId, fieldId);
					texts = (texts) ? texts : (fixNullEmptyBug() ? [] : null);
				}
				return texts;
			}
			this.getCurrentLineItemTexts = wrapEmitLegacyError(getCurrentLineItemTexts);

			function setCurrentLineItemValue(sublistId, fieldId, value, fireFieldChange)
			{
				fireFieldChange = util.isBoolean(fireFieldChange) ? fireFieldChange : fireFieldChange || true;
				var subrecordRedirect = record.getSubrecordRedirect(sublistId, fieldId);
				if (!!subrecordRedirect)
				{
					var subrecord = subrecordControllerV1.getUncommittedSubrecord(sublistId, subrecordRedirect.subrecordFieldId, -1);
					if (!!subrecord)
					{
						subrecord.setFieldValue(subrecordRedirect.fieldId, value, fireFieldChange);
					}

					subrecord = record.doGetBodySubrecord(subrecordRedirect.subrecordFieldId);
					subrecord.setValue({fieldId: subrecordRedirect.fieldId, value: value});
				}
				else
				{
					record.setCurrentLineItemValue(sublistId, fieldId, value, fireFieldChange);
				}
			}
			this.setCurrentLineItemValue = wrapEmitLegacyError(setCurrentLineItemValue);

			function setCurrentLineItemValues(sublistId, fieldId, values, fireFieldChange)
			{
				setCurrentLineItemValue(sublistId, fieldId, values != null ? values.join(String.fromCharCode(5)) : "", fireFieldChange);
			}
			this.setCurrentLineItemValues = wrapEmitLegacyError(setCurrentLineItemValues);

			function setCurrentLineItemText(sublistId, fieldId, text, fireFieldChange)
			{
				fireFieldChange = util.isBoolean(fireFieldChange) ? fireFieldChange : fireFieldChange || true;
				record.setCurrentLineItemText(sublistId, fieldId, text, fireFieldChange)
			}
			this.setCurrentLineItemText = wrapEmitLegacyError(setCurrentLineItemText);


			function getCurrentLineItemDateTimeValue(sublistId, fieldId, timeZone)
			{
				var dateTime = getCurrentLineItemValue(sublistId, fieldId);
				return calculateGetDateTimeWithTimeZone(dateTime, timeZone);
			}
			this.getCurrentLineItemDateTimeValue = wrapEmitLegacyError(getCurrentLineItemDateTimeValue);

			function setCurrentLineItemDateTimeValue(sublistId, fieldId, dateTime, timeZone)
			{
				dateTime = calculateSetDateTimeWithNewTimeZone(dateTime, timeZone);
				return setCurrentLineItemValue(sublistId, fieldId, dateTime);
			}
			this.setCurrentLineItemDateTimeValue = wrapEmitLegacyError(setCurrentLineItemDateTimeValue);

			function getLineItemDateTimeValue(sublistId, fieldId, line, timeZone)
			{
				var dateTime = getLineItemValue(sublistId, fieldId, line);
				return calculateGetDateTimeWithTimeZone(dateTime, timeZone);
			}
			this.getLineItemDateTimeValue = wrapEmitLegacyError(getLineItemDateTimeValue);

			function setLineItemDateTimeValue(sublistId, fieldId, lineNum, dateTime, timeZone)
			{
				dateTime = calculateSetDateTimeWithNewTimeZone(dateTime, timeZone);
				return setLineItemValue(sublistId, fieldId, lineNum, dateTime);
			}
			this.setLineItemDateTimeValue = wrapEmitLegacyError(setLineItemDateTimeValue);

			function getCurrentLineItemIndex(sublistId)
			{
				return recordUtil.getOneBasedIndex(record.doGetCurrentSublistIndex(sublistId));
			}
			this.getCurrentLineItemIndex = wrapEmitLegacyError(getCurrentLineItemIndex);

			function lineItemIsChanged(type) {
				var useBuffer = true;
				var isChanged = false;
				var line = record.doGetCurrentSublistIndex(type);
				(record.getSublistFields(type) || []).forEach(function (fld) {
					isChanged |= record.getSublistFieldState(type, fld, line, useBuffer).isChanged;
				});
				return !!isChanged;
			}
			this.lineItemIsChanged = wrapEmitLegacyError(lineItemIsChanged);

			function getSublistType(sublistId) {
				return record.getSublistType(sublistId);
			}
			this.getSublistType = wrapEmitLegacyError(getSublistType);

			function getV1Sublist(sublistId)
			{
				var sublistLevelMetadata = record.getSublistMetadata(sublistId);
				return (sublistLevelMetadata != null) ? sublist.newInstanceOfV1Sublist({
					type: sublistLevelMetadata.nlobjSublistConstructorType,
					sublistState: record.getSublistState(sublistId),
					sublistFields: sublistLevelMetadata.fieldMetadata
				}) : null;
			}
			this.getV1Sublist = wrapEmitLegacyError(getV1Sublist);

			function getSublist(sublistId)
			{
				return getV1Sublist(sublistId);
			}
			this.getSublist = wrapEmitLegacyError(getSublist);

			function getLineItemCount(sublistId)
			{
				return record.doGetLineCount(sublistId);
			}
			this.getLineItemCount = wrapEmitLegacyError(getLineItemCount);

			function findLineItemValue(sublistId, fieldId, value)
			{
				var index = record.doFindSublistLineWithValue(sublistId, fieldId, value);
				return recordUtil.getOneBasedIndex(index);
			}
			this.findLineItemValue = wrapEmitLegacyError(findLineItemValue);

			function findLineItemMatrixValue(options, fieldId, column_1, value)
			{
				var column_0 = recordUtil.getZeroBasedIndex(column_1);
				var index = record.findMatrixSublistLineWithValue(options, fieldId, column_0, value);
				return recordUtil.getOneBasedIndex(index);
			}
			this.findLineItemMatrixValue = wrapEmitLegacyError(findLineItemMatrixValue);

			function getMatrixField(options, fieldId, column_1)
			{
				var column_0 = recordUtil.getZeroBasedIndex(column_1);
				return record.getMatrixHeaderField(options, fieldId, column_0);
			}
			this.getMatrixField = wrapEmitLegacyError(getMatrixField);

			function getMatrixCount(options, fieldId)
			{
				return record.getMatrixHeaderCount(options, fieldId);
			}
			this.getMatrixCount = wrapEmitLegacyError(getMatrixCount);

			function getMatrixValue(options, fieldId, column_1)
			{
				var column_0 = recordUtil.getZeroBasedIndex(column_1);
				return record.getMatrixHeaderValue(options, fieldId, column_0);
			}
			this.getMatrixValue = wrapEmitLegacyError(getMatrixValue);

			function setMatrixValue(options, fieldId, column_1, value, fireFieldChange)
			{
				fireFieldChange = util.isBoolean(fireFieldChange) ? fireFieldChange : fireFieldChange || true;
				var column_0 = recordUtil.getZeroBasedIndex(column_1);
				return record.setMatrixHeaderValue(options, fieldId, column_0, value, !fireFieldChange);
			}
			this.setMatrixValue = wrapEmitLegacyError(setMatrixValue);


			function getLineItemMatrixField(sublistId, fieldId, line_1, column_1)
			{
				if(!column_1)
				{
					column_1 = line_1;
					line_1 = -1;
				}
				var column_0 = recordUtil.getZeroBasedIndex(column_1);
				var line_0 = recordUtil.getZeroBasedIndex(line_1);
				return record.getMatrixSublistField(sublistId, fieldId, line_0, column_0);
			}
			this.getLineItemMatrixField = wrapEmitLegacyError(getLineItemMatrixField);

			function getLineItemMatrixValue(sublistId, fieldId, line_1, column_1)
			{
				var column_0 = recordUtil.getZeroBasedIndex(column_1);
				var line_0 = recordUtil.getZeroBasedIndex(line_1);
				return record.getMatrixSublistValue(sublistId, fieldId, line_0, column_0);
			}
			this.getLineItemMatrixValue = wrapEmitLegacyError(getLineItemMatrixValue);

			function setLineItemMatrixValue(sublistId, fieldId, line_1, column_1, value)
			{
				var column_0 = recordUtil.getZeroBasedIndex(column_1);
				var line_0 = recordUtil.getZeroBasedIndex(line_1);
				return record.setMatrixSublistValue(sublistId, fieldId, line_0, column_0, value);
			}
			this.setLineItemMatrixValue = wrapEmitLegacyError(setLineItemMatrixValue);

			function getCurrentLineItemMatrixValue(sublistId, fieldId, column_1)
			{
				var column_0 = recordUtil.getZeroBasedIndex(column_1);
				return record.getCurrentMatrixSublistValue(sublistId, fieldId, column_0);
			}
			this.getCurrentLineItemMatrixValue = wrapEmitLegacyError(getCurrentLineItemMatrixValue);

			function setCurrentLineItemMatrixValue(sublistId, fieldId, column_1, value, fireFieldChange)
			{
				var column_0 = recordUtil.getZeroBasedIndex(column_1);
				fireFieldChange = util.isBoolean(fireFieldChange) ? fireFieldChange : fireFieldChange || true;
				return record.setCurrentMatrixSublistValue(sublistId, fieldId, column_0, value, !fireFieldChange);
			}
			this.setCurrentLineItemMatrixValue = wrapEmitLegacyError(setCurrentLineItemMatrixValue);

			function selectNewLineItem(sublistId, ignoreLineInit)
			{
				var lineObj = record.doSelectNewLine(sublistId, ignoreLineInit);
				subrecordControllerV1.invalidateCurrentSublistLineForSubrecordCache(sublistId);
				return lineObj;
			}
			this.selectNewLineItem = wrapEmitLegacyError(selectNewLineItem);

			function selectLineItem(sublistId, line_1)
			{
				var line_0 = recordUtil.getZeroBasedIndex(line_1);
				var lineObj = record.doSelectLine(sublistId, line_0);
				subrecordControllerV1.invalidateCurrentSublistLineForSubrecordCache(sublistId);
				return lineObj;
			}
			this.selectLineItem = wrapEmitLegacyError(selectLineItem);

			function insertLineItem(sublistId, line_1, ignoreRecalc)
			{
				if(!line_1)
				{
					line_1 = getCurrentLineItemIndex(sublistId);
				}
				var line_0 = recordUtil.getZeroBasedIndex(line_1);
				record.doInsertLine(sublistId, line_0, ignoreRecalc);
				subrecordControllerV1.invalidateCurrentSublistLineForSubrecordCache(sublistId);
			}
			this.insertLineItem = wrapEmitLegacyError(insertLineItem);

			function removeLineItem(sublistId, line_1, ignoreRecalc)
			{
				if(!line_1)
				{
					line_1 = getCurrentLineItemIndex(sublistId);
				}
				var line_0 = recordUtil.getZeroBasedIndex(line_1);
				record.doRemoveLine(sublistId, line_0, ignoreRecalc);
				subrecordControllerV1.invalidateCurrentSublistLineForSubrecordCache(sublistId);
			}
			this.removeLineItem = wrapEmitLegacyError(removeLineItem);

			function cancelLineItem(sublistId)
			{
				record.doCancelLine(sublistId);
				subrecordControllerV1.invalidateCurrentSublistLineForSubrecordCache(sublistId);
			}
			this.cancelLineItem = wrapEmitLegacyError(cancelLineItem);

			function commitLineItem(sublistId, ignoreRecalc)
			{
				record.doCommitLine(sublistId, ignoreRecalc);
				var sublistState = record.getSublistState(sublistId);
				if (!sublistState.allowsNewLine)
					sublistState.resetCurrentLineState(record.getCurrentSublistIndex(sublistId));
				subrecordControllerV1.invalidateCurrentSublistLineForSubrecordCache(sublistId);

			}
			this.commitLineItem = wrapEmitLegacyError(commitLineItem);

			function insertLineItemOption(type, fldnam, value, text, selected)
			{
				utilityFunctions.assertTrue(type != null && fldnam != null && fldnam.indexOf('custpage') == 0, 'SSS_INVALID_OPERATION');
				var fld = getLineItemField(type, fldnam);
				if (fld && fld.hasOwnProperty('insertSelectOption') && !fld.isPopup())
					fld.insertSelectOption(value, text, selected, true);
			}
			this.insertLineItemOption = wrapEmitLegacyError(insertLineItemOption);

			function removeLineItemOption(type, fldnam, value)
			{
				utilityFunctions.assertTrue(type != null && fldnam != null && fldnam.indexOf('custpage') == 0, 'SSS_INVALID_OPERATION');
				var fld = getLineItemField(type, fldnam);
				if (fld && fld.hasOwnProperty('removeSelectOption') && !fld.isPopup())
				{
					if (value != null)
						fld.removeSelectOption(value, true);
					else // remove all options
						(fld.getSelectOptions() || []).forEach(function (selectOption) {fld.removeSelectOption(selectOption.getId())});
				}
			}
			this.removeLineItemOption = wrapEmitLegacyError(removeLineItemOption);

			function insertSelectOption(fldnam, value, text, selected)
			{
				utilityFunctions.assertTrue(fldnam != null && fldnam.indexOf('custpage') == 0, 'SSS_INVALID_OPERATION');
				var fld = getField(fldnam);
				if (fld && fld.hasOwnProperty('insertSelectOption') && !fld.isPopup())
					fld.insertSelectOption(value, text, selected);
			}
			this.insertSelectOption = wrapEmitLegacyError(insertSelectOption);

			function removeSelectOption(fldnam, value)
			{
				utilityFunctions.assertTrue(fldnam != null && fldnam.indexOf('custpage') == 0, 'SSS_INVALID_OPERATION');
				var fld = getField(fldnam);
				if (fld && fld.hasOwnProperty('removeSelectOption') && !fld.isPopup())
				{
					if (value != null)
						fld.removeSelectOption(value);
					else // remove all options
						(fld.getSelectOptions() || []).forEach(function (selectOption) {fld.removeSelectOption(selectOption.getId())});
				}
			}
			this.removeSelectOption = wrapEmitLegacyError(removeSelectOption);

			function getField(fieldId)
			{
				var sublistId = undef;
				var lineInstanceId = null;
				var useBuffer = false;
				return record.getCachedRecordField(sublistId, fieldId, lineInstanceId, useBuffer);
			}
			this.getField = wrapEmitLegacyError(getField);

			function getLineItemField(sublistId, fieldId, line_1)
			{
				var line_0;
				if (line_1 === undef || line_1 === -1)
					line_0 = record.getCurrentSublistIndex(sublistId);
				else
					line_0 = recordUtil.getZeroBasedIndex(line_1);
				var useBuffer = line_0 === record.getCurrentSublistIndex(sublistId);
				return (line_0 === -1) ? undef : record.getCachedRecordField(sublistId, fieldId, line_0, useBuffer);
			}
			this.getLineItemField = wrapEmitLegacyError(getLineItemField);

			function getAllSublists()
			{
				return record.getSublists()
			}
			this.getAllSublists = wrapEmitLegacyError(getAllSublists);

			function getAllFields()
			{
				return record.getFields();
			}
			this.getAllFields = wrapEmitLegacyError(getAllFields);

			function getAllLineItemFields(sublistId)
			{
				return record.getSublistFields(sublistId);
			}
			this.getAllLineItemFields = wrapEmitLegacyError(getAllLineItemFields);

			function isDynamic()
			{
				return record.isDynamic;
			}
			this.isDynamic = wrapEmitLegacyError(isDynamic);

			function isChanged()
			{
				return record.isChanged();
			}
			this.isChanged = wrapEmitLegacyError(isChanged);

			function isInternal()
			{
				return record.isInternal();
			}
			this.isInternal = wrapEmitLegacyError(isInternal);

			function getFieldDisabled(fieldId)
			{
				var field = getField(fieldId);
				if (field)
					return field.isDisabled();
			}
			this.getFieldDisabled = wrapEmitLegacyError(getFieldDisabled);

			function setFieldDisabled(fieldId, disable)
			{
				var field = getField(fieldId);
				if (field)
					field.setDisabled(disable);
			}
			this.setFieldDisabled = wrapEmitLegacyError(setFieldDisabled);

			function getFieldMandatory(fieldId)
			{
				var field = getField(fieldId);
				if (field)
					return field.isMandatory();
			}
			this.getFieldMandatory = wrapEmitLegacyError(getFieldMandatory);

			function setFieldMandatory(fieldId, mandatory)
			{
				var field = getField(fieldId);
				if (field)
					field.setMandatory(mandatory);
			}
			this.setFieldMandatory = wrapEmitLegacyError(setFieldMandatory);

			function getFieldDisplay(fieldId)
			{
				var field = getField(fieldId);
				if (field)
					return field.isDisplay();
			}
			this.getFieldDisplay = wrapEmitLegacyError(getFieldDisplay);

			function setFieldDisplay(fieldId, display)
			{
				var field = getField(fieldId);
				if (field)
					field.setDisplay(display);
			}
			this.setFieldDisplay = wrapEmitLegacyError(setFieldDisplay);

			function getFieldVisibility(fieldId, visible)
			{
				var field = getField(fieldId);
				if (field)
					return field.isVisible(visible);
			}
			this.getFieldVisibility = wrapEmitLegacyError(getFieldVisibility);

			function setFieldVisibility(fieldId, visible)
			{
				var field = getField(fieldId);
				if (field)
					field.setVisible(visible);
			}
			this.setFieldVisibility = wrapEmitLegacyError(setFieldVisibility);

			function getFieldReadOnly(fieldId)
			{
				var field = getField(fieldId);
				if (field)
					return field.isReadOnly();
			}
			this.getFieldReadOnly = wrapEmitLegacyError(getFieldReadOnly);

			function setFieldReadOnly(fieldId, readonly)
			{
				var field = getField(fieldId);
				if (field)
					field.setReadOnly(readonly);
			}
			this.setFieldReadOnly = wrapEmitLegacyError(setFieldReadOnly);

			function getFieldLabel(fieldId)
			{
				var field = getField(fieldId);
				if (field)
					return field.getLabel();
			}
			this.getFieldLabel = wrapEmitLegacyError(getFieldLabel);

			function setFieldLabel(fieldId, label)
			{
				var field = getField(fieldId);
				if (field)
					field.setLabel(label);
			}
			this.setFieldLabel = wrapEmitLegacyError(setFieldLabel);

			function getLineItemDisplay(sublistId)
			{
				var sublistState = record.getSublistState(sublistId);
				return (sublistState) ? sublistState.isDisplay : false;
			}
			this.getLineItemDisplay = wrapEmitLegacyError(getLineItemDisplay);

			function setLineItemDisplay(sublistId, display)
			{
				var sublistState = record.getSublistState(sublistId);
				if (sublistState)
					sublistState.isDisplay = display;
			}
			this.setLineItemDisplay = wrapEmitLegacyError(setLineItemDisplay);

			function doGetSublistFieldState(sublistId, fieldId, line_1)
			{
				var lineInstanceId;
				var useBuffer = false;
				if (record.isSublistAnEditMachine(sublistId))
				{
					useBuffer = true;
					lineInstanceId = record.doGetCurrentSublistLineInstanceId(sublistId);
				}
				else
				{
					var line_0 = recordUtil.getZeroBasedIndex(line_1);
					line_0 = isNaN(line_0) ? record.doGetCurrentSublistIndex(sublistId) : line_0;
					useBuffer = line_0 === record.doGetCurrentSublistIndex(sublistId);
					lineInstanceId = record.getModelController().getSublistLineInstanceIdForLine(sublistId, line_0, useBuffer)
				}

				return record.getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
			}

			function getLineItemDisabled(sublistId, fieldId, line_1)
			{
				var fieldState = doGetSublistFieldState(sublistId, fieldId, line_1);
				return (fieldState) ? fieldState.isDisabled : false;
			}
			this.getLineItemDisabled = wrapEmitLegacyError(getLineItemDisabled);

			function setLineItemDisabled(sublistId, fieldId, disabled, line_1)
			{
				var fieldState = doGetSublistFieldState(sublistId, fieldId, line_1);
				if (fieldState)
					fieldState.isDisabled = disabled;
			}
			this.setLineItemDisabled = wrapEmitLegacyError(setLineItemDisabled);

			function getLineItemMandatory(sublistId, fieldId, line_1)
			{
				var fieldState = doGetSublistFieldState(sublistId, fieldId, line_1);
				return (fieldState) ? fieldState.isMandatory : false;
			}
			this.getLineItemMandatory = wrapEmitLegacyError(getLineItemMandatory);

			function setLineItemMandatory(sublistId, fieldId, mandatory, line_1)
			{
				var fieldState = doGetSublistFieldState(sublistId, fieldId, line_1);
				if (fieldState)
					fieldState.isMandatory = mandatory;
			}
			this.setLineItemMandatory = wrapEmitLegacyError(setLineItemMandatory);

			function getLineItemLabel(sublistId, fieldId)
			{
				var useBuffer = true;
				var field = record.getCachedRecordField(sublistId, fieldId, record.doGetCurrentSublistIndex(sublistId), useBuffer);
				return field ? field.getLabel() : null;
			}
			this.getLineItemLabel = wrapEmitLegacyError(getLineItemLabel);

			function setLineItemLabel(sublistId, fieldId, label)
			{
				var useBuffer = true;
				var field = record.getCachedRecordField(sublistId, fieldId, record.doGetCurrentSublistIndex(sublistId), useBuffer);
				if (field)
					field.setLabel(label);
			}
			this.setLineItemLabel = wrapEmitLegacyError(setLineItemLabel);

			function handleChangeCall(params)
			{
				record.handleChangeCall(params);
				invalidateSubrecordCacheForV1RecordScope();
			}
			this.handleChangeCall = wrapEmitLegacyError(handleChangeCall);

			function triggerFieldChangeEvent(sublistId, fieldId, line, value, noSlaving)
			{
				record.triggerFieldChangeEvent(sublistId, fieldId, line, value, noSlaving);
			}
			this.triggerFieldChangeEvent = wrapEmitLegacyError(triggerFieldChangeEvent);

			function doSlaving(sublistId, fieldId, value, noSlaving, restrictField)
			{
				record.doSlaving(sublistId, fieldId, value, noSlaving, restrictField);
			}
			this.doSlaving = wrapEmitLegacyError(doSlaving);

			function invalidateSubrecordCacheForV1RecordScope()
			{
				subrecordControllerV1.invalidateSubrecordCacheForV1RecordScope();
			}
		}

		function create(record, subrecordControllerV1){
			return new RecordImplV1(record, subrecordControllerV1);
		}

		return { create: create };
	});

/**
 * SuiteScript module that adds the subrecord accessors to be accessed in a v1 manner based on a v2 record.
 *
 * @private
 * @module N/record/subrecordImplV1Util
 * @suiteScriptVersion 2.x
 */


define('N/record/subrecordImplV1Util',['N/record/recordUtilityFunctions', 'N/record/recordImplV1Util'],
	function(recordUtil, recordImplV1Util){

		// there is no support for a subrecord within a subrecord, so we don't extend this with subrecord functions.
		function wrappedV1Subrecord(proxiedRecord)
		{
			return !!proxiedRecord ? recordImplV1Util.create(proxiedRecord) : null;
		}

		function createCurrentLineItemSubrecord(subrecordControllerV1, sublistId, fieldId)
		{
			return wrappedV1Subrecord(subrecordControllerV1.createCurrentLineItemSubrecord(sublistId, fieldId));
		}
		this.createCurrentLineItemSubrecord = createCurrentLineItemSubrecord;

		function editCurrentLineItemSubrecord(subrecordControllerV1, sublistId, fieldId)
		{
			return wrappedV1Subrecord(subrecordControllerV1.editCurrentLineItemSubrecord(sublistId, fieldId));
		}
		this.editCurrentLineItemSubrecord = editCurrentLineItemSubrecord;

		function removeCurrentLineItemSubrecord(subrecordControllerV1, sublistId, fieldId)
		{
			return wrappedV1Subrecord(subrecordControllerV1.removeCurrentLineItemSubrecord(sublistId, fieldId));
		}
		this.removeCurrentLineItemSubrecord = removeCurrentLineItemSubrecord;

		function viewCurrentLineItemSubrecord(subrecordControllerV1, sublistId, fieldId)
		{
			return wrappedV1Subrecord(subrecordControllerV1.viewCurrentLineItemSubrecord(sublistId, fieldId));
		}
		this.viewCurrentLineItemSubrecord = viewCurrentLineItemSubrecord;

		function viewLineItemSubrecord(subrecordControllerV1, sublistId, fieldId, line_1)
		{
			var line_0 = recordUtil.getZeroBasedIndex(line_1);
			return wrappedV1Subrecord(subrecordControllerV1.viewLineItemSubrecord(sublistId, fieldId, line_0));
		}
		this.viewLineItemSubrecord = viewLineItemSubrecord;

		function createSubrecord(subrecordControllerV1, fieldId)
		{
			return wrappedV1Subrecord(subrecordControllerV1.createSubrecord(fieldId));
		}
		this.createSubrecord = createSubrecord;

		function editSubrecord(subrecordControllerV1, fieldId)
		{
			return wrappedV1Subrecord(subrecordControllerV1.editSubrecord(fieldId));
		}
		this.editSubrecord = editSubrecord;

		function viewSubrecord(subrecordControllerV1, fieldId)
		{
			return wrappedV1Subrecord(subrecordControllerV1.viewSubrecord(fieldId));
		}
		this.viewSubrecord = viewSubrecord;

		function removeSubrecord(subrecordControllerV1, fieldId)
		{
			return wrappedV1Subrecord(subrecordControllerV1.removeSubrecord(fieldId));
		}
		this.removeSubrecord = removeSubrecord;

		function commit(subrecordControllerV1, subrecordToCommit)
		{
			return wrappedV1Subrecord(subrecordControllerV1.commit(subrecordToCommit));
		}
		this.commit = commit;

		function invalidateSubrecordCacheEntry(subrecordControllerV1, sublistId, fieldId, line_0)
		{
			subrecordControllerV1.invalidateSubrecordCacheEntry(sublistId, fieldId, line_0);
		}
		this.invalidateSubrecordCacheEntry = invalidateSubrecordCacheEntry;

		function insertLineForSubrecordCache(subrecordControllerV1, sublistId, line)
		{
			subrecordControllerV1.insertLineForSubrecordCache(sublistId, line);
		}
		this.insertLineForSubrecordCache = insertLineForSubrecordCache;

		function removeLineForSubrecordCache(subrecordControllerV1, sublistId, line)
		{
			subrecordControllerV1.removeLineForSubrecordCache(sublistId, line);
		}
		this.removeLineForSubrecordCache = removeLineForSubrecordCache;

		function invalidateCurrentSublistLineForSubrecordCache(subrecordControllerV1, sublistId)
		{
			subrecordControllerV1.invalidateCurrentSublistLineForSubrecordCache(sublistId);
		}
		this.invalidateCurrentSublistLineForSubrecordCache = invalidateCurrentSublistLineForSubrecordCache;

		//TODO: cancel

		function extendWithSubrecord(recordObject, subrecordV1)
		{
			if (!!recordObject)
			{			
				recordObject.commit = commit.bind(null, subrecordV1);
				recordObject.createCurrentLineItemSubrecord = createCurrentLineItemSubrecord.bind(null, subrecordV1);
				recordObject.createSubrecord = createSubrecord.bind(null, subrecordV1);
				recordObject.editCurrentLineItemSubrecord = editCurrentLineItemSubrecord.bind(null, subrecordV1);
				recordObject.editSubrecord = editSubrecord.bind(null, subrecordV1);
				recordObject.insertLineForSubrecordCache = insertLineForSubrecordCache.bind(null, subrecordV1);
				recordObject.invalidateCurrentSublistLineForSubrecordCache = invalidateCurrentSublistLineForSubrecordCache.bind(null, subrecordV1);
				recordObject.invalidateSubrecordCacheEntry = invalidateSubrecordCacheEntry.bind(null, subrecordV1);
				recordObject.removeCurrentLineItemSubrecord = removeCurrentLineItemSubrecord.bind(null, subrecordV1);
				recordObject.removeLineForSubrecordCache = removeLineForSubrecordCache.bind(null, subrecordV1);
				recordObject.removeSubrecord = removeSubrecord.bind(null, subrecordV1);
				recordObject.viewCurrentLineItemSubrecord = viewCurrentLineItemSubrecord.bind(null, subrecordV1);
				recordObject.viewLineItemSubrecord = viewLineItemSubrecord.bind(null, subrecordV1);
				recordObject.viewSubrecord = viewSubrecord.bind(null, subrecordV1);
			}
			return recordObject;
		}
		
		return { extendWithSubrecord : extendWithSubrecord }
	});

/**
 * SuiteScript record implementation for version one based on version 2 record
 *
 * @private
 * @module N/record/recordImplV1
 * @NApiVersion 2.x
 *
 */
define('N/record/recordImplV1',['N/record/subrecordController', 'N/record/recordImplV1Util', 'N/record/subrecordImplV1Util'],
       function(subrecordController, recordImplV1Util, subrecordImplV1Util){

    function create(options){
	    var record = options.record;
	    var subrecordControllerV1 = subrecordController.create(record);
        var v1RecordObj = recordImplV1Util.create(record, subrecordControllerV1);
	    return subrecordImplV1Util.extendWithSubrecord(v1RecordObj, subrecordControllerV1);
    }

    return { create: create };
});

/**
 * SuiteScript scope
 *
 * @private
 * @module N/scope
 * @NApiVersion 2.x
 *
 */
define('N/scope',[], function(){
    var blacklist = ['blacklist'];

    // HIDE SCOPE loadCallback
    blacklist = blacklist.concat('error', 'parent', 'responseObj', 'scriptInfo');

    // HIDE SCOPE require.load
    blacklist = blacklist.concat('argList', 'context', 'getParentPath', 'loadCallback', 'method', 'moduleName',
        'pageMode', 'parentMap', 'parentPath', 'recordType', 'url');

    // HIDE SCOPE undefined
    blacklist = blacklist.concat('SuiteScriptModuleLoaderError', 'addModuleNameToDefineModuleList', 'define',
        'dependencyCheck', 'doLogExecution', 'forceSync', 'global', 'internals', 'isApiPath', 'isFilePathLike',
        'isModuleNameAlreadyDefined', 'log', 'makeServerCall', 'namesOfDefinedModules', 'old_define', 'p', 'require',
        'requirejs', 'serverCallAsync', 'serverCallSync', 'stripApiPath', 'toEmptyString', 'util');

    // HIDE SCOPE undefined
    blacklist = blacklist.concat('callURL', 'createNode', 'getGlobalScope', 'legacyCallURL', 'nlRequestId', 'nlapi');

    return function(){
        eval(function(blacklist){
            return !!blacklist && blacklist.map(function(v){ return 'var ' + v + ' = undefined;' ;}).join('');
        }.bind(null, blacklist)());

        eval(function(blacklist){
            return !!blacklist && blacklist.map(function(v){ return 'var ' + v + ' = undefined;' ;}).join('');
        }.bind(null, arguments[0] && arguments[0].blacklist)());

        eval(function(whitelist){
            return !!whitelist && Object.keys(whitelist).map(function(v){
                    return 'var ' + v + ' = arguments[0].whitelist["' + v + '"];';
                }).join('');
        }.bind(null, arguments[0] && arguments[0].whitelist)());

        eval(function(libraries){
            return !!libraries && libraries.join(';');
        }.bind(null, arguments[0] && arguments[0].libraries)());

        return function(){
            return eval(arguments[0]);
        };
    };
});

/**
 * SuiteScript record definition common module
 *
 * @private
 * @module N/record/recordScriptingScope
 * @NApiVersion 2.x
 *
 */
define('N/record/recordScriptingScope',['N/record/recordConstants', 'N/utilityFunctions', 'N/util/currencyUtility', 'N/util/date', 'N/error', 'N/restricted/invoker', 'N/restricted/scopeRemoteApiBridge', 'N/record/recordImplV1', 'N/scope', 'N/msgRouter', 'N/runtime', 'N/environment'],
	function(constants, utilityFunctions, currencyutil, dateutil, error, invoker, remoteApi, recordImpl, jsScope, msgRouter, runtime, environment)
	{
		var undef = undefined;

		/* If this is > 0, it means the current script execution is occuring from within a client script. */
		var clientScriptInvocationDepthCount = 0;
		function isExecutionWithinAClientScript()
		{
			return clientScriptInvocationDepthCount > 0;
		}

		function create(options)
		{
			return new Scope(options);
		}

		/**
		 *
		 * @param {Object} options
		 * @param {function} options.record function returns the core record
		 * @param {string} options.libraryScript
		 * @param {string} options.staticScript
		 * @param {string} options.uiFormScript
		 * @param {boolean} options.shouldTriggerCustomFormLevelScript
		 * @param {object} options.formLevelScriptComponent
		 * @param {boolean} options.shouldTriggerCustomClientScript
		 * @param {object} options.clientScriptComponent
		 * @param {string} options.clientScriptComponent.libraryScript
		 * @param {*} options.clientScriptComponent.scriptList
		 * @constructor
		 */
		function Scope(options)
		{
			var that = this;
			var coreRecord = options.record;
			var record = recordImpl.create({record: coreRecord});
			// script defined in NLRecord by internal NS developer
			var recordLibraryScript = options.libraryScript;
			var staticScript = options.staticScript;
			var uiFormScript = options.uiFormScript;

			// for backward compatiability UIFormScripts
			var NS;
			var parent = record;

			// form-level script information
			var shouldTriggerCustomFormLevelScript = options.shouldTriggerCustomFormLevelScript;
			var formLevelScript = options.formLevelScriptComponent ? options.formLevelScriptComponent.script : null;
			var formLevelScriptAllText = options.formLevelScriptComponent ? options.formLevelScriptComponent.libraryScript : null;

			// client script information
			var shouldTriggerCustomClientScript = options.shouldTriggerCustomClientScript;
			var clientScriptList = options.clientScriptComponent ? options.clientScriptComponent.scriptList : null;
			var clientScriptAllText = options.clientScriptComponent ? options.clientScriptComponent.libraryScript : null;

			var currentActiveScriptId = null;
			var clientScriptScopes = {};

			function uiFormScriptWrapper() { eval(uiFormScript); }

			function evaluateUIFormScriptAndCleanUp()
			{
				var triggerUiFormScriptWrapper = uiFormScriptWrapper.bind(that);
				triggerUiFormScriptWrapper();
				NS = that.NS;
				delete that.NS;
			}

			evaluateUIFormScriptAndCleanUp();
			eval(staticScript);
			eval(recordLibraryScript);

			var createScriptScopes = (function ()
			{
				var v1Scope = null;

				return function createScriptScopes(version, libraries, uniqueDisplayId)
				{
					/* There's only one shared v1 scope */
					if (version === '1.0')
					{
						if (v1Scope === null)
						{
							v1Scope = jsScope({
								blacklist: getV1ApiBlackList(),
								whitelist: utilityFunctions.addParameterToMap(utilityFunctions.addParameterToMap({}, getV1ApiGrayList()), getV1ApiWhiteList()),
								libraries: libraries
							});
						}
						clientScriptScopes[uniqueDisplayId] = v1Scope;
					}
					/* Each v2 script gets its own scope. */
					else
					{
						clientScriptScopes[uniqueDisplayId] = jsScope({
							whitelist: {
								require: require,
								util: util,
								log: log
							},
							libraries: libraries
						});
					}
				};
			}());

			/* Assemble a unified list of V1 and V2 scripts, in script precedence order (form script, if any, followed by client scripts). */
			var formAndClientScriptList = [];
			var formAndClientScriptAllTextList = {};

			if (shouldTriggerCustomFormLevelScript)
			{
				var formScriptRepresentation = {version: formLevelScript.version, scriptId: 'formscript'};
				formAndClientScriptList.push(formScriptRepresentation);
				formAndClientScriptAllTextList['formscript'] = formLevelScriptAllText;
			}

			if (shouldTriggerCustomClientScript)
			{
				for (var i = 0; i < clientScriptList.length; i++)
				{
					var clientScript = clientScriptList[i];
					formAndClientScriptList.push(clientScript);
					formAndClientScriptAllTextList[clientScript.scriptId] = clientScriptAllText[clientScript.scriptId];
				}
			}

			/* Put the scripts into their appropriate scopes, by version, in definition order (form script followed by client scripts). */
			{
				var v1Libraries = formAndClientScriptList.filter(function (script)
				{
					return script.version === '1.0';
				}).map(function (script)
				{
					return formAndClientScriptAllTextList[script.scriptId];
				});

				for (var i = 0; i < formAndClientScriptList.length; i++)
				{
					var scriptRepresentation = formAndClientScriptList[i];
					var libraries = scriptRepresentation.version === '1.0' ? v1Libraries : [formAndClientScriptAllTextList[scriptRepresentation.scriptId]];
					createScriptScopes(scriptRepresentation.version, libraries, scriptRepresentation.scriptId);
				}
			}

			function runInternalScript(scriptContent)
			{
				runInternalScriptAndReturnResult(scriptContent);
			}

			function runInternalScriptAndAssert(scriptContent, code, usingErrorMessageContext)
			{
				try
				{
					var is_valid = runInternalScriptAndReturnBooleanResult(scriptContent);
					_assertValidation(is_valid, code, usingErrorMessageContext);
					return is_valid;
				}
				catch (e)
				{
					_handleError(e);
				}
			}

			function evaluateSlavingResponse(response)
			{
				var slaveValues;
				eval(response);
				return slaveValues;
			}

			this.evaluateSlavingResponse = evaluateSlavingResponse;

			function runInternalScriptAndReturnResult(scriptContent)
			{
				var wasInternal = coreRecord.isInternal();
				try
				{
					coreRecord.setInternalEvent(true);
					var toRet = eval(scriptContent);
					return toRet;
				}
				catch (e)
				{
					_handleError(e);
				}
				finally
				{
					coreRecord.setInternalEvent(wasInternal);
				}
			}

			this.runInternalScriptAndReturnResult = runInternalScriptAndReturnResult;

			function runInternalScriptAndReturnBooleanResult(scriptContent)
			{
				return !!runInternalScriptAndReturnResult(scriptContent);
			}

			this.runInternalScriptAndReturnBooleanResult = runInternalScriptAndReturnBooleanResult;

			function runScript(scriptContent)
			{
				try
				{
					eval(scriptContent);
				}
				catch (e)
				{
					_handleError(e);
				}
			}

			this.runScript = runScript;

			function _handleError(e)
			{
				var err = e;
				if (e instanceof Error)
				{
					err = error.create({name: e.name, message: e.message});
				}
				throw err;
				//TODO - notify error
			}

			function _assertValidation(valid, code, usingErrorMessageContext)
			{
				if (!valid)
				{
					invoker(remoteApi, 'checkWarningMessageInSession', [], null /* callback */, false /* parseResult */);
					if (!!usingErrorMessageContext)
					{
						utilityFunctions.throwSuiteScriptError(code);
					}
					else
					{
						throw error.create({name: 'USER_ERROR', message: code});
					}
				}
			}

			function _createArgumentsJSExpression(args)
			{
				var innerArgs = JSON.stringify(args);
				innerArgs = innerArgs.substr(1, innerArgs.length - 2);

				return '(' + innerArgs + ')';
			}

			function _getFieldScript(sublistId, fieldId, fieldscripttype)
			{
				var metadata = coreRecord.getMetadata().getFieldMetadata(sublistId, fieldId);
				return (metadata) ? utilityFunctions.returnEmptyIfNull(metadata.getFieldScript(fieldscripttype)) : '';
			}

			function _pageInit()
			{
				var scriptToRun = 'function NLRecordScripting_pageInit() { page_init(); }; NLRecordScripting_pageInit();';
				runInternalScript(scriptToRun);

				runClientScripts(PAGE_INIT_TRIGGER, ['create']);
			}

			this.pageInit = _pageInit;

			function _validateField(sublistId, fieldId, line, matrixColumn)
			{
				var validationFieldScript = _getFieldScript(sublistId, fieldId, 'validatefield');
				var errorMessage = 'Field validation failed for field: ' + fieldId;
				if (!utilityFunctions.isValEmpty(validationFieldScript))
				{
					var scriptDefinition = 'function NLRecordScripting_validateField(type,fld,linenum,bucket) { var is_valid = ' + validationFieldScript + '; return is_valid; };\n';
					var args = [sublistId, fieldId];
					if (line > 0)
					{
						args.push(line);
					}
					if (matrixColumn != -1)
					{
						args.push(matrixColumn);
					}
					var scriptInvoker = ' NLRecordScripting_validateField' + _createArgumentsJSExpression(args);
					var scriptToRun = scriptDefinition + scriptInvoker;
					runInternalScriptAndAssert(scriptToRun, errorMessage);
				}

				var clientScriptResult = runClientScripts(VALIDATE_FIELD_TRIGGER, [sublistId, fieldId, line, matrixColumn]);
				_assertValidation(clientScriptResult, errorMessage);
			}

			this.validateField = _validateField;

			function _canCreateSubrecord(sublistId, fieldId, line)
			{
				var canCreateSubrecordScript = _getFieldScript(sublistId, fieldId, 'canCreateSubrecord');
				if (!utilityFunctions.isValEmpty(canCreateSubrecordScript))
				{
					var wrappedScript = '(function(type,fld,linenum){ ' + canCreateSubrecordScript + '})(type,fld,linenum);';
					var scriptDefinition = 'function NLRecordScripting_canCreateSubrecord(type,fld,linenum) { var is_valid = ' + wrappedScript + '; return is_valid; };\n';
					var args = [sublistId, fieldId];
					if (line > 0)
					{
						args.push(line);
					}
					var scriptInvoker = ' NLRecordScripting_canCreateSubrecord' + _createArgumentsJSExpression(args);
					var scriptToRun = scriptDefinition + scriptInvoker;
					runInternalScriptAndAssert(scriptToRun, error.Type.FORM_VALIDATION_FAILED_YOU_CANNOT_CREATE_THIS_SUBRECORD, true);
				}
			}

			this.canCreateSubrecord = _canCreateSubrecord;

			function _fieldChange(sublistId, fieldId, line, matrixColumn)
			{
				var fieldChangeScript = _getFieldScript(sublistId, fieldId, 'fieldchange');
				if (!utilityFunctions.isValEmpty(fieldChangeScript))
				{
					var scriptDefinition = 'function NLRecordScripting_fieldChange(type,fld,linenum,bucket) { ' + fieldChangeScript + ' }\n';
					var args = [sublistId, fieldId];
					if (line > 0)
					{
						args.push(line);
					}
					if (matrixColumn != -1)
					{
						args.push(matrixColumn);
					}
					var scriptInvoker = 'NLRecordScripting_fieldChange' + _createArgumentsJSExpression(args);
					var scriptToRun = scriptDefinition + scriptInvoker;
					runInternalScript(scriptToRun);
				}
				runClientScripts(FIELD_CHANGED_TRIGGER, [sublistId, fieldId, line, matrixColumn]);
			}

			this.fieldChange = _fieldChange;

			function _saveRecord(ignoreMandatoryFields)
			{
				var scriptDefinition = 'function NLRecordScripting_saveRecord(ignoreMandatoryFields) { return save_record(ignoreMandatoryFields); };';
				var scriptInvoker = 'NLRecordScripting_saveRecord(' + ignoreMandatoryFields + ')';
				var scriptToRun = scriptDefinition + scriptInvoker;
				runInternalScriptAndAssert(scriptToRun, error.Type.FORM_VALIDATION_FAILED_YOU_CANNOT_SUBMIT_THIS_RECORD, true);

				var saveRecordResult = runClientScripts(SAVE_RECORD_TRIGGER, []);
				_assertValidation(saveRecordResult, error.Type.FORM_VALIDATION_FAILED_YOU_CANNOT_SUBMIT_THIS_RECORD, true);
			}

			this.saveRecord = _saveRecord;

			function _getSublistScript(sublistId, scriptingTrigger, args)
			{
				var toRet = '';
				var sublistScripts = coreRecord.getMetadata().getSublistScripts(sublistId, scriptingTrigger);
				if (!utilityFunctions.isValEmpty(sublistScripts))
				{
					toRet = sublistScripts + args;
				}

				return toRet;
			}

			function _lineInit(sublistId)
			{
				if (coreRecord.isSublistAnEditMachine(sublistId))
				{
					var lineInitScript = _getSublistScript(sublistId, 'lineinit', '()');
					if (!utilityFunctions.isValEmpty(lineInitScript))
					{
						var scriptDefinition = 'function NLRecordScripting_lineInit(type) { ' + lineInitScript + '; nlapiLineInit(type);};\n ';
						var scriptInvoker = 'NLRecordScripting_lineInit' + _createArgumentsJSExpression([sublistId]);
						var scriptToRun = scriptDefinition + scriptInvoker;
						runInternalScript(scriptToRun);
					}

					runClientScripts(LINE_INIT_TRIGGER, [sublistId]);
				}
			}

			this.lineInit = _lineInit;

			function _lineCommit(sublistId, line)
			{
				var lineCommitScript = _getSublistScript(sublistId, 'linecommit', '(linenum)');
				if (coreRecord.isSublistAnEditMachine(sublistId) && !utilityFunctions.isValEmpty(lineCommitScript))
				{
					var scriptDefinition = 'function NLRecordScripting_lineCommit(type, linenum) { ' + lineCommitScript + '; nlapiLineCommit(type, linenum); };\n ';
					var scriptInvoker = 'NLRecordScripting_lineCommit' + _createArgumentsJSExpression([sublistId, line]);
					var scriptToRun = scriptDefinition + scriptInvoker;
					runInternalScript(scriptToRun);
				}
			}

			this.lineCommit = _lineCommit;

			function _postDeleteLine(sublistId, line)
			{
				var postDeleteLineScript = _getSublistScript(sublistId, 'postdeleteline', '');
				if (coreRecord.isSublistAnEditMachine(sublistId) && !utilityFunctions.isValEmpty(postDeleteLineScript))
				{
					//TODO: verify postDeleteLine path.
					var scriptDefinition = 'function NLRecordScripting_postDeleteLine(type, linenum) { var hndlr = ' + postDeleteLineScript + '; hndlr(linenum); };\n ';
					var scriptInvoker = 'NLRecordScripting_postDeleteLine' + _createArgumentsJSExpression([sublistId, line]);
					var scriptToRun = scriptDefinition + scriptInvoker;
					runInternalScript(scriptToRun);
				}
			}

			this.postDeleteLine = _postDeleteLine;

			function _validateLine(sublistId)
			{
				if (coreRecord.isSublistAnEditMachine(sublistId))
				{
					var validationLineScript = _getSublistScript(sublistId, 'validateline', '()');
					var errorMessage = 'Line validation failed for sublist: ' + sublistId;
					if (!utilityFunctions.isValEmpty(validationLineScript))
					{
						var scriptDefinition = 'function NLRecordScripting_validateLine(type) { var is_valid = ' + validationLineScript + ' && nlapiValidateLine(type, true); return is_valid; };\n ';
						var scriptInvoker = 'NLRecordScripting_validateLine' + _createArgumentsJSExpression([sublistId]);
						var scriptToRun = scriptDefinition + scriptInvoker;
						runInternalScriptAndAssert(scriptToRun, errorMessage);
					}

					var clientScriptResult = runClientScripts(VALIDATE_LINE_TRIGGER, [sublistId]);
					_assertValidation(clientScriptResult, errorMessage);
				}
			}

			this.validateLine = _validateLine;

			function _validateInsert(sublistId)
			{
				if (coreRecord.isSublistAnEditMachine(sublistId))
				{
					var validationInsertScript = _getSublistScript(sublistId, 'validateinsert', '()');
					var errorMessage = 'Line insert validation failed for sublist: ' + sublistId;
					if (!utilityFunctions.isValEmpty(validationInsertScript))
					{
						var scriptDefinition = 'function NLRecordScripting_validateInsert(type) { var is_valid = ' + validationInsertScript + ' && nlapiValidateInsert(type); return is_valid; };\n ';
						var scriptInvoker = 'NLRecordScripting_validateInsert' + _createArgumentsJSExpression([sublistId]);
						var scriptToRun = scriptDefinition + scriptInvoker;
						runInternalScriptAndAssert(scriptToRun, errorMessage);
					}

					var clientScriptResult = runClientScripts(VALIDATE_INSERT_TRIGGER, [sublistId]);
					_assertValidation(clientScriptResult, errorMessage);
				}
			}

			this.validateInsert = _validateInsert;

			function _validateDelete(sublistId)
			{
				if (coreRecord.isSublistAnEditMachine(sublistId))
				{
					var validationDeleteScript = _getSublistScript(sublistId, 'validatedelete', '()');
					var errorMessage = 'Line delete validation failed for sublist: ' + sublistId;
					if (!utilityFunctions.isValEmpty(validationDeleteScript))
					{
						var scriptDefinition = 'function NLRecordScripting_validateDelete(type) { var is_valid = ' + validationDeleteScript + ' && nlapiValidateDelete(type); return is_valid; };\n ';
						var scriptInvoker = 'NLRecordScripting_validateDelete' + _createArgumentsJSExpression([sublistId]);
						var scriptToRun = scriptDefinition + scriptInvoker;
						runInternalScriptAndAssert(scriptToRun, errorMessage);
					}

					var clientScriptResult = runClientScripts(VALIDATE_DELETE_TRIGGER, [sublistId]);
					_assertValidation(clientScriptResult, errorMessage);
				}
			}

			this.validateDelete = _validateDelete;

			function _recalc(sublistId, localRecalc, operation)
			{
				if (operation === undef)
				{
					operation = 'commit';
				}
				var recalcScript = _getSublistScript(sublistId, 'recalc', '');
				if (coreRecord.isSublistAnEditMachine(sublistId) || (localRecalc && !coreRecord.isSublistAnEditMachine(sublistId)))
				{
					if (!utilityFunctions.isValEmpty(recalcScript))
					{
						var scriptDefinition = 'function NLRecordScripting_recalc(type) { ' + recalcScript + '; nlapiRecalc(type, false, \'' + operation + '\'); };\n ';
						var scriptInvoker = 'NLRecordScripting_recalc(\'' + sublistId + '\');';
						var scriptToRun = scriptDefinition + scriptInvoker;
						runInternalScript(scriptToRun);
					}

					runClientScripts(RECALC_TRIGGER, [sublistId, operation]);
				}
			}

			this.recalc = _recalc;

			function _postSublistSourcing(postSourcingScript)
			{
				runInternalScript(postSourcingScript);
			}

			this.postSublistSourcing = _postSublistSourcing;

			function _postSourcing(sublistId, fieldId, line)
			{
				runClientScripts(POST_SOURCING_TRIGGER, [sublistId, fieldId, line]);
			}

			this.postSourcing = _postSourcing;

			function invalidateSubrecordCache(subrecordSublistId, subrecordFieldId, line)
			{
				record.invalidateSubrecordCacheEntry(subrecordSublistId, subrecordFieldId, line);
			}

			this.invalidateSubrecordCache = invalidateSubrecordCache;

			function _notifyInsertLine(sublistId, line)
			{
				record.insertLineForSubrecordCache(sublistId, line);
			}

			this.notifyInsertLine = _notifyInsertLine;

			function _notifyRemoveLine(sublistId, line)
			{
				record.removeLineForSubrecordCache(sublistId, line);

			}

			this.notifyRemoveLine = _notifyRemoveLine;

			function _notifyCurrentSublistLineReset(sublistId)
			{
				record.invalidateCurrentSublistLineForSubrecordCache(sublistId);
			}

			this.notifyCurrentSublistLineReset = _notifyCurrentSublistLineReset;


			//TODO remove to its own module
			var PAGE_INIT_TRIGGER = 'pageInit';
			var SAVE_RECORD_TRIGGER = 'saveRecord';
			var LINE_INIT_TRIGGER = 'lineInit';
			var VALIDATE_DELETE_TRIGGER = 'validateDelete';
			var VALIDATE_INSERT_TRIGGER = 'validateInsert';
			var VALIDATE_LINE_TRIGGER = 'validateLine';
			var RECALC_TRIGGER = 'recalc';
			var SUBLIST_CHANGED_TRIGGER = 'sublistChanged';
			var POST_SOURCING_TRIGGER = 'postSourcing';
			var VALIDATE_FIELD_TRIGGER = 'validateField';
			var FIELD_CHANGED_TRIGGER = 'fieldChanged';
			var caresAboutReturn = [SAVE_RECORD_TRIGGER, VALIDATE_DELETE_TRIGGER, VALIDATE_INSERT_TRIGGER, VALIDATE_LINE_TRIGGER, VALIDATE_FIELD_TRIGGER];

			function doesTriggerCareAboutReturn(trigger)
			{
				return caresAboutReturn.indexOf(trigger) > -1;
			}

			function runLegacyScript(script)
			{
				var scope = clientScriptScopes['formscript'];
				scope(script);
			}

			this.runLegacyScript = runLegacyScript;

			function runClientScripts(trigger, args)
			{
				var caresAboutRet = doesTriggerCareAboutReturn(trigger);

				if (formLevelScript != null)
				{
					currentActiveScriptId = null;
					var isValid = runClientScriptWithTracking(trigger, args, formLevelScript, 'formscript');
					if (caresAboutRet && !isValid)
					{
						return false;
					}
				}

				if (clientScriptList != null)
				{
					for (var xo = 0; xo < clientScriptList.length; xo++)
					{
						var clientScript = clientScriptList[xo];
						currentActiveScriptId = clientScript.scriptId;
						var isValid = runClientScriptWithTracking(trigger, args, clientScript, clientScript.scriptId);
						if (caresAboutRet && !isValid)
						{
							return false;
						}
					}
				}
				return true;
			}

			function runClientScriptWithTracking(trigger, args, theScript, uniqueDisplayId)
			{
				var isValid;
				clientScriptInvocationDepthCount++;
				try
				{
					isValid = runClientScript(trigger, args, theScript, uniqueDisplayId);
				}
				finally
				{
					clientScriptInvocationDepthCount--;
					if (clientScriptInvocationDepthCount < 0)
						utilityFunctions.throwSuiteScriptError(error.Type.FAILED_AN_UNEXPECTED_ERROR_OCCURRED);
				}
				return isValid;
			}

			function runClientScript(trigger, args, theScript, uniqueDisplayId)
			{
				var isValid;
				var contextArgs;
				var runMe;
				var scope = clientScriptScopes[uniqueDisplayId];

				runtime.setupScriptRun(theScript);

				msgRouter.pushQueue(coreRecord);
				try
				{
					if (theScript.version === '1.0')
					{
						contextArgs = _createArgumentsJSExpression(args);
						runMe = JSON.parse(theScript.scriptInfo)[trigger];
						isValid = (!!runMe) ? scope(runMe + contextArgs) : true;
					}
					else
					{
						contextArgs = organizeArgs(trigger, args);
						var thisTrigger = (trigger === RECALC_TRIGGER) ? SUBLIST_CHANGED_TRIGGER : trigger;
						runMe = '_v2f_' + uniqueDisplayId;

						require.forceSync(true);
						isValid = scope(runMe).apply(null, [thisTrigger, contextArgs]);
						require.forceSync(false);
					}
				}
				finally
				{
					msgRouter.popQueue();
				}
				return isValid;
			}

			function organizeArgs(trigger, args)
			{
				function getZeroBasedIndex(idx)
				{
					if (isNaN(idx))
					{
						return idx;
					}
					else
					{
						idx = parseInt(idx, 10);
						return (idx < 0) ? idx : idx - 1;
					}
				}

				/* Use interactive mode only if current scenario permits client scripts to use interactive mode (typically current record of a new UI page, but not remote record). */
				var exposedCurrentRecord = coreRecord.proxy({isInteractive: environment.isNewUI()});
				var returnMe;
				switch (trigger)
				{
					case PAGE_INIT_TRIGGER:
						returnMe = {currentRecord: exposedCurrentRecord, mode: args[0]};
						break;

					case SAVE_RECORD_TRIGGER:
						returnMe = {currentRecord: exposedCurrentRecord};
						break;

					case LINE_INIT_TRIGGER:
					case VALIDATE_DELETE_TRIGGER:
					case VALIDATE_INSERT_TRIGGER:
					case VALIDATE_LINE_TRIGGER:
						returnMe = {currentRecord: exposedCurrentRecord, sublistId: args[0]};
						break;

					case RECALC_TRIGGER:
						returnMe = {currentRecord: exposedCurrentRecord, sublistId: args[0], operation: args[1]};
						break;

					case POST_SOURCING_TRIGGER:
						returnMe = {
							currentRecord: exposedCurrentRecord,
							sublistId: args[0],
							fieldId: args[1],
							line: getZeroBasedIndex(args[2])
						};
						break;

					case VALIDATE_FIELD_TRIGGER:
					case FIELD_CHANGED_TRIGGER:
						returnMe = {
							currentRecord: exposedCurrentRecord,
							sublistId: args[0],
							fieldId: args[1],
							line: getZeroBasedIndex(args[2]),
							column: getZeroBasedIndex(args[3])
						};
						break;

					default:
						returnMe = {};
				}
				return returnMe;
			}
		}

		return {
			create: create,
			isExecutionWithinAClientScript: isExecutionWithinAClientScript
		};
	});

/**
 * SuiteScript notification module
 *
 * @private
 * @module N/notification
 * @suiteScriptVersion 2.x
 *
 */
define('N/notification',[],function () {

	var TYPE = Object.freeze({
		CONFIRMATION: 0,
		INFORMATION: 1,
		WARNING: 2,
		ERROR: 3
	});

	function Severity(type)
	{
		Object.defineProperty(this, 'value', {
			get: function ()
			{
				return type;
			},
			enumerable: true,
			configurable: false
		});

		Object.defineProperty(this, 'label', {
			get: function ()
			{
				return getLabel(type);
			},
			enumerable: true,
			configurable: false
		});
	}

	function getLabel(severity)
	{
		/* system default is confirmation */
		var label = 'Confirmation';
		switch(severity)
		{
			case TYPE.INFORMATION:
				label = 'Information';
				break;
			case TYPE.WARNING:
				label = 'Warning';
				break;
			case TYPE.ERROR:
				label = 'Error';
				break;
		}
		return label;
	}

	return Object.freeze({
		Type : TYPE,
		create: function(args)
		{
			return new Severity(args);
		}
	});
});

/**
 * SuiteScript saveResult module
 *
 * @private
 * @module N/saveResult
 * @NApiVersion 2.x
 *
 */
define('N/saveResult',['N/notification','N/utilityFunctions'],
	function (notification, utilityFunctions)
	{

		var SEVERITY = Object.freeze({
			CONFIRMATION: notification.create(notification.Type.CONFIRMATION),
			INFORMATION: notification.create(notification.Type.INFORMATION),
			WARNING: notification.create(notification.Type.WARNING),
			ERROR: notification.create(notification.Type.ERROR)
		});

		/**
		 * @protected
		 * @constructor
		 */
		function SaveResult(options, result)
		{
			Object.defineProperty(this, 'recordData', {
				get: function ()
				{
					return new RecordData(result['recordData']);
				},
				enumerable: true,
				configurable: false
			});

			Object.defineProperty(this, 'notifications', {
				get: function ()
				{
					return createArrayMessages(result.notifications);
				},
				enumerable: true,
				configurable: false
			});
		}

		function createArrayMessages(array)
		{
			var result = new Array();
			for(var i = 0; i < array.length; i++)
			{
				var oldMsg = array[i];
				result.push(new SaveMessage(oldMsg, isExpandedErrorMessage(oldMsg)));
			}
			return result;
		}

		/* Determines if the expanded message with stack trace and args should be rendered */
		function isExpandedErrorMessage(oldMsg)
		{
			return !utilityFunctions.isEmpty(oldMsg['errorStack']);
		}

		/**
		 * @protected
		 * @constructor
		 */
		function RecordData(recordData)
		{
			Object.defineProperty(this, 'id', {
				get: function ()
				{
					return recordData.id;
				},
				enumerable: true,
				configurable: false
			});

			Object.defineProperty(this, 'label', {
				get: function ()
				{
					return recordData.label;
				},
				enumerable: true,
				configurable: false
			});

			Object.defineProperty(this, 'redirectUrl', {
				get: function ()
				{
					return recordData.redirectUrl;
				},
				enumerable: true,
				configurable: false
			});
		}

		/**
		 * @protected
		 * @constructor
		 */
		function SaveMessage(saveMessage, error)
		{
			Object.defineProperty(this, 'id', {
				get: function ()
				{
					return saveMessage.id;
				},
				enumerable: true,
				configurable: false
			});

			Object.defineProperty(this, 'title', {
				get: function ()
				{
					return saveMessage.title;
				},
				enumerable: true,
				configurable: false
			});

			Object.defineProperty(this, 'message', {
				get: function ()
				{
					return saveMessage.message;
				},
				enumerable: true,
				configurable: false
			});

			Object.defineProperty(this, 'severity', {
				get: function ()
				{
					switch(saveMessage.type)
					{
						case notification.Type.INFORMATION:
							return SEVERITY.INFORMATION;
							break;
						case notification.Type.WARNING:
							return SEVERITY.WARNING;
							break;
						case notification.Type.ERROR:
							return SEVERITY.ERROR;
							break;

						default:
							return SEVERITY.CONFIRMATION;
							break;
					}
				},
				enumerable: true,
				configurable: false
			});

			if(error)
			{
				Object.defineProperty(this, 'name', {
					get: function ()
					{
						return saveMessage.name;
					},
					enumerable: true,
					configurable: false
				});

				Object.defineProperty(this, 'errorStack', {
					get: function ()
					{
						return saveMessage.errorStack;
					},
					enumerable: true,
					configurable: false
				});

				Object.defineProperty(this, 'scriptMetadata', {
					get: function ()
					{
						return new ScriptMetadata(saveMessage.scriptMetadata);
					},
					enumerable: true,
					configurable: false
				});
			}
		}

		/**
		 * @protected
		 * @constructor
		 */
		function ScriptMetadata(scriptData)
		{
			Object.defineProperty(this, 'id', {
				get: function ()
				{
					return scriptData.id;
				},
				enumerable: true,
				configurable: false
			});

			Object.defineProperty(this, 'type', {
				get: function ()
				{
					return scriptData.type;
				},
				enumerable: true,
				configurable: false
			});

			Object.defineProperty(this, 'internalId', {
				get: function ()
				{
					return scriptData.internalId;
				},
				enumerable: true,
				configurable: false
			});

			Object.defineProperty(this, 'deployment', {
				get: function ()
				{
					return new Deployment(scriptData);
				},
				enumerable: true,
				configurable: false
			});

		}

		/**
		 * @protected
		 * @constructor
		 */
		function Deployment(scriptData) {
			Object.defineProperty(this, 'id', {
				get: function () {
					return scriptData.deploymentId;
				},
				enumerable: true,
				configurable: false
			});

			Object.defineProperty(this, 'internalId', {
				get: function () {
					return scriptData.deploymentInternalId;
				},
				enumerable: true,
				configurable: false
			});
		}


		return Object.freeze({
			create: function (options, results)
			{
				return Object.freeze(new SaveResult(options, results));
			}
		});

	});

/**
 * SuiteScript record definition common module
 *
 * @private
 * @module N/common/record/recordDefinition
 * @NApiVersion 2.x
 *
 */
define(
	'N/common/record/recordDefinition',['N/restricted/clientScriptHandler', 'N/restricted/recordRemoteApiBridge', 'N/restricted/invoker', 'N/record/recordConstants', 'N/utilityFunctions','N/error',
	 'N/field', 'N/metadata/fieldMetadata', 'N/record/metadata', 'N/record/recordStateController','N/record/recordField','N/record/matrix', 'N/record/sublist', 'N/metadata/sublistMetadata',
	 'N/common/record/line/lineDefinition',
	 'N/util', 'N/util/formatter', 'N/util/validator', 'N/util/slaving',
	 'N/record/recordProxy',
	 'N/record/relatedRecord',
	 'N/record/modelController', 'N/record/recordUtilityFunctions', 'N/record/recordImplementation',
	 'N/record/subrecordUtilityFunctions', 'N/record/recordScriptingScope',
	 'N/common/record/recordDefinitionEvent', 'N/eventEmitter',
	 'N/common/record/recordActualWork', 'N/saveResult', 'N/msgRouter', 'N/environment'],
	function (apiBridge, remoteApi, invoker, constants, utilityFunctions, error,
			  field, fieldMetadata, metadata, recordStateController, recordfield, matrix, sublist, sublistMD,
			  lineDefinition,
			  util, formatter, validator, slaving,
			  recordProxy,
			  relatedRecord,
			  modelController, recordUtil, recordImplementation,
			  subrecordUtil, scope,
			  recordDefinitionEvent, eventEmitter,
			  recordBehaviorDelegateService, saveResult, msgRouter, environment)
	{
		var undef = undefined;

		function getCopyContainer()
		{
			var result;
			var copies = null;

			function add(obj)
			{
				if (!contains(obj))
				{
					copies = copies || [];
					copies.push(obj);
				}
				return result;
			}

			function clear()
			{
				copies = null;
				return result;
			}

			function contains(obj)
			{
				return copies !== null && copies.some(function (v)
				{
					return v === obj;
				});
			}

			function execute(func)
			{
				if (!!copies)
				{
					copies.forEach(function (copy)
					{
						func(copy);
					});
				}
			}

			result = {
				add: add,
				clear: clear,
				contains: contains,
				execute: execute
			};

			return result;
		}


		/**
		 * Primary object used to encapsulate a record object.
		 *
		 * @protected
		 * @param {Object} options
		 * @param {Object} options.recordObj (server-generated object holding the full metadata and data for a record type,
		 *     including all scripting and customization. See RecordSerializationKey.java)
		 * @param {number} options.recordObj.id
		 * @param {boolean} options.recordObj.isSubrecord = true if the record instance is a subrecord
		 * @param {boolean} options.recordObj.isReadOnly = true if the record instance is read only instance
		 * @param {boolean} options.recordObj.isDynamic = true if the record instance is a dynamic record
		 * @param {boolean} options.recordObj.isCurrentRecord
		 * @param {boolean} options.recordObj.isUserEvent
		 * @param {Object} options.recordObj.recordContext
		 * @param {Metadata} options.recordObj.metadata (record metadata data used to populate the model controller)
		 * @param {ModelController} options.recordObj.data (record data used to populate the model)
		 * @param {RecordStateController} options.recordObj.state (record state to use to pre-populate the model controller)
		 * @return {Record} client-side record implementation
		 * @constructor
		 */
		function Record(options)
		{
			var freshCopies = getCopyContainer();

			var recordObj = util.extend({}, options.recordObj);

			recordObj.id = recordObj.id ? parseInt(recordObj.id, 10) : null;
			recordObj.isSubrecord = !!recordObj.isSubrecord;
			recordObj.isReadOnly = !!recordObj.isReadOnly;
			recordObj.isDynamic = !!recordObj.isDynamic;
			recordObj.isCurrentRecord = !!recordObj.isCurrentRecord;

			var compressEvents = !!recordObj && !!recordObj.data && !!recordObj.data.initialization && !!recordObj.data.initialization.params && typeof recordObj.data.initialization.params.compressEvents !== 'undefined' ?
				!!recordObj.data.initialization.params.compressEvents : true;

			var emitter = eventEmitter.create({
				eventTypes: Object.keys(recordDefinitionEvent.Type).map(function (v) { return recordDefinitionEvent.Type[v]; }),
				async: typeof setTimeout === 'function',
				insulated: true,
				preProcessor: compressEvents ? recordDefinitionEvent.eventCompress : recordDefinitionEvent.eventNoCompress
			});

			var implementation;
			var recordBehaviorDelegate = recordBehaviorDelegateService.create({delegate: this});
			var v1ScopeOptions = null;

			var that = this;

			var _metadata, _modelController, _state, _recordRequestContext, _recordScriptingV1Scope;

			var isInternalEvent = false;
			var isInited = false;

			var subrecordParent,
				subrecordSublistId,
				subrecordFieldId,
				subrecordValidated = false,
				subrecordDead = false,
				subrecordReadOnly = false;
			var subrecordIsDereferencedFromParent = false;
			var subrecordSublistState, subrecordFieldState, subrecordCompatibility;

			var SUBRECORD_KEY_FIELDID_REGEX = /^(parent\.){1}\w+$/;

			var lineCache = {};
			var actionCache = {};

			function getLineObjectFromCache(sublistId, lineInstanceId, useBuffer)
			{
				var obj = lineCache;
				if (!obj[sublistId])
				{
					obj[sublistId] = {};
				}
				obj = obj[sublistId];

				if (!obj[lineInstanceId])
				{
					obj[lineInstanceId] = {};
				}
				obj = obj[lineInstanceId];

				if (!obj[useBuffer])
				{
					obj[useBuffer] = constructLineObject(sublistId, lineInstanceId, useBuffer);
				}
				obj = obj[useBuffer];

				return obj;
			}

			this.getLineObjectFromCache = getLineObjectFromCache;

			function removeLineObjectFromCache(sublistId, lineInstanceId, useBuffer)
			{
				if (sublistId !== undefined)
				{
					if (lineInstanceId !== undefined)
					{
						if (useBuffer !== undefined)
						{
							delete lineCache[sublistId][lineInstanceId][useBuffer];
						}
						else
						{
							delete lineCache[sublistId][lineInstanceId];
						}
					}
					else
					{
						delete lineCache[sublistId];
					}
				}
				else
				{
					lineCache = {};
				}
			}

			//TODO: consider moving to metadata on a per-record basis.
			var RECORD_SPECIFIC_SAVE_OPTIONS = {'timesheet': ['savesubmit']};

			//TODO move to event module
			var sublistEventListeners = {
				change: [function (data)
				{
					invalidateSubrecordClones();
				}]
			};

			function invalidateSubrecordClones()
			{
				freshCopies.execute(function (clone)
				{
					clone.setDereferencedFromParent(true);
					clone.setReadonly();
				});
				freshCopies.clear();
			}

			this.invalidateSubrecordClones = invalidateSubrecordClones;

			function getRecordStateController() { return _state; }

			this.getRecordStateController = getRecordStateController;

			function setRecordStateController(state)
			{
				invalidateSubrecordClones();
				_state = state;
				recordDefinitionEvent.forwardRecordStateEvents(emitter, that);
			}

			this.setRecordStateController = setRecordStateController;

			function resetsetRecordStateController()
			{
				setRecordStateController(recordStateController.create({
					metadata: getMetadata(),
					data: getModelController(),
					getModelController: getModelController
				}));
			}

			this.resetsetRecordStateController = resetsetRecordStateController;

			function getMetadata() { return _metadata; }

			this.getMetadata = getMetadata;

			function setMetadata(metadata)
			{
				invalidateSubrecordClones();
				_metadata = metadata;
				recordDefinitionEvent.forwardMetadataEvents(emitter, that);
			}

			function getModelController() { return _modelController; }

			this.getModelController = getModelController;

			function setModelController(modelController)
			{
				invalidateSubrecordClones();
				_modelController = modelController;
				recordDefinitionEvent.forwardModelControllerEvents({
					record: that,
					emitter: emitter
				});
			}

			this.setModelController = setModelController;

			function getCurrentRecordDelegate()
			{
				var useBuffer = true;
				return {
					currentRecord: that,
					util: {
						isEditableSublist: isSublistAnEditMachine,
						isFieldMultiSelect: isFieldMultiSelect,
						setFieldNoSlaving: function setFieldNoSlaving(sublistId, fieldId, line, noSlaving)
						{
							var fieldState = !!sublistId ? getSublistFieldState(sublistId, fieldId, line, useBuffer) : getFieldState(fieldId);
							fieldState.ignoreSlaving = noSlaving;
						},
						getFieldOptions: getSelectOptionCache
					}
				};
			}

			//TODO remove
			function getHack()
			{
				return that;
			}

			this.getHack = getHack;

			/**
			 * The record id
			 * @property {number} id
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'id', getId);

			/**
			 * The recordType of the record
			 * @property {string} type
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'type', getRecordType);

			/**
			 * True if the record is dynamicRecord
			 * @property {boolean} isDynamic
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'isDynamic', function () { return getIsDynamicRecord(); });

			/**
			 * Query of the record
			 * @property {string} query
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'query', getQuery);

			var messageService;
			this.getMessageService = function getMessageService()
			{
				if (!messageService)
					messageService = msgRouter.getMessageServiceInstance();
				return messageService;
			};

			function getRecordRequestContext() { return _recordRequestContext; }

			this.getRecordRequestContext = getRecordRequestContext;

			function getId() { return recordObj.id ? parseInt(recordObj.id, 10) : null; }

			this.getId = getId;

			function getRecordType() { return _metadata.type; }

			this.getRecordType = getRecordType;

			function getIsSubrecord() { return !!recordObj.isSubrecord; }

			this.getIsSubrecord = getIsSubrecord;

			function getIsReadOnlyRecord() { return !!recordObj.isReadOnly; }

			this.getIsReadOnlyRecord = getIsReadOnlyRecord;

			function getIsDynamicRecord() { return !!recordObj.isDynamic; }

			this.getIsDynamicRecord = getIsDynamicRecord;

			function getIsCurrentRecord() { return !!recordObj.isCurrentRecord; }

			this.getIsCurrentRecord = getIsCurrentRecord;

			function isNewRecord() { return parseInt(getId(), 10) === -1 || getId() === undef || getId() === null; }

			this.isNewRecord = isNewRecord;

			function setIsInited() { isInited = true; }

			function getIsInited() { return isInited; }

			function shouldValidateField()
			{
				return getIsInited() && !isInternal();
			}

			this.shouldValidateField = shouldValidateField;

			function shouldValidateFieldPermissions()
			{
				return implementation.shouldValidateFieldPermissions();
			}

			this.shouldValidateFieldPermissions = shouldValidateFieldPermissions;

			function setInternalEvent(internal)
			{
				isInternalEvent = !!internal;
			}

			this.setInternalEvent = setInternalEvent;

			function isInternal()
			{
				return isInternalEvent;
			}

			this.isInternal = isInternal;

			function isChanged()
			{
				return _state.isChanged;
			}

			function getLineInstanceId(sublistId, line, useBuffer)
			{
				return implementation.getLineInstanceId(sublistId, line, useBuffer);
			}

			function getMissingArgumentErrorMessageFillerValue(methodName)
			{
				return 'Record' + '.' + methodName;
			}

			this.getMissingArgumentErrorMessageFillerValue = getMissingArgumentErrorMessageFillerValue;

			function isWithinValidLineRange(sublistId, line)
			{
				var lineNumberIndex = parseInt(line, 10);
				return 0 <= lineNumberIndex && lineNumberIndex < doGetLineCount(sublistId);
			}

			function isWithinValidLineRangeForFieldOnly(sublistId, line)
			{
				var lineNumberIndex = parseInt(line, 10);
				return 0 <= lineNumberIndex && lineNumberIndex < (doGetLineCount(sublistId) + 1);
			}

			function validateTextApi(isTextApi, fieldState, methodName, suggestedMethod)
			{
				implementation.validateTextApi(isTextApi, fieldState, methodName, suggestedMethod);
			}

			this.validateTextApi = validateTextApi;

			function validateLineIndex(lineNumberIndex, lowerBoundInclusive, upperBoundExclusive)
			{
				implementation.validateLineIndex(lineNumberIndex, lowerBoundInclusive, upperBoundExclusive);
			}

			this.validateLineIndex = validateLineIndex;

			function validateLineInstanceId(sublistId, lineInstanceId, useBuffer)
			{
				var lineInstanceExists = getModelController().isSublistLineInstanceIdValid(sublistId, lineInstanceId, useBuffer);
				recordUtil.assertValidSublistOperation(lineInstanceExists);
			}

			function getCachedOptionsForRecordField(sublistId, fieldId, line)
			{
				return implementation.getCachedOptionsForRecordField(sublistId, fieldId, line);
			}

			function getSublistMetadata(sublistId)
			{
				return _metadata.getSublistMetadata(sublistId);
			}

			this.getSublistMetadata = getSublistMetadata;

			function getSublistType(sublistId)
			{
				return _metadata.getSublistType(sublistId);
			}

			this.getSublistType = getSublistType;

			function isSublistAnEditMachine(sublistId)
			{
				return getSublistType(sublistId) === 'edit';
			}

			this.isSublistAnEditMachine = isSublistAnEditMachine;

			function isSublistEditable(sublistId)
			{
				return getSublistMetadata(sublistId) && getSublistMetadata(sublistId).isEditable;
			}

			this.isSublistEditable = isSublistEditable;

			function isSublistAListMachine(sublistId)
			{
				return getSublistType(sublistId) === 'list';
			}

			this.isSublistAListMachine = isSublistAListMachine;

			// TODO should be refactored out and utilize recordBehaviorDelegate
			function isValidField(sublistId, fieldId)
			{
				var isValid = false;
				if (sublistId != null)
				{
					isValid = isValidSublistField(sublistId, fieldId);
				}
				else
				{
					isValid = isValidBodyField(fieldId);
				}
				return isValid;
			}

			this.isValidField = isValidField;

			function isValidBodyField(fieldId)
			{
				return _metadata.isValidField(fieldId);
			}

			this.isValidBodyField = isValidBodyField;

			function isValidSublistField(sublistId, fieldId)
			{
				return _metadata.isValidSublistField(sublistId, fieldId);
			}

			this.isValidSublistField = isValidSublistField;

			function getSublistFieldState(sublistId, fieldId, line, useBuffer)
			{
				var lineInstanceId = getLineInstanceId(sublistId, line, useBuffer);
				return getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
			}

			this.getSublistFieldState = getSublistFieldState;

			function getSublistState(sublistId)
			{
				return getRecordStateController().getSublistState(sublistId);
			}

			this.getSublistState = getSublistState;

			function getSublistFieldStateForInstance(sublistId, fieldId, lineInstancecId, useBuffer)
			{
				var sublistState = getSublistState(sublistId);
				return sublistState != null ? sublistState.getFieldStateForInstance(fieldId, lineInstancecId, useBuffer) : null;
			}

			this.getSublistFieldStateForInstance = getSublistFieldStateForInstance;

			function setSublistIsChanged(sublistId, value)
			{
				getSublistState(sublistId).isChanged = value;
				return that;
			}

			function getFieldState(fieldId)
			{
				return _state.getFieldState(fieldId);
			}

			this.getFieldState = getFieldState;

			function hasFieldValueOrFieldExisted(fieldId)
			{
				return getModelController().hasFieldValue(fieldId) || _metadata.isValidField(fieldId);
			}

			function hasSublistFieldValueOrSublistFieldExisted(sublistId, fieldId, line)
			{
				var useBuffer = false;
				var lineInstanceId = getLineInstanceId(sublistId, line, useBuffer);
				return hasSublistLineValueOrSublistFieldExisted(sublistId, fieldId, lineInstanceId, useBuffer);
			}

			function hasCurrentSublistFieldValueOrSublistFieldExisted(sublistId, fieldId)
			{
				var lineInstanceId = getModelController().getSublistSelectedLineInstanceId(sublistId);
				return hasSublistLineValueOrSublistFieldExisted(sublistId, fieldId, lineInstanceId, true);
			}

			function hasSublistLineValueOrSublistFieldExisted(sublistId, fieldId, lineInstanceId, useBuffer)
			{
				return getModelController().hasSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer)
					|| isSublistFieldExisted(sublistId, fieldId);
			}

			function isSublistFieldExisted(sublistId, fieldId)
			{
				return _metadata.isValidSublistField(sublistId, fieldId);
			}

			function isSublistValid(sublistId)
			{
				return _metadata.isValidSublist(sublistId);
			}

			this.isSublistValid = isSublistValid;

			function getFieldLevelMetadataForBodyField(fieldId)
			{
				return _metadata.getFieldMetadata(undef, fieldId);
			}

			this.getFieldLevelMetadataForBodyField = getFieldLevelMetadataForBodyField;

			function getFieldLevelMetadataForSublistField(sublistId, fieldId)
			{
				return _metadata.getFieldMetadata(sublistId, fieldId);
			}

			this.getFieldLevelMetadataForSublistField = getFieldLevelMetadataForSublistField;

			function extractInforFromFieldLevelMetadata(sublistId, fieldId)
			{
				var fieldLevelMetadata = _metadata.getFieldMetadata(sublistId, fieldId);
				return {
					fieldId: fieldId,
					sublistId: sublistId,
					radioSet: !!fieldLevelMetadata ? fieldLevelMetadata.radioSet : undef,
					hasBlankString: !!fieldLevelMetadata ? fieldLevelMetadata.hasBlankString : undef,
					blankString: !!fieldLevelMetadata ? fieldLevelMetadata.blankString : undef,
					supplementedOptions: !!fieldLevelMetadata ? fieldLevelMetadata.supplementedOptions : undef
				};
			}

			this.extractInforFromFieldLevelMetadata = extractInforFromFieldLevelMetadata;

			function getFieldType(sublistId, fieldId)
			{
				var fieldLevelMetadata = _metadata.getFieldMetadata(sublistId, fieldId);
				return fieldLevelMetadata ? fieldLevelMetadata.type : null;
			}

			function isFieldNumeric(sublistId, fieldId)
			{
				var fieldLevelMetadata = _metadata.getFieldMetadata(sublistId, fieldId);
				return fieldLevelMetadata ? fieldLevelMetadata.isNumeric : null;
			}

			function isFieldCurrency(sublistId, fieldId)
			{
				var fieldLevelMetadata = _metadata.getFieldMetadata(sublistId, fieldId);
				return fieldLevelMetadata ? fieldLevelMetadata.isCurrency : null;
			}

			function isFieldTime(sublistId, fieldId)
			{
				return getFieldType(sublistId, fieldId) === recordUtil.FIELD_TYPE.TIME;
			}

			this.isFieldTime = isFieldTime;

			function isFieldTimeTrack(sublistId, fieldId)
			{
				return getFieldType(sublistId, fieldId) === recordUtil.FIELD_TYPE.TIMETRACK;
			}

			this.isFieldTime = isFieldTimeTrack;

			function isFieldMultiSelect(sublistId, fieldId)
			{
				var fieldLevelMetadata = _metadata.getFieldMetadata(sublistId, fieldId);
				return fieldLevelMetadata && fieldLevelMetadata.type === recordUtil.FIELD_TYPE.MULTISELECT;
			}
			this.isFieldMultiSelect = isFieldMultiSelect;

			function isFieldSelectType(sublistId, fieldId)
			{
				var fieldLevelMetadata = _metadata.getFieldMetadata(sublistId, fieldId);
				return fieldLevelMetadata && recordUtil.isSelectType(fieldLevelMetadata.type);
			}

			this.isFieldSelectType = isFieldSelectType;

			function isFieldCheckbox(sublistId, fieldId)
			{
				var fieldLevelMetadata = _metadata.getFieldMetadata(sublistId, fieldId);
				return fieldLevelMetadata && fieldLevelMetadata.type === recordUtil.FIELD_TYPE.CHECKBOX;
			}

			this.isFieldCheckbox = isFieldCheckbox;

			function isFieldRadio(sublistId, fieldId)
			{
				var fieldLevelMetadata = _metadata.getFieldMetadata(sublistId, fieldId);
				return fieldLevelMetadata && fieldLevelMetadata.type === recordUtil.FIELD_TYPE.RADIO;
			}

			this.isFieldRadio = isFieldRadio;

			function isFieldSubrecordField(sublistId, fieldId)
			{
				var fieldLevelMetadata = _metadata.getFieldMetadata(sublistId, fieldId);
				return fieldLevelMetadata && fieldLevelMetadata.type === recordUtil.FIELD_TYPE.SUBRECORD_FIELD_TYPE;
			}

			function getSlavingMetadata(sublistId, fieldId)
			{
				var metadata = _metadata.getFieldMetadata(sublistId, fieldId);
				return metadata ? metadata.slavingMetadata : null;
			}

			this.getSlavingMetadata = getSlavingMetadata;

			function getClientSlavingMetadata(sublistId, fieldId)
			{
				var metadata = _metadata.getFieldMetadata(sublistId, fieldId);
				return metadata ? metadata.clientSlavingMetadata : null;
			}

			this.getClientSlavingMetadata = getClientSlavingMetadata;

			function getMacrosMetadata(limited)
			{
				var macroMetadata = typeof recordObj.macro !== 'undefined' && recordObj.macro.macroMetadata || [];
				var macroList = [];

				macroMetadata.forEach(function (metadata)
				{
					var macro = {
						// basic info for the user
						id: metadata.id,
						'package': metadata['package'],
						label: metadata.label,
						description: metadata.description,
						attributes: metadata.attributes
					};
					if (!limited)
					{
						// all props for internal use
						for (var attr in metadata) { macro[attr] = metadata[attr]; }
					}
					macroList.push(macro);
				});
				return macroList;
			}

			function getMacroMetadata(options)
			{
				return getMacrosMetadata(options.limited).filter(
					function (macro)
					{
						return (macro.id === options.id
							&& macro['package'] === options['package']);
					})[0];
			}

			function getMacros()
			{
				var Macros = {};
				getMacrosMetadata().forEach(function (macroDef)
				{
					var macro = that.getMacro({id: macroDef.id, 'package': macroDef['package']});
					if (!macro['package'])
					{
						Macros[macro.id] = macro;
					}
					else
					{
						if (Macros[macro['package']] === undefined)
						{
							Macros[macro['package']] = {};
						}
						Macros[macro['package']][macro.id] = macro;
					}
				});
				return Object.freeze(Macros);
			}

			/**
			 * contains necessary macro information, performs macro operation (specified by getMacro)
			 * and returns result; the Macro.promise returns a Promise
			 * @name Macro
			 * @function
			 * @param {Object} [params]
			 * @returns {Object} [macro result]
			 */

			/**
			 * provides available macros
			 * @return {Object} a set of macros (@see Macro) defined on the record indexed by macroId
			 */
			this.getMacros = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: getMacros,
				emitter: emitter
			});

			function getMacro(options)
			{
				var id, pckgId;
				if (options !== undef && options !== null)
				{
					id = options.id;
					pckgId = options['package'];
				}
				utilityFunctions.checkArgs([id], ['id'], getMissingArgumentErrorMessageFillerValue('getMacro'));
				pckgId = pckgId || '';

				var macro = getMacroMetadata({'id': id, 'package': pckgId, limited: true});
				if (!macro)
				{
					return null;
				}

				var Macro = function (params)
				{
					return that.executeMacro({'id': macro.id, 'package': macro['package'], 'params': params});
				};
				Macro.execute = function (params)
				{
					return that.executeMacro({'id': macro.id, 'package': macro['package'], 'params': params});
				};
				Macro.promise = function (params)
				{
					return that.executeMacro.promise({'id': macro.id, 'package': macro['package'], 'params': params});
				};
				Macro.execute.promise = Macro.promise;

				var jsonDescription = {};

				// add metadata
				for (var attr in macro)
				{
					Macro[attr] = macro[attr];

					if (!!Macro[attr])
					{
						jsonDescription[attr] = Macro[attr];
					}
				}

				Macro.toJSON = function ()
				{
					return Object.freeze(jsonDescription);
				};

				Macro.toString = function ()
				{
					return 'Macro' + JSON.stringify(Macro.toJSON());
				};

				return Object.freeze(Macro);
			}

			/**
			 * provides a macro to execute
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @return {?Macro} [executor function for macro specified by options, or null if not found]
			 */
			this.getMacro = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: getMacro,
				emitter: emitter
			});

			/**
			 * performs macro operation and returns result
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @param {Object} [options.params] macro arguments
			 * @returns {Object} [macro result, or null]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
			 */
			function executeMacro(options, isInteractive)
			{
				msgRouter.pushQueue(that);
				if (typeof(nlapi) !== 'undefined' && nlapi && nlapi.async) nlapi.async.prepareForAsync({info: {}, record: that});
				try
				{
					return doExecuteMacro(options, null/*callbacks*/, isInteractive);
				}
				finally
				{
					if (typeof(nlapi) !== 'undefined' && nlapi && nlapi.async) nlapi.async.unloadAsync();
					msgRouter.popQueue();
				}
			}

			function executeMacroPromise(options, isInteractive)
			{
				var myPromise = new Promise(
					function (resolve, reject)
					{
						// set message queue for whatever happens synchronously
						var queueCount = msgRouter.pushQueue(that);
						// a reflet maintains info about current script execution
						// we need to restore this once promise is fulfilled
						var scriptRun;
						if (typeof apiBridge["getScript"] !== "undefined")
						{
							scriptRun = apiBridge["getScript"].apply(apiBridge, []);
						}
						// make sure context is set correctly for asynchronous operations (e.g. require)
						if (typeof(nlapi) !== 'undefined' && nlapi && nlapi.async) nlapi.async.prepareForAsync({info: {}, record: that});
						try
						{
							var myResolve = function (result)
							{
								if (!!scriptRun && typeof apiBridge['recoverScript'] !== 'undefined')
								{
									apiBridge['recoverScript'].apply(apiBridge, [scriptRun]);
									window.NLScriptId = scriptRun.scriptId;
								}
								if (typeof(nlapi) !== 'undefined' && nlapi && nlapi.async) nlapi.async.unloadAsync();
								msgRouter.popQueue(queueCount);
								resolve(result);
							};
							var myReject = function (result)
							{
								if (!!scriptRun && typeof apiBridge['recoverScript'] !== 'undefined')
								{
									apiBridge['recoverScript'].apply(apiBridge, [scriptRun]);
									window.NLScriptId = scriptRun.scriptId;
								}
								if (typeof(nlapi) !== 'undefined' && nlapi && nlapi.async) nlapi.async.unloadAsync();
								msgRouter.popQueue(queueCount);
								reject(result);
							};

							doExecuteMacro(options, {'resolve': myResolve, 'reject': myReject}, isInteractive);
						}
						catch (e)
						{
							if (!!scriptRun && typeof apiBridge["recoverScript"] !== "undefined")
							{
								apiBridge["recoverScript"].apply(apiBridge, [scriptRun]);
								window.NLScriptId = scriptRun.scriptId;
							}
							if (typeof(nlapi) !== 'undefined' && nlapi && nlapi.async) nlapi.async.unloadAsync();
							msgRouter.popQueue(queueCount);
							reject(e);
						}
					}
				);
				return myPromise;
			}

			/**
			 * performs macro operation and returns result
			 * executeMacro.promise returns a Promise
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @param {Object} [options.params] macro arguments
			 * @return {Object} [macro result]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
			 */
			this.executeMacro = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: executeMacro,
				emitter: emitter
			});
			this.executeMacro.promise = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: executeMacroPromise,
				emitter: emitter
			});

			function doExecuteMacro(options, callbacks, isInteractive)
			{
				/* As per spec, macros will run in standard mode for the intermediate future. The code to support interactive mode is still in place for the future, but disabled for now. */
				if (!environment.isNewUI())
				{
					isInteractive = false;
				}

				var id, pckgId, params;
				if (options !== undef && options !== null)
				{
					id = options.id;
					pckgId = options['package'];
					params = options.params;
				}
				utilityFunctions.checkArgs([id], ['id'], getMissingArgumentErrorMessageFillerValue('executeMacro'));
				pckgId = pckgId || '';
				if (params === undefined)
				{
					params = null;
				}

				var macroDef = getMacroMetadata({'id': id, 'package': pckgId});
				if (!macroDef)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_MACRO_ID, id);
				}

				var modulePath = macroDef.modulePath;
				var functionName = macroDef.id;
				var context = {'context': macroDef.context};

				if (callbacks)
				{
					var macroHasPromise = false;
					require([modulePath], function (mod)
					{
						var requirePromise = new Promise(function (requireResolve, requireReject) {
							try
							{
								var macroFunc = mod[functionName];
								if (macroFunc && typeof(macroFunc.promise) === 'function')
								{
									macroFunc = macroFunc.promise;
									macroHasPromise = true;
								}
								if (typeof(macroFunc) === 'function')
								{
									requireResolve(macroFunc);
								}
								else
								{
									requireReject(error.create(error.Type.SSS_INVALID_MACRO_ID));
								}
							}
							catch (e)
							{
								utilityFunctions.throwSuiteScriptError(error.Type.FAILED_AN_UNEXPECTED_ERROR_OCCURRED);
							}
						});
						requirePromise.then(function (macroFunc)
						{
							var proxiedRecord = that.proxy({isInteractive: isInteractive});
							var result = macroFunc.apply(context, [proxiedRecord, params]);

							result = result === undefined ? null : result;

							if (result instanceof Promise)
							{
								result.then(callbacks.resolve)['catch'](callbacks.reject);
							}
							else
							{
								if (macroHasPromise)
								{
									utilityFunctions.throwSuiteScriptError(error.Type.INVALID_RETURN_TYPE_EXPECTED_1, 'Promise');
								}
								else
								{
									callbacks.resolve(result);
								}
							}
						})['catch'](function (macroErr)
						{
							callbacks.reject(macroErr);
						});
					});
				}
				else
				{
					var macroFunc;
					require.forceSync(true);
					try
					{
						require([modulePath], function (mod)
						{
							macroFunc = mod[functionName];
						});
					}
					finally
					{
						require.forceSync(false);
					}
					if (typeof(macroFunc) === 'function')
					{
						var proxiedRecord = that.proxy({isInteractive: isInteractive});
						var result = macroFunc.apply(context, [proxiedRecord, params]);
						result = result === undefined ? null : result;
					}
					else
					{
						utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_MACRO_ID, id);
					}
					return result;
				}
			}

			function promiseTo(fn, options, postProcess)
			{
				var myPromise = new Promise(function (resolve, reject)
				{
					function callback(result)
					{
						if (result instanceof Error)
						{
							reject(result);
							return;
						}
						resolve(postProcess ? postProcess(result, options) : result);
					}

					try
					{
						fn(options, callback);
					}
					catch (e)
					{
						reject(e);
					}
				});
				return myPromise;
			}

			function doExecuteAction(options, callback)
			{
				var actionId, params, pkg;
				if (options !== undef && options !== null)
				{
					actionId = options.id;
					params = utilityFunctions.isObject(options.params) ? options.params : {};
					pkg = options['package'] || null;
				}
				utilityFunctions.checkArgs([actionId], ['id'], getMissingArgumentErrorMessageFillerValue('executeAction'));

				return invoker(remoteApi, 'executeAction', [getRecordType(), pkg, actionId, getId(), params], callback, false);
			}

			function executeAction(options)
			{
				return JSON.parse(doExecuteAction(options, null));
			}

			executeAction.promise = function (options)
			{
				return promiseTo(doExecuteAction, options, JSON.parse);
			};

			/**
			 * Executes record action and returns its result. Record ID and type is automatically taken from this record instance.
			 * @param {Object} options
			 * @param {String} options.id action ID
			 * @param {Object} [options.params] action arguments
			 * @returns {Object} action result; the actual return value returned by the action implementation is stored in the response property
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
			 */
			this.executeAction = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: executeAction,
				emitter: emitter
			});
			this.executeAction.promise = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: executeAction.promise,
				emitter: emitter
			});

			function createAction(options)
			{
				var TYPE = 'Action';

				var pkg = options['package'] || null;
				var actionId = options.id;

				var Action = function (params)
				{
					return executeAction(combineOpts(params, actionId, pkg));
				};
				Action.execute = function (params)
				{
					return executeAction(combineOpts(params, actionId, pkg));
				};
				Action.promise = function (params)
				{
					return promiseTo(doExecuteAction, combineOpts(params, actionId, pkg), JSON.parse);
				};
				Action.execute.promise = Action.promise;

				Action.id = actionId;
				Action.recordType = getRecordType();
				Action['package'] = pkg;
				Action.label = options.label || null;
				Action.description = options.description || null;
				var params = {};
				options.parameters.forEach(function (p)
				{
					params[p.id] = p;
					delete p.id;
				});
				Action.parameters = params;
				Action.toJSON = function toJSON(concise)
				{
					var res = {};
					for (var p in Action)
					{
						if (Action.hasOwnProperty(p) && typeof Action[p] !== 'function')
						{
							if (!concise || (Action[p] != null && (Action[p].constructor !== Object || Object.keys(Action[p]).length > 0)))
							{
								res[p] = Action[p];
							}
						}
					}
					return res;
				};
				Action.toString = function toString()
				{
					return TYPE + JSON.stringify(Action.toJSON(true));
				};

				return Object.freeze(Action);
			}

			function combineOpts(params, actionId, pkg)
			{
				var combinedOpts = {};
				combinedOpts.params = params;
				combinedOpts.id = actionId;
				combinedOpts['package'] = pkg;
				return combinedOpts;
			}

			function processGetActionsResult(jsonRes, options)
			{
				var metadata = JSON.parse(jsonRes);
				actionCache[getRecordType().toLowerCase()] = jsonRes;
				if (metadata.length === 0)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_NO_SUCH_RECORD_ACTION);
				}

				var Actions = {};
				for (var i = 0; i < metadata.length; i++)
				{
					var action = createAction(metadata[i]);
					var fullId = action['package'] ? action['package'] + '.' + action.id : action.id;
					Actions[fullId] = action;
				}
				return Object.freeze(Actions);
			}

			function doGetActions(options, callback)
			{
				var recordType = getRecordType().toLowerCase();
				if (!actionCache[recordType])
				{
					return invoker(remoteApi, 'getRecordActions', [recordType], callback, false);
				}

				if (callback)
				{
					callback(actionCache[recordType]);
				}
				else
				{
					return actionCache[recordType];
				}
			}

			function getActions(options)
			{
				return processGetActionsResult(doGetActions(options, null), options);
			}

			getActions.promise = function (options)
			{
				return promiseTo(doGetActions, options, processGetActionsResult);
			};

			/**
			 * Provides available record actions for this record instance.
			 * @returns {Object} a set of actions (@see Action) defined on the record indexed by action ID
			 */
			this.getActions = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: getActions,
				emitter: emitter
			});
			this.getActions.promise = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: getActions.promise,
				emitter: emitter
			});

			function processGetActionResult(jsonRes, options)
			{
				var metadata = JSON.parse(jsonRes);
				actionCache[getRecordType().toLowerCase()] = jsonRes;

				var result = null;
				var pkg = options['package'] || '';
				for (var i = 0; i < metadata.length; i++)
				{
					var curPkg = metadata[i]['package'] || '';
					if (curPkg === pkg && options.id === metadata[i].id)
					{
						result = createAction(metadata[i]);
						break;
					}
				}
				if (result === null)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_NO_SUCH_RECORD_ACTION);
				}
				return result;
			}

			function doGetAction(options, callback)
			{
				var actionId = options ? options.id : null;
				utilityFunctions.checkArgs([actionId], ['id'], getMissingArgumentErrorMessageFillerValue('getAction'));

				return doGetActions(options, callback);
			}

			function getAction(options)
			{
				return processGetActionResult(doGetAction(options, null), options);
			}

			getAction.promise = function (options)
			{
				return promiseTo(doGetAction, options, processGetActionResult);
			};

			/**
			 * Object corresponding to a record action. It contains the necessary action information
			 * and can be executed (both synchronously and asynchronously using Action.promise).
			 * @name Action
			 * @function
			 * @param {Object} params
			 * @returns {Object} action result; the actual return value returned by the action implementation is stored in the response property
			 */

			/**
			 * Returns an executable record action for this record instance.
			 * @param {Object} options
			 * @param {String} options.id action ID
			 * @returns {?Action} record action executor for action specified by options
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
			 */
			this.getAction = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: getAction,
				emitter: emitter
			});
			this.getAction.promise = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: getAction.promise,
				emitter: emitter
			});

			function removeField(options)
			{
				var fieldId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'fieldId', getMissingArgumentErrorMessageFillerValue('removeField'));
				doRemoveField(fieldId);
			}

			/**
			 * remove body field data
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @return {Record} same record, for chaining
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.removeField = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: removeField,
				emitter: emitter
			});

			function doRemoveField(fieldId)
			{
				if (hasFieldValueOrFieldExisted(fieldId))
				{
					var oldValue = doGetValue(fieldId);

					getModelController().removeFieldValue(fieldId);
					_state.removeFieldState(fieldId);
					subrecord_updateFieldState(true);
				}
			}

			this.doRemoveField = doRemoveField;

			function getFields()
			{
				var allFields = {};
				var bodyfields = getModelController().getBodyFieldIds();
				if (util.isArray(bodyfields))
				{
					bodyfields.forEach(function (fieldId) { allFields[fieldId] = true; });
				}

				var fieldNames = _metadata.fieldIds;
				if (util.isArray(fieldNames))
				{
					fieldNames.forEach(function (fieldId)
					{
						if (isFieldSubrecordField(undef, fieldId))
						{
							delete allFields[fieldId];
						}
						else
						{
							allFields[fieldId] = true;
						}
					});
				}

				var uniqueFieldIds = [];
				recordUtil.forEachProperty(allFields, function (fieldId, value) { uniqueFieldIds[uniqueFieldIds.length] = fieldId; });
				return uniqueFieldIds;
			}

			/**
			 * return array of names of all body fields, including machine header field and matrix header fields
			 * @return {string[]}
			 */
			this.getFields = getFields;

			function getSublists()
			{
				return _metadata.sublistIds;
			}

			/**
			 * return array of names of all sublists
			 * @return {string[]}
			 */
			this.getSublists = getSublists;

			function getValue(options)
			{
				return recordBehaviorDelegate.getValue(options);
			}

			/**
			 * return value of the field
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @return {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked after using setText
			 */
			this.getValue = getValue;

			//TODO: move to recordUtil and remove delegation from recordBehaviorDelegate
			function parseValue(isValidField, fieldLevelMetadata, value)
			{
				var parsedValue;

				if (fieldLevelMetadata && fieldLevelMetadata.type === recordUtil.FIELD_TYPE.CHECKBOX && value === '')
				{
					parsedValue = false;
				}
				else if (!isValidField || (!value && value !== false && value !== 0 && value !== ''))
				{
					parsedValue = value;
				}
				else if (fieldLevelMetadata && fieldLevelMetadata.isTypeMultiSelect)
				{
					parsedValue = recordUtil.formatValueToArrayType(value).map(function (val) { return String(val); });
				}
				else if (fieldLevelMetadata && fieldLevelMetadata.isTypeSelect)
				{
					parsedValue = String(value);
				}
				else
				{
					parsedValue = formatter.parse(value, fieldLevelMetadata.type, fieldLevelMetadata.isNumeric, fieldLevelMetadata.isCurrency, fieldLevelMetadata.fieldTypeForValidation);
				}

				return parsedValue;
			}

			this.parseValue = parseValue;

			function getParsedValueForBodyField(fieldId, delegator)
			{
				return implementation.getParsedValueForBodyField(fieldId, delegator);
			}

			this.getParsedValueForBodyField = getParsedValueForBodyField;

			function getParsedSublistValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer)
			{
				var returnValue = doGetSublistValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
				var fs = getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
				var fieldLevelMetadata = getFieldLevelMetadataForSublistField(sublistId, fieldId);
				var isCheckbox = fieldLevelMetadata && fieldLevelMetadata.type === recordUtil.FIELD_TYPE.CHECKBOX;

				if ((fs && !fs.isParsed) || (isCheckbox && returnValue === ''))
				{
					var parsedValue = parseValue(isValidSublistField(sublistId, fieldId), fieldLevelMetadata, returnValue);
					getModelController()
						.setParsedValueForSublistFieldForInstance(sublistId, lineInstanceId, fieldId, parsedValue, useBuffer);
					fs.isParsed = true;

					returnValue = parsedValue;
				}
				return returnValue;
			}

			function doGetValue(fieldId)
			{
				var hasFieldExisted = hasFieldValueOrFieldExisted(fieldId);
				var value = !hasFieldExisted ? undef : getModelController().getFieldValue(fieldId);
				var metadata = {
					hasFieldExisted: hasFieldExisted,
					isMultiSelect: isFieldMultiSelect(undef, fieldId)
				};
				return recordBehaviorDelegateService.handleMultiSelectAndVirtualFieldForReturnValue(value, metadata);
			}

			this.doGetValue = doGetValue;

			function setParsedValueAndUpdateFieldState(fieldId, value, fieldState)
			{
				getModelController().setParsedValueForBodyField(fieldId, value);
				fieldState.isParsed = true;
			}

			this.setParsedValueAndUpdateFieldState = setParsedValueAndUpdateFieldState;

			function setParsedValueForSublistFieldForInstance(sublistId, lineInstanceId, fieldId, value, useBuffer)
			{
				getModelController()
					.setParsedValueForSublistFieldForInstance(sublistId, lineInstanceId, fieldId, value, useBuffer);
			}

			this.setParsedValueForSublistFieldForInstance = setParsedValueForSublistFieldForInstance;

			function setValue(options, value, isInteractive)
			{
				var fieldId, fireFieldChange = true, noSlaving = false;
				if (value !== undef || (options !== undef && options.fieldId === undef && typeof options === 'string'))
				{
					fieldId = options;
				}
				else if (options !== undef && options !== null)
				{
					fieldId = options.fieldId;
					value = options.value;
					fireFieldChange = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChange;
					noSlaving = util.isBoolean(options.noslaving) ? options.noslaving : noSlaving;
					isInteractive = util.isBoolean(options.isInteractive) ? options.isInteractive : false;
				}

				utilityFunctions.checkArgs([fieldId], ['fieldId'], getMissingArgumentErrorMessageFillerValue('setValue'));
				recordUtil.validateAgainstSqlInjection(fieldId, value);
				doSetValue(fieldId, value, fireFieldChange, noSlaving, isInteractive);
			}

			/**
			 * set value of the field
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @param {number|Date|string|Array|boolean} options.value
			 * @param {boolean} [options.ignoreFieldChange=false] Ignore the field change script
			 * @return {Record} same record, for chaining
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.setValue = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: setValue,
				emitter: emitter
			});

			function doSetValue(fieldId, value, fireFieldChange, noSlaving, isInteractive)
			{
				implementation.doSetValue(fieldId, value, fireFieldChange, noSlaving, isInteractive);
				getFieldState(fieldId).useTextApi = false;
			}

			this.doSetValue = doSetValue;

			function validateAndFormatFieldValue(sublistId, fieldId, value, skipParsing)
			{
				return implementation.validateAndFormatFieldValue(sublistId, fieldId, value, skipParsing);
			}

			this.validateAndFormatFieldValue = validateAndFormatFieldValue;

			function validateAndFormatFieldValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer, value, isInteractive)
			{
				return implementation.validateAndFormatFieldValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer, value, isInteractive);
			}

			this.validateAndFormatFieldValueForInstance = validateAndFormatFieldValueForInstance;

			function doSetFieldValue(fieldId, value, fireFieldChange, noSlaving, valueIsFormattedAsString, isUpdatingSlavingField)
			{
				var newThingObject = getSetFieldMetadata(undef, fieldId);
				newThingObject.valueIsFormattedAsString = valueIsFormattedAsString;
				var valueObject = recordBehaviorDelegateService.createObjectToDoSetValue(value, newThingObject);
				getModelController().setFieldValue(fieldId, valueObject);
				var postSetObject = constructPostSetObject(undef, fieldId, valueObject.legacyStringValue,
					fireFieldChange, noSlaving, isUpdatingSlavingField);
				var lineInstance = null;
				var useBuffer = false;
				var fieldState = getFieldState(fieldId);
				fieldState.isParsed = !valueIsFormattedAsString;
				fieldState.isChanged = true;
				recordBehaviorDelegateService.postDoSetValueForInstance(that, postSetObject, lineInstance, useBuffer);
			}

			this.doSetFieldValue = doSetFieldValue;

			function postSetFieldValue(sublistId, fieldId, dbValue, fireFieldChange, noSlaving, isUpdatingSlavingField)
			{
				implementation.postSetFieldValue(sublistId, fieldId, dbValue, fireFieldChange, noSlaving, isUpdatingSlavingField);
			}

			this.postSetFieldValue = postSetFieldValue;

			function postSetFieldValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer, dbValue, fireFieldChange, noSlaving, isUpdatingSlavingField)
			{
				implementation.postSetFieldValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer, dbValue, fireFieldChange, noSlaving, isUpdatingSlavingField);
			}

			this.postSetFieldValueForInstance = postSetFieldValueForInstance;

			function doSlaving(sublistId, fieldId, line, value, noSlaving, restrictField)
			{
				implementation.doSlaving(sublistId, fieldId, line, value, noSlaving, restrictField);
			}

			this.doSlaving = doSlaving;

			function doSlavingForInstance(sublistId, fieldId, line, lineInstanceId, value, noSlaving, restrictField)
			{
				implementation.doSlavingForInstance(sublistId, fieldId, line, lineInstanceId, value, noSlaving, restrictField);
			}

			this.doSlavingForInstance = doSlavingForInstance;

			function doPostSendSlavingRequest(response)
			{
				var slaveValues;
				if (!utilityFunctions.isValEmpty(response))
				{
					slaveValues = _recordScriptingV1Scope.evaluateSlavingResponse(response);
				}
				return slaveValues;
			}

			function doHandleSlavingRequestAsync(slavingRequest)
			{
				return new Promise(
					function (resolve, reject)
					{
						try
						{
							invoker(remoteApi, 'sendSlavingRequest', [getRecordType(), slavingRequest.url, slavingRequest.payload], callback, false /* parseResult */);
						}
						catch (e)
						{
							reject(e);
						}

						function callback(result)
						{
							if (result instanceof Error)
							{
								reject(result);
								return;
							}
							try
							{
								resolve(doPostSendSlavingRequest(result));
							}
							catch (e)
							{
								reject(e);
							}
						}
					}
				);
			}

			function sendSlavingRequest(slavingMetadata, masterFieldInfo)
			{
				var slaveValuesOrPromise;
				var forceSync = (slavingMetadata && slavingMetadata.forceSyncSlaving) ? slavingMetadata.forceSyncSlaving : !getIsCurrentRecord();
				var slavingRequest = slaving.getQueryRequest(slavingMetadata, masterFieldInfo, getCurrentRecordDelegate());

				if (slavingRequest)
				{
					slavingRequest.payload = prepareSlavingPayload(slavingRequest.payload);
					//noinspection JSUnresolvedVariable
					if (forceSync)
					{
						var response = invoker(remoteApi, 'sendSlavingRequest', [getRecordType(), slavingRequest.url, slavingRequest.payload], null /* callback */, false /* parseResult */);
						slaveValuesOrPromise = doPostSendSlavingRequest(response);
					}
					else
					{
						slaveValuesOrPromise = doHandleSlavingRequestAsync(slavingRequest);
					}
				}

				return slaveValuesOrPromise;
			}

			this.sendSlavingRequest = sendSlavingRequest;

			function prepareSlavingPayload(payload)
			{
				payload.newslaving = 'T';
				payload.isCurrentRecord = getIsCurrentRecord();

				return payload;
			}

			function applySlaveValues(slaveValues)
			{
				var wasInternal = isInternal();
				setInternalEvent(true);
				if (slaveValues['machinesData'])
				{
					applySlaveMachineResults(slaveValues['machinesData']);
				}

				slaving.processSlavingValues(slaveValues['fields'], getCurrentRecordDelegate());
				if (util.isFunction(slaveValues['aspectScript']))
				{
					slaveValues['aspectScript'].call();
				}

				setInternalEvent(wasInternal);
			}

			this.applySlaveValues = applySlaveValues;

			function applySlaveMachineResults(machineData)
			{
				for (var sublistId in machineData)
				{
					var sublistData = machineData[sublistId].data;
					var sublistMetadata = machineData[sublistId].metadata;
					var sublistSlaveScript = machineData[sublistId].metadata[0];
					getModelController().clearSublistData(sublistId);
					sublistData.forEach(function (sublistLineData, index)
					{
						var line = index;
						getModelController().insertSublistLine(sublistId, line);
						sublistLineData.forEach(function (fieldValue, index)
						{
							var fieldMetadata = sublistMetadata[index + 1];
							var fieldId = fieldMetadata.name;
							var val = (typeof fieldValue === 'object') ? fieldValue.value : fieldValue;

							getModelController().setSublistLineValue(sublistId, fieldId, line, {
								value: val,
								legacyStringValue: val
							});
							if (typeof fieldValue === 'object' && (fieldValue.hasOwnProperty('options') || fieldMetadata.hasOwnProperty('defaultOptions')))
							{
								var options = fieldMetadata.hasOwnProperty('defaultOptions') ? fieldMetadata.defaultOptions : fieldValue.options;

								if (options.length > 0)
								{
									var selectOptions = getSelectOptionCache().get(sublistId, fieldId, line);
									selectOptions = util.isArray(selectOptions) ? selectOptions : [];

									options.forEach(function (option)
									{
										selectOptions.push({
											text: option[1],
											id: option[0]
										});
									});

									getSelectOptionCache().put(sublistId, fieldId, line, selectOptions);
								}
							}
						});
					});

					doResetSublistState(sublistId);
					invalidateSubrecordClones();
					triggerMachinePostSourcing(sublistSlaveScript);
					if (getSublistState(sublistId))
					{
						getSublistState(sublistId).isChanged = true;
					}
				}
			}

			function doResetSublistState(sublistId)
			{
				_state.addSublist(sublistId, getModelController);
				invalidateSubrecordClones();
			}

			function triggerMachinePostSourcing(postSourcingScript)
			{
				implementation.triggerMachinePostSourcing(postSourcingScript);
			}

			function triggerCustomPostSourcingScript(sublistId, fieldId, line)
			{
				implementation.triggerCustomPostSourcingScript(sublistId, fieldId, line);
			}

			this.triggerCustomPostSourcingScript = triggerCustomPostSourcingScript;


			function getText(options)
			{
				return recordBehaviorDelegate.getText(options);
			}

			/**
			 * get value of the field in text representation
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @return {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.getText = getText;

			function doGetText(fieldId, delegator)
			{
				return implementation.doGetText(fieldId, delegator);
			}

			this.doGetText = doGetText;

			function doGetTextValueForSupplementedSelectFieldForInstance(sublistId, fieldId, value, lineInstanceId, useBuffer)
			{
				var select = getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
				if (!!select.getSelectOptions)
				{
					var opts = select.getSelectOptions();
					var results = opts.filter(function (v) { return v.getId() === value; });
					if (results.length > 0)
					{
						return results[0].getText();
					}
				}
			}

			this.doGetTextValueForSupplementedSelectFieldForInstance = doGetTextValueForSupplementedSelectFieldForInstance;

			function doGetTextValueForSelectFieldForInstance(sublistId, fieldId, value, lineInstanceId, useBuffer, isMultiSelect)
			{
				var result = getModelController().getSelectOptionTextFromCache(sublistId, fieldId, value);
				if (result === undef)
				{
					var select = getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
					result = querySelectTextFromServer(value, select, isMultiSelect);
					getModelController().cacheSelectOptionText(sublistId, fieldId, value, result);
				}
				return result;
			}

			this.doGetTextValueForSelectFieldForInstance = doGetTextValueForSelectFieldForInstance;

			function querySelectTextFromServer(value, select, isMultiSelect)
			{
				var callback = null;
				var shouldParseResult = false;
				var requestParam = select.getRequestParam();
				requestParam.push(value);
				return invoker(remoteApi, isMultiSelect ? 'getMultiSelectTextValue' : 'getSelectTextValue', requestParam, callback, shouldParseResult);
			}

			function setText(options, text, isInteractive)
			{
				var fieldId, fireFieldChange = true;
				if (text !== undef || (options !== undef && options.fieldId === undef && typeof options === 'string'))
				{
					fieldId = options;
				}
				else if (options !== undef && options !== null)
				{
					fieldId = options.fieldId;
					text = options.text;
					fireFieldChange = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChange;
					isInteractive = util.isBoolean(options.isInteractive) ? options.isInteractive : false;
				}
				utilityFunctions.checkArgs([fieldId], ['fieldId'], getMissingArgumentErrorMessageFillerValue('setText'));

				text = recordUtil.emptyIfNullOrUndefined(text);
				recordUtil.validateAgainstSqlInjection(fieldId, text);
				doSetText(fieldId, text, fireFieldChange, isInteractive);
			}

			/**
			 * set value of the field by text representation
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @param {string} options.text ----- The text or texts to change the field value to.
			 *    If the field type is multiselect: - This parameter accepts an array of string values. - This parameter accepts a null value. Passing in null deselects all currentlsy selected values.
			 *    If the field type is not multiselect: this parameter accepts only a single string value.
			 * @param {boolean} [options.ignoreFieldChange=false] ignore field change script and slaving event if set to true
			 * @return {Record} same record, for chaining
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.setText = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: setText,
				emitter: emitter
			});

			function doSetText(fieldId, text, fireFieldChange, noSlaving, isUpdatingSlaveField)
			{
				implementation.doSetText(fieldId, text, fireFieldChange, noSlaving, isUpdatingSlaveField);
			}

			function doSetTexts(fieldId, texts, fireFieldChange, noSlaving)
			{
				var sublistId = undef;
				var lineInstanceId = null;
				var useBuffer = false;
				var rf = getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
				var values = rf.validateSelectFieldByText(texts);
				doSetFieldValue(fieldId, values, fireFieldChange, noSlaving);
			}

			this.doSetTexts = doSetTexts;

			function findSublistLineWithValue(options, fieldId, value)
			{
				var sublistId;
				if (fieldId !== undef && value != undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					value = options.value;
				}
				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], getMissingArgumentErrorMessageFillerValue('findSublistLineWithValue'));
				return doFindSublistLineWithValue(sublistId, fieldId, value);
			}

			/**
			 * return the line number for the first occurrence of a field value in a sublist and return -1 if not found
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {(number|Date|string|Array|boolean)} options.value
			 * @return {number}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or field is missing
			 */
			this.findSublistLineWithValue = findSublistLineWithValue;

			function doFindSublistLineWithValue(sublistId, fieldId, value)
			{
				for (var lineIndex = 0; lineIndex < doGetLineCount(sublistId); lineIndex++)
					//purposefully left == so that string/number matches occur for backwards compatibility
				{
					var foundValue = doGetSublistValue(sublistId, fieldId, lineIndex);
					if (value == foundValue || ('F' === foundValue && value === false) || ('T' === foundValue && value === true))
					{
						return lineIndex;
					}
				}
				return -1;
			}

			this.doFindSublistLineWithValue = doFindSublistLineWithValue;

			function getSublistValue(options, fieldId, line)
			{
				var useBuffer = false;
				var sublistId;
				if (fieldId !== undef && line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					line = options.line;
				}

				utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], getMissingArgumentErrorMessageFillerValue('getSublistValue'));
				validateTextApi(false, getSublistFieldState(sublistId, fieldId, line, useBuffer), 'setSublistText', 'getSublistText');
				return isWithinValidLineRange(sublistId, line) ? doGetParsedSublistValue(sublistId, fieldId, line) : undef;
			}

			/**
			 * return value of a sublist field
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @return {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked after using setSublistText
			 */
			this.getSublistValue = getSublistValue;

			function doGetParsedSublistValue(sublistId, fieldId, line)
			{
				validateLineIndex(line, 0, doGetLineCount(sublistId));
				var value = undef;
				if (line >= 0)
				{
					var useBuffer = false;
					var lineInstanceId = getLineInstanceId(sublistId, line, useBuffer);
					var lineDefinitionObject = getLineObjectFromCache(sublistId, lineInstanceId, useBuffer);
					value = lineDefinitionObject.getParsedValueForBodyField(fieldId);
				}
				return value;
			}

			function doGetParsedSublistValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer, delegator)
			{
				return implementation.doGetParsedSublistValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer, delegator);
			}

			this.doGetParsedSublistValueForInstance = doGetParsedSublistValueForInstance;

			function doGetSublistValue(sublistId, fieldId, line)
			{
				var useBuffer = false;
				var lineInstanceId = getLineInstanceId(sublistId, line, useBuffer);
				return doGetSublistValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
			}

			function doGetSublistValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer)
			{
				var hasFieldExisted = hasSublistLineValueOrSublistFieldExisted(sublistId, fieldId, lineInstanceId, useBuffer);
				var value = !hasFieldExisted ? undef :
					getModelController().getSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
				var metadata = {
					hasFieldExisted: hasFieldExisted,
					isMultiSelect: isFieldMultiSelect(sublistId, fieldId)
				};

				return recordBehaviorDelegateService.handleMultiSelectAndVirtualFieldForReturnValue(value, metadata);
			}

			this.doGetSublistValueForInstance = doGetSublistValueForInstance;


			function setSublistValue(options, fieldId, line, value)
			{
				implementation.setSublistValue(options, fieldId, line, value);
			}

			/**
			 * set the value of a sublist field (available for deferred dynamic only)
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @param {(number|Date|string|Array|boolean)} options.value
			 * @return {Record} same record, for chaining
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 */
			this.setSublistValue = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: setSublistValue,
				emitter: emitter
			});

			function doSetSublistValue(sublistId, fieldId, line, value)
			{
				var useBuffer = false;
				var lineInstanceId = getLineInstanceId(sublistId, line, useBuffer);
				finishSetSublistValueForInstance(sublistId, fieldId, lineInstanceId, value, useBuffer);
			}

			this.doSetSublistValue = doSetSublistValue;

			function finishSetSublistValueForInstance(sublistId, fieldId, lineInstanceId, value, useBuffer)
			{
				if (isSublistValid(sublistId))
				{
					var valueObject = recordBehaviorDelegateService.createObjectToDoSetSublistValue(value, getSetFieldMetadata(sublistId, fieldId));
					getModelController()
						.setSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, valueObject, useBuffer);
					recordBehaviorDelegateService.postDoSetSublistValueForInstance(that, sublistId, fieldId, lineInstanceId, useBuffer);
				}
			}

			function doSetSublistValueForInstance(sublistId, fieldId, lineInstanceId, value, fireFieldChange, useBuffer, isInteractive)
			{
				if (useBuffer)
				{
					doSetSublistBufferValue(sublistId, fieldId, lineInstanceId, value, fireFieldChange, false, isInteractive);
				}
				else
				{
					finishSetSublistValueForInstance(sublistId, fieldId, lineInstanceId, value, useBuffer);
				}
				getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, useBuffer).useTextApi = false;
			}

			this.doSetSublistValueForInstance = doSetSublistValueForInstance;

			function getSetFieldMetadata(sublistId, fieldId)
			{
				//TODO
				return {
					isValidField: isValidField(sublistId, fieldId),
					isMultiSelect: isFieldMultiSelect(sublistId, fieldId),
					isSelect: isFieldSelectType(sublistId, fieldId),
					isRadio: isFieldRadio(sublistId, fieldId),
					isNumeric: isFieldNumeric(sublistId, fieldId),
					isCurrency: isFieldCurrency(sublistId, fieldId),
					type: getFieldType(sublistId, fieldId)
				};
			}

			this.getSetFieldMetadata = getSetFieldMetadata;

			function getSublistText(options, fieldId, line)
			{
				var sublistId;
				if (fieldId !== undef && line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					line = options.line;
				}
				utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], getMissingArgumentErrorMessageFillerValue('getSublistText'));
				return doGetSublistText(sublistId, fieldId, line);
			}

			/**
			 * return value of a sublist field in text representation
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @return {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked prior using setSublistText
			 */
			this.getSublistText = getSublistText;

			function doGetSublistText(sublistId, fieldId, line)
			{
				var useBuffer = false;
				var fieldState = getSublistFieldState(sublistId, fieldId, line, useBuffer);
				validateTextApi(true, fieldState, 'setSublistValue', 'getSublistValue');
				validateLineIndex(line, 0, doGetLineCount(sublistId));
				var value = undef;
				if (line >= 0)
				{
					var lineInstanceId = getLineInstanceId(sublistId, line, useBuffer);
					var lineDefinitionObject = getLineObjectFromCache(sublistId, lineInstanceId, useBuffer);
					value = lineDefinitionObject.doGetText(fieldId);
				}
				return value;
			}

			function doGetSublistTextForInstance(sublistId, fieldId, lineInstanceId, useBuffer, delegator)
			{
				return implementation.doGetSublistTextForInstance(sublistId, fieldId, lineInstanceId, useBuffer, delegator);
			}

			this.doGetSublistTextForInstance = doGetSublistTextForInstance;

			function setSublistText(options, fieldId, line, text)
			{
				implementation.setSublistText(options, fieldId, line, text);
			}

			/**
			 * set the value of a sublist field in text representation (available for deferred dynamic only)
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @param {string} options.text
			 * @return {Record} same record, for chaining
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 */
			this.setSublistText = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: setSublistText,
				emitter: emitter
			});

			function doSetSublistTextForInstance(sublistId, fieldId, lineInstanceId, text, fireFieldChange, noSlaving, isUpdatingSlavingField, useBuffer, isInteractive)
			{
				if (useBuffer)
				{
					var metadata = {
						isMultiSelect: isFieldMultiSelect(sublistId, fieldId),
						isSelect: isFieldSelectType(sublistId, fieldId),
						isRadio: isFieldRadio(sublistId, fieldId),
						radioSet: getRadioSet(fieldId),
						isValidField: isValidField(sublistId, fieldId)
					};
					var value = recordBehaviorDelegateService.convertTextToValueForSetText(that, sublistId, fieldId, lineInstanceId, text, metadata, useBuffer);
					if (metadata.isMultiSelect || metadata.isSelect || metadata.isRadio)
					{
						doSetSublistBufferFieldValue(sublistId, fieldId, lineInstanceId, value, fireFieldChange, noSlaving, metadata.isRadio, isUpdatingSlavingField, useBuffer);
					}
					else
					{
						doSetSublistValueForInstance(sublistId, fieldId, lineInstanceId, value, fireFieldChange, useBuffer, isInteractive);
					}
				}
				else
				{
					finishSetSublistValueForInstance(sublistId, fieldId, lineInstanceId, text, useBuffer);
				}
				getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, useBuffer).useTextApi = true;
			}

			this.doSetSublistTextForInstance = doSetSublistTextForInstance;

			function getLineCount(options)
			{
				var sublistId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'sublistId', getMissingArgumentErrorMessageFillerValue('getLineCount'));
				return doGetLineCount(sublistId);
			}

			/**
			 * return line count of sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @return {number}
			 */
			this.getLineCount = getLineCount;

			function doGetLineCount(sublistId)
			{
				return isSublistValid(sublistId) ? getModelController().getSublistLineCount(sublistId) : -1;
			}

			this.doGetLineCount = doGetLineCount;

			function insertLine(options, line)
			{
				var sublistId, beforeLineInstanceId, lineObj, ignoreRecalc = false;
				if (line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					line = options.line;
					beforeLineInstanceId = options.beforeLineInstanceId;
					ignoreRecalc = options.ignoreRecalc || false;
				}
				utilityFunctions.checkMutuallyExclusiveArguments(line, beforeLineInstanceId, 'line', 'beforeLineInstanceId');

				recordUtil.assertValidSublistOperation(isSublistAnEditMachine(sublistId));
				if (line != undef)
				{
					utilityFunctions.checkArgs([sublistId, line], ['sublistId', 'line'], getMissingArgumentErrorMessageFillerValue('insertLine'));
					lineObj = doInsertLine(sublistId, line, ignoreRecalc);
				}
				else
				{
					utilityFunctions.checkArgs([sublistId, beforeLineInstanceId], ['sublistId', 'beforeLineInstanceId'], getMissingArgumentErrorMessageFillerValue('insertLine'));
					lineObj = doInsertLineForInstance(sublistId, beforeLineInstanceId, ignoreRecalc);
				}
				return !lineObj ? null : lineObj.proxy();
			}

			/**
			 * insert a sublist line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @param {string} options.beforeLineInstanceId
			 * @param {boolean} [ignoreRecalc=false] options.ignoreRecalc ignore recalc scripting
			 * @return {Line} [new line object]
			 * @throws {SuiteScriptError} MUTUALLY_EXCLUSIVE_ARGUMENTS if both line and beforeLineInstanceId are provided
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or both line and beforeLineInstanceId
			 *     are missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId or line index is invalid or if machine is not
			 *     editable or before exists and before is an instanceId that does not point to a line in the sublist.
			 */
			this.insertLine = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: insertLine,
				emitter: emitter
			});

			function doInsertLine(sublistId, line, ignoreRecalc)
			{
				var useBuffer = false;
				var lineInstanceId = null;
				if (ignoreRecalc === undef)
				{
					ignoreRecalc = false;
				}

				if (isSublistAnEditMachine(sublistId))
				{
					validateLineIndex(line, 0, doGetLineCount(sublistId) + 1);
					preInsertLine(sublistId, line);
					insertSublistLine(sublistId, line);
					postInsertLine(sublistId, line, ignoreRecalc);
					setSublistIsChanged(sublistId, true);
					if (!!getLineInstanceId(sublistId, line, true/*useBuffer*/))
					{
						useBuffer = true;
					}
				}
				else
				{
					useBuffer = false;
				}
				var lineInstanceId = getLineInstanceId(sublistId, line, useBuffer);
				return getLineObjectFromCache(sublistId, lineInstanceId, useBuffer);
			}

			this.doInsertLine = doInsertLine;

			function doInsertLineForInstance(sublistId, beforeLineInstanceId, ignoreRecalc)
			{
				var lineObj = null;
				if (ignoreRecalc === undef)
				{
					ignoreRecalc = false;
				}

				if (isSublistAnEditMachine(sublistId))
				{
					var useBuffer = false;
					validateLineInstanceId(sublistId, beforeLineInstanceId, useBuffer);
					preInsertLineForInstance(sublistId, beforeLineInstanceId);
					var lineInstanceId = insertSublistLineForInstance(sublistId, beforeLineInstanceId);
					postInsertLineForInstance(sublistId, lineInstanceId, ignoreRecalc);
					setSublistIsChanged(sublistId, true);
					lineObj = getLineObjectFromCache(sublistId, lineInstanceId, useBuffer);
				}
				return lineObj;
			}

			this.doInsertLineForInstance = doInsertLineForInstance;

			function insertSublistLine(sublistId, line)
			{
				getModelController().insertSublistLine(sublistId, line);
				getSublistState(sublistId).insertLine(line, true);
				subrecord_updateFieldState(true);
			}

			function insertSublistLineForInstance(sublistId, beforeLineInstanceId)
			{
				var useBuffer = true;
				var lineInstanceId = getModelController().insertSublistLineForInstance(sublistId, beforeLineInstanceId);
				getSublistState(sublistId).insertLineForInstance(lineInstanceId, useBuffer, true);
				subrecord_updateFieldState(true);
				return lineInstanceId;
			}

			function preInsertLine(sublistId, line)
			{
				implementation.preInsertLine(sublistId, line);
			}

			function preInsertLineForInstance(sublistId, beforeLineInstanceId)
			{
				implementation.preInsertLineForInstance(sublistId, beforeLineInstanceId);
			}

			function postInsertLine(sublistId, line, ignoreRecalc)
			{
				return implementation.postInsertLine(sublistId, line, ignoreRecalc);
			}

			function postInsertLineForInstance(sublistId, beforeLineInstanceId, ignoreRecalc)
			{
				return implementation.postInsertLineForInstance(sublistId, beforeLineInstanceId, ignoreRecalc);
			}

			function makeCopyForInstance(sublistId, lineInstanceId, useBuffer)
			{
				var lineToCopy = getModelController().getSublistLineForInstance(sublistId, lineInstanceId, useBuffer);
				var newLineId = getModelController().putCopyIntoNewLineBuffer(sublistId, lineToCopy);

				var fromBuffer = true;
				var copiedLine = getLineObjectFromCache(sublistId, newLineId, fromBuffer);
				return !copiedLine ? null : copiedLine.proxy();
			}
			this.makeCopyForInstance = makeCopyForInstance;

			function copyLine(options)
			{
				var useBuffer = false;
				var sublistId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'sublistId', getMissingArgumentErrorMessageFillerValue("copyLine"));
				var currIdx = doGetCurrentSublistIndex(sublistId);
				var currInstanceId = getLineInstanceId(sublistId, currIdx, useBuffer);

				recordUtil.assertValidSublistOperation(isSublistAnEditMachine(sublistId) && (currInstanceId != null));

				commitLine(options);

				var lineToCopy = getModelController().getSublistLineForInstance(sublistId, currInstanceId, useBuffer);
				var newLineId = getModelController().updateNewLineBufferWithCopy(sublistId, lineToCopy);
			}

			/**
			 * Commits and copies the currently selected line into a new line, which will be the new selected line.
			 *
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @return {Record} same record, for chaining
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId is invalid or not editable
			 */
			this.copyLine = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: copyLine,
				emitter: emitter
			});

			function doResetSublistLine(sublistId, line, data)
			{
				getModelController().resetSublistLine(sublistId, line, data);
			}

			this.doResetSublistLine = doResetSublistLine;

			function doResetSublistLineForInstance(sublistId, lineInstanceId, data)
			{
				var useBuffer = true;
				getModelController().resetSublistLineForInstance(sublistId, lineInstanceId, data, useBuffer);
			}

			this.doResetSublistLineForInstance = doResetSublistLineForInstance;

			function removeLine(options, line)
			{
				var sublistId, lineInstanceId, ignoreRecalc = false;
				if (line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					line = options.line;
					lineInstanceId = options.lineInstanceId;
					ignoreRecalc = options.ignoreRecalc || false;
				}
				utilityFunctions.checkMutuallyExclusiveArguments(line, lineInstanceId, 'line', 'lineInstanceId');

				recordUtil.assertValidSublistOperation(isSublistAnEditMachine(sublistId));
				if (line != undef)
				{
					utilityFunctions.checkArgs([sublistId, line], ['sublistId', 'line'], getMissingArgumentErrorMessageFillerValue('removeLine'));
					doRemoveLine(sublistId, line, ignoreRecalc);
				}
				else
				{
					utilityFunctions.checkArgs([sublistId, lineInstanceId], ['sublistId', 'lineInstanceId'], getMissingArgumentErrorMessageFillerValue('removeLine'));
					doRemoveLineForInstance(sublistId, lineInstanceId, ignoreRecalc);
				}
			}

			/**
			 * remove a sublist line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @param {string} options.lineInstanceId
			 * @param {boolean} [ignoreRecalc=false] options.ignoreRecalc ignore recalc scripting
			 * @return {Record} same record, for chaining
			 * @throws {SuiteScriptError} MUTUALLY_EXCLUSIVE_ARGUMENTS if both line and lineInstanceId are provided
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or both line and lineInstanceId are
			 *     missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId or line index is invalid or if machine is not
			 *     editable
			 */
			this.removeLine = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: removeLine,
				emitter: emitter
			});

			function doRemoveLine(sublistId, line, ignoreRecalc)
			{
				if (isSublistAnEditMachine(sublistId))
				{
					validateLineIndex(line, 0, doGetLineCount(sublistId));
					var isLastLine = (line === doGetLineCount(sublistId) - 1);
					removeSublistLine(sublistId, line, ignoreRecalc);
					getSublistState(sublistId).removeLine(line);
					postRemoveLine(sublistId, line, isLastLine);
					setSublistIsChanged(sublistId, true);
				}
			}

			this.doRemoveLine = doRemoveLine;

			function doRemoveLineForInstance(sublistId, lineInstanceId, ignoreRecalc)
			{
				if (isSublistAnEditMachine(sublistId))
				{
					var useBuffer = false;
					validateLineInstanceId(sublistId, lineInstanceId, useBuffer);
					removeSublistLineForInstance(sublistId, lineInstanceId, ignoreRecalc);
					getSublistState(sublistId).removeLineForInstance(lineInstanceId);
					postRemoveLineForInstance(sublistId, lineInstanceId, useBuffer);
					setSublistIsChanged(sublistId, true);
				}
			}

			function removeSublistLine(sublistId, line, ignoreRecalc)
			{
				implementation.removeSublistLine(sublistId, line, ignoreRecalc);
			}

			function removeSublistLineForInstance(sublistId, lineInstanceId, ignoreRecalc)
			{
				implementation.removeSublistLineForInstance(sublistId, lineInstanceId, ignoreRecalc);
			}

			function doRemoveSublistLine(sublistId, line)
			{
				var lineInstanceId = getModelController().removeSublistLine(sublistId, line);
				subrecord_updateFieldState(true);
				removeLineObjectFromCache(sublistId, lineInstanceId);
				return lineInstanceId;
			}

			this.doRemoveSublistLine = doRemoveSublistLine;

			function doRemoveSublistLineForInstance(sublistId, lineInstanceId)
			{
				getModelController().removeSublistLineForInstance(sublistId, lineInstanceId);
				subrecord_updateFieldState(true);
				removeLineObjectFromCache(sublistId, lineInstanceId);
				return lineInstanceId;
			}

			this.doRemoveSublistLineForInstance = doRemoveSublistLineForInstance;

			function postRemoveLine(sublistId, line, isLastLine)
			{
				implementation.postRemoveLine(sublistId, line, isLastLine);
			}

			function postRemoveLineForInstance(sublistId, lineInstanceId, useBuffer)
			{
				implementation.postRemoveLineForInstance(sublistId, lineInstanceId, useBuffer);
			}

			/**
			 * return the line number of current selected line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @return {number}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 * @restriction only available in dynamic record
			 */
			function getCurrentSublistIndex(options)
			{
				var sublistId;
				sublistId = options !== undef && options !== null && !util.isString(options) ? options.sublistId : options;
				utilityFunctions.checkArgs([sublistId], ['sublistId'], getMissingArgumentErrorMessageFillerValue('getCurrentSublistIndex'));
				return doGetCurrentSublistIndex(sublistId);
			}

			this.getCurrentSublistIndex = getCurrentSublistIndex;

			function doGetCurrentSublistIndex(sublistId)
			{
				return getModelController().getCurrentSublistLineIndex(sublistId);
			}

			this.doGetCurrentSublistIndex = doGetCurrentSublistIndex;

			function doGetCurrentSublistLineInstanceId(sublistId)
			{
				return getModelController().getSublistSelectedLineInstanceId(sublistId);
			}

			this.doGetCurrentSublistLineInstanceId = doGetCurrentSublistLineInstanceId;

			/**
			 * select line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @param {String} options.lineInstanceId
			 * @return {Line} [requested line object]
			 * @throws {SuiteScriptError} MUTUALLY_EXCLUSIVE_ARGUMENTS if both line and lineInstanceId are provided
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or both line and lineInstanceId are
			 *     missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id or line index
			 * @restriction only available in dynamic record
			 */
			function selectLine(options, line)
			{
				var lineObj = implementation.selectLine(options, line);
				return !lineObj ? null : lineObj.proxy();
			}

			this.selectLine = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: selectLine,
				emitter: emitter
			});

			function doSelectLine(sublistId, line)
			{
				var lineInstanceId;
				if (line === doGetCurrentSublistIndex(sublistId))
				{
					lineInstanceId = getModelController().getSublistSelectedLineInstanceId(sublistId);
				}
				else
				{
					validateLineIndex(line, 0, doGetLineCount(sublistId));
					lineInstanceId = handleSelectSublistLine(sublistId, line);
					triggerLineInitScript(sublistId);
				}

				return getLineObjectFromCache(sublistId, lineInstanceId, true);
			}

			this.doSelectLine = doSelectLine;

			function doSelectLineForInstance(sublistId, lineInstanceId)
			{
				if (lineInstanceId !== doGetCurrentSublistLineInstanceId(sublistId))
				{
					var useBuffer = false;
					validateLineInstanceId(sublistId, lineInstanceId, useBuffer);
					lineInstanceId = handleSelectSublistLineForInstance(sublistId, lineInstanceId);
					triggerLineInitScript(sublistId);
				}
				return getLineObjectFromCache(sublistId, lineInstanceId, true);
			}

			this.doSelectLineForInstance = doSelectLineForInstance;

			function handleSelectSublistLine(sublistId, line)
			{
				var lineInstanceId = getModelController().selectSublistLine(sublistId, line);
				getSublistState(sublistId).resetCurrentLineState(line);
				subrecord_updateFieldState(true);
				return lineInstanceId;
			}

			function handleSelectSublistLineForInstance(sublistId, lineInstanceId)
			{
				var useBuffer = true;
				var resultLineInstanceId = getModelController().selectSublistLineForInstance(sublistId, lineInstanceId);
				var line = getModelController()
					.getSublistLineValueForInstance(sublistId, '_sequence', resultLineInstanceId, useBuffer);
				getSublistState(sublistId).resetCurrentLineState(line);
				subrecord_updateFieldState(true);
				return resultLineInstanceId;
			}

			function selectNewLine(options)
			{
				var lineObj = implementation.selectNewLine(options);
				return !lineObj ? null : lineObj.proxy();
			}

			/**
			 * select a new line at the end of sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @return {Line} [new line object]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id or sublist is not editable
			 * @restriction only available in dynamic record
			 */
			this.selectNewLine = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: selectNewLine,
				emitter: emitter
			});

			function doSelectNewLine(sublistId, ignoreLineInit)
			{
				ignoreLineInit = ignoreLineInit || false;
				var lineObj = null;

				if (isSublistAnEditMachine(sublistId))
				{
					var lineInstanceId = handleSelectNewSublistLine(sublistId);
					if (!ignoreLineInit)
					{
						triggerLineInitScript(sublistId);
					}

					lineObj = getLineObjectFromCache(sublistId, lineInstanceId, true);
					return lineObj;
				}

				return lineObj;
			}

			this.doSelectNewLine = doSelectNewLine;

			function handleSelectNewSublistLine(sublistId)
			{
				var lineInstanceId = getModelController()
					.selectNewSublistLine(sublistId, _metadata.getSublistDefaultValue(sublistId));
				getSublistState(sublistId).resetCurrentLineState(doGetLineCount(sublistId));
				subrecord_updateFieldState(true);

				return lineInstanceId;
			}

			function getLine(options)
			{
				var sublistId;
				var lineInstanceId;
				var useBuffer;

				if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					lineInstanceId = options.lineInstanceId;
					useBuffer = !!options.fromBuffer;
				}
				utilityFunctions.checkArgs([sublistId, lineInstanceId], ['sublistId', 'lineInstanceId'], getMissingArgumentErrorMessageFillerValue('getLine'));

				var lineExists = getModelController()
					.isSublistLineInstanceIdValidWithFallback(sublistId, lineInstanceId, useBuffer);
				if (!lineExists)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_SUBLIST_OPERATION);
				}

				var lineObj = getLineObjectFromCache(sublistId, lineInstanceId, useBuffer);
				return !lineObj ? null : lineObj.proxy();
			}

			this.getLine = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: getLine,
				emitter: emitter
			});

			function getLineIterator(options)
			{
				var sublistId;
				var useBuffer;

				if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					useBuffer = !!options.fromBuffer;
				}
				utilityFunctions.checkArgs([sublistId], ['sublistId'], getMissingArgumentErrorMessageFillerValue('getLineIterator'));
				utilityFunctions.assertTrue(getModelController()
					.doesSublistExist(sublistId, useBuffer), error.Type.INVALID_SUBLIST_OPERATION);

				var result = {
					each: function (func)
					{
						var modelController = getModelController();
						var maxIndex = modelController.getSublistLineCount(sublistId);

						if (useBuffer)
						{
							maxIndex = Math.max(maxIndex, modelController.getCurrentSublistLineIndex(sublistId) + 1);
						}

						for (var index = 0; index < maxIndex; index += 1)
						{
							var lineInstanceId = getLineInstanceId(sublistId, index, useBuffer);
							if (!lineInstanceId && useBuffer)
							{
								lineInstanceId = getLineInstanceId(sublistId, index, !useBuffer);
							}
							var lineObj = getLineObjectFromCache(sublistId, lineInstanceId, useBuffer);
							func(lineObj.proxy());
						}
						if (useBuffer)
						{
							var lineInstanceId = getLineInstanceId(sublistId, index, useBuffer);
							if (!!lineInstanceId)
							{
								var lineObj = getLineObjectFromCache(sublistId, lineInstanceId, useBuffer);
								func(lineObj.proxy());
							}
						}
					},
					next: (function ()
					{
						var index = 0;
						var done = false;

						return function ()
						{
							var modelController = getModelController();
							var result = {
								done: done
							};

							if (!done)
							{
								var maxIndex = modelController.getSublistLineCount(sublistId);
								if (useBuffer)
								{
									maxIndex = Math.max(maxIndex, modelController.getCurrentSublistLineIndex(sublistId) + 1);
								}

								done = !(index < maxIndex);
								var lastChance = (index === maxIndex) && useBuffer;
								result.done = done && !lastChance;

								if (!done)
								{
									var lineInstanceId = getLineInstanceId(sublistId, index, useBuffer);
									if (!lineInstanceId && useBuffer)
									{
										lineInstanceId = getLineInstanceId(sublistId, index, !useBuffer);
									}
									var lineObj = getLineObjectFromCache(sublistId, lineInstanceId, useBuffer);
									index += 1;

									result.value = lineObj.proxy();
								}
								else if (lastChance)
								{
									var lineInstanceId = getLineInstanceId(sublistId, index, useBuffer);
									if (!!lineInstanceId)
									{
										var lineObj = getLineObjectFromCache(sublistId, lineInstanceId, useBuffer);
										index += 1;
										result.value = lineObj.proxy();
									}
									result.done = !lineInstanceId;
								}
							}

							return result;
						};
					})()
				};

				return Object.freeze(result);
			}

			this.getLineIterator = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: getLineIterator,
				emitter: emitter
			});

			function getLines()
			{
				utilityFunctions.throwSuiteScriptError(error.Type.YOU_HAVE_ATTEMPTED_AN_UNSUPPORTED_ACTION);  // !!@TODO - implementme
			}

			//
			// !!@TODO - write properly formed JSDoc here for this new MLB API
			//
			this.getLines = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: getLines,
				emitter: emitter
			});

			function getCommittedLine()
			{
				utilityFunctions.throwSuiteScriptError(error.Type.YOU_HAVE_ATTEMPTED_AN_UNSUPPORTED_ACTION);  // !!@TODO - implementme
			}

			//
			// !!@TODO - write properly formed JSDoc here for this new MLB API
			//
			this.getCommittedLine = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: getCommittedLine,
				emitter: emitter
			});

			function getPendingLine()
			{
				utilityFunctions.throwSuiteScriptError(error.Type.YOU_HAVE_ATTEMPTED_AN_UNSUPPORTED_ACTION);  // !!@TODO - implementme
			}

			//
			// !!@TODO - write properly formed JSDoc here for this new MLB API
			//
			this.getPendingLine = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: getPendingLine,
				emitter: emitter
			});

			function getCommittedLinesIterator()
			{
				utilityFunctions.throwSuiteScriptError(error.Type.YOU_HAVE_ATTEMPTED_AN_UNSUPPORTED_ACTION);  // !!@TODO - implementme
			}

			//
			// !!@TODO - write properly formed JSDoc here for this new MLB API
			//
			this.getCommittedLinesIterator = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: getCommittedLinesIterator,
				emitter: emitter
			});

			function getPendingLinesIterator()
			{
				utilityFunctions.throwSuiteScriptError(error.Type.YOU_HAVE_ATTEMPTED_AN_UNSUPPORTED_ACTION);  // !!@TODO - implementme
			}

			//
			// !!@TODO - write properly formed JSDoc here for this new MLB API
			//
			this.getPendingLinesIterator = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: getPendingLinesIterator,
				emitter: emitter
			});

			function addLine()
			{
				utilityFunctions.throwSuiteScriptError(error.Type.YOU_HAVE_ATTEMPTED_AN_UNSUPPORTED_ACTION);  // !!@TODO - implementme
			}

			//
			// !!@TODO - write properly formed JSDoc here for this new MLB API
			//
			this.addLine = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: addLine,
				emitter: emitter
			});

			function cancelLine(options)
			{
				implementation.cancelLine(options);
			}

			/**
			 * cancel the current selected line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @return {Record} same record, for chaining
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId is invalid or if machine is not editable
			 * @restriction only available in dynamic record
			 */
			this.cancelLine = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: cancelLine,
				emitter: emitter
			});

			function doCancelLine(sublistId)
			{
				if (isSublistAnEditMachine(sublistId))
				{
					var line = doGetCurrentSublistIndex(sublistId);
					validateLineIndex(line, 0, doGetLineCount(sublistId) + 1);
					var lineInstanceId = getModelController().getSublistSelectedLineInstanceId(sublistId);
					doCancelLineForInstance(sublistId, lineInstanceId);
					postCancelLine(sublistId, line);
				}
			}

			this.doCancelLine = doCancelLine;

			function cancelLineForInstance(sublistId, lineInstanceId)
			{
				implementation.cancelLineForInstance(sublistId, lineInstanceId);
			}

			this.cancelLineForInstance = cancelLineForInstance;

			function doCancelLineForInstance(sublistId, lineInstanceId)
			{
				if (isSublistAnEditMachine(sublistId))
				{
					var useBuffer = true;
					dereferencedSublistLineSubrecords(sublistId, lineInstanceId, useBuffer);
					getSublistState(sublistId).removeCurrentLineState();
					getModelController().cancelCurrentSublistLine(sublistId);
					subrecord_updateFieldState(true);
				}
			}

			this.doCancelLineForInstance = doCancelLineForInstance;

			function postCancelLine(sublistId, line)
			{
				var lineObj = null;

				if (line < doGetLineCount(sublistId))
				{
					lineObj = doSelectLine(sublistId, line);
				}
				else
				{
					lineObj = doSelectNewLine(sublistId);
				}

				return lineObj;
			}

			function commitLine(options)
			{
				implementation.commitLine(options);
			}

			function commitLinePromise(delegate, args, proxyOptions)
			{
				return new Promise(
					function (resolve, reject)
					{
						try
						{
							implementation.commitLine(args[0]);
							resolve(delegate.proxy(proxyOptions));
						}
						catch (e)
						{
							reject(e);
						}
					}
				);
			}

			/**
			 * commit the current selected line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @return {Record} same record, for chaining
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id
			 * @restriction only available in dynamic record
			 */
			this.commitLine = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: commitLine,
				emitter: emitter
			});
			this.commitLine.promise = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: commitLinePromise,
				emitter: emitter
			});

			function doCommitLine(sublistId, ignoreRecalc)
			{
				if (isSublistEditable(sublistId))
				{
					var line = doGetCurrentSublistIndex(sublistId);
					validateLineIndex(line, 0, doGetLineCount(sublistId) + 1);
					var lineInstanceId = getModelController().getSublistSelectedLineInstanceId(sublistId);
					doCommitLineForInstance(sublistId, lineInstanceId, ignoreRecalc);
					if (isSublistAnEditMachine(sublistId))
					{
						doSelectNewLine(sublistId);
					}
				}
			}

			this.doCommitLine = doCommitLine;

			function commitLineForInstance(sublistId, lineInstanceId)
			{
				implementation.commitLineForInstance(sublistId, lineInstanceId);
			}

			this.commitLineForInstance = commitLineForInstance;

			function doCommitLineForInstance(sublistId, lineInstanceId, ignoreRecalc)
			{
				if (isSublistEditable(sublistId))
				{
					var useBuffer = true;
					triggerValidateLineScript(sublistId);
					getModelController().validateCurrentSublistSubrecordsForInstance(sublistId, lineInstanceId);
					getSublistState(sublistId).commitLineForInstance(lineInstanceId);
					getModelController().commitSublistLineForInstance(sublistId, lineInstanceId);
					subrecord_updateFieldState(true);
					if (!ignoreRecalc)
					{
						triggerRecalcScript(sublistId, false, 'commit');
					}
					if (isSublistAnEditMachine(sublistId))
					{
						triggerLineCommitScriptForInstance(sublistId, lineInstanceId, useBuffer);
					}
				}
			}

			this.doCommitLineForInstance = doCommitLineForInstance;

			function constructLineObject(sublistId, lineInstanceId, useBuffer)
			{
				var lineObj;
				var lineOptions = {
					unproxiedRecord: that,
					sublistId: sublistId,
					lineInstanceId: lineInstanceId,
					fromBuffer: useBuffer,
					isReadOnly: getIsReadOnlyRecord() || (getIsDynamicRecord() && !useBuffer)
				};
				lineObj = new lineDefinition(lineOptions);
				return lineObj;
			}

			function constructPostSetObject(sublistId, fieldId, dbValue, fireFieldChange, noSlaving, isUpdatingSlavingField)
			{
				return {
					sublistId: sublistId,
					fieldId: fieldId,
					dbValue: dbValue,
					fireFieldChange: fireFieldChange,
					noSlaving: noSlaving,
					isUpdatingSlavingField: isUpdatingSlavingField
				};
			}

			function getCurrentSublistValue(options, fieldId)
			{
				return implementation.getCurrentSublistValue(options, fieldId);
			}

			/**
			 * return value of a sublist field on the current selected sublist line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @return {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id or field id
			 * @restriction only available in dynamic record
			 */
			this.getCurrentSublistValue = getCurrentSublistValue;

			function doGetCurrentSublistValue(sublistId, fieldId)
			{
				var hasFieldExisted = hasCurrentSublistFieldValueOrSublistFieldExisted(sublistId, fieldId);
				var value = !hasFieldExisted ? undef : getModelController().getCurrentSublistLineValue(sublistId, fieldId);
				var metadata = {
					hasFieldExisted: hasFieldExisted,
					isMultiSelect: isFieldMultiSelect(sublistId, fieldId)
				};
				return recordBehaviorDelegateService.handleMultiSelectAndVirtualFieldForReturnValue(value, metadata);
			}

			function setCurrentSublistValue(options, fieldId, value, isInteractive)
			{
				implementation.setCurrentSublistValue(options, fieldId, value, isInteractive);
			}

			//!!@ Issue 446030 - this API appears to be unused. Scott will investigate.
			function setSublistBufferValue(options)
			{
				implementation.setSublistBufferValue(options);
			}

			this.setSublistBufferValue = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: setSublistBufferValue,
				emitter: emitter
			});

			/**
			 * set the value for field in the current selected line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {(number|Date|string|Array|boolean)} options.value
			 * @param {boolean} [options.ignoreFieldChange=false] ignore field change script and slaving event if set to true
			 * @return {Record} same record, for chaining
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} A_SCRIPT_IS_ATTEMPTING_TO_EDIT_THE_1_SUBLIST_THIS_SUBLIST_IS_CURRENTLY_IN_READONLY_MODE_AND_CANNOT_BE_EDITED_CALL_YOUR_NETSUITE_ADMINISTRATOR_TO_DISABLE_THIS_SCRIPT_IF_YOU_NEED_TO_SUBMIT_THIS_RECORD
			 *     if user tries to edit readonly sublist field
			 */
			this.setCurrentSublistValue = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: setCurrentSublistValue,
				emitter: emitter
			});

			function doSetCurrentSublistValue(sublistId, fieldId, value, fireFieldChange, noSlaving, isInteractive)
			{
				var lineInstanceId = getModelController().getSublistSelectedLineInstanceId(sublistId);
				doSetSublistBufferValue(sublistId, fieldId, lineInstanceId, value, fireFieldChange, noSlaving, isInteractive);
			}

			this.doSetCurrentSublistValue = doSetCurrentSublistValue;

			function doSetSublistBufferValue(sublistId, fieldId, lineInstanceId, value, fireFieldChange, noSlaving, isInteractive)
			{
				validateIfSublistIdEditableCurrentSublist(sublistId);
				var relevantMetadata = {
					sublistId: sublistId,
					fieldId: fieldId,
					isMultiSelect: isFieldMultiSelect(sublistId, fieldId),
					isRadio: isFieldRadio(sublistId, fieldId),
					isInteractive: isInteractive
				};
				var validatedValue = recordBehaviorDelegateService.preDoSetSublistBufferValue(that, lineInstanceId, value, relevantMetadata);
				var valueIsFormattedAsString = false;
				var isUpdatingSlavingField = false;
				var useBuffer = true;
				doSetSublistBufferFieldValue(sublistId, fieldId, lineInstanceId, validatedValue, fireFieldChange, noSlaving, valueIsFormattedAsString, isUpdatingSlavingField, useBuffer);
			}

			this.doSetSublistBufferValue = doSetSublistBufferValue;

			function validateIfSublistIdEditableCurrentSublist(sublistId)
			{
				var sublistMetadata = getSublistMetadata(sublistId);

				recordUtil.assertValidSublistOperation(sublistMetadata !== null);
				if (sublistMetadata.displayOnly)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.INVALID_SCRIPT_OPERATION_ON_READONLY_SUBLIST_FIELD, sublistId);
				}

				validateLineIndex(doGetCurrentSublistIndex(sublistId), 0, doGetLineCount(sublistId) + 1);
			}

			this.validateIfSublistIdEditableCurrentSublist = validateIfSublistIdEditableCurrentSublist;

			function doSetCurrentSublistFieldValue(sublistId, fieldId, value, fireFieldChange, noSlaving, valueIsFormattedAsString, isUpdatingSlavingField)
			{
				var useBuffer = true;
				var lineInstanceId = getModelController().getSublistSelectedLineInstanceId(sublistId);
				doSetSublistBufferFieldValue(sublistId, fieldId, lineInstanceId, value, fireFieldChange, noSlaving, valueIsFormattedAsString, isUpdatingSlavingField, useBuffer);
			}

			this.doSetCurrentSublistFieldValue = doSetCurrentSublistFieldValue;

			function doSetSublistBufferFieldValue(sublistId, fieldId, lineInstanceId, value, fireFieldChange, noSlaving, valueIsFormattedAsString, isUpdatingSlavingField, useBuffer)
			{
				var relevantMetadata = getSetFieldMetadata(sublistId, fieldId);
				relevantMetadata.valueIsFormattedAsString = valueIsFormattedAsString;
				var valueObject = recordBehaviorDelegateService.createObjectToDoSetValue(value, relevantMetadata);
				getModelController().setSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, valueObject, useBuffer);
				var postSetObject = constructPostSetObject(sublistId, fieldId, valueObject.legacyStringValue,
					fireFieldChange, noSlaving, isUpdatingSlavingField);
				var fieldState = getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
				fieldState.isParsed = !valueIsFormattedAsString;
				fieldState.isChanged = true;
				recordBehaviorDelegateService.postDoSetValueForInstance(that, postSetObject, lineInstanceId, useBuffer);
			}

			this.doSetSublistBufferFieldValue = doSetSublistBufferFieldValue;

			function getCurrentSublistText(options, fieldId)
			{
				return implementation.getCurrentSublistText(options, fieldId);
			}

			/**
			 * return the value for field in the current selected line by text representation
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @return {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id or field id
			 * @restriction only available in dynamic record
			 */
			this.getCurrentSublistText = getCurrentSublistText;

			function setCurrentSublistText(options, fieldId, text, isInteractive)
			{
				implementation.setCurrentSublistText(options, fieldId, text, isInteractive);
			}

			/**
			 * set the value for field in the current selected line by text representation
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {(number|Date|string|Array|boolean)} options.text
			 * @param {boolean} [options.ignoreFieldChange=false] ignore field change script and slaving event if set to true
			 * @return {Record} same record, for chaining
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} A_SCRIPT_IS_ATTEMPTING_TO_EDIT_THE_1_SUBLIST_THIS_SUBLIST_IS_CURRENTLY_IN_READONLY_MODE_AND_CANNOT_BE_EDITED_CALL_YOUR_NETSUITE_ADMINISTRATOR_TO_DISABLE_THIS_SCRIPT_IF_YOU_NEED_TO_SUBMIT_THIS_RECORD
			 *     if user tries to edit readonly sublist field
			 * @restriction only available in dynamic record
			 */
			this.setCurrentSublistText = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: setCurrentSublistText,
				emitter: emitter
			});

			function doSetCurrentSublistText(sublistId, fieldId, text, fireFieldChange, noSlaving, isUpdatingSlaveField, isInteractive)
			{
				var useBuffer = true;
				var lineInstanceId = getModelController().getSublistSelectedLineInstanceId(sublistId);
				doSetSublistTextForInstance(sublistId, fieldId, lineInstanceId, text, fireFieldChange, noSlaving, isUpdatingSlaveField, useBuffer, isInteractive);
			}

			this.doSetCurrentSublistText = doSetCurrentSublistText;

			function overwriteSublistState(clonedSublistState, sourceSublistState)
			{
				clonedSublistState.isDisplay = sourceSublistState.isDisplay;
				clonedSublistState.isChanged = sourceSublistState.isChanged;
				clonedSublistState.isHidden = sourceSublistState.isHidden;

				for (var i = 0; i < sourceSublistState.getLineCount(); i++)
				{
					var lineFields = sourceSublistState.getAllLineFields(i) || [];
					lineFields.forEach(function (v, i, a)
					{
						overwriteFieldState(clonedSublistState.getFieldState(v, i), sourceSublistState.getFieldState(v, i), false);
					});
				}

				return clonedSublistState;
			}

			function overwriteSublistsState(sink, source)
			{
				source.getAllSublists().forEach(function (sublistId, i, a)
				{
					overwriteSublistState(sink.getSublistState(sublistId), source.getSublistState(sublistId));
				});

				return sink;
			}

			function overwriteFieldState(clonedFieldState, sourceFieldState)
			{
				clonedFieldState.useTextApi = sourceFieldState.useTextApi;
				clonedFieldState.isParsed = sourceFieldState.isParsed;
				clonedFieldState.isMandatory = sourceFieldState.isMandatory;
				clonedFieldState.isHidden = sourceFieldState.isHidden;
				clonedFieldState.isDisabled = sourceFieldState.isDisabled;
				clonedFieldState.isVisible = sourceFieldState.isVisible;
				clonedFieldState.isDisplay = sourceFieldState.isDisplay;
				clonedFieldState.isReadOnly = sourceFieldState.isReadOnly;
				clonedFieldState.ignoreSlaving = sourceFieldState.ignoreSlaving;
				clonedFieldState.isChanged = sourceFieldState.isChanged;
				clonedFieldState.label = sourceFieldState.label;
				clonedFieldState.id = sourceFieldState.id;

				return clonedFieldState;
			}

			function overwriteFieldsState(clonedRecordStateController, sourceRecordStateController)
			{
				sourceRecordStateController.getAllFields().forEach(function (fieldId, i, a)
				{
					overwriteFieldState(clonedRecordStateController.getFieldState(fieldId), sourceRecordStateController.getFieldState(fieldId));
				});

				return clonedRecordStateController;
			}

			function overwriteRecordState(clonedRecordStateController, sourceRecordStateController)
			{
				overwriteFieldsState(clonedRecordStateController, sourceRecordStateController);
				overwriteSublistsState(clonedRecordStateController, sourceRecordStateController);

				return clonedRecordStateController;
			}

			function clone(options)
			{
				options = options || {};
				options.cloneable = options.cloneable !== undefined ? !!options.cloneable : true;
				options.mergeable = options.mergeable !== undefined ? !!options.mergeable : false;

				var clonedModelController = getModelController().clone(),
					clonedMetadata = getMetadata().clone(),
					clonedState = overwriteRecordState(recordStateController.create({
						metadata: clonedMetadata,
						data: clonedModelController,
						// TODO this may not be sufficient
						getModelController: function ()
						{
							return clonedModelController;
						}
					}), getRecordStateController());

				var R = {
					id: that.id,
					data: clonedModelController,
					metadata: clonedMetadata,
					state: clonedState,
					isDynamic: true,
					isSubrecord: true,
					isUserEvent: false,
					recordContext: util.extend({}, _recordRequestContext)
				};
				var recordClone = new Record({
					recordObj: R,
					cloneable: options.cloneable,
					merge: (options.mergeable ? function ()
					{
						return merge(recordClone);
					} : undef)
				});

				if (getIsSubrecord())
				{
					recordClone.link(subrecordParent, subrecordSublistId, subrecordFieldId);
				}
				freshCopies.add(recordClone);

				return recordClone;
			}

			function merge(copy)
			{
				if (!freshCopies.contains(copy))
				{
					utilityFunctions.throwSuiteScriptError(error.Type.INVALID_SUBRECORD_MERGE);
				}
				else
				{
					var sysId = getValue(subrecordUtil.SYS_ID);
					var sysParentId = getValue(subrecordUtil.SYS_PARENT_ID);

					copy.validate();

					var clonedMetadata = copy.getMetadata().clone();
					setMetadata(clonedMetadata);

					var clonedModelController = copy.getModelController().clone();
					setModelController(clonedModelController);

					var newRecordState = overwriteRecordState(
						recordStateController.create({
							metadata: clonedMetadata,
							data: clonedModelController,
							getModelController: getModelController
						}),
						copy.getRecordStateController());

					setRecordStateController(newRecordState);

					// TODO figure out why these are getting lost so they dont need to be reset
					copy.setValue(subrecordUtil.SYS_ID, sysId);
					copy.setValue(subrecordUtil.SYS_PARENT_ID, sysParentId);
					that.setValue(subrecordUtil.SYS_ID, sysId);
					that.setValue(subrecordUtil.SYS_PARENT_ID, sysParentId);

					freshCopies.add(copy);
				}
			}

			/* synchronization */
			/**
			 * synchronize the line removal;
			 * @param {Record} record
			 * @return {Record} same record, for chaining
			 */
			function synchronization_removelines(dynamicRecord)
			{
				var sublists = getModelController().getSublists();
				for (var i = 0; i < sublists.length; i++)
				{
					var sublistId = sublists[i];
					var sublistState = getSublistState(sublistId);
					if (!sublistState && shouldValidateFieldPermissions())
					{
						utilityFunctions.throwSuiteScriptError(error.Type.WS_NO_PERMISSIONS_TO_SET_VALUE, sublistId);
					}
					if (!sublistState || !sublistState.isChanged)
					{
						continue;
					}

					for (var lineNum = dynamicRecord.doGetLineCount(sublistId) - 1; lineNum >= 0; lineNum--)
					{

						if (dynamicRecord.getSublistState(sublistId) && dynamicRecord.getSublistState(sublistId)
								.isLineInserted(lineNum))
						{
							continue;
						}
						if (sublistState.isLineRemoved(lineNum))
						{
							dynamicRecord.doSelectLine(sublistId, lineNum);
							dynamicRecord.doRemoveLine(sublistId, dynamicRecord.doGetCurrentSublistIndex(sublistId));
						}
					}
				}

				return dynamicRecord;
			}

			function synchronize(deferredDynamicRecordState, record)
			{
				deferredDynamicRecordState = deferredDynamicRecordState || _state;

				var fieldId,
					fieldLevelMetadata,
					fieldState,
					fieldChanged,
					isSubrecordField,
					deferredSubrecord,
					subrecord,
					sysIdsUpdated;

				if (!record) // synchronize self
				{
					var newRecordObj = util.extend({}, recordObj);
					newRecordObj.isDynamic = true;
					record = new Record({'recordObj': newRecordObj});
				}

				//1a body field changes
				var sorted_bodyFields = _metadata.sortedFields;
				for (var i = 0; i < sorted_bodyFields.length; i++)
				{
					fieldId = sorted_bodyFields[i];
					fieldLevelMetadata = _metadata.getFieldMetadata(null, fieldId);
					isSubrecordField = !!fieldLevelMetadata && fieldLevelMetadata.type === 'summary';
					fieldState = deferredDynamicRecordState.getFieldState(fieldId);
					fieldChanged = !!fieldState && fieldState.isChanged;

					if (isSubrecordField)
					{
						if (!sysIdsUpdated)
						{
							record.setValue(subrecordUtil.SYS_ID, getValue(subrecordUtil.SYS_ID));
							record.setValue(subrecordUtil.SYS_PARENT_ID, getValue(subrecordUtil.SYS_PARENT_ID));
							sysIdsUpdated = true;
						}

						deferredSubrecord = getModelController().getSubrecord(fieldId);

						if (fieldChanged)
						{
							record.doRemoveSubrecord(fieldId);
						}
						if (!!deferredSubrecord)
						{
							subrecord = record.doGetBodySubrecord(fieldId);
							subrecord = deferredSubrecord.synchronize(deferredSubrecord.getRecordStateController(), subrecord);
							subrecord.validate();
						}
					}
					else
					{
						if (fieldChanged)
						{
							if (fieldState.useTextApi)
							{
								record.setText(fieldId, getText(fieldId));
							}
							else
							{
								record.setValue(fieldId, getValue(fieldId));
							}
						}
					}
				}
				//1b non standard field changes
				var fields = deferredDynamicRecordState.getAllFields();
				for (var j = 0; j < fields.length; j++)
				{
					fieldId = fields[j];
					fieldLevelMetadata = _metadata.getFieldMetadata(undef, fieldId);
					fieldState = deferredDynamicRecordState.getFieldState(fieldId);
					fieldChanged = !!fieldState && fieldState.isChanged;

					if (fieldLevelMetadata == null && fieldChanged)
					{
						if (fieldState.useTextApi)
						{
							record.setText(fieldId, getText(fieldId));
						}
						else
						{
							record.setValue(fieldId, getValue(fieldId));
						}
					}
				}

				//2 Remove any pre-existing sublist lines changed by the script/program/client
				record = synchronization_removelines(record);
				//3 Apply sublists` changes in the order they naturally occur in the record. Apply sublist field changes based on
				// dependency graph and logical order
				var sublists = _metadata.sortedSublists;
				for (var k = 0; k < sublists.length; k++)
				{
					var sublistId = sublists[k];
					var sublistState = getSublistState(sublistId);
					var sublistMetadata = getSublistMetadata(sublistId);

					if (!sublistState || !sublistState.isChanged || !sublistMetadata)
					{
						continue;
					}

					if (sublistMetadata)
					{
						for (var deferredDynamicRecordLineNum = 0, dynamicRecordLineNum = 0;
							deferredDynamicRecordLineNum < doGetLineCount(sublistId);
							deferredDynamicRecordLineNum++, dynamicRecordLineNum++)
						{
							var dynamicRecordLineCount = record.doGetLineCount(sublistId);
							var lineObj = null;
							if (sublistState.isLineInserted(deferredDynamicRecordLineNum))
							{
								if (record.doGetLineCount(sublistId) < dynamicRecordLineNum)
								{
									lineObj = record.doSelectNewLine(sublistId);
								}
								else
								{
									lineObj = record.doInsertLine(sublistId, dynamicRecordLineNum, sublistMetadata.isTotallingSublist);
								}
							}
							else if (sublistState.isLineChanged(deferredDynamicRecordLineNum))
							{
								lineObj = record.doSelectLine(sublistId, dynamicRecordLineNum);
							}
							else
							{
								continue;
							}

							//TODO: update subrecord "thereWereRecordsToUpdate"
							var sys_id = doGetSublistValue(sublistId, subrecordUtil.SYS_ID, deferredDynamicRecordLineNum);
							if (!utilityFunctions.isValEmpty(sys_id))
							{
								record.doSetCurrentSublistFieldValue(sublistId, subrecordUtil.SYS_ID, sys_id, false);
							}
							// 3a : set any changed/submitted fields on the line
							var sortedFields = sublistMetadata.sortedFields;
							for (var l = 0; l < sortedFields.length; l++)
							{
								fieldId = sortedFields[l];
								fieldLevelMetadata = _metadata.getFieldMetadata(sublistId, fieldId);
								isSubrecordField = !!fieldLevelMetadata && fieldLevelMetadata.type === 'summary';
								fieldState = sublistState.getFieldState(fieldId, deferredDynamicRecordLineNum);
								fieldChanged = !!fieldState && fieldState.isChanged;
								if (isSubrecordField)
								{
									if (!sysIdsUpdated)
									{
										record.doSetCurrentSublistFieldValue(sublistId, subrecordUtil.SYS_ID, doGetSublistValue(sublistId, subrecordUtil.SYS_ID, deferredDynamicRecordLineNum), false);
										record.doSetCurrentSublistFieldValue(sublistId, subrecordUtil.SYS_PARENT_ID, doGetSublistValue(sublistId, subrecordUtil.SYS_PARENT_ID, deferredDynamicRecordLineNum), false);
										sysIdsUpdated = true;
									}

									deferredSubrecord = getModelController()
										.getSublistSubrecord(sublistId, fieldId, deferredDynamicRecordLineNum);

									if (fieldChanged)
									{
										record.removeCurrentSublistSubrecord(sublistId, fieldId);
									}
									if (!!deferredSubrecord)
									{
										subrecord = record.doGetCurrentSublistSubrecord(sublistId, fieldId);
										subrecord = deferredSubrecord.synchronize(deferredSubrecord.getRecordStateController(), subrecord);
										subrecord.validate();
									}
								}
								else
								{
									if (fieldChanged)
									{
										if (fieldState.useTextApi)
										{
											record.doSetCurrentSublistText(sublistId, fieldId, getSublistText(sublistId, fieldId, deferredDynamicRecordLineNum));
										}
										else
										{
											record.doSetCurrentSublistValue(sublistId, fieldId, getSublistValue(sublistId, fieldId, deferredDynamicRecordLineNum));
										}
									}
								}
							}

							var backwardCompatibilityFieldNames = sublistMetadata.backwardCompatibilityFieldNamesForSubrecord;
							var sublistFields = sublistState.getAllFields();
							for (var m = 0; m < sublistFields.length; m++)
							{
								var sublistFieldName = sublistFields[m];
								if (backwardCompatibilityFieldNames.indexOf(sublistFieldName) == -1 &&
									sublistMetadata.getFieldMetadata(sublistFieldName) == null &&
									sublistState.getFieldState(sublistFieldName, deferredDynamicRecordLineNum).isChanged)
								{
									if (sublistState.getFieldState(fieldId, deferredDynamicRecordLineNum).useTextApi)
									{
										record.doSetCurrentSublistText(sublistId, fieldId, getSublistText(sublistId, sublistFieldName, deferredDynamicRecordLineNum), false);
									}
									else
									{
										record.doSetCurrentSublistValue(sublistId, sublistFieldName, getSublistValue(sublistId, sublistFieldName, deferredDynamicRecordLineNum), false);
									}
								}
							}

							record.doCommitLine(sublistId, sublistMetadata.isTotallingSublist);
							var linesAddedInThisIteration = record.doGetLineCount(sublistId) - dynamicRecordLineCount;

							// In some cases when a line is committed, more that one line is added to the
							// machine.  For example, when an item group is set on a line, its members
							// are expanded.
							// We need to account for this by incrementing the dynamic record line number by the
							// number of lines beyond one.
							if (linesAddedInThisIteration > 1)
							{
								dynamicRecordLineNum = dynamicRecordLineNum + linesAddedInThisIteration - 1;
							}
						}

						if (sublistMetadata.isTotallingSublist)
						{
							record.triggerRecalcScript(sublistId, false, 'batchcommit');
						}
					}
				}

				return record;
			}

			this.synchronize = synchronize;

			function getQuery()
			{
				return slaving.cleanupQueryURL(_metadata.queryUrl);
			}

			function save(options, returnFetchedObject)
			{
				options = options || {};
				if (returnFetchedObject)
				{
					options.returnLabel = true;
					options.returnMessage = true;
				}
				else
					delete options.isFormSave; // allow this only in saveAndFetch (which is only available in interactive mode)

				/* It's not allowed to save the current record from within a client script. */
				if (getIsCurrentRecord() && scope.isExecutionWithinAClientScript())
				{
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_UNSUPPORTED_METHOD);
				}

				var argList = doSave(options);
				var result = invoker(remoteApi, 'submitDynamicClientRecord', argList);
				try
				{
					return returnFetchedObject ? saveResult.create(options, result) : parseInt(result.recordData.id, 10);
				}
				finally
				{
					dereferencedBodySubrecords();
				}
			}

			/**
			 * save record updates to the system
			 * @governance 20 units for transactions, 4 for custom records, 10 for all other records
			 *
			 * @param {Object} options
			 * @param {boolean} [options.enableSourcing=false] enable sourcing during record update
			 * @param {boolean} [options.ignoreMandatoryFields=false] ignore mandatory field during record submission
			 * @return {number} id of submitted record
			 */
			this.save = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: function(options) { return save(options, false); },
				emitter: emitter
			});

			/**
			 * Save record updates to the system and return object with additional information about the saved record.
			 * @governance 20 units for transactions, 4 for custom records, 10 for all other records
			 *
			 * @param {Object} options
			 * @param {boolean} [options.enableSourcing=false] enable sourcing during record update
			 * @param {boolean} [options.ignoreMandatoryFields=false] ignore mandatory field during record submission
			 * @return {Object} contains id of submitted record
			 */
			this.saveAndFetch = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: function(options) { return save(options, true); },
				emitter: emitter
			});

			function promiseToSave(options, returnFetchedObject)
			{
				options = options || {};
				if (returnFetchedObject)
				{
					options.returnLabel = true;
					options.returnMessage = true;
				}
				else
					delete options.isFormSave; // allow this only in saveAndFetch (which is only available in interactive mode)

				var myPromise = new Promise(function (resolve, reject)
				{
					function callback(result)
					{
						if (result instanceof Error)
						{
							reject(result);
							return;
						}
						dereferencedBodySubrecords();
						resolve(returnFetchedObject ? saveResult.create(options, result) : parseInt(result.recordData.id, 10));
					}

					try
					{
						var argList = doSave(options);
						invoker(remoteApi, 'submitDynamicClientRecord', argList, callback);
					}
					catch (e)
					{
						reject(e);
					}
				});
				return myPromise;
			}

			/**
			 * save record updates to the system
			 * @governance 20 units for transactions, 4 for custom records, 10 for all other records
			 *
			 * @param {Object} options
			 * @param {boolean} [options.enableSourcing=false] enable sourcing during record update
			 * @param {boolean} [options.ignoreMandatoryFields=false] ignore mandatory field during record submission
			 * @return {Promise} id of submitted record
			 */
			this.save.promise = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: function(options) { return promiseToSave(options, false); },
				emitter: emitter
			});

			/**
			 * Save record updates to the system and return object with additional information about the saved record.
			 * @governance 20 units for transactions, 4 for custom records, 10 for all other records
			 *
			 * @param {Object} options
			 * @param {boolean} [options.enableSourcing=false] enable sourcing during record update
			 * @param {boolean} [options.ignoreMandatoryFields=false] ignore mandatory field during record submission
			 * @return {Promise} Object containing id of submitted record
			 */
			this.saveAndFetch.promise = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: function(options) { return promiseToSave(options, true); },
				emitter: emitter
			});

			function doSave(options)
			{
				options = options || {};
				var submitOptions = {
					enablesourcing: options['enableSourcing'] === true,
					disabletriggers: options['disableTriggers'] === true,
					ignoremandatoryfields: options['ignoreMandatoryFields'] === true,
					returnlabel: options['returnLabel'] === true,
					returnmessage: options['returnMessage'] !== false,
					failOnAfterSubmitScriptError: options['returnMessage'] === false
				};
				if (options.hasOwnProperty('isFormSave'))
					submitOptions.isFormSave = options.isFormSave === true;

				handleRecordSpecificSaveOptions(getRecordType(), options, submitOptions);

				var dynamicRecordToBeSubmitted = getIsDynamicRecord() ? that : synchronize(_state);

				dynamicRecordToBeSubmitted.commitSubrecords();
				dynamicRecordToBeSubmitted.triggerSaveRecordScript(submitOptions.ignoremandatoryfields);
				var data = dynamicRecordToBeSubmitted.getRecordData();
				return [getRecordType(), data.fields, data.sublists, submitOptions];
			}

			function handleRecordSpecificSaveOptions(recType, options, submitOptions)
			{
				var possibleSaveOptions = RECORD_SPECIFIC_SAVE_OPTIONS[recType];
				if (utilityFunctions.isObject(options) && util.isArray(possibleSaveOptions))
				{
					for (var i = 0; i < possibleSaveOptions.length; i++)
					{
						var thisPossibleOption = possibleSaveOptions[i];
						if (options.hasOwnProperty(thisPossibleOption))
						{
							submitOptions[thisPossibleOption] = options[thisPossibleOption];
						}
					}
				}
			}

			function commitSubrecords()
			{
				var bodyFields = getModelController().getBodyFieldIds();
				bodyFields.forEach(function (fieldId)
				{
					var fieldType = getFieldType(undef, fieldId);
					if (recordUtil.FIELD_TYPE.SUBRECORD_FIELD_TYPE === fieldType && getModelController().hasSubrecord(fieldId))
					{
						var subrecord = getModelController().getSubrecord(fieldId);
						if (!!subrecord)
						{
							subrecord.validate();
						}
					}
				});
			}

			this.commitSubrecords = commitSubrecords;

			function dereferencedBodySubrecords()
			{
				var bodyFields = getModelController().getBodyFieldIds();
				bodyFields.forEach(function (fieldId)
				{
					var fieldType = getFieldType(undef, fieldId);
					if (recordUtil.FIELD_TYPE.SUBRECORD_FIELD_TYPE === fieldType && getModelController().hasSubrecord(fieldId))
					{
						var subrecord = getModelController().getSubrecord(fieldId);
						if (!!subrecord)
						{
							subrecord.setDereferencedFromParent(true);
						}
					}
				});
			}

			function dereferencedSublistLineSubrecords(sublistId, lineInstanceId, useBuffer)
			{
				var sublistLineFieldIds = getModelController().getSublistLineFieldIds(sublistId, lineInstanceId, useBuffer);
				sublistLineFieldIds.forEach(function (fieldId)
				{
					var fieldType = getFieldType(sublistId, fieldId);
					if (recordUtil.FIELD_TYPE.SUBRECORD_FIELD_TYPE === fieldType && getModelController()
							.hasSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer))
					{
						var subrecord = getModelController()
							.doGetSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
						if (!!subrecord)
						{
							subrecord.setDereferencedFromParent(true);
						}
					}
				});
			}

			function getRecordData()
			{
				var CREATE = 'CREATE', EDIT = 'EDIT', VIEW = 'VIEW';

				var wasInternal = isInternal();
				setInternalEvent(true);
				var body = {},
					sublists = {},
					mainFieldNames = getFields(),
					sublistNames = _metadata.sublistIds;

				mainFieldNames.forEach(function (fieldId)
				{
					var value = getValueAsLegacyString(fieldId);
					if (value !== undef)
					{
						body[fieldId] = recordUtil.emptyIfNullOrUndefined(value);
					}
				});

				var subrecordData = getModelController().getSubrecordDataForSubmission();
				if (subrecordData)
				{
					Object.keys(subrecordData).forEach(function (v, i, a)
					{
						sublists[v] = subrecordData[v];
						body['next' + v + 'idx'] = String(subrecordData[v].size + 1);
					});
				}

				sublistNames.forEach(function (sublistId)
				{
					var sublistData = {};
					sublistData.fields = _metadata.getAllSublistFields(sublistId);
					if (sublistData.fields.length > 0) // skip sublist without field information
					{
						if (subrecordData)
						{
							sublistData.fields.splice(0, 0, subrecordUtil.SYS_PARENT_ID, subrecordUtil.SYS_ID, subrecordUtil.SYS_OP);
						}
						sublistData.size = doGetLineCount(sublistId);
						sublistData.data = doGetLineCount(sublistId) > 0 ? [] : null;
						for (var ln = 0; ln < doGetLineCount(sublistId); ln++)
						{
							var sublistLine = sublistData.fields.map(function (fieldId)
							{
								if (fieldId === subrecordUtil.SYS_OP)
								{
									var operation = EDIT;
									if (!getSublistState(sublistId).isLineChanged(ln))
									{
										operation = VIEW;
									}
									if (getSublistState(sublistId).isLineInserted(ln))
									{
										operation = CREATE;
									}
									return operation;
								}
								return recordUtil.emptyIfNullOrUndefined(getSublistLineValueAsLegacyString(sublistId, fieldId, ln));
							});

							sublistData.data[ln] = sublistLine;
						}

						sublists[sublistId] = sublistData;
					}
				});
				setInternalEvent(wasInternal);
				return {fields: body, sublists: sublists};
			}

			this.getRecordData = getRecordData;

			function handleChangeCall(params)
			{
				if (getIsDynamicRecord())
				{
					var sysId = doGetValue(subrecordUtil.SYS_ID),
						sysParentId = doGetValue(subrecordUtil.SYS_PARENT_ID);
					var context = getRecordRequestContext();
					var params = utilityFunctions.addParameterToMap(context, params);
					params.recordmode = 'dynamic';

					//noinspection JSUnresolvedVariable
					var nsrecord = invoker(remoteApi, 'handleChangeCall', [getRecordType(), getId(), params, true /*isClientRecord*/]);

					// reset Record Metadata and Data
					_recordRequestContext = nsrecord.recordContext;
					_recordScriptingV1Scope = scope.create({
						record: that,
						libraryScript: getMetadata().libraryScript,
						staticScript: getMetadata().staticScript,
						uiFormScript: getMetadata().uiFormScript
					});

					setMetadata(metadata.create(nsrecord.metadata));
					setModelController(modelController.create({
						type: _metadata.type,
						data: nsrecord.data
					}));
					setRecordStateController(recordStateController.create({
						metadata: _metadata,
						data: getModelController(),
						getModelController: getModelController
					}));

					doSetFieldValue(subrecordUtil.SYS_ID, sysId, true, false);
					doSetFieldValue(subrecordUtil.SYS_PARENT_ID, sysParentId, true, false);


					implementation.initRecord(that, _recordScriptingV1Scope);
					recordDefinitionEvent.emitUpdateAll(emitter, that);
				}
			}

			this.handleChangeCall = handleChangeCall;

			function callRestrictedMethod(options)
			{
				options = options || {};
				utilityFunctions.checkArgs([options.token, options.methodName], ['token', 'methodName'], getMissingArgumentErrorMessageFillerValue('hasSublistSubrecord'));

				if (options.token != null && options.token === recordObj.token)
				{
					this[options.methodName].apply(this, options.args || []);
				}
			}

			this.callRestrictedMethod = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: callRestrictedMethod,
				emitter: emitter
			});

			this.runLegacyScript = function runLegacyScript(script)
			{
				return _recordScriptingV1Scope.runLegacyScript(script);
			};

			/* Subrecord APIs */
			function subrecord_link(parent, sublistId, fieldId)
			{
				subrecordParent = parent;
				subrecordSublistId = sublistId;
				subrecordFieldId = fieldId;
			}

			function subrecord_linkParentState(parentSublistState, parentFieldState)
			{
				subrecordSublistState = parentSublistState;
				subrecordFieldState = parentFieldState;
			}

			function subrecord_updateFieldState(isChanged)
			{
				if (subrecordSublistState != null)
				{
					subrecordSublistState.isChanged = isChanged;
				}
				if (subrecordFieldState != null)
				{
					subrecordFieldState.isChanged = isChanged;
				}
			}

			function getSubrecordSublistState()
			{
				return subrecordSublistState;
			}

			this.getSubrecordSublistState = getSubrecordSublistState;

			function getSubrecordFieldState()
			{
				return subrecordFieldState;
			}

			this.getSubrecordFieldState = getSubrecordFieldState;

			//TODO move to subrecord wrapper
			function subrecord_abandon()
			{
				subrecordParent = null;
				subrecordDead = true;
				invalidateSubrecordClones();
				doSetFieldValue(subrecordUtil.SYS_PARENT_ID, null, false, true);
			}

			//TODO move to subrecord wrapper
			function subrecord_isValidated()
			{
				return !!subrecordValidated;
			}

			//TODO move to subrecord wrapper
			function subrecord_setDereferencedFromParent(dereferencedFromParent)
			{
				subrecordIsDereferencedFromParent = dereferencedFromParent;
				if (dereferencedFromParent)
				{
					subrecord_abandon();
				}
			}

			//TODO move to subrecord wrapper
			function subrecord_isDereferencedFromParent()
			{
				return subrecordIsDereferencedFromParent;
			}

			function subrecord_validate()
			{
				if (!subrecordValidated)
				{
					triggerSaveRecordScript(false);
					subrecord_triggerPostValidationEventOnParent();

					subrecordValidated = true;
				}
			}

			function subrecord_triggerPostValidationEventOnParent()
			{
				var line = -1;
				var value = null;

				if (!subrecordSublistId)
				{
					value = subrecordParent.getValue(subrecordFieldId);
				}
				else
				{
					line = subrecordParent.getCurrentSublistIndex(subrecordSublistId);
					value = subrecordParent.getCurrentSublistValue(subrecordSublistId, subrecordFieldId);
				}

				if (_recordScriptingV1Scope)
				{
					_recordScriptingV1Scope.invalidateSubrecordCache(subrecordSublistId, subrecordFieldId, line);
				}

				subrecordParent.triggerFieldChangeEvent(subrecordSublistId, subrecordFieldId, line, String(value), false);
			}

			function subrecord_setReadonly(value)
			{
				subrecordReadOnly = getIsSubrecord() && !!value;
			}

			this.setReadonly = subrecord_setReadonly;

			function getSubrecordRedirect(sublistId, fieldId)
			{
				var subrecordFieldIds = !!sublistId ? subrecordCompatibility[sublistId] || [] : subrecordCompatibility.body;
				subrecordFieldIds = subrecordFieldIds.reduce(function (p, c, i, a)
				{
					var subrecordFieldId = c;
					var subrecordCompatibilityMap = _metadata.getFieldMetadata(sublistId, subrecordFieldId).subrecordCompatibilityMap;

					if (!!subrecordCompatibilityMap && subrecordCompatibilityMap.hasOwnProperty(fieldId))
					{
						p.push({
							subrecordFieldId: subrecordFieldId,
							fieldId: subrecordCompatibilityMap[fieldId]
						});
					}

					return p;
				}, []);

				return subrecordFieldIds[0] || null;
			}

			this.getSubrecordRedirect = getSubrecordRedirect;

			function hasSubrecordRedirect(sublistId, fieldId)
			{
				return !!getSubrecordRedirect(sublistId, fieldId);
			}

			function doGetSubrecordInitialParamsInfo(sublistId, fieldId)
			{
				var fieldMetadata = _metadata.getFieldMetadata(sublistId, fieldId),
					initialParams = fieldMetadata.subrecordInitialParameters || [];

				return initialParams;
			}

			function getSystemId()
			{
				return getModelController().getSystemId();
			}

			function getSublistSystemId(sublistId, line)
			{
				return getModelController().getSublistSystemId(sublistId, line);
			}

			function getCurrentSublistSystemId(sublistId)
			{
				return getModelController().getCurrentSublistSystemId(sublistId);
			}

			function doGetSubrecordInitialParamsForInstance(field, lineInstanceId, useBuffer)
			{
				var result = {},
					sublistId = field.getSublistName(),
					fieldId = field.getName(),
					initialParams = doGetSubrecordInitialParamsInfo(sublistId, fieldId);

				initialParams.forEach(function (v, i, a)
				{
					var param = v.param,
						path = v.path.split('.'),
						mandatory = v.mandatory,
						value = path.length === 1 && path[0] || null;

					if (path.length > 1)
					{
						if (!!sublistId)
						{
							if (path.length === 2)
							{
								value = getModelController()
									.getSublistLineValueAsLegacyStringForInstance(sublistId, path[1], lineInstanceId, useBuffer);
							}
							else
							{
								value = doGetValue(path[2]);
							}
						}
						else
						{
							value = doGetValue(path[1]);
						}
					}

					if (mandatory || value !== undef && value !== null && value !== '')
					{
						result[param] = value;
					}
				});

				if (getIsDynamicRecord())
				{
					result.recordmode = 'dynamic';
				}

				return result;
			}

			function doGetSubrecordFromServerForInstance(field, id, lineInstanceId, useBuffer)
			{
				var result, sublistId, fieldId, type, nsrecord, initializedParams;

				if (field === null || field.getType() !== 'summary')
				{
					utilityFunctions.throwSuiteScriptError(error.Type.FIELD_1_IS_NOT_A_SUBRECORD_FIELD, field.getName());
				}
				else
				{
					sublistId = field.getSublistName();
					fieldId = field.getName();
					type = field.getSubrecordType();
					initializedParams = doGetSubrecordInitialParamsForInstance(field, lineInstanceId, useBuffer);
					var parentSystemId = getModelController().getParentSystemIdForInstance(sublistId, lineInstanceId, useBuffer);

					if (!!id)
					{
						nsrecord = invoker(apiBridge, 'loadRecord', [type, String(id), initializedParams]);
						nsrecord.isReadOnly = getIsReadOnlyRecord();
						nsrecord.isCurrentRecord = getIsCurrentRecord();
						nsrecord.data.initialization = {
							method: 'loadRecord',
							params: {
								type: type,
								id: String(id),
								defaults: initializedParams
							}
						};
						nsrecord.data.bodyField.sys_parentid = [parentSystemId];


						result = new Record({
							recordObj: nsrecord
						});
					}
					else
					{
						triggerCanCreateSubrecordScriptForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
						nsrecord = invoker(apiBridge, 'createRecord', [type, initializedParams]);
						nsrecord.isReadOnly = getIsReadOnlyRecord();
						nsrecord.isCurrentRecord = getIsCurrentRecord();
						nsrecord.data.initialization = {
							method: 'createRecord',
							params: {
								type: type,
								defaults: initializedParams
							}
						};
						nsrecord.data.bodyField.sys_parentid = [parentSystemId];

						result = new Record({
							recordObj: nsrecord
						});
					}

					result.link(that, sublistId, fieldId);
					var sublistFieldState = getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
					result.linkParentState(getSublistState(sublistId), sublistFieldState);
				}

				return result;
			}

			function hasSubrecord(options)
			{
				var useBuffer = false;
				var fieldId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'fieldId', getMissingArgumentErrorMessageFillerValue('hasSubrecord'));
				return doHasSubrecord(undef, fieldId, -1, useBuffer);
			}

			/**
			 * return a value indicating if the field has a subrecord
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @return {boolean}
			 */
			this.hasSubrecord = hasSubrecord;

			function getSubrecord(options)
			{
				var fieldId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'fieldId', getMissingArgumentErrorMessageFillerValue('getSubrecord'));
				var subrecord = doGetBodySubrecord(fieldId);
				return subrecord;
			}

			/**
			 * get the subrecord for the associated field
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @return {Record} [client-side subrecord implementation]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 * @throws {SuiteScriptError} FIELD_1_IS_NOT_A_SUBRECORD_FIELD if field is not a subrecord field
			 * @throws {SuiteScriptError} FIELD_1_IS_DISABLED_YOU_CANNOT_APPLY_SUBRECORD_OPERATION_ON_THIS_FIELD if field is disable
			 */
			this.getSubrecord = getSubrecord;

			function removeSubrecord(options)
			{
				var fieldId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'fieldId', getMissingArgumentErrorMessageFillerValue('removeSubrecord'));

				if (!hasFieldValueOrFieldExisted(fieldId))
				{
					utilityFunctions.throwSuiteScriptError(error.Type.FIELD_1_IS_NOT_A_SUBRECORD_FIELD, fieldId);
				}

				doRemoveSubrecord(fieldId);
			}

			/**
			 * remove the subrecord for the associated field
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @return {Record} same record, for chaining
			 */
			this.removeSubrecord = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: removeSubrecord,
				emitter: emitter
			});

			function performSubrecordRemoval(fieldId)
			{
				var useBuffer = false;
				var sublistId = undef;
				var lineInstanceId = null;
				doRemoveSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
				getModelController().removeFieldValue(fieldId);
			}

			this.performSubrecordRemoval = performSubrecordRemoval;

			function doRemoveSubrecord(fieldId)
			{
				var sublistId = undef;
				performSubrecordRemoval(fieldId);
				var subrecordKeyFieldId = getSubrecordKeyFieldId(sublistId, fieldId);
				if (!!subrecordKeyFieldId)
				{
					var keyFieldId = subrecordKeyFieldId[0];
					var value = '';
					var fireFieldChanged = true;
					var noSlaving = false;
					doSetFieldValue(keyFieldId, value, fireFieldChanged, noSlaving);
				}
			}

			this.doRemoveSubrecord = doRemoveSubrecord;

			function doRemoveSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer)
			{
				var field = getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
				subrecordUtil.validateIfSummaryField(field, fieldId);

				var subrecord = getModelController().doGetSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
				if (!!subrecord)
				{
					subrecord.setDereferencedFromParent(true);
					subrecord.abandon();
				}
				getModelController().clearSubrecordCacheForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
				invalidateSubrecordClones();
			}

			function doRemoveSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer)
			{
				var field = getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
				subrecordUtil.validateIfSummaryField(field, fieldId);

				var subrecord = getModelController().doGetSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
				getModelController().clearSubrecordCacheForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
				if (!!subrecord)
				{
					subrecord.setDereferencedFromParent(true);
					subrecord.abandon();
				}
				postRemoveSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
			}

			this.doRemoveSublistSubrecordForInstance = doRemoveSublistSubrecordForInstance;

			function postRemoveSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer)
			{
				var value = null;
				if (useBuffer)
				{
					var fireFieldChanged = true;
					doSetCurrentSublistValue(sublistId, fieldId, value, fireFieldChanged);
					var subrecordKeyFieldId = getSubrecordKeyFieldId(sublistId, fieldId);
					if (!!subrecordKeyFieldId)
					{
						setCurrentSublistValue(sublistId, subrecordKeyFieldId[0], '');
					}
				}
				else
				{
					invalidateSubrecordClones();
					getModelController().setSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, value, useBuffer);
				}
			}

			function getSubrecordKeyFieldId(sublistId, fieldId)
			{
				var subrecordKeyFieldId = doGetSubrecordInitialParamsInfo(sublistId, fieldId).reduce(function (p, c, i, a)
				{
					return p || (c.param === 'id' && c.path) || null;
				}, null);

				return SUBRECORD_KEY_FIELDID_REGEX.test(subrecordKeyFieldId) && subrecordKeyFieldId.split('.').slice(-1) || null;
			}

			function hasSublistSubrecord(options, fieldId, line)
			{
				var useBuffer = false;
				var sublistId;
				if (fieldId !== undef && line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					line = options.line;
				}
				utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], getMissingArgumentErrorMessageFillerValue('hasSublistSubrecord'));
				return doHasSubrecord(sublistId, fieldId, line, useBuffer);
			}

			/**
			 * return a value indicating if the associated sublist field has a subrecord
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @restriction only available in deferred dynamic record
			 * @return {boolean}
			 */
			this.hasSublistSubrecord = hasSublistSubrecord;

			function doHasSubrecord(sublistId, fieldId, line, useBuffer)
			{
				var lineInstanceId = getLineInstanceId(sublistId, line, useBuffer);
				return doHasSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
			}

			function doHasSubrecordForInstance(sublistId, fieldId, lineInstanceId, usesBuffer)
			{
				var field = getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, usesBuffer);
				subrecordUtil.validateIfSummaryField(field, fieldId);
				return getModelController().hasSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, usesBuffer);
			}

			this.doHasSubrecordForInstance = doHasSubrecordForInstance;

			function getSublistSubrecord(options, fieldId, line)
			{
				var sublistId, field, id;

				if (fieldId !== undef && line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					line = options.line;
				}
				utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], getMissingArgumentErrorMessageFillerValue('getSublistSubrecord'));
				var subrecord = doGetSublistSubrecord(sublistId, fieldId, line);
				return subrecord;
			}

			/**
			 * get the subrecord for the associated sublist field
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @restriction only available in deferred dynamic record
			 * @return {Record} [client-side subrecord implementation]
			 */
			this.getSublistSubrecord = getSublistSubrecord;

			function doGetSublistSubrecord(sublistId, fieldId, line)
			{
				var useBuffer = false;
				var lineInstanceId = getLineInstanceId(sublistId, line, useBuffer);
				return doGetSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
			}

			this.doGetSublistSubrecord = doGetSublistSubrecord;

			function doGetBodySubrecord(fieldId)
			{
				var subrecord, field, id;
				var sublistId = undef;
				var lineInstanceId = null;
				var useBuffer = false;

				field = getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
				subrecordUtil.validateIfSummaryField(field, fieldId);

				subrecord = _modelController.getSubrecord(fieldId);
				if (!subrecord)
				{
					id = _modelController.getFieldValue(fieldId);
					subrecord = doGetSubrecordFromServerForInstance(field, id, lineInstanceId, useBuffer);
					getModelController().cacheSubrecord(fieldId, subrecord);
					invalidateSubrecordClones();
				}
				return subrecord;
			}

			this.doGetBodySubrecord = doGetBodySubrecord;


			function tryToGetSublistSubrecord(sublistId, fieldId, lineInstanceId, useBuffer)
			{
				var subrecord = getModelController().doGetSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
				if (!subrecord && useBuffer)
				{
					subrecord = getModelController().doGetSubrecordForInstance(sublistId, fieldId, lineInstanceId, !useBuffer);
				}
				return subrecord;
			}

			function doGetSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer)
			{
				var field = getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
				subrecordUtil.validateIfSummaryField(field, fieldId);

				var subrecord = tryToGetSublistSubrecord(sublistId, fieldId, lineInstanceId, useBuffer);
				if (!subrecord)
				{
					var id = getModelController().getSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
					subrecord = doGetSubrecordFromServerForInstance(field, id, lineInstanceId, useBuffer);
					getModelController()
						.cacheSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer, subrecord);
					invalidateSubrecordClones();
				}
				return subrecord;
			}

			this.doGetSublistSubrecordForInstance = doGetSublistSubrecordForInstance;

			function removeSublistSubrecord(options, fieldId, line)
			{
				var sublistId;
				if (fieldId !== undef && line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					line = options.line;
				}
				utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], getMissingArgumentErrorMessageFillerValue('removeSublistSubrecord'));

				if (!hasSublistFieldValueOrSublistFieldExisted(sublistId, fieldId, line))
				{
					utilityFunctions.throwSuiteScriptError(error.Type.FIELD_1_IS_NOT_A_SUBRECORD_FIELD, fieldId);
				}

				var useBuffer = false;
				var lineInstanceId = getLineInstanceId(sublistId, line, useBuffer);
				doRemoveSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
			}

			/**
			 * remove the subrecord for the associated sublist field
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @restriction only available in deferred dynamic record
			 * @return {Record} same record, for chaining
			 */
			this.removeSublistSubrecord = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: removeSublistSubrecord,
				emitter: emitter
			});


			function hasCurrentSublistSubrecord(options, fieldId)
			{
				var sublistId;
				if (fieldId !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
				}
				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], getMissingArgumentErrorMessageFillerValue('hasCurrentSublistSubrecord'));
				return doHasCurrentSublistSubrecord(sublistId, fieldId);
			}

			/**
			 * return a value indicating if the associated sublist field has a subrecord on the current line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @restriction only available in dynamic record
			 * @return {boolean}
			 */
			this.hasCurrentSublistSubrecord = hasCurrentSublistSubrecord;

			function doHasCurrentSublistSubrecord(sublistId, fieldId)
			{
				var lineInstanceId = getModelController().getSublistSelectedLineInstanceId(sublistId);
				var useBuffer = true;
				return doHasSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
			}

			function getCurrentSublistSubrecord(options, fieldId)
			{
				var sublistId;
				if (fieldId !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
				}
				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], getMissingArgumentErrorMessageFillerValue('getCurrentSublistSubrecord'));

				var subrecord = doGetCurrentSublistSubrecord(sublistId, fieldId);
				return subrecord;
			}

			/**
			 * get the subrecord for the associated sublist field on the current line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @restriction only available in dynamic record
			 * @return {Record} [client-side subrecord implementation]
			 */
			this.getCurrentSublistSubrecord = getCurrentSublistSubrecord;

			function doGetCurrentSublistSubrecord(sublistId, fieldId)
			{
				var useBuffer = true;
				var lineInstanceId = getModelController().getSublistSelectedLineInstanceId(sublistId);
				var field = getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
				subrecordUtil.validateIfSummaryField(field, fieldId);
				var subrecord = getModelController().getCurrentSublistSubrecord(sublistId, fieldId);

				if (!subrecord)
				{
					getModelController().getSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
					var isSameSubrecordReference = doGetCurrentSublistIndex(sublistId) < doGetLineCount(sublistId) &&
						getModelController().getCurrentSublistLineValue(sublistId, fieldId) == getModelController()
							.getSublistLineValue(sublistId, fieldId, doGetCurrentSublistIndex(sublistId));

					if (getModelController()
							.hasNewlyCommittedSublistSubrecord(getModelController()
								.getCurrentSublistSystemId(sublistId), fieldId) && isSameSubrecordReference)
					{
						subrecord = doGetSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
						subrecord = subrecord.internalClone();
						subrecord.linkParentState(getSublistState(sublistId), getSublistState(sublistId)
							.getCurrentLineFieldState(fieldId));
					}

					if (!subrecord)
					{
						var id = getModelController().getCurrentSublistLineValue(sublistId, fieldId);
						subrecord = doGetSubrecordFromServerForInstance(field, id, lineInstanceId, useBuffer);
					}

					getModelController().setCurrentSublistSubrecord(sublistId, fieldId, subrecord);
				}

				return subrecord;
			}

			this.doGetCurrentSublistSubrecord = doGetCurrentSublistSubrecord;

			function removeCurrentSublistSubrecord(options, fieldId)
			{
				var sublistId;
				if (fieldId !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
				}

				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], getMissingArgumentErrorMessageFillerValue('removeCurrentSublistSubrecord'));

				if (!hasCurrentSublistFieldValueOrSublistFieldExisted(sublistId, fieldId))
				{
					utilityFunctions.throwSuiteScriptError(error.Type.FIELD_1_IS_NOT_A_SUBRECORD_FIELD, fieldId);
				}

				var useBuffer = true;
				var lineInstanceId = getModelController().getSublistSelectedLineInstanceId(sublistId);
				doRemoveSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
			}

			/**
			 * remove the subrecord for the associated sublist field on the current line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @restriction only available in dynamic record
			 * @return {Record} same record, for chaining
			 */
			this.removeCurrentSublistSubrecord = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: removeCurrentSublistSubrecord,
				emitter: emitter
			});

			/* Record Scripting */
			function triggerPageInitScript()
			{
				implementation.triggerPageInitScript();
			}

			function triggerLineInitScript(sublistId)
			{
				implementation.triggerLineInitScript(sublistId);
			}

			function postDeleteLine(sublistId, line_0)
			{
				implementation.triggerPostDeleteLineScript(sublistId, recordUtil.getOneBasedIndex(line_0));
			}

			this.postDeleteLine = postDeleteLine;

			function postDeleteLineForInstance(sublistId, lineInstanceId, useBuffer)
			{
				var line_0 = getLineIndexFromInstanceId(sublistId, lineInstanceId, useBuffer);
				postDeleteLine(sublistId, line_0);
			}

			this.postDeleteLineForInstance = postDeleteLineForInstance;

			function triggerLineCommitScript(sublistId, line)
			{
				implementation.triggerLineCommitScript(sublistId, line);
			}

			function triggerLineCommitScriptForInstance(sublistId, lineInstanceId, useBuffer)
			{
				var line_0 = getLineIndexFromInstanceId(sublistId, lineInstanceId, useBuffer);
				triggerLineCommitScript(sublistId, recordUtil.getOneBasedIndex(line_0));
			}

			function triggerValidateLineScript(sublistId)
			{
				recordDefinitionEvent.wrapEmitLineValidationError({
					record: that,
					sublistId: sublistId,
					func: implementation.triggerValidateLineScript,
					emitter: emitter
				})(sublistId);
			}

			function triggerValidateInsertScript(sublistId)
			{
				implementation.triggerValidateInsertScript(sublistId);
			}

			this.triggerValidateInsertScript = triggerValidateInsertScript;

			function triggerValidateDeleteScript(sublistId)
			{
				implementation.triggerValidateDeleteScript(sublistId);
			}

			this.triggerValidateDeleteScript = triggerValidateDeleteScript;

			function triggerValidateFieldScript(sublistId, fieldId, line)
			{
				var lineItemMatrixFieldMetadata = line >= 0 && matrix.parseMatrixLineField(that, fieldId, sublistId) || null;
				var fieldId = !!lineItemMatrixFieldMetadata && lineItemMatrixFieldMetadata.fieldname || fieldId;
				var matrixColumn = !!lineItemMatrixFieldMetadata && lineItemMatrixFieldMetadata.column || -1;
				implementation.triggerValidateFieldScript(sublistId, fieldId, line, matrixColumn);
			}

			this.triggerValidateFieldScript = triggerValidateFieldScript;

			function triggerFieldChangeEvent(sublistId, fieldId, line, value, noSlaving)
			{
				implementation.triggerFieldChangeEvent(sublistId, fieldId, line, value, noSlaving);
			}

			this.triggerFieldChangeEvent = triggerFieldChangeEvent;

			function triggerFieldChangeEventForInstance(sublistId, fieldId, line, lineInstanceId, value, noSlaving)
			{
				implementation.triggerFieldChangeEventForInstance(sublistId, fieldId, line, lineInstanceId, value, noSlaving);
			}

			this.triggerFieldChangeEventForInstance = triggerFieldChangeEventForInstance;

			function triggerFieldChangeScript(sublistId, field, line)
			{
				var lineItemMatrixFieldMetadata = line > 0 && matrix.parseMatrixLineField(that, field, sublistId) || null;
				var matrixColumn = !!lineItemMatrixFieldMetadata && lineItemMatrixFieldMetadata.column || -1;
				var fieldId = !!lineItemMatrixFieldMetadata && lineItemMatrixFieldMetadata.fieldname || field;
				implementation.triggerFieldChangeScript(sublistId, fieldId, line, matrixColumn);
			}

			this.triggerFieldChangeScript = triggerFieldChangeScript;

			function triggerCanCreateSubrecordScript(sublistId, fieldId, line)
			{
				implementation.triggerCanCreateSubrecordScript(sublistId, fieldId, line);
			}

			function triggerCanCreateSubrecordScriptForInstance(sublistId, fieldId, lineInstanceId, useBuffer)
			{
				var line_0 = getLineIndexFromInstanceId(sublistId, lineInstanceId, useBuffer);
				implementation.triggerCanCreateSubrecordScript(sublistId, fieldId, recordUtil.getOneBasedIndex(line_0));
			}

			function triggerSaveRecordScript(ignoreMandatoryFields)
			{
				implementation.triggerSaveRecordScript(ignoreMandatoryFields);
			}

			this.triggerSaveRecordScript = triggerSaveRecordScript;

			function triggerRecalcScript(sublistId, localRecalc, operation)
			{
				implementation.triggerRecalcScript(sublistId, localRecalc, operation);
			}

			this.triggerRecalcScript = triggerRecalcScript;


			function getValueAsLegacyString(fieldId)
			{
				return getModelController().getValueAsLegacyString(fieldId);
			}

			this.getValueAsLegacyString = getValueAsLegacyString;

			function getValueAsLegacyStringArray(fieldId)
			{
				return recordUtil.formatValueToArrayType(getValueAsLegacyString(fieldId));
			}

			this.getValueAsLegacyStringArray = getValueAsLegacyStringArray;

			function doSetFieldValueWithoutFormatValue(fieldId, value, fireFieldChange, noSlaving)
			{
				doSetFieldValue(fieldId, value, fireFieldChange, noSlaving, true);
			}

			this.doSetFieldValueWithoutFormatValue = doSetFieldValueWithoutFormatValue;

			function doSetCurrentSublistFieldValueWithoutFormatValue(sublistId, fieldId, value, fireFieldChange, noSlaving)
			{
				doSetCurrentSublistFieldValue(sublistId, fieldId, value, fireFieldChange, noSlaving, true);
			}

			this.doSetCurrentSublistFieldValueWithoutFormatValue = doSetCurrentSublistFieldValueWithoutFormatValue;

			function setValueAsLegacyString(fieldId, value, fireFieldChange, noSlaving)
			{
				if (isInternal())
				{
					doSetFieldValueWithoutFormatValue(fieldId, value, fireFieldChange, noSlaving);
					getFieldState(fieldId).isParsed = false;
				}
				else
				{
					value = recordUtil.formatArrayToStringType(value);
					var fieldLevelMetadata = getFieldLevelMetadataForBodyField(fieldId);
					doSetValue(fieldId, parseValue(isValidBodyField(fieldId), fieldLevelMetadata, value), fireFieldChange, noSlaving);
				}
			}

			function setCurrentSublistValueAsLegacyString(sublistId, fieldId, value, fireFieldChange, noSlaving)
			{
				if (isInternal())
				{
					var useBuffer = true;
					doSetCurrentSublistFieldValueWithoutFormatValue(sublistId, fieldId, value, fireFieldChange, noSlaving);
					var currentLineIdx = doGetCurrentSublistIndex(sublistId);
					getSublistFieldState(sublistId, fieldId, currentLineIdx, useBuffer).isParsed = false;
				}
				else
				{
					value = recordUtil.formatArrayToStringType(value);

					var fieldLevelMetadata = getFieldLevelMetadataForSublistField(sublistId, fieldId);
					var parsedValue = parseValue(isValidSublistField(sublistId, fieldId), fieldLevelMetadata, value);
					doSetCurrentSublistValue(sublistId, fieldId, parsedValue, fireFieldChange, noSlaving);
				}
			}

			//TODO: move to RecordImplV1, but need to add subrecord V1 ..etc
			function setFieldValue(fieldId, value, fireFieldChange, noSlaving)
			{
				recordUtil.validateAgainstSqlInjection(fieldId, value);
				value = String(recordUtil.emptyIfNullOrUndefined(value));
				setValueAsLegacyString(fieldId, value, fireFieldChange, noSlaving);
			}

			this.setFieldValue = setFieldValue;

			function setFieldText(fieldId, text, fireFieldChange)
			{
				if (isFieldSelectType(null, fieldId))
				{
					if (util.isArray(text))
					{
						text.forEach(function (txt)
						{
							recordUtil.validateAgainstSqlInjection(fieldId, txt);
						});
					}
					else
					{
						recordUtil.validateAgainstSqlInjection(fieldId, text);
					}

					doSetText(fieldId, text, fireFieldChange);
				}
			}

			this.setFieldtext = setFieldText;

			//TODO: for subrecord v1
			function getFieldValue(fieldId)
			{
				return recordUtil.emptyIfNullOrUndefined(getValueAsLegacyString(fieldId));
			}

			this.getFieldValue = getFieldValue;

			function setFieldValues(fieldId, values, fireFieldChange, noSlaving)
			{
				if (isFieldMultiSelect(undef, fieldId))
				{
					if (util.isArray(values))
					{
						values.forEach(function (value)
						{
							recordUtil.validateAgainstSqlInjection(fieldId, value);
						});
					}
					else
					{
						recordUtil.validateAgainstSqlInjection(fieldId, values);
					}

					values = util.isArray(values) ? values : [values];
					values = recordUtil.formatArrayToStringType(values);
					setFieldValue(fieldId, values, fireFieldChange, noSlaving);
				}
			}

			this.setFieldValues = setFieldValues;

			function setFieldTexts(fieldId, texts, fireFieldChange)
			{
				if (isFieldMultiSelect(fieldId))
				{
					doSetTexts(fieldId, texts, fireFieldChange);
				}
			}

			this.setFieldTexts = setFieldTexts;

			function getSublistLineValueAsLegacyString(sublistId, fieldId, line)
			{
				return getModelController().getSublistLineValueAsLegacyString(sublistId, fieldId, line);
			}

			this.getSublistLineValueAsLegacyString = getSublistLineValueAsLegacyString;

			function getSublistLineValueAsLegacyStringForInstance(sublistId, fieldId, lineInstanceId, useBuffer)
			{
				return getModelController()
					.getSublistLineValueAsLegacyStringForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
			}

			this.getSublistLineValueAsLegacyStringForInstance = getSublistLineValueAsLegacyStringForInstance;

			function getSublistLineValueAsLegacyStringArray(sublistId, fieldId, line)
			{
				return recordUtil.formatValueToArrayType(getSublistLineValueAsLegacyString(sublistId, fieldId, line));
			}

			this.getSublistLineValueAsLegacyStringArray = getSublistLineValueAsLegacyStringArray;

			function getCurrentSublistLineValueAsLegacyString(sublistId, fieldId)
			{
				return getModelController().getCurrentSublistLineValueAsLegacyString(sublistId, fieldId);
			}

			this.getCurrentSublistLineValueAsLegacyString = getCurrentSublistLineValueAsLegacyString;

			function setLineItemValue(sublistId, fieldId, line_0, value)
			{
				if (isSublistValid(sublistId))
				{
					recordUtil.validateAgainstSqlInjection(fieldId, value);


					var fieldLevelMetadata = getFieldLevelMetadataForSublistField(sublistId, fieldId);
					var parsedValue = parseValue(isValidSublistField(sublistId, fieldId), fieldLevelMetadata, value);
					var validatedValue = validateAndFormatFieldValue(sublistId, fieldId, parsedValue);
					doSetSublistValue(sublistId, fieldId, line_0, validatedValue);
				}
			}

			this.setLineItemValue = setLineItemValue;

			function setCurrentLineItemValue(sublistId, fieldId, value, fireFieldChange, noSlaving)
			{
				recordUtil.validateAgainstSqlInjection(fieldId, value);
				value = String(recordUtil.emptyIfNullOrUndefined(value));
				setCurrentSublistValueAsLegacyString(sublistId, fieldId, value, fireFieldChange, noSlaving);
			}

			this.setCurrentLineItemValue = setCurrentLineItemValue;

			function setCurrentLineItemText(sublistId, fieldId, text, fireFieldChange)
			{
				if (isFieldSelectType(sublistId, fieldId))
				{
					if (util.isArray(text))
					{
						text.forEach(function (txt)
						{
							recordUtil.validateAgainstSqlInjection(fieldId, txt);
						});
					}
					else
					{
						recordUtil.validateAgainstSqlInjection(fieldId, text);
					}

					doSetCurrentSublistText(sublistId, fieldId, text, fireFieldChange);
				}
			}

			this.setCurrentLineItemText = setCurrentLineItemText;


			/* Sublist APIs */

			function getSublist(options)
			{
				var sublistId;
				sublistId = options !== undef && options !== null && !util.isString(options) ? options.sublistId : options;
				utilityFunctions.checkArgs([sublistId], ['sublistId'], getMissingArgumentErrorMessageFillerValue('getSublist'));
				return doGetSublist(sublistId);
			}

			/**
			 * returns the specified sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @return {Sublist} [requested sublist]
			 */
			this.getSublist = getSublist;

			function doGetSublist(sublistId)
			{
				function createSublist(type, state, fields)
				{
					var _sublist = sublist.create({
						type: type,
						sublistState: state,
						sublistFields: fields
					});

					return _sublist;
				}

				var sublistLevelMetadata = getSublistMetadata(sublistId);
				var jsSublist = (sublistLevelMetadata != null)
					? createSublist(sublistLevelMetadata.nlobjSublistConstructorType, _state.getSublistState(sublistId), sublistLevelMetadata.fieldMetadata)
					: null;
				if (jsSublist !== null)
				{
					jsSublist = sublistMD.wrap({delegate: jsSublist, category: getSublistDefinitionCategory()});
				}

				return jsSublist;
			}

			function getSublistDefinitionCategory()
			{
				return getIsReadOnlyRecord() ? sublistMD.Category.READ_ONLY : sublistMD.Category.REMOTE;
			}

			function getSublistFields(options)
			{
				var sublistId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'sublistId', getMissingArgumentErrorMessageFillerValue('getSublistFields'));
				var allSublistFields = null;

				var sublistfields = _metadata.getAllSublistFields(sublistId);
				if (sublistfields)
				{
					allSublistFields = [];
					var setOfSublistFields = {};
					/* by current line data */
					var sublistData = getModelController().getCurrentSublistFieldIds(sublistId);
					if (util.isArray(sublistData))
					{
						sublistData.forEach(function (fieldId) { setOfSublistFields[fieldId] = ''; });
					}

					/* by metadata line data */
					sublistfields.forEach(function (fieldId) { setOfSublistFields[fieldId] = ''; });

					allSublistFields = Object.keys(setOfSublistFields);
				}

				return allSublistFields;
			}

			/**
			 * return array of names of all fields in a sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @return {Array}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.sublistId is missing or undefined
			 */
			this.getSublistFields = getSublistFields;

			/* Field APIs */
			function getField(options)
			{
				var fieldId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'fieldId', getMissingArgumentErrorMessageFillerValue('getField'));
				return doGetField(undef, fieldId, -1, false);
			}

			/**
			 * return field object from record
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @return {Field}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 */
			this.getField = getField;

			function doGetField(sublistId, fieldId, line, useBuffer)
			{
				var lineInstanceId = getLineInstanceId(sublistId, line, useBuffer);
				return doGetFieldForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
			}

			function doGetFieldForInstance(sublistId, fieldId, lineInstanceId, useBuffer)
			{
				var returnedField;
				if (getModelController().hasUserFieldForInstance(sublistId, fieldId, lineInstanceId, useBuffer))
				{
					returnedField = getModelController().getUserFieldForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
				}
				else
				{
					var recordField = getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
					returnedField = recordField ? fieldMetadata.wrap({
						delegate: field.create(recordField),
						category: fieldMetadata.Category.getInstance({
							isSublistField: sublistId !== undef,
							isDynamic: getIsDynamicRecord(),
							isReadOnly: getIsReadOnlyRecord()
						}),
						current: getIsCurrentRecord()
					}) : null;
					getModelController().cacheUserFieldForInstance(sublistId, fieldId, lineInstanceId, returnedField, useBuffer);
				}
				return returnedField;
			}

			this.doGetFieldForInstance = doGetFieldForInstance;

			function getSublistField(options, fieldId, line)
			{
				var sublistId;
				if (fieldId !== undef && line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					line = options.line;
				}
				utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], getMissingArgumentErrorMessageFillerValue('getSublistField'));
				return doGetSublistField(sublistId, fieldId, line);
			}

			/**
			 * return field object from record's sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @return {Field} [requested field]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if line number is invalid
			 */
			this.getSublistField = getSublistField;

			function doGetSublistField(sublistId, fieldId, line)
			{
				var useBuffer = false;
				recordUtil.assertValidSublistOperation(isWithinValidLineRangeForFieldOnly(sublistId, line));
				if (line === doGetLineCount(sublistId) && isValidSublistField(sublistId, fieldId)){
					useBuffer = true;
				}
				return doGetField(sublistId, fieldId, line, useBuffer);
			}

			function getCurrentSublistField(options, fieldId)
			{
				var sublistId;
				if (fieldId !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
				}
				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], getMissingArgumentErrorMessageFillerValue('getCurrentSublistField'));
				return doGetCurrentSublistField(sublistId, fieldId);
			}

			/**
			 * return field object from record's sublist current line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @return {Field}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @restriction only available in dynamic record
			 */
			this.getCurrentSublistField = getCurrentSublistField;

			function doGetCurrentSublistField(sublistId, fieldId)
			{
				var lineInstanceId = getModelController().getSublistSelectedLineInstanceId(sublistId);
				var useBuffer = true;
				return doGetFieldForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
			}


			/**
			 * get cached RecordField object
			 * @param {string} sublistId
			 * @param {string} fieldId
			 * @param {number} line -1 if target is current sublist line
			 * @param {boolean} useBuffer
			 * @return {*}
			 */
			function getCachedRecordField(sublistId, fieldId, line, useBuffer)
			{
				var lineInstanceId = getLineInstanceId(sublistId, line, useBuffer);
				return getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
			}

			this.getCachedRecordField = getCachedRecordField;

			function getCurrentCachedRecordField(sublistId, fieldId)
			{
				var lineInstanceId = getModelController().getSublistSelectedLineInstanceId(sublistId);
				var useBuffer = true;
				return getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
			}

			this.getCurrentCachedRecordField = getCurrentCachedRecordField;

			function getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, useBuffer)
			{
				var recordField = getModelController().getRecordfieldForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
				if (recordField != null)
				{
					if (!!sublistId && !!lineInstanceId)
					{
						var lineIndex = getLineIndexFromInstanceId(sublistId, lineInstanceId, useBuffer);
						recordField.setLine(parseInt(lineIndex, 10));
					}
				}
				else
				{
					var fieldConstructorObject = getFieldConstructorObjectForInstance(sublistId, fieldId, lineInstanceId, useBuffer);
					if (fieldConstructorObject)
					{
						recordField = recordfield.create(fieldConstructorObject);
						recordDefinitionEvent.forwardRecordFieldEvents(emitter, that, recordField);
						getModelController()
							.cacheRecordFieldForInstance(sublistId, fieldId, lineInstanceId, recordField, useBuffer);
					}
					else
					{
						recordField = null;
					}
				}
				return recordField;
			}

			this.getCachedRecordFieldForInstance = getCachedRecordFieldForInstance;

			function flushBufferCacheForFieldStateUpdate(sublistId, fieldId, lineNum, isCurrentLine)
			{
				var useBuffer = true;
				var lineInstanceId = null;
				if (!!sublistId)
				{
					lineInstanceId = isCurrentLine ? getModelController().getSublistSelectedLineInstanceId(sublistId)
						: getLineInstanceId(sublistId, lineNum, useBuffer);
				}
				getModelController().flushBufferCacheForFieldStateUpdate(sublistId, fieldId, lineInstanceId);
			}

			this.flushBufferCacheForFieldStateUpdate = flushBufferCacheForFieldStateUpdate;

			function updateSelectOptions(sublistId, fieldId, line, opts, value, text, selected)
			{
				getModelController().cacheSelectOptions(sublistId, fieldId, line, opts);
				getModelController().cacheSelectOptionText(sublistId, fieldId, value, text);
				if (selected)
				{
					if (!!sublistId)
					{
						setCurrentSublistValue(sublistId, fieldId, value);
					}
					else
					{
						doSetFieldValue(fieldId, value);
					}
				}
			}

			function getFieldConstructorObjectForInstance(sublistId, fieldId, lineInstanceId, useBuffer)
			{
				var fieldObj = null;
				var metadata = _metadata.getFieldMetadata(sublistId, fieldId);

				if (metadata != null)
				{
					var lineIndex = !!sublistId && !!lineInstanceId ? getLineIndexFromInstanceId(sublistId, lineInstanceId, useBuffer) : null;
					var fieldState = !!sublistId ? getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, useBuffer) : getFieldState(fieldId);
					fieldObj = {
						fieldState: fieldState,
						metadata: metadata,
						record: that,
						isRecordDynamic: getIsDynamicRecord(),
						isCurrentRecord: getIsCurrentRecord(),
						sublistId: sublistId,
						lineNum: lineIndex,
						recordFunctions: {
							getRadioSet: getRadioSet,
							getQueryRequest: getQueryRequest,
							setInternalEvent: setInternalEvent,
							isInternal: isInternal,
							getFieldOptions: getSelectOptionCache,
							updateSelectOptions: updateSelectOptions
						}
					};
				}
				return fieldObj;
			}

			function getLineIndexFromInstanceId(sublistId, lineInstanceId, useBuffer)
			{
				return getModelController().getSublistLineValueForInstance(sublistId, '_sequence', lineInstanceId, useBuffer);
			}

			function getQueryRequest()
			{
				var req = slaving.cleanupQueryURL(_metadata.queryUrl);
				if (getIsCurrentRecord())
				{
					req.payload.isCurrentRecord = true;
				}
				return req;
			}

			function getRadioSet(fieldId)
			{
				var metadata = _metadata.getFieldMetadata(null, fieldId);
				return (metadata) ? metadata.radioSet : null;
			}

			function getSelectOptionCache()
			{
				var selectOptionCache = getModelController().getSelectOptionCache();
				var result = {
					commitFromSublistBufferToSublist: selectOptionCache.commitFromSublistBufferToSublist,
					fields: selectOptionCache.fields,
					get: selectOptionCache.get,
					getSublist: selectOptionCache.getSublist,
					getSublistBuffer: selectOptionCache.getSublistBuffer,
					has: selectOptionCache.has,
					invalidate: selectOptionCache.invalidate,
					invalidateSublist: selectOptionCache.invalidateSublist,
					migrateFromSublistToSublistBuffer: selectOptionCache.migrateFromSublistToSublistBuffer,
					put: function (sublistId, fieldId, line, newOptions, action, data)
					{
						if (!action && !selectOptionCache.has(sublistId, fieldId, line))
						{
							action = 'init';
							data = newOptions;
						}
						selectOptionCache.put(sublistId, fieldId, line, newOptions);
						recordDefinitionEvent.emitUpdateFieldOptions(emitter, that, sublistId, fieldId, line, action, data);
					},
					removeLine: selectOptionCache.removeLine
				};
				return result;
			}

			function getFieldSelectOption(field, lookupBind)
			{
				if (field.isPopup())
				{
					return field.getSelectOptions('', '', lookupBind);
				}
				else
				{
					return field.getSelectOptions();
				}
			}


			/**
			 * set the value for the associated header in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId the id of the matrix field
			 * @param {number} options.column the column number for the field
			 * @param {string} options.value the value to set it to
			 * @param {boolean} [options.ignoreFieldChange] Ignore the field change script (default false)
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @return {Record} same record, for chaining
			 */
			this.setMatrixHeaderValue = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: matrix.setMatrixHeaderValue.bind(that, that),
				emitter: emitter
			});
			/**
			 * get the value for the associated header in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId the id of the matrix field
			 * @param {number} options.column the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @return {number|Date|string}
			 */
			this.getMatrixHeaderValue = matrix.getMatrixHeaderValue.bind(that, that);
			/**
			 * set the value for the associated field in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId the id of the matrix field
			 * @param {number} options.line the line number for the field
			 * @param {number} options.column the column number for the field
			 * @param {string} options.value the value to set it to
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @restriction only available in deferred dynamic record
			 * @return {Record} same record, for chaining
			 */
			this.setMatrixSublistValue = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: matrix.setMatrixSublistValue.bind(that, that),
				emitter: emitter
			});
			/**
			 * get the value for the associated field in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId the id of the matrix field
			 * @param {number} options.line the line number for the field
			 * @param {number} options.column the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @return {number|Date|string}
			 */
			this.getMatrixSublistValue = matrix.getMatrixSublistValue.bind(that, that);

			/**
			 * get the field for the specified header in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId the id of the matrix field
			 * @param {number} options.column the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @return {Field} [requested field]
			 */
			this.getMatrixHeaderField = matrix.getMatrixHeaderField.bind(that, that);
			/**
			 * get the field for the specified sublist in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId the id of the matrix field
			 * @param {number} options.column the column number for the field
			 * @param {number} options.line the line number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @return {Field} [requested field]
			 */
			this.getMatrixSublistField = matrix.getMatrixSublistField.bind(that, that);
			/**
			 * returns the line number of the first line that contains the specified value in the specified column of the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId the id of the matrix field
			 * @param {number} options.value the column number for the field
			 * @param {number} options.column the line number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @return {number}
			 */
			this.findMatrixSublistLineWithValue = matrix.findMatrixSublistLineWithValue.bind(that, that);
			/**
			 * returns the number of columns for the specified matrix.
			 * @param {Object} options
			 * @param {string} options.sublistId the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId the id of the matrix field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @return {number}
			 */
			this.getMatrixHeaderCount = matrix.getMatrixHeaderCount.bind(that, that);
			/**
			 * set the value for the line currently selected in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @param {string} options.value - the value to set it to
			 * @param {boolean} options.ignoreFieldChange (optional) - Ignore the field change script (default false)
			 * @param {boolean} options.fireSlavingSync (optional) - Flag to perform slaving synchronously (default false)
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @restriction only available in dynamic record
			 * @return {Record} same record, for chaining
			 */
			this.setCurrentMatrixSublistValue = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: matrix.setCurrentMatrixSublistValue.bind(that, that),
				emitter: emitter
			});
			/**
			 * get the value for the line currently selected in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @restriction only available in dynamic record
			 * @return {number|Date|string}
			 */
			this.getCurrentMatrixSublistValue = matrix.getCurrentMatrixSublistValue.bind(that, that);

			/**
			 * This callback type is called `eventCallback` and is displayed as a global symbol.
			 * @callback requestCallback
			 * @param {Object} event
			 */
			/**
			 * Start listening to events
			 * @param {Object} options
			 * @param {string[]} options.types [required]
			 * @param {eventCallback} options.listener [required]
			 * @return {Object} record
			 */
			this.on = function on(options)
			{
				var types = options.types,
					listener = options.listener;

				utilityFunctions.checkArgs([types, listener], ['types', 'listener'], getMissingArgumentErrorMessageFillerValue('on'));
				emitter.on({
					types: types,
					listener: listener
				});
			};
			/**
			 * Stop listening to events
			 * @param {Object} options
			 * @param {string[]} options.types [required]
			 * @param {eventCallback} options.listener [required]
			 * @return {Object} record
			 */
			this.off = function off(options)
			{
				var types = options.types,
					listener = options.listener;

				utilityFunctions.checkArgs([types, listener], ['types', 'listener'], getMissingArgumentErrorMessageFillerValue('off'));
				emitter.off({
					types: types,
					listener: listener
				});
			};

			function toString() { return constants.RECORD_UNDERLYING_IMPL_NAME.CLIENT_DYNAMIC_RECORD; }

			this.toString = toString;

			function toJSON()
			{
				return {
					id: that.id,
					type: that.type,
					isDynamic: that.isDynamic,
					fields: getModelController().getData().body,
					sublists: getModelController().getSublistData()
				};
			}

			this.toJSON = toJSON;

			/* This method is used only by unit tests, to re-cast the record object into a different kind of proxy interface type on the fly. */
			function reCreateExposedRecordProxy(isSubrecord_param, isDynamic_param, isReadOnly_param, isInteractive_param)
			{
				recordObj.isSubrecord = isSubrecord_param;
				recordObj.isReadOnly = isReadOnly_param;
				recordObj.isDynamic = isDynamic_param;

				var proxiedRecord = that.proxy({isInteractive: isInteractive_param});
				return proxiedRecord;
			}

			this.reCreateExposedRecordProxy = reCreateExposedRecordProxy;

			(function processOptions(options)
			{
				implementation = recordImplementation.create(getIsDynamicRecord(), that);

				_recordRequestContext = options.recordContext;
				setMetadata(metadata.isInstance(options.metadata)
					? options.metadata
					: metadata.create(options.metadata));

				var shouldTriggerCustomFormLevelScript = getIsCurrentRecord() && getIsDynamicRecord() && !!options.formLevelScriptPayload;
				var formLevelScriptComponent = shouldTriggerCustomFormLevelScript ? {
					libraryScript: options.formLevelScriptPayload,
					script: options.formLevelScriptMetadata.superScript
				} : {};

				var shouldTriggerCustomClientScript = getIsCurrentRecord() && getIsDynamicRecord() && !!options.clientScriptPayload;
				var clientScriptComponent = shouldTriggerCustomClientScript ? {
					libraryScript: options.clientScriptPayload,
					scriptList: options.clientScriptMetadata.superScriptList,
					pageMode: options.pageInitMode
				} : {};

				setModelController(
					modelController.isInstance(options.data) ?
						options.data :
						modelController.create({
							type: _metadata.type,
							data: options.data
						})
				);

				setRecordStateController(
					recordStateController.isInstance(options.state) ?
						options.state :
						recordStateController.create({
							metadata: _metadata,
							data: getModelController(),
							getModelController: getModelController
						})
				);

				subrecordCompatibility = (function ()
				{
					var result = {body: null, sublist: {}};

					result.body = _metadata.subrecordFieldIds;

					_metadata.sublistIds.forEach(function (v, i, a)
					{
						var sublistId = v;
						result.sublist[sublistId] = _metadata.getAllSublistSubrecordFields(sublistId);
					});

					return result;

				}());

				v1ScopeOptions = getIsReadOnlyRecord() ? null : {
					record: that,
					libraryScript: getMetadata().libraryScript,
					staticScript: getMetadata().staticScript,
					uiFormScript: getMetadata().uiFormScript,
					shouldTriggerCustomFormLevelScript: shouldTriggerCustomFormLevelScript,
					formLevelScriptComponent: formLevelScriptComponent,
					shouldTriggerCustomClientScript: shouldTriggerCustomClientScript,
					clientScriptComponent: clientScriptComponent
				};
			}(recordObj));

			/* --- Proxy cache mechanism setup --- */

			this.proxy = recordProxy.proxy.bind(null, this, recordObj);

			/* --- End of proxy cache mechanism --- */

			this.internalClone = function ()
			{
				return clone({
					cloneable: true,
					mergeable: true
				});
			};
			if (options.cloneable === undefined || !!options.cloneable)
			{
				this.clone = recordDefinitionEvent.wrapEmitError({
					record: that,
					func: function ()
					{
						return clone({
							cloneable: false,
							mergeable: true
						});
					},
					emitter: emitter
				});
			}
			if (typeof options.merge === 'function')
			{
				this.merge = recordDefinitionEvent.wrapEmitError({
					record: that,
					func: options.merge,
					emitter: emitter
				});
			}
			if (getIsSubrecord())
			{
				this.abandon = subrecord_abandon;
				this.validate = recordDefinitionEvent.wrapEmitError({
					record: that,
					func: subrecord_validate,
					emitter: emitter
				});
				this.setReadonly = subrecord_setReadonly;
				this.link = subrecord_link;
				this.linkParentState = subrecord_linkParentState;
				this.isValidated = subrecord_isValidated;
				this.setDereferencedFromParent = subrecord_setDereferencedFromParent;
				this.isDereferencedFromParent = subrecord_isDereferencedFromParent;
			}

			/* This lets us establish currentRecord before pageInit() is called, making it possible to use currentRecord
			 * module from within pageInit(). */
			if (recordObj.initCallback)
			{
				recordObj.initCallback(that);
			}

			_recordScriptingV1Scope = v1ScopeOptions ? scope.create(v1ScopeOptions) : null;

			/* Call pageInit() */
			implementation.initRecord(that, _recordScriptingV1Scope);
			setIsInited();
			var event = {type: recordDefinitionEvent.Type.RECORD_INITIALIZED, record: that};
			emitter.emit(event);
			return that;
		}

		return Record;
	});

/**
 * SuiteScript record service module (Client Side)
 *
 * @private
 * @module N/record/recordService
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/recordService',['N/common/record/recordDefinition', 'N/record/recordProxy', 'N/util'],
	function (recordDefinition, recordProxy, util)
	{

		function create(rawRecordOrCreateOptions)
		{
			/* Make a copy of the args, as we will make changes to our copy. */
			var recordOptions = util.extend({}, rawRecordOrCreateOptions);

			/* Create a dynamic, deferred-dynamic, or read-only record instance. */
			var record = create_raw(recordOptions);

			return record.proxy({isInteractive: recordOptions.isInteractive});
		}

		function create_raw(recordOptions)
		{
			/* Add required isClientRecord=true, so the engine knows this is not intended to be a server-side record */
			recordOptions = util.extend({isClientRecord: true}, recordOptions);

			return new recordDefinition({recordObj: recordOptions});
		}


		return Object.freeze({
			create: create,
			create_raw: create_raw
		});
	});




/**
 * SuiteScript record util module
 *
 * @private
 * @module N/record/recordUtil
 * @suiteScriptVersion 2.x
 *
 */

define('N/record/recordUtil',['N/record/recordService', 'N/utilityFunctions', 'N/record/recordConstants', 'N/util'],
	function (recordService, utilityFunctions, constants, util)
	{
		var undef = undefined;

		// ==================== HELPERS ====================

		function getEventsParam(options)
		{
			var result = {};
			result.compress = !!options && typeof options.compressEvents !== 'undefined' ? !!options.compressEvents : true;

			return result;
		}

		function extractProxyCreateOptions(options)
		{
			var result = {};
			if (options !== undef && options !== null)
			{
				/* Pull out the parameters used only on the client side (for proxy wrapping the record) */
				if (util.isBoolean(options.isReadOnly))
				{
					result.isReadOnly = !!options.isReadOnly;
				}
				if (util.isBoolean(options.isInteractive))
				{
					result.isInteractive = !!options.isInteractive;
				}

				/* Remove these, as the server-side record engine does not recognize them and will throw an error if present */
				delete options.isReadOnly;
				delete options.isInteractive;
			}
			return result;
		}

		function createRecordInstance(nsrecord, doNotProxy)
		{
			var record;
			if (!!doNotProxy)
			{
				record = recordService.create_raw(nsrecord);
			}
			else
			{
				record = recordService.create(nsrecord);
			}
			return record;
		}

		// ==================== CREATE ====================

		function getCreateParams(options, isPromise)
		{
			var type, defaultValues, isCurrent,
				events = getEventsParam(options);

			if (options !== undef && options !== null)
			{
				type = options.type;
				defaultValues = options.isDynamic ? {recordmode: 'dynamic'} : {};
				util.extend(defaultValues, options.defaultValues || {});
				isCurrent = options.isCurrent || false;
			}
			var moduleName = (isPromise) ? 'create.promise' : 'create';
			utilityFunctions.checkArgs([type], ['type'], moduleName);
			return {type: type, defaults: defaultValues, current: isCurrent, compressEvents: events.compress};
		}

		function doCreateRecord(createArgs, nsrecord, isPromise) { return doCreateRecord_impl(createArgs, nsrecord, isPromise, false/*doNotProxy*/); }

		function doCreateRecord_raw(createArgs, nsrecord, isPromise) { return doCreateRecord_impl(createArgs, nsrecord, isPromise, true/*doNotProxy*/); }

		function doCreateRecord_impl(createArgs, nsrecord, isPromise, doNotProxy)
		{
			if (nsrecord.data)
			{
				nsrecord.data.initialization = {
					method: 'createRecord',
					params: createArgs
				};

				if (!isPromise)
				{
					nsrecord.data.initialization.remoteId = nsrecord.remoteId;
				}
			}

			var record = createRecordInstance(nsrecord, doNotProxy);
			utilityFunctions.assertTrue(createArgs.type.toLowerCase() === record.type.toLowerCase(), 'SSS_RECORD_TYPE_MISMATCH');
			return record;
		}

		// ==================== COPY ====================

		function getCopyParams(options, isPromise)
		{
			var type, id, defaultValues,
				events = getEventsParam(options);

			if (options !== undef && options !== null)
			{
				type = options.type;
				id = options.id;
				defaultValues = options.isDynamic ? {recordmode: 'dynamic'} : {};
				util.extend(defaultValues, options.defaultValues || {});
			}
			var moduleName = (isPromise) ? 'copy.promise' : 'copy';
			utilityFunctions.checkArgs([type, id], ['type', 'id'], moduleName);
			return {type: type, id: String(id), defaults: defaultValues, compressEvents: events.compress};
		}

		function validateCopyRecord(type, record)
		{
			utilityFunctions.assertTrue(type.toLowerCase() === record.type.toLowerCase()
				|| (type.toLowerCase() === 'customer' && /(prospect|lead|customer)/
					.test(record.type.toLowerCase())), 'SSS_RECORD_TYPE_MISMATCH');
		}

		function doCopyRecord(copyArgs, nsrecord, isPromise) { return doCopyRecord_impl(copyArgs, nsrecord, isPromise, false/*doNotProxy*/); }

		function doCopyRecord_raw(copyArgs, nsrecord, isPromise) { return doCopyRecord_impl(copyArgs, nsrecord, isPromise, true/*doNotProxy*/); }

		function doCopyRecord_impl(copyArgs, nsrecord, isPromise, doNotProxy)
		{
			if (nsrecord.data)
			{
				nsrecord.data.initialization = {
					method: 'copyRecord',
					params: copyArgs
				};

				if (!isPromise)
				{
					nsrecord.data.initialization.remoteId = nsrecord.remoteId;
				}
			}

			var record = createRecordInstance(nsrecord, doNotProxy);
			validateCopyRecord(copyArgs.type, record);
			return record;
		}

		// ==================== LOAD ====================

		function getLoadParams(options, isPromise)
		{
			var type, id, defaultValues, isCurrent,
				events = getEventsParam(options);

			if (options !== undef && options !== null)
			{
				type = options.type;
				id = options.id;
				defaultValues = options.isDynamic ? {recordmode: 'dynamic'} : {};
				util.extend(defaultValues, options.defaultValues || {});
				isCurrent = options.isCurrent || false;
			}
			var moduleName = (isPromise) ? 'load.promise' : 'load';
			utilityFunctions.checkArgs([type, id], ['type', 'id'], moduleName);
			return {type: type, id: String(id), defaults: defaultValues, current: isCurrent, compressEvents: events.compress};
		}

		function validateLoadRecord(type, record)
		{
			utilityFunctions.assertTrue(type.toLowerCase() === record.type.toLowerCase() ||
				(type.toLowerCase() === 'assemblyitem' && /.*assemblyitem/.test(record.type.toLowerCase())) ||
				(type.toLowerCase() === 'inventoryitem' && /.*inventoryitem/.test(record.type.toLowerCase())) ||
				(type.toLowerCase() === 'customer' && /(prospect|lead|customer)/.test(record.type.toLowerCase())), 'SSS_RECORD_TYPE_MISMATCH');
		}

		function doLoadRecord(loadArgs, nsrecord, isPromise) { return doLoadRecord_impl(loadArgs, nsrecord, isPromise, false/*doNotProxy*/); }

		function doLoadRecord_raw(loadArgs, nsrecord, isPromise) { return doLoadRecord_impl(loadArgs, nsrecord, isPromise, true/*doNotProxy*/); }

		function doLoadRecord_impl(loadArgs, nsrecord, isPromise, doNotProxy)
		{
			if (nsrecord.data)
			{
				nsrecord.data.initialization = {
					method: 'loadRecord',
					params: loadArgs
				};

				if (!isPromise)
				{
					nsrecord.data.initialization.remoteId = nsrecord.remoteId;
				}
			}

			var record = createRecordInstance(nsrecord, doNotProxy);
			validateLoadRecord(loadArgs.type, record);
			return record;
		}

		// ==================== TRANSFORM ====================

		function getTransformParams(options, isPromise)
		{
			var fromType, fromId, toType, defaultValues,
				events = getEventsParam(options);

			if (options !== undef && options !== null)
			{
				fromType = options.fromType;
				fromId = options.fromId;
				toType = options.toType;
				defaultValues = options.isDynamic ? {recordmode: 'dynamic'} : {};
				util.extend(defaultValues, options.defaultValues || {});
			}
			var moduleName = (isPromise) ? 'transform.promise' : 'transform';
			utilityFunctions.checkArgs([fromType, fromId, toType], ['fromType', 'fromId', 'toType'], moduleName);
			return {
				type: fromType,
				id: String(fromId),
				transformType: toType,
				defaults: defaultValues,
				compressEvents: events.compress
			};
		}

		function doTransformRecord(transformArgs, nsrecord, isPromise) { return doTransformRecord_impl(transformArgs, nsrecord, isPromise, false/*doNotProxy*/); }

		function doTransformRecord_raw(transformArgs, nsrecord, isPromise) { return doTransformRecord_impl(transformArgs, nsrecord, isPromise, true/*doNotProxy*/); }

		function doTransformRecord_impl(transformArgs, nsrecord, isPromise, doNotProxy)
		{
			if (nsrecord.data)
			{
				nsrecord.data.initialization = {
					method: 'transformRecord',
					params: transformArgs
				};

				if (isPromise)
				{
					nsrecord.data.initialization.remoteId = nsrecord.remoteId;
				}
			}

			var record = createRecordInstance(nsrecord, doNotProxy);
			utilityFunctions.assertTrue(transformArgs.transformType.toLowerCase() === record.type.toLowerCase(), 'SSS_RECORD_TYPE_MISMATCH');
			return record;
		}

		// ==================== DELETE ====================

		function getDeleteParams(options, isPromise)
		{
			var type, id;
			if (options !== undef && options !== null)
			{
				type = options.type;
				id = options.id;
			}
			var moduleName = (isPromise) ? 'delete.promise' : 'delete';
			utilityFunctions.checkArgs([type, id], ['type', 'id'], moduleName);
			return {type: type, id: String(id)};
		}

		function doDeleteRecord(recordId)
		{
			return parseInt(recordId, 10);
		}

		// ==================== SUBMIT FIELDS ====================
		function getSubmitFieldsParams(option, isPromise)
		{
			option = option || {};
			var type = option.type, id = option.id, values = option.values, options = option.options;
			var moduleName = (isPromise) ? 'submitFields.promise' : 'submitFields';
			utilityFunctions.checkArgs([type, id, values], ['type', 'id', 'values'], moduleName);

			var submitOptions = {
				enablesourcing: (utilityFunctions.isObject(options) && options['enableSourcing'] === true) ? true : false,
				disabletriggers: (utilityFunctions.isObject(options) && options['disableTriggers'] === true) ? true : false,
				ignoremandatoryfields: (utilityFunctions.isObject(options) && options['ignoreMandatoryFields'] === true) ? true : false
			};

			var flds = [], vals = [];
			for (var field in values)
			{
				if (values.hasOwnProperty(field))
				{
					flds[flds.length] = field;
					vals[vals.length] = values[field];
				}
			}
			flds = flds.length > 0 ? flds : null;
			vals = vals.length > 0 ? vals : null;
			return [type, id, flds, vals, submitOptions];
		}

		function doSubmitFields(submitResponse)
		{
			return parseInt(submitResponse, 10);
		}

		// ==================== ATTACH ====================
		function getAttachParams(options, isPromise)
		{
			var record = options.record, to = options.to, attributes = options.attributes || null;
			var moduleName = (isPromise) ? 'attach.promise' : 'attach';
			utilityFunctions.checkArgs([record, to], ['record', 'to'], moduleName);

			var recordType = options.record.type, recordId = options.record.id,
				toType = options.to.type, toId = options.to.id;
			utilityFunctions.checkArgs([recordType, recordId, toType, toId], ['record.type', 'record.id', 'to.type', 'to.id'], moduleName);
			return [recordType, recordId, toType, toId, attributes];
		}

		// ==================== DETACH ====================
		function getDetachParams(options, isPromise)
		{
			var record = options.record, from = options.from, attributes = options.attributes || null;
			var moduleName = (isPromise) ? 'detach.promise' : 'detach';
			utilityFunctions.checkArgs([record, from], ['record', 'from'], moduleName);

			var recordType = options.record.type, recordId = options.record.id,
				fromType = options.from.type, fromId = options.from.id;
			utilityFunctions.checkArgs([recordType, recordId, fromType, fromId], ['record.type', 'record.id', 'from.type', 'from.id'], moduleName);
			return [recordType, recordId, fromType, fromId, attributes];
		}

		return Object.freeze({
			extractProxyCreateOptions: extractProxyCreateOptions,

			getCreateParams: getCreateParams,
			doCreateRecord: doCreateRecord,
			doCreateRecord_raw: doCreateRecord_raw,

			getCopyParams: getCopyParams,
			doCopyRecord: doCopyRecord,
			doCopyRecord_raw: doCopyRecord_raw,

			getLoadParams: getLoadParams,
			doLoadRecord: doLoadRecord,
			doLoadRecord_raw: doLoadRecord_raw,

			getTransformParams: getTransformParams,
			doTransformRecord: doTransformRecord,
			doTransformRecord_raw: doTransformRecord_raw,

			getDeleteParams: getDeleteParams,
			doDeleteRecord: doDeleteRecord,
			getSubmitFieldsParams: getSubmitFieldsParams,
			doSubmitFields: doSubmitFields,
			getAttachParams: getAttachParams,
			getDetachParams: getDetachParams
		});
	});

/**
 * SuiteScript record implementation common module.
 *
 * Implements the 4 primary methods that can create a record, and offers both a proxied and raw (unproxied) variant of each.
 *
 * @private
 * @module N/record/recordImpl
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/recordImpl',['N/restricted/clientScriptHandler', 'N/restricted/invoker', 'N/record/recordUtil'],
	function (api, invoker, recordUtil)
	{
		// ==================== OPERATIONS THAT RETURN A RECORD ====================

		function createRecord(options) {return createRecord_impl(options, true/*doCreateProxy*/); }

		function createRecord_raw(options) { return createRecord_impl(options, false/*doCreateProxy*/); }

		function createRecord_impl(options, doCreateProxy)
		{
			var proxyOptions = recordUtil.extractProxyCreateOptions(options);
			var createArgs = recordUtil.getCreateParams(options, false);
			var nsrecord = invoker(api, 'createRecord', [createArgs.type, createArgs.defaults]);

			if (!doCreateProxy)
			{
				return recordUtil.doCreateRecord_raw(createArgs, nsrecord, false);
			}
			else
			{
				return recordUtil.doCreateRecord(createArgs, util.extend(nsrecord, proxyOptions), false);
			}
		}


		function copyRecord(options) { return copyRecord_impl(options, true/*doCreateProxy*/); }

		function copyRecord_raw(options) { return copyRecord_impl(options, false/*doCreateProxy*/); }

		function copyRecord_impl(options, doCreateProxy)
		{
			var proxyOptions = recordUtil.extractProxyCreateOptions(options);
			var copyArgs = recordUtil.getCopyParams(options, false);
			var nsrecord = invoker(api, 'copyRecord', [copyArgs.type, copyArgs.id, copyArgs.defaults]);

			if (!doCreateProxy)
			{
				return recordUtil.doCopyRecord_raw(copyArgs, nsrecord, false);
			}
			else
			{
				return recordUtil.doCopyRecord(copyArgs, util.extend(nsrecord, proxyOptions), false);
			}
		}


		function loadRecord(options) { return loadRecord_impl(options, true/*doCreateProxy*/); }

		function loadRecord_raw(options) { return loadRecord_impl(options, false/*doCreateProxy*/); }

		function loadRecord_impl(options, doCreateProxy)
		{
			var proxyOptions = recordUtil.extractProxyCreateOptions(options);
			var loadArgs = recordUtil.getLoadParams(options, false);
			var nsrecord = invoker(api, 'loadRecord', [loadArgs.type, loadArgs.id, loadArgs.defaults]);

			if (!doCreateProxy)
			{
				return recordUtil.doLoadRecord_raw(loadArgs, nsrecord, false);
			}
			else
			{
				return recordUtil.doLoadRecord(loadArgs, util.extend(nsrecord, proxyOptions), false);
			}
		}


		function transformRecord(options) { return transformRecord_impl(options, true/*doCreateProxy*/); }

		function transformRecord_raw(options) { return transformRecord_impl(options, false/*doCreateProxy*/); }

		function transformRecord_impl(options, doCreateProxy)
		{
			var proxyOptions = recordUtil.extractProxyCreateOptions(options);
			var transformArgs = recordUtil.getTransformParams(options, false);
			var nsrecord = invoker(api, 'transformRecord', [transformArgs.type, transformArgs.id, transformArgs.transformType, transformArgs.defaults]);

			if (!doCreateProxy)
			{
				return recordUtil.doTransformRecord_raw(transformArgs, nsrecord, false);
			}
			else
			{
				return recordUtil.doTransformRecord(transformArgs, util.extend(nsrecord, proxyOptions), false);
			}
		}


		return Object.freeze({
			create: createRecord,
			create_raw: createRecord_raw,

			load: loadRecord,
			load_raw: loadRecord_raw,

			copy: copyRecord,
			copy_raw: copyRecord_raw,

			transform: transformRecord,
			transform_raw: transformRecord_raw
		});
	}
);

/**
 * SuiteScript record common module
 *
 * @module N/common/record
 * @suiteScriptVersion 2.x
 *
 */
define('N/common/record',['N/restricted/clientScriptHandler', 'N/restricted/invoker', 'N/record/recordImpl', 'N/record/recordUtil'],
	function (api, invoker, recordImpl, recordUtil)
	{
		var recordTypes;

		// ==================== OPERATIONS THAT RETURN A RECORD ====================

		function createRecord(options) {return recordImpl.create(options); }

		function copyRecord(options) { return recordImpl.copy(options); }

		function loadRecord(options) { return recordImpl.load(options); }

		function transformRecord(options) { return recordImpl.transform(options); }

		// ==================== OPERATIONS THAT DO NOT RETURN A RECORD ====================

		function deleteRecord(options)
		{
			var deleteArgs = recordUtil.getDeleteParams(options, false);
			var recordID = invoker(api, 'nlapiDeleteRecord', [deleteArgs.type, deleteArgs.id, null]);

			return recordUtil.doDeleteRecord(recordID);
		}

		function submitFields(options)
		{
			var argList = recordUtil.getSubmitFieldsParams(options, false);
			var submitResponse = invoker(api, 'nlapiSubmitField', argList);

			return recordUtil.doSubmitFields(submitResponse);
		}

		function attachRecord(options)
		{
			var argList = recordUtil.getAttachParams(options, false);
			invoker(api, 'nlapiAttachRecord', argList);
		}

		function detachRecord(options)
		{
			var argList = recordUtil.getDetachParams(options, false);
			invoker(api, 'nlapiDetachRecord', argList);
		}


		/* Don't freeze this, because we have to be able to attach promise methods later (clientRecord.js). */
		return {
			/**
			 * Create a new record object based on provided type
			 *
			 * @governance 10 units for transactions, 2 for custom records, 5 for all other records
			 *
			 * @param {Object} options
			 * @param {string} options.type record type
			 * @param {boolean} [options.isDynamic=false] record is dynamic
			 * @param {Object} [options.defaultValues={}] record default values
			 * @return {Record}
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.type is missing
			 *
			 * @since 2015.2
			 */
			create: function(options) { return createRecord(options, true/*doCreateProxy*/); },

			/**
			 * Load an existing nlobjRecord from the database based on provided type, id
			 *
			 * @governance 10 units for transactions, 2 for custom records, 5 for all other records
			 *
			 * @param {Object} options
			 * @param {string} options.type record type
			 * @param {number|string} options.id record id
			 * @param {boolean} [options.isDynamic=false] record is dynamic
			 * @param {Object} [options.defaultValues={}] record default values
			 * @return {Record}
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.type or options.id is missing
			 *
			 * @since 2015.2
			 */
			load: function(options) { return loadRecord(options, true/*doCreateProxy*/); },

			/**
			 * Copy a record object based on provided type, id
			 *
			 * @governance 10 units for transactions, 2 for custom records, 5 for all other records
			 *
			 * @param {Object} options
			 * @param {string} options.type record type
			 * @param {number|string} options.id record id
			 * @param {boolean} [options.isDynamic=false] record is dynamic
			 * @param {Object} [options.defaultValues={}] record default values
			 * @return {Record}
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.type or options.id is missing
			 *
			 * @since 2015.2
			 */
			copy: function(options) { return copyRecord(options, true/*doCreateProxy*/); },

			/**
			 * Transform a record into another type (i.e. salesOrder -> invoice -or- opportunity -> estimate)
			 *
			 * @governance 10 units for transactions, 2 for custom records, 5 for all other records
			 *
			 * @param {Object} options
			 * @param {string} options.fromType record type to be transformed from
			 * @param {number|string} options.fromId record id to be transformed from
			 * @param {string} options.toType record type to be transformed to
			 * @param {boolean} [options.isDynamic=false] record is dynamic
			 * @param {Object} [options.defaultValues={}] transformed record's default values
			 * @return {Record}
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.type or options.id is missing
			 *
			 * @since 2015.2
			 */
			transform: transformRecord,                                                                     //!!@TODO: flip polarity (currently is rejected by the stub generator)

			/**
			 * Delete a record object based on provided type, id and return the id of deleted record
			 *
			 * @governance 20 units for transactions, 4 for custom records, 10 for all other records
			 *
			 * @param {Object} options
			 * @param {string} options.type record type
			 * @param {number|string} options.id record id
			 * @return {number} recordId
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if type or id is missing
			 *
			 * @since 2015.2
			 */
			'delete': deleteRecord,

			/**
			 * commit record field updates to the system
			 *
			 * @governance 10 units for transactions, 2 for custom records, 5 for all other records
			 * @restriction only supported for records and fields where DLE (Direct List Editing) is supported
			 *
			 * @param {Object} options
			 * @param {string} options.type record type
			 * @param {number|string} options.id record id
			 * @param {Object} options.values field and value mapping to be submitted
			 * @param {Object} [options.options] additonal flags for submission
			 * @param {boolean} [options.options.enablesourcing=true] enable sourcing during record update
			 * @param {boolean} [options.options.ignoreMandatoryFields=false] ignore mandatory field during record submission
			 *
			 * @return {number} id of submitted record
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if type or id is missing
			 *
			 * @since 2015.2
			 */
			submitFields: submitFields,

			/**
			 * attach record to another record
			 *
			 * @governance 10 units
			 *
			 * @param {Object} options
			 * @param {Object} options.record record to be attached
			 * @param {Object} options.record.type the type of the record to be attached
			 * @param {number|string} options.record.id the id of the record to be attached
			 * @param {Object} options.to the destination record where options.record will be attached to
			 * @param {string} options.to.type the type of the destination
			 * @param {number|string} options.to.id the id of the destination
			 * @param {Object} [options.attributes=null] name/value pairs containing attributes
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any of record or to (and their type and id) are missing
			 *
			 * @since 2015.2
			 */
			attach: attachRecord,

			/**
			 * detach record from another record
			 *
			 * @governance 10 units
			 *
			 * @param {Object} options
			 * @param {Object} options.record record to be detached
			 * @param {Object} options.record.type the type of the record to be detached
			 * @param {number|string} options.record.id the id of the record to be detached
			 * @param {Object} options.from the destination record where options.record will be detached from
			 * @param {string} options.from.type the type of the destination
			 * @param {number|string} options.from.id the id of the destination
			 * @param {Object} [options.attributes=null] name/value pairs containing attributes
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any of record or from (and their type and id) are missing
			 *
			 * @since 2015.2
			 */
			detach: detachRecord,

			/*
			 * module enums
			 */
			get Type()
			{
				if (!recordTypes)
				{
					recordTypes = invoker(api, 'getStandardTypeEnumMap', ['record']);
				}
				return recordTypes;
			}
		};
	}
);

/**
 * SuiteScript record module (Client Side)
 *
 * @module N/record
 * @NApiVersion 2.x
 *
 */
define('N/record',['N/common/record', 'N/record/recordUtil', 'N/restricted/invoker', 'N/restricted/bridge', 'N/record/recordEvent'],
	function (recordCommon, recordUtil, invoker, api, recordEvent)
	{
		recordCommon.create.promise = function (options)
		{
			return new Promise(
				function (resolve, reject)
				{
					try
					{
						var createArgs = recordUtil.getCreateParams(options, true);
						invoker(api, 'createRecord', [createArgs.type, createArgs.defaults], callback);
					}
					catch (e)
					{
						reject(e);
					}

					function callback(result)
					{
						if (result instanceof Error)
						{
							reject(result);
							return;
						}
						try
						{
							resolve(recordUtil.doCreateRecord(createArgs, result, true/*isPromise*/));
						}
						catch (e)
						{
							reject(e);
						}
					}
				}
			);
		};

		recordCommon.load.promise = function (options)
		{
			return new Promise(
				function (resolve, reject)
				{
					try
					{
						var args = recordUtil.getLoadParams(options, true);
						invoker(api, 'loadRecord', [args.type, args.id, args.defaults], callback);
					}
					catch (e)
					{
						reject(e);
					}

					function callback(result)
					{
						if (result instanceof Error)
						{
							reject(result);
							return;
						}
						try
						{
							resolve(recordUtil.doLoadRecord(args, result, true/*isPromise*/));
						}
						catch (e)
						{
							reject(e);
						}
					}
				}
			);
		};

		recordCommon.copy.promise = function (options)
		{
			return new Promise(
				function (resolve, reject)
				{
					try
					{
						var copyArgs = recordUtil.getCopyParams(options, true);
						invoker(api, 'copyRecord', [copyArgs.type, copyArgs.id, copyArgs.defaults], callback);
					}
					catch (e)
					{
						reject(e);
					}

					function callback(result)
					{
						if (result instanceof Error)
						{
							reject(result);
							return;
						}
						try
						{
							resolve(recordUtil.doCopyRecord(copyArgs, result, true/*isPromise*/));
						}
						catch (e)
						{
							reject(e);
						}
					}
				}
			);
		};

		recordCommon.transform.promise = function (options)
		{
			return new Promise(
				function (resolve, reject)
				{
					try
					{
						var transformArgs = recordUtil.getTransformParams(options, true);
						invoker(api, 'transformRecord', [transformArgs.type, transformArgs.id, transformArgs.transformType, transformArgs.defaults], callback);
					}
					catch (e)
					{
						reject(e);
					}

					function callback(result)
					{
						if (result instanceof Error)
						{
							reject(result);
							return;
						}
						try
						{
							resolve(recordUtil.doTransformRecord(transformArgs, result, true/*isPromise*/));
						}
						catch (e)
						{
							reject(e);
						}
					}
				}
			);
		};

		recordCommon['delete'].promise = function (options)
		{
			return new Promise(
				function (resolve, reject)
				{
					try
					{
						var args = recordUtil.getDeleteParams(options, true);
						invoker(api, 'nlapiDeleteRecord', [args.type, args.id, null], callback);
					}
					catch (e)
					{
						reject(e);
					}

					function callback(result)
					{
						if (result instanceof Error)
						{
							reject(result);
							return;
						}
						try
						{
							resolve(recordUtil.doDeleteRecord(args, result));
						}
						catch (e)
						{
							reject(e);
						}
					}
				}
			);
		};

		recordCommon.submitFields.promise = function (options)
		{
			return new Promise(
				function (resolve, reject)
				{
					try
					{
						var argList = recordUtil.getSubmitFieldsParams(options, true);
						invoker(api, 'nlapiSubmitField', argList, callback);
					}
					catch (e)
					{
						reject(e);
					}

					function callback(result)
					{
						if (result instanceof Error)
						{
							reject(result);
							return;
						}
						try
						{
							resolve(recordUtil.doSubmitFields(result));
						}
						catch (e)
						{
							reject(e);
						}
					}
				}
			);
		};

		recordCommon.attach.promise = function (options)
		{
			return new Promise(
				function (resolve, reject)
				{
					try
					{
						var argList = recordUtil.getAttachParams(options, true);
						invoker(api, 'nlapiAttachRecord', argList, callback);
					}
					catch (e)
					{
						reject(e);
					}

					function callback(result)
					{
						if (result instanceof Error)
						{
							reject(result);
							return;
						}
						try
						{
							resolve();
						}
						catch (e)
						{
							reject(e);
						}
					}
				}
			);
		};

		recordCommon.detach.promise = function (options)
		{
			return new Promise(
				function (resolve, reject)
				{
					try
					{
						var argList = recordUtil.getDetachParams(options, true);
						invoker(api, 'nlapiDetachRecord', argList, callback);
					}
					catch (e)
					{
						reject(e);
					}

					function callback(result)
					{
						if (result instanceof Error)
						{
							reject(result);
							return;
						}
						try
						{
							resolve();
						}
						catch (e)
						{
							reject(e);
						}
					}
				}
			);
		};

		recordCommon.Event = recordEvent.Type;

		return Object.freeze(recordCommon);
	});

/**
 * SuiteScript Form Record Bootstrap Module
 *
 * @module N/currentRecordBootstrap
 * @suiteScriptVersion 2.x
 *
 */
define('N/currentRecordBootstrap',['N/record/recordService', 'N/error', 'N/utilityFunctions', 'N/environment', 'N/msgRouter'],
	function (recordService, error, utilityFunctions, environment, msgRouter)
	{
		var undef = undefined;

		function isSuiteScriptError(obj)
		{
			return obj && obj.toJSON && obj.toJSON().type === 'error.SuiteScriptError';
		}

		var currentRecord = undef;

		/**
		 * Return {Record} [singleton DR-based current record object, if one was already created by a prior call to
		 * getModuleInstance(), otherwise, returnes undefined]
		 */
		function getCurrentRecord()
		{
			return currentRecord;
		}

		/**
		 * Create current record using promise
		 *
		 * @param rawRecord
		 * @return {Record|SuiteScriptError}
		 */
		function getModuleInstance(rawRecord)
		{
			var currentRecordModule = {};
			var toRet;

			if (!isSuiteScriptError(rawRecord))
			{
				try
				{
					environment.setInNewUI();
					var isInteractive = true;

					rawRecord.isClientRecord = true;
					rawRecord.isCurrentRecord = true;
					rawRecord.isInteractive = isInteractive;
					rawRecord.data = rawRecord.data || {};
					rawRecord.data.initialization = {
						method: rawRecord.id ? 'loadRecord' : 'createRecord',
						params: {
							type: rawRecord.metadata.recordType,
							defaults: {}
						}
					};
					/* This will set our currentRecord from within the record creation code, right before pageInit() is called.
					 * That allows currentRecord module to be used inside of pageInit(). */
					rawRecord.initCallback = function initCallback(recordBeingCreated)
					{
						currentRecord = recordBeingCreated.proxy({isInteractive: isInteractive});
					};
					/* Set our currentRecord again once the record has been fully created. */
					toRet = recordService.create(rawRecord);
					currentRecord = toRet;

					msgRouter.showMessagesFromBeforeLoad({currentRecord:currentRecord});
				}
				catch (err)
				{
					toRet = utilityFunctions.createSuiteScriptError(error.Type.CANNOT_CREATE_RECORD_INSTANCE);
					currentRecord = undef;
				}
			}
			else
			{
				if (rawRecord === null || rawRecord === undef)
				{
					toRet = utilityFunctions.createSuiteScriptError(error.Type.CANNOT_CREATE_RECORD_INSTANCE);
				}
				else
				{
					toRet = rawRecord;
				}
			}


			currentRecordModule.get = function ()
			{
				if (isSuiteScriptError(toRet))
				{
					throw toRet;
				}
				return toRet;
			};
			currentRecordModule.get.promise = function ()
			{
				return new Promise(function (resolve, reject)
				{
					if (isSuiteScriptError(toRet))
					{
						reject(toRet);
					}
					else
					{
						resolve(toRet);
					}
				});
			};

			return utilityFunctions.freezeObjectIfPossible(currentRecordModule);
		}

		return {
			getModuleInstance: getModuleInstance,
			getCurrentRecord: getCurrentRecord
		}
	}
);

/**
 * SuiteScript currentField module
 *
 * @private
 * @module N/currentRecord/currentField
 * @NApiVersion 2.x
 *
 */
define('N/currentRecord/currentField',['N/nsobject', 'N/error', 'N/utilityFunctions', 'N/fieldUtil'], function(nsobject, error, utilityFunctions, fieldUtil) {

    /**
     * Return a wrapped nlobjField used for accessing and manipulating the fields on the current record
     *
     * @classDescription Encapsulation of fields on the currentRecord
     * @return {CurrentRecordField}
     * @constructor
     *
     * @since 2015.2
     */
    function nlobjFieldCurrentRecordField(fieldObj)
    {
        /**
         * Return label of the field
         * @name CurrentRecordField#label
         * @type string
         * @since 2015.2
         */
        Object.defineProperty(this, 'label', {
            get: function ()
            {
                return fieldObj.getLabel();
            },
            set: function (label)
            {
                var sublistId = fieldObj.getSubList();
                if (!sublistId)
                {
                    setLabel(fieldObj.getName() + "_fs", label);
                    fieldObj.label = label;
                }
                else
                {
                    if (hasMachine(sublistId))
                    {
                        var mch = eval( String(sublistId) + '_machine');
                        var fldnam = fieldObj.getName();
                        var possibleLabel = mch.getFormElementLabel(mch.getArrayPosition(fldnam));
                        var useDisplay = false;
                        if (possibleLabel === "")
                        {
                            // If the existing column is hidden, we won't display it. Go see if the _display version exists.

                            var displayLabel = mch.getFormElementLabel(mch.getArrayPosition(fldnam + "_display"));
                            if (displayLabel !== "" && displayLabel !== undefined)
                            {
                                // update the object, then the actual value on the machine, then update the array that is used to initialize the objects
                                fieldObj.label = label;
                                mch.setFormElementLabel(fldnam + "_display", label);
                                window.lineitemFieldlabelArray[sublistId][fldnam] = label;
                                window.lineitemFieldlabelArray[sublistId][fldnam + "_display"] = label;
                            }
                            // if it still a hidden field (or doesn't exist), then don't do anything.
                        }
                        else if (possibleLabel !== undefined)
                        {
                            fieldObj.label = label;
                            mch.setFormElementLabel(fldnam, label);
                            window.lineitemFieldlabelArray[sublistId][fldnam] = label;
                        }
                    }
                    else
                    {
                        // No implementation for list machines.
                    }
                }
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return id of the field
         * @name CurrentRecordField#id
         * @readonly
         * @throws READ_ONLY when setting the property is attempted
         * @type string
         * @since 2015.2
         */
        Object.defineProperty(this, 'id', {
            get: function ()
            {
                return fieldObj.getName();
            },
            set: function (val)
            {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'id' );
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return type of the field
         * @name CurrentRecordField#type
         * @readonly
         * @throws READ_ONLY when setting the property is attempted
         * @type string
         * @since 2015.2
         */
        Object.defineProperty(this, 'type', {
            get: function ()
            {
                return fieldObj.getType();
            },
            set: function (val)
            {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'type' );
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return sublist Id of the field, undefined if not applicable
         * @name CurrentRecordField#sublistId
         * @readonly
         * @throws READ_ONLY when setting the property is attempted
         * @type string
         * @since 2015.2
         */
        Object.defineProperty(this, 'sublistId', {
            get: function ()
            {
                return fieldObj.getSubList();
            },
            set: function (val)
            {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'sublistId' );
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return whether the field is mandatory
         * @name CurrentRecordField#isMandatory
         * @type string
         * @since 2015.2
         */
        Object.defineProperty(this, 'isMandatory', {
            get: function ()
            {
                return !!fieldObj.isMandatory();
            },
            set: function (required)
            {
                if (!fieldObj.getSubList())
                {
                    var fldnam = fieldObj.getName();
                    var form = typeof(ftabs) != 'undefined' && ftabs[getFieldName(fldnam)] != null ? document.forms[ftabs[getFieldName(fldnam)] + '_form'] : document.forms['main_form'];
                    if (nsapiIsInternal() || /cust(entity|item|body|column|record|itemnumber|page|event).+/.test(fldnam))
                        setRequired(getFormElement(form, getFieldName(fldnam)), required);
                    fieldObj.required = required;
                }
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return whether the field is Disabled
         * @name CurrentRecordField#isDisabled
         * @type string
         * @since 2015.2
         */
        Object.defineProperty(this, 'isDisabled', {
            get: function ()
            {
                return !!fieldObj.isDisabled();
            },
            set: function (val)
            {
                var sublist = fieldObj.getSubList();
                var fldnam = fieldObj.getName();
                if (!sublist)
                {
                    var form = typeof(ftabs) != 'undefined' && ftabs[getFieldName(fldnam)] != null ? document.forms[ftabs[getFieldName(fldnam)] + '_form'] : document.forms['main_form'];
                    disableField(getFormElement(form, getFieldName(fldnam)), val);
                    if (typeof(ftabs) == 'undefined' || ftabs[getFieldName(fldnam)] == null || ftabs[getFieldName(fldnam)] == "main")
                        nsDisabledFields[fldnam] = val;
                }
                else
                {
                    var fld = getFormElement(document.forms[sublist.toLowerCase() + '_form'], getFieldName(fldnam));
                    if (fld == null)
                        fld = getFormElement(document.forms[sublist.toLowerCase() + '_form'], getFieldName(fldnam) + fieldObj.getLine())
                    disableField(fld, val);
                }
                fieldObj.disabled = val;
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return whether the field is a Popup
         * @name CurrentRecordField#isPopup
         * @readonly
         * @throws READ_ONLY when setting the property is attempted
         * @type string
         * @since 2015.2
         */
        Object.defineProperty(this, 'isPopup', {
            get: function ()
            {
                return !!fieldObj.isPopup();
            },
            set: function (val)
            {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isPopup' );
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return whether the field is Displayed (false means, unlike Visible, the space where it used to be is also not visible)
         * @name CurrentRecordField#isDisplay
         * @type string
         * @since 2015.2
         */
        Object.defineProperty(this, 'isDisplay', {
            get: function ()
            {
                return !!fieldObj.isDisplay();
            },
            set: function (show)
            {
                var sublist = fieldObj.getSubList();
                var fldnam = fieldObj.getName();
                if (!sublist)
                {
                    showFieldAndLabel(fldnam + "_fs", show)
                    if (typeof(ftabs) != 'undefined')
                    {
                        var tabName = ftabs[getFieldName(fldnam)];
                        ns_tabUtils.updateTabVisibility(tabName);
                    }
                    fieldObj.display = show;
                }
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return whether the field is Visible (false means, unlike Display, the space where it used to be is still there, just the field itself is not visible)
         * @name CurrentRecordField#isVisible
         * @type string
         * @since 2015.2
         */
        Object.defineProperty(this, 'isVisible', {
            get: function ()
            {
                return !!fieldObj.isVisible();
            },
            set: function (show)
            {
                if (!fieldObj.getSubList())
                {
                    setFieldAndLabelVisibility(fieldObj.getName() + "_fs", show);
                    fieldObj.visible = show;
                }
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return whether the field is ReadOnly
         * @name CurrentRecordField#isReadOnly
         * @type string
         * @since 2015.2
         */
        Object.defineProperty(this, 'isReadOnly', {
            get: function ()
            {
                return !!fieldObj.isReadOnly();
            },
            set: function (val)
            {
                if (!fieldObj.getSubList())
                {
                    var fldnam = fieldObj.getName();
                    var form = typeof(ftabs) != 'undefined' && ftabs[getFieldName(fldnam)] != null ? document.forms[ftabs[getFieldName(fldnam)] + '_form'] : document.forms['main_form'];
                    var fld = getFormElement(form, getFieldName(fldnam));
                    if (fld != null)
                    {
                        if (fieldObj.getType() !== "textarea")
                        {
                            utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isReadOnly' );
                        }
                        else
                        {
                            setFieldReadOnly(fld, val);
                            fieldObj.readonly = !!fld.readOnly;
                        }
                    }
                }
            },
            enumerable: true,
            configurable: false
        });

	    if (fieldUtil.isSelectType(fieldObj.getType()))
	    {
		    this.getSelectOptions = getSelectOptions;
		    this.insertSelectOption = insertSelectOption;
		    this.removeSelectOption = removeSelectOption;
	    }

	    /**
	     * Returns a list of available options on a select field. This API can be used on both standard and custom select fields. Only the first 1,000 available options will be returned by this API. Does nothing if this field is not a select/multiselect
	     * @param {string} [filter] Will not filter if not present.
	     * @param {string} [filteroperator] Supported operators are contains | is | startswith. If not specified, defaults to the contains operator.
	     * @return {Array}
	     *
	     */
        function getSelectOptions(filter, filteroperator)
        {
	        if (utilityFunctions.isObject(filter))
	        {
		        filteroperator = filter.operator;
		        filter = filter.filter;
	        }

            var sOptions = [];
            var uiField = fieldObj.getUIField();
            var dropdown = (fieldObj.getType() === "select") ? getDropdown(uiField) : getMultiDropdown(uiField);
            if (dropdown)
            {
                var optionValues = dropdown.valueArray;
                var optionTexts = dropdown.textArray;
                var filterfunction = null;
                if (!!filter)
                {
                    filteroperator = filteroperator || "contains";
                    if (filteroperator === "is")
                    {
                        filterfunction = function (v) { return ("" + v).length === filter.length && ("" + v).search(new RegExp(filter, "i")) === 0; };
                    }
                    else if (filteroperator === "startswith")
                    {
                        filterfunction = function (v) { return ("" + v).search(new RegExp(filter, "i")) === 0; }
                    }
                    else if (filteroperator === "contains")
                    {
                        filterfunction = function (v) { return ("" + v).search(new RegExp(filter, "i")) !== -1;}
                    }
                }
                for (var i in optionValues)
                {
                    if ((filterfunction === null) || filterfunction(optionTexts[i]))
                        sOptions[sOptions.length] = {
                            value: optionValues[i],
                            text: optionTexts[i]
                        };
                }
            }
            return sOptions;
        }

	    /**
	     * Inserts a select option to a select/multiselect field added via script.
	     *
	     * @restriction This API can only be used if this field is a select/multiselect and was added via the UI Objects API (e.g. Suitelets or beforeLoad user events)
	     *
	     * @param {Object} options
	     * @param {string} options.value a unique value for the added select option
	     * @param {string} options.text the display name of the added select option
	     * @param {string} [options.isSelected=false] if true, sets this option to be the default selected option.
	     * @throws SSS_INVALID_UI_OBJECT_TYPE when attempting to use this on a field not added via the UI Objects API
	     */
	    function insertSelectOption(options, text)
	    {
		    var value,
			    selected = false,
			    undef = undefined;

		    if (text !== undef)
		    {
			    value = options;
		    }
		    else if (options !== undef && options !== null)
		    {
			    value = options.value;
			    text = options.text;
			    selected = options.isSelected || false;
		    }
		    fieldUtil.verifyPrefixedWithCustPage(fieldObj.getName());
		    utilityFunctions.checkArgs([value, text], ['value', 'text'], 'CurrentField.insertSelectOption');

		    var uiField = fieldObj.getUIField();
		    var isSingleSelect = (fieldObj.getType() === "select");
		    var dropdown = isSingleSelect ? getDropdown(uiField) : getMultiDropdown(uiField);
		    if (dropdown == null)
			    return;

		    if (isSingleSelect)
		    {
			    dropdown.addOption(text, value);
				if (selected) {
					var newIdx = dropdown.getIndexForValue(value);
					dropdown.setIndex(newIdx, true);
				}
		    }
		    else
		    {
			    dropdown.addOption(text, value, selected);
		    }			    
	    }

	    /**
	     * Removes a select option to a select/multiselect field added via script.
	     *
	     * @restriction This API can only be used if this field is a select/multiselect and was added via the UI Objects API (e.g. Suitelets or beforeLoad user events)
	     *
	     * @param {Object} options
	     * @param {string} options.value the value of the select option to be removed, or null to delete all options.
	     * @throws SSS_INVALID_UI_OBJECT_TYPE when attempting to use this on a field not added via the UI Objects API
	     */
	    function removeSelectOption(options)
	    {
		    var undef = undefined,
			    value = ((options !== undef) && (options !== null) && (options.value !== undef)) ? options.value : options;

		    fieldUtil.verifyPrefixedWithCustPage(fieldObj.getName());

		    var uiField = fieldObj.getUIField();
		    var dropdown = (fieldObj.getType() === "select") ? getDropdown(uiField) : getMultiDropdown(uiField);
			if (value !== null){
				utilityFunctions.checkArgs([value], ['value'], 'CurrentField.removeSelectOption');
				dropdown.deleteOneOption(value);
			}
		    else
				dropdown.deleteAllOptions();
	    }
    }

    function pojsoCurrentRecordField(fieldObj)
    {
        var internalField = {};

        Object.defineProperty(this, 'label', {
            get: function(){ return fieldObj.label; },
            set: function(value){ utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'label' ); },
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'id', {
            get: function(){ return fieldObj.name; },
            set: function(value){ utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'id' ); },
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'type', {
            get: function(){ return fieldObj.type; },
            set: function(value){ utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'type' ); },
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'sublistId', {
            get: function(){ return fieldObj.machinename; },
            set: function(value){ utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'sublistId' ); },
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'isMandatory', {
            get: function(){ return fieldObj.required;},
            set: function(value){ utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isMandatory' ); },
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'isDisabled', {
            get: function(){ return fieldObj.isDisabled;},
            set: function(value){ utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isDisabled' ); },
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'isPopup', {
            get: function(){ return fieldObj.isPopup;},
            set: function(value){ utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isPopup' ); },
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'isDisplay', {
            get: function(){ return fieldObj.isDisplay;},
            set: function(value){ utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isDisplay' ); },
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'isVisible', {
            get: function(){ return fieldObj.isVisible;},
            set: function(value){ utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isVisible' ); },
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'isReadOnly', {
            get: function(){ return fieldObj.readonly;},
            set: function(value){ utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isReadOnly' ); },
            enumerable: true,
            configurable: false
        });
        this.getSelectOptions = fieldObj.getSelectOptions;
	    this.insertSelectOption = fieldObj.insertSelectOption;
	    this.removeSelectOption = fieldObj.removeSelectOption;
    }
    /*
     noSlaving
     isDisabled
     isPopup
     isDisplay
     isVisible
     */


    function CurrentRecordField(fieldObj)
    {
        var that = this,
                internalField = fieldObj instanceof nlobjField ? new nlobjFieldCurrentRecordField(fieldObj) : new pojsoCurrentRecordField(fieldObj);

        Object.defineProperty(this, 'label', {
            get: function () { return internalField.label;},
            set: function (value) { internalField.label = value;},
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'id', {
            get: function () { return internalField.id;},
            set: function (value) { internalField.id = value;},
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'type', {
            get: function () { return internalField.type;},
            set: function (value) { internalField.type = value;},
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'sublistId', {
            get: function () { return internalField.sublistId;},
            set: function (value) { internalField.sublistId = value;},
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'isMandatory', {
            get: function () { return internalField.isMandatory;},
            set: function (value) { internalField.isMandatory = value;},
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'isDisabled', {
            get: function () { return internalField.isDisabled;},
            set: function (value) { return internalField.isDisabled = value;},
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'isPopup', {
            get: function () { return internalField.isPopup;},
            set: function (value) { return internalField.isPopup = value;},
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'isDisplay', {
            get: function () { return internalField.isDisplay;},
            set: function (value) { return internalField.isDisplay = value;},
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'isVisible', {
            get: function () { return internalField.isVisible;},
            set: function (value) { return internalField.isVisible = value;},
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'isReadOnly', {
            get: function () { return internalField.isReadOnly;},
            set: function (value) { internalField.isReadOnly = value;},
            enumerable: true,
            configurable: false
        });
        this.getSelectOptions = internalField.getSelectOptions;
	    this.insertSelectOption = internalField.insertSelectOption;
	    this.removeSelectOption = internalField.removeSelectOption;
        this.toJSON = function ()
        {
            return {
                id: that.id,
                label: that.label,
                type: that.type,
                sublistId: that.sublistId,
                isMandatory: that.isMandatory,
                isDisabled: that.isDisabled,
                isPopup: that.isPopup,
                isDisplay: that.isDisplay,
                isVisible: that.isVisible,
                isReadOnly: that.isReadOnly
            };
        };
        this.toString = function ()
        {
            return "currentRecordField";
        };
    }
    CurrentRecordField.prototype = nsobject.getNewInstance();
    Object.freeze(CurrentRecordField);

    return Object.freeze({
        /**
         * return a new instance of field object
         * @param {Object} fieldObj
         * @returns {CurrentRecordField}
         */
        create: function(fieldObj)
        {
            return !fieldObj ? null : new CurrentRecordField(fieldObj);
        },
        isSelectType: fieldUtil.isSelectType,
        Type: fieldUtil.SELECT_FIELD_TYPES
    });
});

/**
 * SuiteScript currentSublist module
 *
 * @private
 * @module N/currentRecord/currentSublist
 * @NApiVersion 2.x
 *
 */
define('N/currentRecord/currentSublist',['N/nsobject', 'N/error', 'N/utilityFunctions'], function(nsobject, error, utilityFunctions) {
    var SUBLIST_TYPE = Object.freeze({
        INLINE_EDITOR : 'inlineeditor',
        EDITOR : 'editor',
        STATIC_LIST : 'staticlist',
        LIST: 'list'
    });

    /**
     * Return a wrapped nlobjSublist used for accessing and manipulating the sublists on the current record
     *
     * @classDescription Encapsulation of sublists on the currentRecord
     * @return {CurrentRecordSublist}
     * @constructor
     *
     * @since 2015.2
     */
    function CurrentRecordSublist( sublistObj )
    {

        /**
         * Return the label of the given field's column
         * @name CurrentRecordField#getFieldLabel
         * @param fieldId the field that the label is associated with
         * @return {String} the label of the given field. null if sublist or fieldId doesn't exist.
         * @since 2015.2
         */
        this.getFieldLabel = function(options) //fieldId)
        {
            var fieldId = options.fieldId;
            var sublistName = sublistObj.getName();
            if (hasMachine(sublistName))
            {
                var mch = eval( String(sublistName) + '_machine');
                return mch.getFormElementLabel(mch.getArrayPosition(fieldId));
            }
            return null;
        };

        /**
         * Set the label of the given field's column
         * @name CurrentRecordField#setFieldLabel
         * @param fieldId the field that the label is associated with
         * @param label the new label name to set
         * @since 2015.2
         */
        this.setFieldLabel = function (options) //fieldId, label)
        {
            var fieldId = options.fieldId;
            var label = options.label;
            var sublistName = sublistObj.getName();
            if (isEditMachine(sublistName))
            {
                var mch = eval(String(sublistName) + '_machine');
                mch.setFormElementLabel(fieldId, label);
            }
        };

        /**
         * Return the id of the sublist
         * @name CurrentRecordField#id
         * @readonly
         * @throws READ_ONLY when setting the property is attempted
         * @type string
         * @since 2015.2
         */
        this.getName = function() { return sublistObj.getName(); };

        /**
         * Return the type of the sublist
         * @name CurrentRecordField#type
         * @readonly
         * @throws READ_ONLY when setting the property is attempted
         * @type string
         * @since 2015.2
         */
        this.getType = function() { return sublistObj.getType(); };

        /**
         * Return whether the sublist is hidden or not.
         * @name CurrentRecordField#isHidden
         * @readonly
         * @throws READ_ONLY when setting the property is attempted
         * @type string
         * @since 2015.2
         */
        this.isHidden = function() { return sublistObj.isHidden(); };

        /**
         * Return whether the sublist is displayed or not.
         * @name CurrentRecordField#isDisplay
         * @readonly
         * @throws READ_ONLY when setting the property is attempted
         * @type string
         * @since 2015.2
         */
        this.isDisplay = function() { return sublistObj.isDisplay(); };

        /**
         * Return whether the sublist has been changed or not.
         * For List machines, it will return true when ANY field has changed
         * For Edit machines, once any line change is committed to the hidden fields of the machine.
         * @name CurrentRecordField#isChanged
         * @readonly
         * @throws READ_ONLY when setting the property is attempted
         * @type string
         * @since 2015.2
         */
        this.isChanged = function() { return wasMachineChanged(sublistObj.getName()); };

        /**
         * Return whether the current Line of the sublist has been changed or not.
         * For List machines, it will return true when ANY field has changed
         * For Edit machines, when ANY field on the CURRENT line is changed. Once that line is committed, it returns false again.
         * @name CurrentRecordField#isCurrentLineChanged
         * @readonly
         * @throws READ_ONLY when setting the property is attempted
         * @type string
         * @since 2015.2
         */
        this.isCurrentLineChanged = function() { return  isMachineChanged(sublistObj.getName()); };

        this.getColumn = function(options)
        {
            var undef = undefined,
                fieldId = options !== undef && options !== null && options.fieldId !== undef ? options.fieldId : options,
                returnMe = null;

            utilityFunctions.checkArgs([fieldId], ['fieldId'], 'CurrentSublist.getColumn');
            var fieldInfo = nlapiGetLineItemField(sublistObj.getName(), fieldId);
            if (fieldInfo !== null)
            {
                returnMe = {
                              getName: function() { return fieldInfo.name; },
                              getType: function() { return fieldInfo.type; },
                              getLabel: function() { return fieldInfo.label; },
                              setLabel: function() {},
                              getSublistId: function() { return sublistObj.getName()}
                           };
            }

            return returnMe;
        };

        // Functions for debugger
        this.toJSON = function ()
        {
            return {
                id: this.getName(),
                type: this.getType(),
                isChanged: this.isChanged(),
                isDisplay: this.isDisplay()
            };
        };

        this.toString = function ()
        {
            return "currentRecordSublist";
        };
    }
    CurrentRecordSublist.prototype = nsobject.getNewInstance();
    Object.freeze(CurrentRecordSublist);

    return Object.freeze({
        /**
         * return a new instance of sublist object
         * @param {Object} sublistObj
         * @returns {CurrentRecordSublist}
         */
        create: function(sublistObj) { return new CurrentRecordSublist(sublistObj); },
        /**
         * @enum
         */
        Type: SUBLIST_TYPE
    });
});

/**
 * SuiteScript currentSubrecord module
 *
 * This is the V1/V2 implementation for all record methods, executed against the legacy DOM current record
 *
 * @private
 * @module N/currentRecord/currentSubrecord
 * @NApiVersion 2.x
 *
 */
define(
	'N/currentRecord/currentSubrecord',['N/utilityFunctions', 'N/error', 'N/util/formatter', 'N/currentRecord/currentField', 'N/currentRecord/currentSublist', 'N/record/recordUtilityFunctions',
	 'N/record/recordProxy', 'N/record/recordConstants'],
	function (utilityFunctions, error, formatter, field, sublist, recordUtil,
			  recordProxy, constants)
	{
		/**
		 * Current Subrecord interface
		 * @return {CurrentSubrecord}
		 * @constructor
		 * @since 2015.2
		 */
		function CurrentSubrecord(subrecordParent, subrecordObj)
		{
			var subrecordParent = subrecordParent;

			var recordOptions = {
				isClientRecord: true,
				isDynamic : true,
				isReadOnly : false,
				isCurrentRecord : true,
				isSubrecord : true
			};

			var that = this;

			/**
			 * The id of the record
			 * @name Record#id
			 * @type number
			 * @readonly
			 */
			this.id = null;

			/**
			 * The type of the record
			 * @name Record#type
			 * @type string
			 * @readonly
			 */
			this.type = null;

			/**
			 * return true if record is a dynamic record
			 * @name Record#isDynamic
			 * @type boolean
			 * @readonly
			 */
			this.isDynamic = true;

			/**
			 * JSON.stringify() implementation.
			 * @returns {Object}
			 */
			this.toJSON = function ()
			{
				var result = {};

				result.type = this.type;
				result.id = this.id;
				result.isDynamic = true;

				result.fields = subrecordObj.recordmanager.getFieldNames().reduce(function (p, c, i, a)
																				  {
																					  p[c] = subrecordObj.recordmanager.getFieldValue(c);

																					  return p;
																				  }, {});

				return result;
			};
			/**
			 * Returns the object type name for the implementation.
			 * @returns {string}
			 */
			function toString()
			{
				return constants.RECORD_UNDERLYING_IMPL_NAME.DOM_CURRENT_SUBRECORD;
			}

			this.toString = toString;

			/**
			 * remove body field data
			 * @param {string} fieldId
			 * @return {CurrentSubrecord}
			 */
			this.removeField = function (options)
			{
				var undef = undefined,
					fieldId;

				fieldId = options !== undef && options !== null && options.fieldId !== undef ? options.fieldId : options;

				utilityFunctions.checkArgs([fieldId], ['fieldId'], 'CurrentSubrecord.removeField');

				utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.removeField');
			};

			/**
			 * return array of names of all body fields, including machine header field and matrix header fields
			 * @return {array}
			 */
			this.getFields = function ()
			{
				return subrecordObj.recordmanager.getFieldNames();
			};

			/**
			 * return array of names of all sublists
			 * @return {array}
			 */
			this.getSublists = function ()
			{
				utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.getSublists');
			};

			/**
			 * return array of names of all fields in a sublist
			 * @param {string} sublistId
			 * @return {array}
			 */
			this.getSublistFields = function (options)
			{
				var undef = undefined,
					result,
					sublistId, sublist;

				sublistId = options !== undef && options !== null && options.sublistId !== undef ? options.sublistId : options;

				utilityFunctions.checkArgs([sublistId], ['sublistId'], 'CurrentSubrecord.getValue');

				sublist = subrecordObj.getChildMachineRecordManager(sublistId);

				result = !!sublist && sublist.getFieldNames() || null;

				return result;
			};

			/**
			 * return value of the field
			 *
			 * @param {string} fieldId
			 * @return {number|date|string|array}
			 *
			 */
			this.getValue = function (options)
			{
				var undef = undefined,
					fieldId,
					value, field;

				fieldId = options !== undef && options !== null && options.fieldId !== undef ? options.fieldId : options;

				utilityFunctions.checkArgs([fieldId], ['fieldId'], 'CurrentSubrecord.getValue');

				value = subrecordObj.getFieldValue(fieldId);
				field = subrecordObj.recordmanager.getField(fieldId);

				return !field ? undefined : formatter.parse(value, field.type, field.isNumeric, field.isCurrency, field.validationType);
			};

			/**
			 * set value of the field
			 *
			 * @param {string} fieldId
			 * @param {number|date|string|array} value
			 * @return {CurrentSubrecord}
			 *
			 */
			this.setValue = function (options, value)
			{
				var undef = undefined,
					fieldId;

				if (value !== undef)
				{
					fieldId = options;
				}
				else if (options !== undef && options !== null)
				{
					fieldId = options.fieldId;
					value = options.value;
				}

				utilityFunctions.checkArgs([fieldId, value], ['fieldId', 'value'], 'CurrentSubrecord.setValue');

				utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.setValue');
			};

			/**
			 * get value of the field in text representation
			 * @param {string} fieldId
			 * @return {string}
			 */
			this.getText = function (options)
			{
				var undef = undefined,
					fieldId,
					value, field;

				fieldId = options !== undef && options !== null && options.fieldId !== undef ? options.fieldId : options;

				utilityFunctions.checkArgs([fieldId], ['fieldId'], 'CurrentSubrecord.getText');

				value = subrecordObj.getFieldValue(fieldId);
				field = subrecordObj.recordmanager.getField(fieldId);

				if (!!field && field.type === 'select')
				{
					utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.getText');
				}

				return !field ? undefined : formatter.format(value, field.type, field.isNumeric, field.isCurrency, false);
			};

			/**
			 * set value of the field by text representation
			 *
			 * @param {string} fieldId
			 * @param {string} value
			 * @return {CurrentSubrecord}
			 */
			this.setText = function (options, value)
			{
				var undef = undefined,
					fieldId;

				if (value !== undef)
				{
					fieldId = options;
				}
				else if (options !== undef && options !== null)
				{
					fieldId = options.fieldId;
					value = options.value;
				}

				utilityFunctions.checkArgs([fieldId, value], ['fieldId', 'value'], 'CurrentSubrecord.setText');

				utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.setText');
			};

			/**
			 * return field object from record
			 * @param {string} fieldId
			 * @return {Field}
			 */
			this.getField = function (options)
			{
				var undef = undefined,
					fieldId, fldObj;

				fieldId = options !== undef && options !== null && options.fieldId !== undef ? options.fieldId : options;

				utilityFunctions.checkArgs([fieldId], ['fieldId'], 'CurrentSubrecord.getField');

				fldObj = subrecordObj.recordmanager.getField(fieldId);

				return !fldObj ? undefined : field.create(fldObj);
			};

			/**
			 * return field object from record
			 * return field object from record's sublist
			 * @param {string} sublistId
			 * @param {string} fieldId
			 * @param {number} line
			 * @return {Field}
			 */
			this.getSublistField = function (options, fieldId, line)
			{
				var undef = undefined,
					sublistId,
					fldObj;

				if (fieldId !== undef && line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					line = options.line;
				}

				utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], 'CurrentSubrecord.getSublistField');

				fldObj = subrecordObj.getChildMachineRecordManager(sublistId).getField(fieldId);

				return !fldObj ? undef : field.create(fldObj);
			};

			/**
			 * return line count of sublist
			 * @param {string} sublistId
			 * @return {number}
			 */
			this.getLineCount = function ()
			{
				var undef = undefined,
					result,
					sublistId;

				sublistId = options !== undef && options !== null && options.sublistId !== undef ? options.sublistId : options;

				utilityFunctions.checkArgs([sublistId], ['sublistId'], 'CurrentSubrecord.getLineCount');

				try
				{
					result = subrecordObj.getLineItemCount(sublistId);
				}
				catch (e)
				{
					result = -1;
				}

				return result;
			};

			/**
			 * insert a sublist line
			 * @param {string} sublistId
			 * @param {number} line
			 * @param {boolean} [ignoreRecalc=false] ignore recalc scripting
			 * @return {CurrentSubrecord}
			 */
			this.insertLine = function (options, line)
			{
				var undef = undefined,
					sublistId,
					ignoreRecalc = false;

				if (line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					line = options.line;
					ignoreRecalc = !!options.ignoreRecalc;
				}

				utilityFunctions.checkArgs([sublistId, line], ['sublistId', 'line'], 'CurrentRecord.insertLine');

				utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.insertLine');
			};

			/**
			 * remove a sublist line
			 * @param {string} sublistId
			 * @param {number} line
			 * @param {boolean} [ignoreRecalc=false] ignore recalc scripting
			 * @return {CurrentSubrecord}
			 */
			this.removeLine = function (options, line)
			{
				var undef = undefined,
					sublistId,
					ignoreRecalc = false;

				if (line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					line = options.line;
					ignoreRecalc = !!options.ignoreRecalc;
				}

				utilityFunctions.checkArgs([sublistId, line], ['sublistId', 'line'], 'CurrentRecord.removeLine');

				utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.removeLine');
			};

			/**
			 * return the line number for the first occurrence of a field value in a sublist
			 * @param {string} sublistId
			 * @param {string} fieldId
			 * @param {number|date|string|array} value
			 * @return {number}
			 */
			this.findSublistLineWithValue = function (options, fieldId, value)
			{
				var undef = undefined,
					result = -1,
					sublistId,
					field,
					i, v;

				if (fieldId !== undef && value !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					value = options.value;
				}

				utilityFunctions.checkArgs([sublistId, fieldId, value], ['sublistId', 'fieldId', 'value'], 'CurrentSubrecord.findSublistLineWithValue');

				field = subrecordObj.recordmanager.getField(fieldId);
				sublist = subrecordObj.getChildMachineRecordManager(sublistId);
				if (!!field && !!sublist)
				{
					for (i = 0; i < sublist.rows.length; i++)
					{
						v = formatter.parse(sublist.rows[i][sublist.fldIdx[fieldId]], field.type, field.isNumeric, field.isCurrency, field.validationType);

						if (v === value)
						{
							result = i;
							break;
						}
					}
				}

				return result;
			};

			/**
			 * cancel the current selected line
			 * @param {string} sublistId
			 * @return {CurrentSubrecord}
			 */
			this.cancelLine = function (options)
			{
				var undef = undefined,
					sublistId;

				sublistId = options !== undef && options !== null && options.sublistId !== undef ? options.sublistId : options;

				utilityFunctions.checkArgs([sublistId], ['sublistId'], 'CurrentSubrecord.cancelLine');

				utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.cancelLine');
			};

			/**
			 * commit the current selected line
			 * @param {string} sublistId
			 * @return {CurrentSubrecord}
			 */
			this.commitLine = function (options)
			{
				var undef = undefined,
					sublistId;

				sublistId = options !== undef && options !== null && options.sublistId !== undef ? options.sublistId : options;

				utilityFunctions.checkArgs([sublistId], ['sublistId'], 'CurrentSubrecord.commitLine');

				utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.commitLine');
			};

			/**
			 * select line
			 * @param {string} sublistId
			 * @param {number} line
			 * @return {CurrentSubrecord}
			 */
			this.selectLine = function (options, line)
			{
				var undef = undefined,
					sublistId;

				if (line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					line = options.line;
				}

				utilityFunctions.checkArgs([sublistId, line], ['sublistId', 'line'], 'CurrentRecord.selectLine');
				line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentRecord.selectLine", subrecordObj.getLineItemCount(sublistId));
				subrecordObj.selectLineItem(sublistId, line);
			};

			/**
			 * select a new line at the end of sublist
			 * @param {string} sublistId
			 * @return {CurrentSubrecord}
			 */
			this.selectNewLine = function (options)
			{
				var undef = undefined,
					sublistId;

				sublistId = options !== undef && options !== null && options.sublistId !== undef ? options.sublistId : options;

				utilityFunctions.checkArgs([sublistId], ['sublistId'], 'CurrentSubrecord.selectNewLine');

				utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.selectNewLine');
			};

			/**
			 * return value of a sublist field on the current selected sublist line
			 * @param {string} sublistId
			 * @param {string} fieldId
			 * @return {number|date|string|array}
			 */
			this.getCurrentSublistValue = function (options, fieldId)
			{
				var undef = undefined,
					sublistId, sublist,
					value, field;

				if (fieldId !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
				}

				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], 'CurrentRecord.getCurrentSublistValue');

				sublist = subrecordObj.getChildMachineRecordManager(sublistId);
				if (!!sublist)
				{
					value = sublist.getFieldValue(fieldId);
					field = sublist.getField(fieldId);
				}

				return !field ? undefined : formatter.parse(value, field.type, field.isNumeric, field.isCurrency, field.validationType);
			};

			/**
			 * return value of a sublist field on the current selected sublist line
			 * @param {string} sublistId
			 * @param {string} fieldId
			 * @param {string} line
			 * @return {number|date|string|array}
			 */
			this.getSublistValue = function (options, fieldId, line)
			{
				var undef = undefined,
					sublistId, sublist,
					value, field;

				if (fieldId !== undef && line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					line = options.line;
				}

				utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], 'CurrentRecord.getSublistValue');
				line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentRecord.getSublistValue", subrecordObj.getLineItemCount(sublistId));
				sublist = subrecordObj.getChildMachineRecordManager(sublistId);
				if (!!sublist)
				{
					value = sublist.getFieldValue(fieldId, line);
					field = sublist.getField(fieldId);
				}

				return !field ? undefined : formatter.parse(value, field.type, field.isNumeric, field.isCurrency, field.validationType);
			};

			/**
			 * set the value for field in the current selected line
			 * @param {string} sublistId
			 * @param {string} fieldId
			 * @param {number|date|string|array} value
			 * @returns {CurrentSubrecord}
			 */
			this.setCurrentSublistValue = function (options, fieldId, value)
			{
				var undef = undefined,
					sublistId;

				if (fieldId !== undef && value !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					value = options.value;
				}

				utilityFunctions.checkArgs([sublistId, fieldId, value], ['sublistId', 'fieldId', 'value'], 'CurrentSubrecord.setCurrentSublistValue');

				utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.setCurrentSublistValue');
			};

			/**
			 * return the value for field in the current selected line by text representation
			 * @param {string} sublistId
			 * @param {string} fieldId
			 * @returns {string}
			 */
			this.getCurrentSublistText = function (options, fieldId)
			{
				var undef = undefined,
					sublistId, sublist,
					value, field;

				if (fieldId !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
				}

				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], 'CurrentRecord.getCurrentSublistText');

				sublist = subrecordObj.getChildMachineRecordManager(sublistId);
				if (!!sublist)
				{
					value = sublist.getFieldValue(fieldId);
					field = sublist.getField(fieldId);

					if (!!field && field.type === 'select')
					{
						utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.getCurrentSublistText');
					}
				}

				return !field ? undefined : formatter.format(value, field.type, field.isNumeric, field.isCurrency, false);
			};

			/**
			 * return the value for field in the current selected line by text representation
			 * @param {string} sublistId
			 * @param {string} fieldId
			 * @param {number} line
			 * @returns {string}
			 */
			this.getSublistText = function (options, fieldId, line)
			{
				var undef = undefined,
					sublistId, sublist,
					value, field;

				if (fieldId !== undef && line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					line = options.line;
				}

				utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], 'CurrentRecord.getSublistText');
				line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentRecord.getSublistText", subrecordObj.getLineItemCount(sublistId));
				sublist = subrecordObj.getChildMachineRecordManager(sublistId);
				if (!!sublist)
				{
					value = sublist.getFieldValue(fieldId, line);
					field = sublist.getField(fieldId);

					if (!!field && field.type === 'select')
					{
						utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.getSublistText');
					}
				}

				return !field ? undefined : formatter.format(value, field.type, field.isNumeric, field.isCurrency, false);
			};

			/**
			 * set the value for field in the current selected line by text representation
			 * @param {string} sublistId
			 * @param {string} fieldId
			 * @param {number|date|string|array} value
			 * @returns {CurrentSubrecord}
			 */
			this.setCurrentSublistText = function (options, fieldId)
			{
				var undef = undefined,
					sublistId;

				if (fieldId !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
				}

				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], 'CurrentSubrecord.setCurrentSublistText');

				utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.setCurrentSublistText');
			};

			/**
			 * return the line number of current selected line
			 * @param {string} sublistId
			 * @type {number}
			 */
			this.getCurrentSublistIndex = function ()
			{
				var lineNum = subrecordObj.linenum;
				return recordUtil.getZeroBasedIndex(lineNum);
			};

			/**
			 * copy the subrecord inorder to perform cancellable actions
			 * @returns {CurrentSubrecord}
			 */
			//this.copy = function()
			//{
			//    throw error.create({name: 'NOT_DONE_YET', message: 'CurrentSubrecord.copy'});
			//};

			/**
			 * merge changes into original subrecord
			 * @returns {CurrentSubrecord}
			 */
			//this.merge = function()
			//{
			//    throw error.create({name: 'NOT_DONE_YET', message: 'CurrentSubrecord.merge'});
			//};

			/* --- Start of proxy cache mechanism --- */

			this.proxy = recordProxy.proxy.bind(null, this, recordOptions);

			/* --- End of proxy cache mechanism --- */

			return that;
		}

		/**
		 * return a new instance of field object
		 * @param {Object} subrecordParent
		 * @param {Object} subrecordObj
		 * @returns {CurrentSubrecord}
		 */
		function create(subrecordParent, subrecordObj)
		{
			if (!subrecordObj)
				return undefined;
			else
			{
				var subrecord = new CurrentSubrecord(subrecordParent, subrecordObj);
				return subrecord;
			}
		}

		return Object.freeze({create: create});
	});

/**
 * SuiteScript module
 *
 * This is the V1/V2 implementation for all record methods, executed against the legacy DOM current record
 *
 * @private
 * @module N/domCurrentRecord
 * @NApiVersion 2.x
 */
define(
	'N/domCurrentRecord',['N/error', 'N/utilityFunctions', 'N/record/recordUtilityFunctions', 'N/restricted/bridge', 'N/restricted/remoteApiBridge', 'N/restricted/invoker',
	 'N/record/recordProxy', 'N/record/recordConstants',
	 'N/util/formatter', 'N/util/validator', 'N/currentRecord/currentField', 'N/currentRecord/currentSublist',
	 'N/currentRecord/currentSubrecord', 'N/metadata/fieldMetadata',
	 'N/metadata/sublistMetadata', 'N/msgRouter'],
	function (error, utilityFunctions, recordUtil, apiBridge, remoteApi, invoker,
			  recordProxy, constants,
			  formatter, validator, field, sublist,
			  domSubrecord, fieldMetadata,
			  sublistMetadata, msgRouter)
	{
		var V1api = null;
		var currentRecord = {};

		var recordOptions = {
			isClientRecord: true,
			isSubrecord: false,
			isDynamic: true,
			isReadOnly: false,
			isCurrentRecord: true
		};

		var actionCache = {};

		/*
		 * This provides us with a set of all the needed API's for V1, getting them from the only available source,
		 * currentRecord.js (and only once).  That class has special-case built for it (mostly located in NsRequre.js)
		 * which ehsures ONLY currentRecord.js is given access to the full V1 API in the V2 world. That made it a bit
		 * harder here.
		 *
		 * I moved all DOM-related record implementation code out of currentRecord, as a matter of cleanup, to give
		 * that class only a single reason to change, and creted domCurrentRecord, which specializes in being a V2-like
		 * record implementation built on V1 calls.
		 *
		 * For complex reasons that I don't fully understand, currentRecord will not be given have assess to the V1 API's
		 * at module instantiation time, but much later, right before record methods get nivoked. Therefore, I had to
		 * defer the mechanism whereby domCurrentRecord gets the set of needed V1 API's from currentRecord until the
		 * point right before any V1 code is called.
		 */
		function getV1api()
		{
			return V1api;
		}

		/**
		 * Returns the object type name for the implementation.
		 * @returns {string}
		 */
		function toString()
		{
			return constants.RECORD_UNDERLYING_IMPL_NAME.DOM_CURRENT_RECORD;
		}

		currentRecord.toString = toString;

		var messageService;
		currentRecord.getMessageService = function getMessageService()
		{
			if (!messageService)
				messageService = msgRouter.getMessageServiceInstance();
			return messageService;
		};

		function getMacrosMetadata(limited)
		{
			var macroMetadata = typeof _macro !== 'undefined' && _macro.macroMetadata || [];
			var macroList = [];

			macroMetadata.forEach(
				function (metadata)
				{
					var macro = {
						// basic info for the user
						id: metadata.id,
						'package': metadata['package'],
						label: metadata.label,
						description: metadata.description,
						attributes: metadata.attributes
					};
					if (!limited)
					{
						// all props for internal use
						for (var attr in metadata)
						{ macro[attr] = metadata[attr]; }
					}
					macroList.push(macro);
				});
			return macroList;
		}

		function getMacroMetadata(options)
		{
			return getMacrosMetadata(options.limited).filter(
				function (macro)
				{
					return (macro.id === options.id
							&& macro['package'] === options['package']);
				})[0];
		}

		function getMacros()
		{
			var Macros = {};
			getMacrosMetadata().forEach(
				function (macroDef)
				{
					var macro = getMacro({id: macroDef.id, 'package': macroDef['package']});
					if (!macro['package'])
						Macros[macro.id] = macro;
					else
					{
						if (Macros[macro['package']] === undefined)
						{
							Macros[macro['package']] = {};
						}
						Macros[macro['package']][macro.id] = macro;
					}
				});
			return Object.freeze(Macros);
		}

		currentRecord.getMacros = getMacros;

		function getMacro(options)
		{
			var id, pckgId;
			if (options !== undefined && options !== null)
			{
				id = options.id;
				pckgId = options['package'];
			}
			utilityFunctions.checkArgs([id], ['id'], 'CurrentRecord.getMacro');
			pckgId = pckgId || '';

			var macro = getMacroMetadata({'id': id, 'package': pckgId, limited: true});
			if (!macro)
				return null;

			var Macro = function (params)
			{
				return currentRecord.executeMacro({'id': macro.id, 'package': macro['package'], 'params': params});
			};
			Macro.execute = function (params)
			{
				return currentRecord.executeMacro({'id': macro.id, 'package': macro['package'], 'params': params});
			};
			Macro.promise = function (params)
			{
				return currentRecord.executeMacro.promise({
															  'id': macro.id,
															  'package': macro['package'],
															  'params': params
														  });
			};
			Macro.execute.promise = Macro.promise;

			var jsonDescription = {};

			// add metadata
			for (var attr in macro)
			{
				Macro[attr] = macro[attr];

				if (!!Macro[attr])
					jsonDescription[attr] = Macro[attr];
			}

			Macro.toJSON = function() {
				return Object.freeze(jsonDescription);
			};

			Macro.toString = function() {
				return 'Macro' + JSON.stringify(Macro.toJSON());
			};

			return Object.freeze(Macro);
		}

		currentRecord.getMacro = getMacro;

		var executeMacro = function (options)
		{
			msgRouter.pushQueue(currentRecord);
			if (typeof(nlapi) !== 'undefined' && nlapi && nlapi.async) nlapi.async.prepareForAsync({info: {}, record: currentRecord});
			try {
				return doExecuteMacro(options);
			}
			finally {
				if (typeof(nlapi) !== 'undefined' && nlapi && nlapi.async) nlapi.async.unloadAsync();
				msgRouter.popQueue();
			}
		};
		currentRecord.executeMacro = executeMacro;

		executeMacro.promise = function (options)
		{
			var myPromise = new Promise(
				function (resolve, reject)
				{
					// set message queue for whatever happens synchronously
					var queueCount = msgRouter.pushQueue(currentRecord);
					// a reflet maintains info about current script execution
					// we need to restore this once promise is fulfilled
					var scriptRun;
					if (typeof apiBridge["getScript"] !== "undefined")
					{
						scriptRun = apiBridge["getScript"].apply(apiBridge, []);
					}
					// make sure context is set correctly for asynchronous operations (e.g. require)
					if (typeof(nlapi) !== 'undefined' && nlapi && nlapi.async) nlapi.async.prepareForAsync({info: {}, record: currentRecord});

					try
					{
						var myResolve = function (result)
						{
							if (!!scriptRun && typeof apiBridge["recoverScript"] !== "undefined")
							{
								apiBridge["recoverScript"].apply(apiBridge, [scriptRun]);
								window.NLScriptId = scriptRun.scriptId;
							}
							if (typeof(nlapi) !== 'undefined' && nlapi && nlapi.async) nlapi.async.unloadAsync();
							msgRouter.popQueue(queueCount);
							resolve(result);
						};
						var myReject = function (result)
						{
							if (!!scriptRun && typeof apiBridge["recoverScript"] !== "undefined")
							{
								apiBridge["recoverScript"].apply(apiBridge, [scriptRun]);
								window.NLScriptId = scriptRun.scriptId;
							}
							if (typeof(nlapi) !== 'undefined' && nlapi && nlapi.async) nlapi.async.unloadAsync();
							msgRouter.popQueue(queueCount);
							reject(result);
						};
						doExecuteMacro(options, {'resolve': myResolve, 'reject': myReject});
					}
					catch (e)
					{
						if (!!scriptRun && typeof apiBridge["recoverScript"] !== "undefined")
						{
							apiBridge["recoverScript"].apply(apiBridge, [scriptRun]);
							window.NLScriptId = scriptRun.scriptId;
						}
						if (typeof(nlapi) !== 'undefined' && nlapi && nlapi.async) nlapi.async.unloadAsync();
						msgRouter.popQueue(queueCount);
						reject(e);
					}
				}
			);
			return myPromise;
		};

		function doExecuteMacro(options, callbacks)
		{
			var id, pckgId, params;
			if (options !== undefined && options !== null)
			{
				id = options.id;
				pckgId = options['package'];
				params = options.params;
			}
			utilityFunctions.checkArgs([id], ['id'], 'CurrentRecord.executeMacro');
			pckgId = pckgId || '';
			if (params === undefined)
				params = null;

			var macroDef = getMacroMetadata({'id': id, 'package': pckgId});
			if (!macroDef)
				utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_MACRO_ID, id);

			var modulePath = macroDef.modulePath;
			var functionName = macroDef.id;
			var context = {'context': macroDef.context};

			if (callbacks)
			{
				var macroHasPromise = false;
				require([modulePath], function (mod)
				{
					var requirePromise = new Promise(function (requireResolve, requireReject)
					{
						try
						{
							var macroFunc = mod[functionName];
							if (macroFunc && typeof(macroFunc.promise) === 'function')
							{
								macroFunc = macroFunc.promise;
								macroHasPromise = true;
							}
							if (typeof(macroFunc) === 'function')
								requireResolve(macroFunc);
							else
								requireReject(error.create(error.Type.SSS_INVALID_MACRO_ID));
						}
						catch (e)
						{
							utilityFunctions.throwSuiteScriptError(error.Type.FAILED_AN_UNEXPECTED_ERROR_OCCURRED);
						}
					});
					requirePromise.then(function (macroFunc) {
						var result = macroFunc.apply(context, [currentRecord, params]);
						result = result === undefined ? null : result;

						if (result instanceof Promise)
						{
							result.then(callbacks.resolve)['catch'](callbacks.reject);
						}
						else
						{
							if (macroHasPromise)
								utilityFunctions.throwSuiteScriptError(error.Type.INVALID_RETURN_TYPE_EXPECTED_1, 'Promise');
							else
								callbacks.resolve(result);
						}
					})['catch'](function (macroErr) {
						callbacks.reject(macroErr);
					});
				});
			}
			else
			{
				var macroFunc;
				require.forceSync(true);
				try
				{
					require([modulePath], function (mod)
					{
						macroFunc = mod[functionName];
					});
				}
				finally
				{
					require.forceSync(false);
				}
				if (typeof(macroFunc) === 'function')
				{
					try
					{
						/* TODO: set internal is here to get nlapiCalculateTax call working for calculateTax macro
						 * and should be removed once the macro is ported for new UI.
						 */
						var _isInternal = getV1api().nsapiIsInternal();
						getV1api().nsapiSetIsInternal(true);
						var result = macroFunc.apply(context, [currentRecord, params]);
						result = result === undefined ? null : result;
					}
					finally
					{
						getV1api().nsapiSetIsInternal(_isInternal);
					}
				}
				else
				{
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_MACRO_ID, id);
				}
				return result;
			}
		}

		function promiseTo(fn, options, postProcess)
		{
			var myPromise = new Promise(function (resolve, reject)
			{
				function callback(result)
				{
					if (result instanceof Error)
					{
						reject(result);
						return;
					}
					resolve(postProcess ? postProcess(result, options) : result);
				}

				try
				{
					fn(options, callback);
				}
				catch (e)
				{
					reject(e);
				}
			});
			return myPromise;
		}

		function doExecuteAction(options, callback)
		{
			var actionId, params, pkg;
			if (options !== undefined && options !== null)
			{
				actionId = options.id;
				params = utilityFunctions.isObject(options.params) ? options.params : {};
				pkg = options['package'] || null;
			}
			utilityFunctions.checkArgs([actionId], ['id'], 'CurrentRecord.executeAction');

			return invoker(remoteApi, 'executeAction', [getRecordType(), pkg, actionId, getId(), params], callback, false);
		}

		function executeAction(options)
		{
			return JSON.parse(doExecuteAction(options, null));
		}
		executeAction.promise = function(options)
		{
			return promiseTo(doExecuteAction, options, JSON.parse);
		};
		currentRecord.executeAction = executeAction;

		function createAction(options)
		{
			var TYPE = 'Action';

			var pkg = options['package'] || null;
			var actionId = options.id;

			var Action = function(params)
			{
				return executeAction(combineOpts(params, actionId, pkg));
			};
			Action.execute = function(params)
			{
				return executeAction(combineOpts(params, actionId, pkg));
			};
			Action.promise = function(params)
			{
				return promiseTo(doExecuteAction, combineOpts(params, actionId, pkg), JSON.parse);
			};
			Action.execute.promise = Action.promise;

			Action.id = actionId;
			Action.recordType = getRecordType();
			Action['package'] = pkg;
			Action.label = options.label || null;
			Action.description = options.description || null;
			var params = {};
			options.parameters.forEach(function(p) {
				params[p.id] = p;
				delete p.id;
			});
			Action.parameters = params;
			Action.toJSON = function toJSON(concise)
			{
				var res = {};
				for (var p in Action)
				{
					if (Action.hasOwnProperty(p) && typeof Action[p] !== 'function')
					{
						if (!concise || (Action[p] != null && (Action[p].constructor !== Object || Object.keys(Action[p]).length > 0)))
							res[p] = Action[p];
					}
				}
				return res;
			};
			Action.toString = function toString()
			{
				return TYPE + JSON.stringify(Action.toJSON(true));
			};

			return Object.freeze(Action);
		}

		function combineOpts(params, actionId, pkg)
		{
			var combinedOpts = {};
			combinedOpts.params = params;
			combinedOpts.id = actionId;
			combinedOpts['package'] = pkg;
			return combinedOpts;
		}

		function processGetActionsResult(jsonRes, options)
		{
			var metadata = JSON.parse(jsonRes);
			actionCache[getRecordType().toLowerCase()] = jsonRes;
			if (metadata.length === 0)
				utilityFunctions.throwSuiteScriptError(error.Type.SSS_NO_SUCH_RECORD_ACTION);

			var Actions = {};
			for (var i = 0; i < metadata.length; i++)
			{
				var action = createAction(metadata[i]);
				var fullId = action['package'] ? action['package'] + '.' + action.id : action.id;
				Actions[fullId] = action;
			}
			return Object.freeze(Actions);
		}

		function doGetActions(options, callback)
		{
			var recordType = getRecordType().toLowerCase();
			if (!actionCache[recordType])
				return invoker(remoteApi, 'getRecordActions', [recordType], callback, false);

			if (callback)
				callback(actionCache[recordType]);
			else
				return actionCache[recordType];
		}

		function getActions(options)
		{
			return processGetActionsResult(doGetActions(options, null), options);
		}
		getActions.promise = function(options)
		{
			return promiseTo(doGetActions, options, processGetActionsResult);
		};
		currentRecord.getActions = getActions;

		function processGetActionResult(jsonRes, options)
		{
			var metadata = JSON.parse(jsonRes);
			actionCache[getRecordType().toLowerCase()] = jsonRes;

			var result = null;
			var pkg = options['package'] || '';
			for (var i = 0; i < metadata.length; i++)
			{
				var curPkg = metadata[i]['package'] || '';
				if (curPkg === pkg && options.id === metadata[i].id)
				{
					result = createAction(metadata[i]);
					break;
				}
			}
			if (result === null)
				utilityFunctions.throwSuiteScriptError(error.Type.SSS_NO_SUCH_RECORD_ACTION);
			return result;
		}

		function doGetAction(options, callback)
		{
			var actionId = options ? options.id : null;
			utilityFunctions.checkArgs([actionId], ['id'], 'CurrentRecord.getAction');

			return doGetActions(options, callback);
		}

		function getAction(options)
		{
			return processGetActionResult(doGetAction(options, null), options);
		}
		getAction.promise = function(options)
		{
			return promiseTo(doGetAction, options, processGetActionResult);
		};
		currentRecord.getAction = getAction;

		function validateAndFormat(id, type, value)
		{
			validator.validateField(id, type, value);
			return formatter.format(value, type);
		}

		function checkAndFormatForSetText(text, fldObj, fieldId)
		{
			var value = formatter.parse(text, fldObj.type);
			validator.validateField(fieldId, fldObj.type, value);
			return formatter.format(value, fldObj.type);
		}

		// ==== set/get fieldValue
		function setValue(options, value)
		{
			var fieldId,
				fireFieldChanged = true,
				fireSlavingSync = false,
				undef = undefined;

			if (value !== undef)
			{
				fieldId = options;
			}
			else if (options !== undef && options !== null)
			{
				fieldId = options.fieldId;
				value = options.value;
				fireFieldChanged = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChanged;
				fireSlavingSync = util.isBoolean(options.fireSlavingSync) ? options.fireSlavingSync : fireSlavingSync;
			}
			utilityFunctions.checkArgs([fieldId], ['fieldId'], "CurrentRecord.setValue");
			doSetValue(fieldId, value, fireFieldChanged, fireSlavingSync);
			return currentRecord;
		}

		currentRecord.setValue = setValue;

		function doSetValue(fieldId, value, fireFieldChanged, fireSlavingSync)
		{
			var fieldObj = getV1api().nlapiGetField(fieldId);
			if (fieldObj !== null)
			{
				value = validateAndFormat(fieldId, fieldObj.type, value);
				getV1api().nlapiSetFieldValue.v2(fieldId, value, fireFieldChanged, fireSlavingSync);
			}
		}

		function getValue(options)
		{
			var fieldId;

			fieldId = ((options !== undefined) && (options !== null) && !util.isString(options)) ? options.fieldId : options;
			utilityFunctions.checkArgs([fieldId], ['fieldId'], "CurrentRecord.getValue");
			getV1api().nsapiAssertTrue(!isSubrecordField(null, fieldId), 'SSS_INVALID_OPERATION_USING_SUBRECORD_FIELD');

			return doGetValue(fieldId);
		}

		currentRecord.getValue = getValue;

		function doGetValue(fieldId)
		{
			var fieldObj = getV1api().nlapiGetField(fieldId);
			var value;
			if (fieldObj == null)
				return undefined;

			if (fieldObj.type === "multiselect")
			{
				if (fieldObj.isHidden)
					value = getV1api().nlapiGetFieldValue(fieldId).split(String.fromCharCode(5));
				else
					value = getV1api().nlapiGetFieldValues(fieldId);
			}
			else
			{
				value = (fieldObj !== null) ? formatter.parse(getV1api().nlapiGetFieldValue(fieldId), fieldObj.type) : undefined;
			}
			return value == null ? undefined : value;
		}

		// ==== set/get matrixValue
		function setMatrixHeaderValue(options, fieldId, column, value)
		{
			var sublistId,
				fireFieldChanged = true,
				fireSlavingSync = false,
				undef = undefined;

			if (fieldId !== undef && column !== undef && value !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				column = options.column;
				value = options.value;

				fireFieldChanged = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChanged;
				fireSlavingSync = util.isBoolean(options.fireSlavingSync) ? options.fireSlavingSync : fireSlavingSync;
			}
			utilityFunctions.checkArgs([sublistId, fieldId, column], ['sublistId', 'fieldId', 'column'], 'CurrentRecord.setMatrixHeaderValue');
			doSetMatrixHeaderValue(sublistId, fieldId, column, value, fireFieldChanged, fireSlavingSync);
			return currentRecord;
		}

		currentRecord.setMatrixHeaderValue = setMatrixHeaderValue;

		function doSetMatrixHeaderValue(sublistId, fieldId, column, value, fireFieldChanged, fireSlavingSync)
		{
			column = recordUtil.validateAndGetOneBasedIndex(column, "CurrentRecord.setMatrixHeaderValue");
			var fieldObj = getV1api().nlapiGetMatrixField(sublistId, fieldId, column);
			if (fieldObj !== null)
			{
				value = validateAndFormat(fieldId, fieldObj.type, value);
				getV1api().nlapiSetMatrixValue.v2(sublistId, fieldId, column, value, fireFieldChanged, fireSlavingSync);
			}
		}

		function getMatrixHeaderValue(options, fieldId, column)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef && column !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				column = options.column;
			}
			utilityFunctions.checkArgs([sublistId, fieldId, column], ['sublistId', 'fieldId', 'column'], 'CurrentRecord.getMatrixHeaderValue');
			return doGetMatrixHeaderValue(sublistId, fieldId, column)
		}

		currentRecord.getMatrixHeaderValue = getMatrixHeaderValue;

		function doGetMatrixHeaderValue(sublistId, fieldId, column)
		{
			column = recordUtil.validateAndGetOneBasedIndex(column, "CurrentRecord.getMatrixHeaderValue");
			var fieldObj = getV1api().nlapiGetMatrixField(sublistId, fieldId, column);
			var value;

			if (fieldObj == null)
				return undefined;

			value = formatter.parse(getV1api().nlapiGetMatrixValue(sublistId, fieldId, column), fieldObj.type);

			return value == null ? undefined : value;
		}

		// ==== set/get fieldText
		function setText(options, text)
		{
			var fieldId,
				fireFieldChanged = true,
				fireSlavingSync = false,
				undef = undefined;

			if (text !== undef)
			{
				fieldId = options;
			}
			else if (options !== undef && options !== null)
			{
				fieldId = options.fieldId;
				text = options.text;
				fireFieldChanged = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChanged;
				fireSlavingSync = util.isBoolean(options.fireSlavingSync) ? options.fireSlavingSync : fireSlavingSync;
			}
			utilityFunctions.checkArgs([fieldId], ['fieldId'], "CurrentRecord.setText");
			doSetText(fieldId, text, fireFieldChanged, fireSlavingSync);
			return currentRecord;
		}

		currentRecord.setText = setText;

		function doSetText(fieldId, text, fireFieldChanged, fireSlavingSync)
		{
			var fldObj = getV1api().nlapiGetField(fieldId);
			if (fldObj == null)
				return;

			if (fldObj.type === "multiselect")
			{
				text = (!Array.isArray(text)) ? text.split(String.fromCharCode(5)) : text;
				getV1api().nlapiSetFieldTexts.v2(fieldId, text, fireFieldChanged, fireSlavingSync);
			}
			else if (fldObj.type.indexOf("select") !== -1)
			{
				getV1api().nlapiSetFieldText.v2(fieldId, text, fireFieldChanged, fireSlavingSync);
			}
			else
			{
				var value = checkAndFormatForSetText(text, fldObj, fieldId);
				getV1api().nlapiSetFieldValue.v2(fieldId, value, fireFieldChanged, fireSlavingSync);
			}
		}

		function getText(options)
		{
			var fieldId;
			fieldId = ((options !== undefined) && (options !== null) && !util.isString(options)) ? options.fieldId : options;
			utilityFunctions.checkArgs([fieldId], ['fieldId'], "CurrentRecord.getText");

			return doGetText(fieldId);
		}

		currentRecord.getText = getText;

		function doGetText(fieldId)
		{
			var fieldObj = getV1api().nlapiGetField(fieldId);
			if (fieldObj == null)
				return undefined;
			var text;
			if (fieldObj.type === "multiselect")
			{
				text = getV1api().nlapiGetFieldTexts(fieldId);
			}
			else if (fieldObj.type.indexOf("select") !== -1)
			{
				text = getV1api().nlapiGetFieldText(fieldId);
			}
			else
			{
				text = formatter.format(getV1api().nlapiGetFieldValue(fieldId), fieldObj.type);
			}
			return text == null ? undefined : text;
		}

		// ==== get sublist information
		function getSublistValue(options, fieldId, line)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef && line !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				line = options.line;
			}
			utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], "CurrentRecord.getSublistValue");
			return doGetSublistValue(sublistId, fieldId, line)
		}

		currentRecord.getSublistValue = getSublistValue;

		function doGetSublistValue(sublistId, fieldId, line)
		{
			line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentRecord.getSublistValue", getV1api().nlapiGetLineItemCount(sublistId));

			var fieldType = getEncodedFieldType(sublistId, fieldId, true);
			var value = fieldType ? formatter.parse(getV1api().nlapiGetLineItemValue(sublistId, fieldId, line), fieldType) : null;

			return value == null ? undefined : value;
		}

		function getSublistText(options, fieldId, line)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef && line !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				line = options.line;
			}
			utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], "CurrentRecord.getSublistText");
			return doGetSublistText(sublistId, fieldId, line)
		}

		currentRecord.getSublistText = getSublistText;

		function doGetSublistText(sublistId, fieldId, line)
		{
			line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentRecord.getSublistText", getV1api().nlapiGetLineItemCount(sublistId));

			var fieldType = getEncodedFieldType(sublistId, fieldId, true);
			if (fieldType === null)
				return undefined;
			var text;
			if (fieldType === "multiselect")
				text = getV1api().nlapiGetLineItemTexts(sublistId, fieldId, line);
			else if (fieldType.indexOf("select") !== -1)
				text = getV1api().nlapiGetLineItemText(sublistId, fieldId, line);
			else
				text = formatter.format(getV1api().nlapiGetLineItemValue(sublistId, fieldId, line), fieldType);

			return text == null ? undefined : text;
		}

		function setMatrixSublistValue(options, fieldId, line, column, value)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef && line !== undef && column !== undef && value !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				line = options.line;
				column = options.column;
				value = options.value;
			}
			utilityFunctions.checkArgs([sublistId, fieldId, line, column], ['sublistId', 'fieldId', 'line', 'column'], 'CurrentRecord.setMatrixSublistValue');
			doSetMatrixSublistValue(sublistId, fieldId, line, column, value)
		}

		currentRecord.setMatrixSublistValue = setMatrixSublistValue;

		function doSetMatrixSublistValue(sublistId, fieldId, line, column, value)
		{
			line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentRecord.setMatrixSublistValue", getV1api().nlapiGetLineItemCount(sublistId));
			column = recordUtil.validateAndGetOneBasedIndex(column, "CurrentRecord.setMatrixSublistValue");
			var fieldObj = getV1api().nlapiGetLineItemMatrixField(sublistId, fieldId, column, line);
			if (fieldObj !== null)
			{
				validator.validateField(fieldId, fieldObj.type, value);
				getV1api().nlapiSetLineItemMatrixValue(sublistId, fieldId, line, column, value);
			}
		}

		function getMatrixSublistValue(options, fieldId, line, column)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef && line !== undef && column !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				line = options.line;
				column = options.column;
			}
			utilityFunctions.checkArgs([sublistId, fieldId, line, column], ['sublistId', 'fieldId', 'line', 'column'], 'CurrentRecord.getMatrixSublistValue');
			return doGetMatrixSublistValue(sublistId, fieldId, line, column);
		}

		currentRecord.getMatrixSublistValue = getMatrixSublistValue;

		function doGetMatrixSublistValue(sublistId, fieldId, line, column)
		{
			line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentRecord.getMatrixSublistValue", getV1api().nlapiGetLineItemCount(sublistId));
			column = recordUtil.validateAndGetOneBasedIndex(column, "CurrentRecord.getMatrixSublistValue");
			var fieldObj = getV1api().nlapiGetLineItemMatrixField(sublistId, fieldId, column, line);
			if (fieldObj == null)
				return undefined;
			var value = formatter.parse(getV1api().nlapiGetLineItemMatrixValue(sublistId, fieldId, line, column), fieldObj.type);

			return value == null ? undefined : value;
		}

		// === set/get currentLineItemValue
		function setCurrentSublistValue(options, fieldId, value)
		{
			var sublistId,
				fireFieldChanged = true,
				fireSlavingSync = false,
				undef = undefined;

			if (fieldId !== undef && value !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				value = options.value;
				fireFieldChanged = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChanged;
				fireSlavingSync = util.isBoolean(options.fireSlavingSync) ? options.fireSlavingSync : fireSlavingSync;
			}
			utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], "CurrentRecord.setCurrentSublistValue");
			doSetCurrentSublistValue(sublistId, fieldId, value, fireFieldChanged, fireSlavingSync);
			return currentRecord;
		}

		currentRecord.setCurrentSublistValue = setCurrentSublistValue;

		function doSetCurrentSublistValue(sublistId, fieldId, value, fireFieldChanged, fireSlavingSync)
		{
			var fieldObj = getV1api().nlapiGetLineItemField(sublistId, fieldId, isEditMachine(sublistId) ? null : getV1api().nlapiGetCurrentLineItemIndex(sublistId));
			if (fieldObj == null)
				return undefined;

			if (Array.isArray(value))
			{
				value = value.join(String.fromCharCode(5));
			}
			else if (fieldObj.type.indexOf("select") === -1)
			{
				value = validateAndFormat(fieldId, fieldObj.type, value);
			}
			getV1api().nlapiSetCurrentLineItemValue.v2(sublistId, fieldId, value, fireFieldChanged, fireSlavingSync);
		}

		function getCurrentSublistValue(options, fieldId)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
			}
			utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], "CurrentRecord.getCurrentSublistValue");
			return doGetCurrentSublistValue(sublistId, fieldId);
		}

		currentRecord.getCurrentSublistValue = getCurrentSublistValue;

		function doGetCurrentSublistValue(sublistId, fieldId)
		{
			var fieldObj = getV1api().nlapiGetLineItemField(sublistId, fieldId, isEditMachine(sublistId) ? null : getV1api().nlapiGetCurrentLineItemIndex(sublistId));
			var value = (fieldObj !== null) ? formatter.parse(getV1api().nlapiGetCurrentLineItemValue(sublistId, fieldId), fieldObj.type) : null;
			return value == null ? undefined : value;
		}

		// === set/get currentLineItemMatrixValue
		function setCurrentMatrixSublistValue(options, fieldId, column, value)
		{
			var sublistId,
				fireFieldChanged = true,
				fireSlavingSync = false,
				undef = undefined;

			if (fieldId !== undef && column !== undef && value !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				column = options.column;
				value = options.value;
				fireFieldChanged = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChanged;
				fireSlavingSync = util.isBoolean(options.fireSlavingSync) ? options.fireSlavingSync : fireSlavingSync;
			}
			utilityFunctions.checkArgs([sublistId, fieldId, column], ['sublistId', 'fieldId', 'column'], 'CurrentRecord.setCurrentMatrixSublistValue');
			doSetCurrentMatrixSublistValue(sublistId, fieldId, column, value, fireFieldChanged, fireSlavingSync)
		}

		currentRecord.setCurrentMatrixSublistValue = setCurrentMatrixSublistValue;

		function doSetCurrentMatrixSublistValue(sublistId, fieldId, column, value, fireFieldChanged, fireSlavingSync)
		{
			column = recordUtil.validateAndGetOneBasedIndex(column, "CurrentRecord.setCurrentMatrixSublistValue");
			var fieldObj = getV1api().nlapiGetLineItemMatrixField(sublistId, fieldId, column, getV1api().nlapiGetCurrentLineItemIndex(sublistId));
			if (fieldObj !== null)
			{
				validator.validateField(fieldId, fieldObj.type, value);
				getV1api().nlapiSetCurrentLineItemMatrixValue(sublistId, fieldId, column, value, fireFieldChanged, fireSlavingSync);
			}
		}

		function getCurrentMatrixSublistValue(options, fieldId, column)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef && column !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				column = options.column;
			}
			utilityFunctions.checkArgs([sublistId, fieldId, column], ['sublistId', 'fieldId', 'column'], 'CurrentRecord.getCurrentMatrixSublistValue');
			var currLine = getV1api().nlapiGetCurrentLineItemIndex(sublistId);
			if (currLine > 0)
				currLine = currLine - 1;

			return doGetMatrixSublistValue(sublistId, fieldId, currLine, column);
		}

		currentRecord.getCurrentMatrixSublistValue = getCurrentMatrixSublistValue;

		// === set/get currentLineItemText
		function setCurrentSublistText(options, fieldId, text)
		{
			var sublistId,
				fireFieldChanged = true,
				fireSlavingSync = false,
				undef = undefined;

			if (fieldId !== undef && text !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				text = options.text;
				fireFieldChanged = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChanged;
				fireSlavingSync = util.isBoolean(options.fireSlavingSync) ? options.fireSlavingSync : fireSlavingSync;
			}
			utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], 'CurrentRecord.setCurrentSublistText');
			doSetCurrentSublistText(sublistId, fieldId, text, fireFieldChanged, fireSlavingSync);
			return currentRecord;
		}

		currentRecord.setCurrentSublistText = setCurrentSublistText;

		function doSetCurrentSublistText(sublistId, fieldId, text, fireFieldChanged, fireSlavingSync)
		{
			var fieldObj = getV1api().nlapiGetLineItemField(sublistId, fieldId, isEditMachine(sublistId) ? null : getV1api().nlapiGetCurrentLineItemIndex(sublistId));
			if (fieldObj === null)
				return;

			if (fieldObj.type.indexOf("select") !== -1)
			{
				getV1api().nlapiSetCurrentLineItemText.v2(sublistId, fieldId, text, fireFieldChanged, fireSlavingSync);
			}
			else
			{
				var value = checkAndFormatForSetText(text, fieldObj, fieldId);
				getV1api().nlapiSetCurrentLineItemValue.v2(sublistId, fieldId, value, fireFieldChanged, fireSlavingSync);
			}
		}

		function getCurrentSublistText(options, fieldId)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
			}
			utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], 'CurrentRecord.getCurrentSublistText');
			return doGetCurrentSublistText(sublistId, fieldId);
		}

		currentRecord.getCurrentSublistText = getCurrentSublistText;

		function doGetCurrentSublistText(sublistId, fieldId)
		{
			var fldObj = getV1api().nlapiGetLineItemField(sublistId, fieldId, isEditMachine(sublistId) ? null : getV1api().nlapiGetCurrentLineItemIndex(sublistId));
			if (fldObj === null)
				return undefined;

			var text;
			if (fldObj.type.indexOf("select") !== -1)
			{
				text = getV1api().nlapiGetCurrentLineItemText(sublistId, fieldId);
			}
			else
			{
				text = getV1api().nlapiGetCurrentLineItemValue(sublistId, fieldId);
			}
			return text == null ? undefined : text;
		}

		function fixMissingProperties(obj)
		{
			if (obj !== null)
			{
				obj.visible = true;
				obj.display = true;
			}
			return obj;
		}

		// === Get Fields
		function getField(options)
		{
			var fieldId = ((options !== undefined) && (options !== null) && !util.isString(options)) ? options.fieldId : options;
			utilityFunctions.checkArgs([fieldId], ['fieldId'], "CurrentRecord.getField");

			var fldObj = getV1api().nlapiGetField(fieldId);

			//nlapiGetField and nlapiGetLineItemField (and their matrix counterparts do not properly initialize
			//isDisplay and isVisible. We should make sure they get the proper values for them.
			var fieldElement = document.getElementById(fieldId + "_fs");
			if (fldObj !== null && fieldElement !== null && fieldElement.style !== null)
			{
				fldObj.visible = fieldElement.style.visibility !== "hidden";
				fldObj.display = fieldElement.style.display !== "none";
			}

			return fldObj != null ? fieldMetadata.wrap({
														   delegate: field.create(fldObj),
														   category: fieldMetadata.Category.CURRENT_BODY
													   }) : null;
		}

		currentRecord.getField = getField;

		function getSublist(options)
		{
			var sublistId = ((options !== undefined) && (options !== null) && !util.isString(options)) ? options.sublistId : options;
			utilityFunctions.checkArgs([sublistId], ['sublistId'], "CurrentRecord.getSublist");

			var sublistObj = getV1api().nlapiGetSubList(sublistId);
			return sublistObj != null ? sublistMetadata.wrap({
																 delegate: sublist.create(sublistObj),
																 category: sublistMetadata.Category.CURRENT
															 }) : null;
		}

		currentRecord.getSublist = getSublist;

		function getMatrixHeaderField(options, fieldId, column)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef && column !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				column = options.column;
			}
			utilityFunctions.checkArgs([sublistId, fieldId, column], ['sublistId', 'fieldId', 'column'], 'CurrentRecord.getMatrixHeaderField');
			column = recordUtil.validateAndGetOneBasedIndex(column, "CurrentRecord.getMatrixHeaderField");

			var fldObj = getV1api().nlapiGetMatrixField(sublistId, fieldId, column);
			fldObj = fixMissingProperties(fldObj);
			return fldObj != null ? fieldMetadata.wrap({
														   delegate: field.create(fldObj),
														   category: fieldMetadata.Category.CURRENT_BODY
													   }) : null;
		}

		currentRecord.getMatrixHeaderField = getMatrixHeaderField;

		function getSublistField(options, fieldId, line)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef && line !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				line = options.line;
			}
			utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], 'CurrentRecord.getSublistField');
			line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentRecord.getSublistField", getV1api().nlapiGetLineItemCount(sublistId));

			var fldObj = getV1api().nlapiGetLineItemField(sublistId, fieldId, line);
			fldObj = fixMissingProperties(fldObj);
			return fldObj != null ? fieldMetadata.wrap({
														   delegate: field.create(fldObj),
														   category: fieldMetadata.Category.CURRENT_SUBLIST
													   }) : null;
		}

		currentRecord.getSublistField = getSublistField;

		function getMatrixSublistField(options, fieldId, column, line)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef && column !== undef && line !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				column = options.column;
				line = options.line;
			}
			utilityFunctions.checkArgs([sublistId, fieldId, column, line], ['sublistId', 'fieldId', 'column', 'line'], 'CurrentRecord.getMatrixSublistField');
			column = recordUtil.validateAndGetOneBasedIndex(column, "CurrentRecord.getMatrixSublistField");
			line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentRecord.getMatrixSublistField", getV1api().nlapiGetLineItemCount(sublistId));

			var fldObj = getV1api().nlapiGetLineItemMatrixField(sublistId, fieldId, column, line);
			fldObj = fixMissingProperties(fldObj);
			return fldObj != null ? fieldMetadata.wrap({
														   delegate: field.create(fldObj),
														   category: fieldMetadata.Category.CURRENT_SUBLIST
													   }) : null;
		}

		currentRecord.getMatrixSublistField = getMatrixSublistField;

		function getCurrentSublistIndex(options)
		{
			var sublistId = ((options !== undefined) && (options !== null) && !util.isString(options)) ? options.sublistId : options;
			utilityFunctions.checkArgs([sublistId], ['sublistId'], "CurrentRecord.getCurrentSublistIndex");

			var currIndex = getV1api().nlapiGetCurrentLineItemIndex(sublistId);
			return recordUtil.getZeroBasedIndex(currIndex);
		}

		currentRecord.getCurrentSublistIndex = getCurrentSublistIndex;

		// === Find Values
		function findSublistLineWithValue(options, fieldId, value)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef && value !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				value = options.value;
			}

			utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], 'CurrentRecord.findSublistLineWithValue');
			return recordUtil.getZeroBasedIndex(getV1api().nlapiFindLineItemValue(sublistId, fieldId, value));
		}

		currentRecord.findSublistLineWithValue = findSublistLineWithValue;

		function findMatrixSublistLineWithValue(options, fieldId, value, column)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef && value !== undef && column !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				value = options.value;
				column = options.column;
			}
			column = recordUtil.validateAndGetOneBasedIndex(column, "CurrentRecord.findMatrixSublistLineWithValue");
			utilityFunctions.checkArgs([sublistId, fieldId, column], ['sublistId', 'fieldId', 'column'], 'CurrentRecord.findMatrixSublistLineWithValue');
			return recordUtil.getZeroBasedIndex(getV1api().nlapiFindLineItemMatrixValue(sublistId, fieldId, value, column));
		}

		currentRecord.findMatrixSublistLineWithValue = findMatrixSublistLineWithValue;

		function selectLine(options, line)
		{
			var sublistId,
				undef = undefined;

			if (line !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				line = options.line;
			}
			utilityFunctions.checkArgs([sublistId, line], ['sublistId', 'line'], "CurrentRecord.selectLine");

			if (recordUtil.getZeroBasedIndex(getV1api().nlapiGetCurrentLineItemIndex(sublistId)) !== line)
			{
				line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentRecord.selectLine", getV1api().nlapiGetLineItemCount(sublistId));
				getV1api().nlapiSelectLineItem(sublistId, line);
			}
			return currentRecord;
		}

		currentRecord.selectLine = selectLine;

		function commitLine(options)
		{
			var sublistId = ((options !== undefined) && (options !== null) && !util.isString(options)) ? options.sublistId : options;
			utilityFunctions.checkArgs([sublistId], ['sublistId'], "CurrentRecord.commitLine");
			getV1api().nlapiCommitLineItem(sublistId);
			return currentRecord;
		}

		currentRecord.commitLine = commitLine;

		function insertLine(options, line)
		{
			var sublistId,
				undef = undefined;

			if (line !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				line = options.line;
			}
			utilityFunctions.checkArgs([sublistId, line], ['sublistId', 'line'], "CurrentRecord.insertLine");
			line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentRecord.insertLine", getV1api().nlapiGetLineItemCount(sublistId) + 1); //+1 because you can insert on the newest line

			getV1api().nlapiInsertLineItem(sublistId, line);
			return currentRecord;
		}

		currentRecord.insertLine = insertLine;

		function removeLine(options, line)
		{
			var sublistId,
				undef = undefined;

			if (line !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				line = options.line;
			}
			utilityFunctions.checkArgs([sublistId, line], ['sublistId', 'line'], "CurrentRecord.removeLine");
			line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentRecord.removeLine", getV1api().nlapiGetLineItemCount(sublistId));

			getV1api().nlapiRemoveLineItem(sublistId, line);
			return currentRecord;
		}

		currentRecord.removeLine = removeLine;

		function cancelLine(options)
		{
			var sublistId = ((options !== undefined) && (options !== null) && !util.isString(options)) ? options.sublistId : options;
			utilityFunctions.checkArgs([sublistId], ['sublistId'], "CurrentRecord.cancelLine");
			getV1api().nlapiCancelLineItem(sublistId);
			return currentRecord;
		}

		currentRecord.cancelLine = cancelLine;

		function selectNewLine(options)
		{
			var sublistId = ((options !== undefined) && (options !== null) && !util.isString(options)) ? options.sublistId : options;
			utilityFunctions.checkArgs([sublistId], ['sublistId'], "CurrentRecord.selectNewLine");
			getV1api().nlapiSelectNewLineItem(sublistId);
			return currentRecord;
		}

		currentRecord.selectNewLine = selectNewLine;

		function getLineCount(options)
		{
			var sublistId = ((options !== undefined) && (options !== null) && !util.isString(options)) ? options.sublistId : options;
			utilityFunctions.checkArgs([sublistId], ['sublistId'], "CurrentRecord.getLineCount");
			return getV1api().nlapiGetLineItemCount(sublistId);
		}

		currentRecord.getLineCount = getLineCount;

		function getMatrixHeaderCount(options, fieldId)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
			}
			utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], 'CurrentRecord.getMatrixHeaderCount');
			return getV1api().nlapiGetMatrixCount(sublistId, fieldId);
		}

		currentRecord.getMatrixHeaderCount = getMatrixHeaderCount;

		function getRecordType()
		{
			return getV1api().nlapiGetRecordType();
		}

		utilityFunctions.addReadOnlyProperty(currentRecord, 'type', getRecordType);

		function getId()
		{
			return getV1api().nlapiGetRecordId();
		}

		utilityFunctions.addReadOnlyProperty(currentRecord, 'id', getId);

		function getIsDynamic () { return !recordOptions.isReadOnly; }

		utilityFunctions.addReadOnlyProperty(currentRecord, 'isDynamic', getIsDynamic);

		function getIsCurrentRecord () { return recordOptions.isCurrentRecord; }

		function hasSubrecord(options)
		{
			var undef = undefined, result, fieldId;

			fieldId = options !== undef && options !== null && !util.isString(options) ? options.fieldId : options;

			utilityFunctions.checkArgs([fieldId], ['fieldId'], 'CurrentRecord.hasSubrecord');

			return getV1api().nlapiViewSubrecord(fieldId) !== null;
		}

		currentRecord.hasSubrecord = hasSubrecord;

		function oldGetSubrecord(options)
		{
			var undef = undefined,
				fieldId,
				subrecordObj;

			fieldId = options !== undef && options !== null && !util.isString(options) ? options.fieldId : options;

			utilityFunctions.checkArgs([fieldId], ['fieldId'], 'CurrentRecord.getSubrecord');

			subrecordObj = getV1api().nlapiViewSubrecord(fieldId);

			return subrecordObj === null ? null : domSubrecord.create(currentRecord, subrecordObj);
		}

		currentRecord.getSubrecord = oldGetSubrecord;

		function oldRemoveSubrecord(options)
		{
			var undef = undefined,
				fieldId;

			fieldId = options !== undef && options !== null && !util.isString(options) ? options.fieldId : options;

			utilityFunctions.checkArgs([fieldId], ['fieldId'], 'CurrentRecord.removeSubrecord');

			getV1api().nlapiRemoveSubrecord(fieldId);

			return currentRecord;
		}

		currentRecord.removeSubrecord = oldRemoveSubrecord;

		function hasSublistSubrecord(options, fieldId, line)
		{
			var undef = undefined,
				result,
				sublistId;

			if (fieldId !== undef && line !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				line = options.line;
			}

			utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], 'CurrentRecord.hasSublistSubrecord');
			line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentRecord.hasSublistSubrecord", getV1api().nlapiGetLineItemCount(sublistId));

			result = getV1api().nlapiViewLineItemSubrecord(sublistId, fieldId, line) !== null;

			return result;
		}

		currentRecord.hasSublistSubrecord = hasSublistSubrecord;

		function hasCurrentSublistSubrecord(options, fieldId)
		{
			var undef = undefined,
				result,
				sublistId;

			if (fieldId !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
			}

			utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], 'CurrentRecord.hasCurrentSublistSubrecord');

			result = getV1api().nlapiViewCurrentLineItemSubrecord(sublistId, fieldId) !== null;

			return result;
		}

		currentRecord.hasCurrentSublistSubrecord = hasCurrentSublistSubrecord;

		function oldGetCurrentSublistSubrecord(options, fieldId)
		{
			var undef = undefined,
				sublistId,
				subrecordObj;

			if (fieldId !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
			}

			utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], 'CurrentRecord.getCurrentSublistSubrecord');

			subrecordObj = getV1api().nlapiViewCurrentLineItemSubrecord(sublistId, fieldId);
			if (!!subrecordObj)
			{
				subrecordObj = domSubrecord.create(currentRecord, subrecordObj);
			}

			return subrecordObj;
		}

		currentRecord.getCurrentSublistSubrecord = oldGetCurrentSublistSubrecord;

		function oldRemoveCurrentSublistSubrecord(options, fieldId)
		{
			var undef = undefined,
				sublistId;

			if (fieldId !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
			}

			utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], 'CurrentRecord.removeCurrentSublistSubrecord');

			getV1api().nlapiRemoveCurrentLineItemSubrecord(sublistId, fieldId);

			return currentRecord;
		}

		currentRecord.removeCurrentSublistSubrecord = oldRemoveCurrentSublistSubrecord;

		/* --- Proxy cache mechanism setup --- */

		currentRecord.proxy = recordProxy.proxy.bind(null, currentRecord, recordOptions);

		/* --- End of proxy cache mechanism --- */


		function getSingletonDomCurrentRecordImpl(V1apiGetterCallback, isReadOnly)
		{
			/* Save the method that provide us the lazy-loaded slab of V1 API calls, which we eill need when DOM record methods are called. */
			if (!V1api)
				V1api = V1apiGetterCallback();

			recordOptions.isReadOnly = isReadOnly;

			/*
			 * Now, wrap this DOM current record object so that it's a proper record object, including making sure all
			 * methods that return the record object do return the proxied record, and not the inner record object.
			 */
			/* Wrap it, removing API's which must not be exposed for current record, and also let it keep its legacy name. */

			var wrappedRecord = currentRecord.proxy({isInteractive: false}); // domCurrentRecord is always non-interactive
			return wrappedRecord;
		}

		return {
			getSingletonDomCurrentRecordImpl: getSingletonDomCurrentRecordImpl
		}
	});

/**
 * SuiteScript module
 *
 * @private
 * @module N/currentRecord
 * @NApiVersion 2.x
 */
define(
	'N/currentRecord',['N/nsobject', 'N/currentRecordBootstrap', 'N/domCurrentRecord'],
	function (nsobject, currentRecordBootstrap, domCurrentRecord)
	{
		var undef = undefined;

		function createCurrentRecordByWrappingNewDynamicRecordOrDomRecord()
		{
			// 1. Try to get the currentRecord in the form of a a dynamicRecord from currentRecordBootstrap.
			//
			// If there's a bootstrapped currentRecord on this page (will be the case on new UI record pages), then use that dynamicRecord for the currentRecord.
			// This prevents attempts to use the NLAPI methods when we have a dynamic record available. The NLAPI methods don't exist, and the singleton dynamicRecord
			// that was created for the currentRecord will be the common source of truth everywhere.
			var dynamicRecord = currentRecordBootstrap.getCurrentRecord();
			if (!!dynamicRecord)
				return dynamicRecord;

			// 2. If dynamicRecord is null at this point, then there's no currentRecord available in the form of a dynamicRecord.
			//
			// We revert to the V1/V2 old UI behavior, and delegate all record API calls to the DOM currentRecord via legacy NLAPI method calls.
			if (pageHasV1Api())
			{
				var isReadOnly = isPageViewMode();
				var domRecord = domCurrentRecord.getSingletonDomCurrentRecordImpl(V1apiGetterFunc, isReadOnly);
				if (!!domRecord)
					return domRecord;
			}

			// 3. If no current record is available, then the caller must retry until one has been created by
			//    currentRecordBootstrap. This will happen when trying to get the current record from scripting
			//    inside the pageInit script of a record that is the current record. Return undefined in that case.
			return undef;
		}


		function isPageViewMode()
		{
			return !(document && document.forms['main_form'] && document.forms['main_form'].onsubmit);
		}

		function pageHasV1Api()
		{
			try
			{
				return !!nlapiGetField;
			}
			catch (e)
			{
				return false;
			}
		}

		/* This is a callback that lazy-creates and returns a copy of needed methods from the V1 API only as soon as theyre needed. */
		function V1apiGetterFunc()
		{
			/*
			 * N/NsRequire.js has some special code that lets only N/currentRecord have access to the V1 API.
			 * So here, we scrape the API, and pass it along to domCurrentRecord, so it may use the V1 API's
			 * to implelemt a V2-like record interface, delegating to legacy V1 implementations. That big
			 * body of code used to be part of this class, causing confusion. I moved it out of here to clearly
			 * separate concerns. Welcome to the much smaller currentRecord.js
			 */
			var V1api = {
				nlapiCancelLineItem: nlapiCancelLineItem,
				nlapiCommitLineItem: nlapiCommitLineItem,
				nlapiFindLineItemMatrixValue: nlapiFindLineItemMatrixValue,
				nlapiFindLineItemValue: nlapiFindLineItemValue,
				nlapiGetCurrentLineItemIndex: nlapiGetCurrentLineItemIndex,
				nlapiGetCurrentLineItemText: nlapiGetCurrentLineItemText,
				nlapiGetCurrentLineItemValue: nlapiGetCurrentLineItemValue,
				nlapiGetField: nlapiGetField,
				nlapiGetFieldText: nlapiGetFieldText,
				nlapiGetFieldTexts: nlapiGetFieldTexts,
				nlapiGetFieldValue: nlapiGetFieldValue,
				nlapiGetFieldValues: nlapiGetFieldValues,
				nlapiGetLineItemCount: nlapiGetLineItemCount,
				nlapiGetLineItemField: nlapiGetLineItemField,
				nlapiGetLineItemMatrixField: nlapiGetLineItemMatrixField,
				nlapiGetLineItemMatrixValue: nlapiGetLineItemMatrixValue,
				nlapiGetLineItemText: nlapiGetLineItemText,
				nlapiGetLineItemTexts: nlapiGetLineItemTexts,
				nlapiGetLineItemValue: nlapiGetLineItemValue,
				nlapiGetMatrixCount: nlapiGetMatrixCount,
				nlapiGetMatrixField: nlapiGetMatrixField,
				nlapiGetMatrixValue: nlapiGetMatrixValue,
				nlapiGetRecordId: nlapiGetRecordId,
				nlapiGetRecordType: nlapiGetRecordType,
				nlapiGetSubList: nlapiGetSubList,
				nlapiInsertLineItem: nlapiInsertLineItem,
				nlapiRemoveCurrentLineItemSubrecord: nlapiRemoveCurrentLineItemSubrecord,
				nlapiRemoveLineItem: nlapiRemoveLineItem,
				nlapiRemoveSubrecord: nlapiRemoveSubrecord,
				nlapiSelectLineItem: nlapiSelectLineItem,
				nlapiSelectNewLineItem: nlapiSelectNewLineItem,
				nlapiSetCurrentLineItemMatrixValue: nlapiSetCurrentLineItemMatrixValue,
				nlapiSetCurrentLineItemText: nlapiSetCurrentLineItemText,
				nlapiSetCurrentLineItemValue: nlapiSetCurrentLineItemValue,
				nlapiSetFieldText: nlapiSetFieldText,
				nlapiSetFieldTexts: nlapiSetFieldTexts,
				nlapiSetFieldValue: nlapiSetFieldValue,
				nlapiSetLineItemMatrixValue: nlapiSetLineItemMatrixValue,
				nlapiSetMatrixValue: nlapiSetMatrixValue,
				nlapiViewCurrentLineItemSubrecord: nlapiViewCurrentLineItemSubrecord,
				nlapiViewLineItemSubrecord: nlapiViewLineItemSubrecord,
				nlapiViewSubrecord: nlapiViewSubrecord,
				nsapiIsInternal: nsapiIsInternal,
				nsapiSetIsInternal: nsapiSetIsInternal,
				nsapiAssertTrue: nsapiAssertTrue
			};
			return V1api;
		}


		var currentRecordModule = {
			get: function ()
			{
				var currentRecord = createCurrentRecordByWrappingNewDynamicRecordOrDomRecord();
				return currentRecord;
			}
		};
		currentRecordModule.get.promise = function ()
		{
			return new Promise(function (resolve, reject)
			{
				var currentRecord = createCurrentRecordByWrappingNewDynamicRecordOrDomRecord();
				if (currentRecord != null)
				{
					resolve(currentRecord);
				}
			});
		};

		return Object.freeze(currentRecordModule);
	});

define('N',['N/nsobject', 'N/error','N/util','N/log','N/xml','N/format','N/currency','N/runtime','N/action','N/query','N/http','N/portlet','N/https','N/search','N/transaction','N/email','N/ui','N/url','N/record','N/currentRecord'],
	function (nsobject, error,util,log,xml,format,currency,runtime,action,query,http,portlet,https,search,transaction,email,ui,url,record,currentRecord){
		function ModuleConfiguration(){
			this.create = function(module){
				return {
					value: module,
					enumerable: true,
					configurable: false,
					writable: false
				};
			};
		}
		var moduleConfiguration = new ModuleConfiguration();

		return Object.create(nsobject.getNewInstance(), {
				error: moduleConfiguration.create(error),
				util: moduleConfiguration.create(util),
				log: moduleConfiguration.create(log),
				xml: moduleConfiguration.create(xml),
				format: moduleConfiguration.create(format),
				currency: moduleConfiguration.create(currency),
				runtime: moduleConfiguration.create(runtime),
				action: moduleConfiguration.create(action),
				query: moduleConfiguration.create(query),
				http: moduleConfiguration.create(http),
				portlet: moduleConfiguration.create(portlet),
				https: moduleConfiguration.create(https),
				search: moduleConfiguration.create(search),
				transaction: moduleConfiguration.create(transaction),
				email: moduleConfiguration.create(email),
				ui: moduleConfiguration.create(ui),
				url: moduleConfiguration.create(url),
				record: moduleConfiguration.create(record),
				currentRecord: moduleConfiguration.create(currentRecord)
		});
	},
	{internal: ['FieldValidationHelper','environment','nsobject','utilityFunctions','fieldUtil','util/currencyUtility','util/date','util/slaving','util/sqlInjectionFilter','util/formatter','fieldTypeConstants','util/validator','util/uuid','field','msgRouter','creationFunctionWrapper','dateTimeZone','metadata/fieldMetadata','metadata/fieldDefinition','metadata/fieldPermissions','metadata/sublistMetadata','metadata/sublistDefinition','metadata/sublistPermissions','http/httpUtil','record/recordImpl','record/recordUtil','search/searchUtil','search/searchObject','search/pagingUtil','suiteletContext','transaction/transactionUtil','common/pattern/iterator','common/record/recordActualWork','common/record/recordDefinition','common/record/recordDefinitionEvent','common/record/recordDefinitionEventCompressor','common/record/line/lineDefinition','emptyModule','pagination/paginationObject','util/serverWidgetUtility','searchDefinition','scope','eventEmitter','notification','saveResult','exampleCommon','common/http','search/searchPaging','common/search','common/transaction','common/email','file','restricted/invoker','restricted/reflet','utilityFunctionsImpl','restricted/scriptArguments','restricted/ajaxHelpers','restricted/xmlHelpers','restricted/exampleBridge','restricted/msgRouterBridge','restricted/queryApiBridge','restricted/bridge','restricted/scriptSessionContext','restricted/scriptWorkQueueContext','restricted/remoteApiBridge','restricted/scriptDeploymentContext','restricted/scriptSessionObjectService','restricted/clientScriptHandler','restricted/recordRemoteApiBridge','restricted/fieldClientScriptHandler','restricted/scopeRemoteApiBridge','restricted/urlApi','restricted/xmlApi','restricted/fileApi','restricted/errorApi','restricted/httpApi','restricted/currencyApi','restricted/searchApi','common/record','record/proxy/dynamicRecord','record/proxy/deferredDynamicRecord','record/proxy/readOnlyRecord','record/proxy/dynamicSubrecord','record/proxy/deferredDynamicSubrecord','record/proxy/readOnlySubrecord','record/recordProxy','record/recordConstants','record/sublist','record/matrix','record/recordField','record/recordFieldEvent','record/recordEvent','record/relatedRecord','record/recordUtilityFunctions','record/subrecordUtilityFunctions','record/line/lineProxy','record/line/deferredDynamicLine','record/line/dynamicLine','record/line/readOnlyLine','record/line/sublistLineImpl','record/line/sublistLineBufferImpl','record/line/sublistLineImplementation','record/recordService','record/modelController','record/sublistLine','record/sublistLineEvent','record/recordCache','record/recordCacheController','record/model','record/modelEvent','record/metadata','record/metadataEvent','record/fieldLevelMetadata','record/fieldLevelMetadataEvent','record/sublistLevelMetadata','record/sublistLevelMetadataEvent','record/recordStateController','record/recordStateControllerEvent','record/fieldState','record/fieldStateEvent','record/sublistState','record/sublistStateEvent','record/sublistLineState','record/sublistLineStateEvent','record/recordImplementation','record/dynamicRecordImpl','record/deferredDynamicRecordImpl','record/recordScriptingScope','record/recordImplV1','record/recordImplV1Util','record/legacyNLObjects','record/subrecordController','record/subrecordImplV1Util','record/selectFieldOptionTextCache','domCurrentRecord','currentRecord/currentSublist','currentRecord/currentField','currentRecord/currentSubrecord'], devonly: ['N/exampleApi']}
);

if (typeof(nlapi) === 'undefined' || !nlapi) nlapi = {};
nlapi.async = (function(){

	var origSetTimeout = window.setTimeout;
	var origSetInterval = window.setInterval;
	var msgRouter = null;

	require.forceSync(true);
	require.setInternal(true);
	try
	{
		require(['N/msgRouter'], function (module) {msgRouter = module;});
	}
	finally
	{
		require.forceSync(false);
		require.setInternal(false);
	}

	function prepareForAsync(options)
	{
		window.setTimeout = function setTimeout(func, delay) {
			return origSetTimeout(function() {
				var timeoutArgs = Array.prototype.slice.call(arguments[1], 2);
				prepareForAsyncCall(func, arguments[0], timeoutArgs);
			}, delay, options, arguments);
		};
		window.setInterval = function setInterval(func, delay) {
			return origSetInterval(function() {
				var timeoutArgs = Array.prototype.slice.call(arguments[1], 2);
				prepareForAsyncCall(func, arguments[0], timeoutArgs);
			}, delay, options, arguments);
		};
	}

	function prepareForAsyncCall(func, options, timeoutArgs)
	{
		var origScriptId = window.NLScriptId;
		if (options.hasOwnProperty("id"))
		{
			window.NLScriptId = options.id;
			makeAsyncCall.apply(options.record, [func, timeoutArgs, origScriptId, options]);
		}
		else
		{
			var moduleInfo = options.info;
			var version = options.version;
			window.NLScriptId = moduleInfo.scriptId;
			if (version === "2.0")
			{
				require.setInternal(true);
				// this is internal require
				try
				{
					require(['N/restricted/reflet'], function (reflet) {
						reflet.recoverScript(moduleInfo);
						makeAsyncCall.apply(options.record, [func, timeoutArgs, origScriptId, options]);
					});
				}
				finally
				{
					require.setInternal(false);
				}
			}
			else
			{
				makeAsyncCall.apply(options.record, [func, timeoutArgs, origScriptId, options]);
			}
		}
	}

	function makeAsyncCall(func, args, origScriptId, options)
	{
		if (msgRouter) msgRouter.pushQueue(this);
		try
		{
			if (window.isRUMEnabled)
			{
				window.NLRUM.clientScriptAsyncCallbackBegin(options.trigger, options.hasOwnProperty("id") ? options.id : options.info.scriptId);
			}
			if (util.isString(func))
			{
				if (func.indexOf("(") > 0)
				{
					eval(func);
				}
				else
				{
					var argParams = "";
					for (var i = 0; i < args.length; i++)
						argParams += (i > 0 ? ", " : "") + (args[i] === null || typeof(args[i]) === "undefined" ? "null" : !util.isString(args[i]) ? args[i] : "'" + args[i] + "'");
					eval(func + "(" + argParams + ")");
				}
			}
			else if (typeof(func) === 'function')
			{
				func.apply(null, args);
			}
			if (window.isRUMEnabled)
			{
				window.NLRUM.clientScriptAsyncCallbackEnd(
					options.trigger,
					options.hasOwnProperty("id") ? options.id : options.info.scriptId,
					options.args,
					options.hasOwnProperty("version") ? options.version : "1.0",
					typeof(nlapiGetRecordType) === 'function' ? nlapiGetRecordType() : null
				);
			}
		}
		finally
		{
			window.NLScriptId = origScriptId;
			if (msgRouter) msgRouter.popQueue();
		}
	}

	function unloadAsync()
	{
		window.setTimeout = origSetTimeout;
		window.setInterval = origSetInterval;
	}

	return {
		prepareForAsync : prepareForAsync,
		unloadAsync : unloadAsync
	};

})();

window._N_define = define;
define = undefined;

